(function(e, t) {
    var n, r, i = typeof t,
        o = e.location,
        a = e.document,
        s = a.documentElement,
        l = e.jQuery,
        u = e.$,
        c = {},
        p = [],
        f = "1.10.2",
        d = p.concat,
        h = p.push,
        g = p.slice,
        m = p.indexOf,
        y = c.toString,
        v = c.hasOwnProperty,
        b = f.trim,
        x = function(e, t) {
            return new x.fn.init(e, t, r)
        },
        w = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
        T = /\S+/g,
        C = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
        N = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
        k = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
        E = /^[\],:{}\s]*$/,
        S = /(?:^|:|,)(?:\s*\[)+/g,
        A = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
        j = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,
        D = /^-ms-/,
        L = /-([\da-z])/gi,
        H = function(e, t) {
            return t.toUpperCase()
        },
        q = function(e) {
            (a.addEventListener || "load" === e.type || "complete" === a.readyState) && (_(), x.ready())
        },
        _ = function() {
            a.addEventListener ? (a.removeEventListener("DOMContentLoaded", q, !1), e.removeEventListener("load", q, !1)) : (a.detachEvent("onreadystatechange", q), e.detachEvent("onload", q))
        };
    x.fn = x.prototype = {
        jquery: f,
        constructor: x,
        init: function(e, n, r) {
            var i, o;
            if (!e) return this;
            if ("string" == typeof e) {
                if (i = "<" === e.charAt(0) && ">" === e.charAt(e.length - 1) && e.length >= 3 ? [null, e, null] : N.exec(e), !i || !i[1] && n) return !n || n.jquery ? (n || r).find(e) : this.constructor(n).find(e);
                if (i[1]) {
                    if (n = n instanceof x ? n[0] : n, x.merge(this, x.parseHTML(i[1], n && n.nodeType ? n.ownerDocument || n : a, !0)), k.test(i[1]) && x.isPlainObject(n))
                        for (i in n) x.isFunction(this[i]) ? this[i](n[i]) : this.attr(i, n[i]);
                    return this
                }
                if (o = a.getElementById(i[2]), o && o.parentNode) {
                    if (o.id !== i[2]) return r.find(e);
                    this.length = 1, this[0] = o
                }
                return this.context = a, this.selector = e, this
            }
            return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : x.isFunction(e) ? r.ready(e) : (e.selector !== t && (this.selector = e.selector, this.context = e.context), x.makeArray(e, this))
        },
        selector: "",
        length: 0,
        toArray: function() {
            return g.call(this)
        },
        get: function(e) {
            return null == e ? this.toArray() : 0 > e ? this[this.length + e] : this[e]
        },
        pushStack: function(e) {
            var t = x.merge(this.constructor(), e);
            return t.prevObject = this, t.context = this.context, t
        },
        each: function(e, t) {
            return x.each(this, e, t)
        },
        ready: function(e) {
            return x.ready.promise().done(e), this
        },
        slice: function() {
            return this.pushStack(g.apply(this, arguments))
        },
        first: function() {
            return this.eq(0)
        },
        last: function() {
            return this.eq(-1)
        },
        eq: function(e) {
            var t = this.length,
                n = +e + (0 > e ? t : 0);
            return this.pushStack(n >= 0 && t > n ? [this[n]] : [])
        },
        map: function(e) {
            return this.pushStack(x.map(this, function(t, n) {
                return e.call(t, n, t)
            }))
        },
        end: function() {
            return this.prevObject || this.constructor(null)
        },
        push: h,
        sort: [].sort,
        splice: [].splice
    }, x.fn.init.prototype = x.fn, x.extend = x.fn.extend = function() {
        var e, n, r, i, o, a, s = arguments[0] || {},
            l = 1,
            u = arguments.length,
            c = !1;
        for ("boolean" == typeof s && (c = s, s = arguments[1] || {}, l = 2), "object" == typeof s || x.isFunction(s) || (s = {}), u === l && (s = this, --l); u > l; l++)
            if (null != (o = arguments[l]))
                for (i in o) e = s[i], r = o[i], s !== r && (c && r && (x.isPlainObject(r) || (n = x.isArray(r))) ? (n ? (n = !1, a = e && x.isArray(e) ? e : []) : a = e && x.isPlainObject(e) ? e : {}, s[i] = x.extend(c, a, r)) : r !== t && (s[i] = r));
        return s
    }, x.extend({
        expando: "jQuery" + (f + Math.random()).replace(/\D/g, ""),
        noConflict: function(t) {
            return e.$ === x && (e.$ = u), t && e.jQuery === x && (e.jQuery = l), x
        },
        isReady: !1,
        readyWait: 1,
        holdReady: function(e) {
            e ? x.readyWait++ : x.ready(!0)
        },
        ready: function(e) {
            if (e === !0 ? !--x.readyWait : !x.isReady) {
                if (!a.body) return setTimeout(x.ready);
                x.isReady = !0, e !== !0 && --x.readyWait > 0 || (n.resolveWith(a, [x]), x.fn.trigger && x(a).trigger("ready").off("ready"))
            }
        },
        isFunction: function(e) {
            return "function" === x.type(e)
        },
        isArray: Array.isArray || function(e) {
            return "array" === x.type(e)
        },
        isWindow: function(e) {
            return null != e && e == e.window
        },
        isNumeric: function(e) {
            return !isNaN(parseFloat(e)) && isFinite(e)
        },
        type: function(e) {
            return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? c[y.call(e)] || "object" : typeof e
        },
        isPlainObject: function(e) {
            var n;
            if (!e || "object" !== x.type(e) || e.nodeType || x.isWindow(e)) return !1;
            try {
                if (e.constructor && !v.call(e, "constructor") && !v.call(e.constructor.prototype, "isPrototypeOf")) return !1
            } catch (r) {
                return !1
            }
            if (x.support.ownLast)
                for (n in e) return v.call(e, n);
            for (n in e);
            return n === t || v.call(e, n)
        },
        isEmptyObject: function(e) {
            var t;
            for (t in e) return !1;
            return !0
        },
        error: function(e) {
            throw Error(e)
        },
        parseHTML: function(e, t, n) {
            if (!e || "string" != typeof e) return null;
            "boolean" == typeof t && (n = t, t = !1), t = t || a;
            var r = k.exec(e),
                i = !n && [];
            return r ? [t.createElement(r[1])] : (r = x.buildFragment([e], t, i), i && x(i).remove(), x.merge([], r.childNodes))
        },
        parseJSON: function(n) {
            return e.JSON && e.JSON.parse ? e.JSON.parse(n) : null === n ? n : "string" == typeof n && (n = x.trim(n), n && E.test(n.replace(A, "@").replace(j, "]").replace(S, ""))) ? Function("return " + n)() : (x.error("Invalid JSON: " + n), t)
        },
        parseXML: function(n) {
            var r, i;
            if (!n || "string" != typeof n) return null;
            try {
                e.DOMParser ? (i = new DOMParser, r = i.parseFromString(n, "text/xml")) : (r = new ActiveXObject("Microsoft.XMLDOM"), r.async = "false", r.loadXML(n))
            } catch (o) {
                r = t
            }
            return r && r.documentElement && !r.getElementsByTagName("parsererror").length || x.error("Invalid XML: " + n), r
        },
        noop: function() {},
        globalEval: function(t) {
            t && x.trim(t) && (e.execScript || function(t) {
                e.eval.call(e, t)
            })(t)
        },
        camelCase: function(e) {
            return e.replace(D, "ms-").replace(L, H)
        },
        nodeName: function(e, t) {
            return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
        },
        each: function(e, t, n) {
            var r, i = 0,
                o = e.length,
                a = M(e);
            if (n) {
                if (a) {
                    for (; o > i; i++)
                        if (r = t.apply(e[i], n), r === !1) break
                } else
                    for (i in e)
                        if (r = t.apply(e[i], n), r === !1) break
            } else if (a) {
                for (; o > i; i++)
                    if (r = t.call(e[i], i, e[i]), r === !1) break
            } else
                for (i in e)
                    if (r = t.call(e[i], i, e[i]), r === !1) break;
            return e
        },
        trim: b && !b.call("\ufeff\u00a0") ? function(e) {
            return null == e ? "" : b.call(e)
        } : function(e) {
            return null == e ? "" : (e + "").replace(C, "")
        },
        makeArray: function(e, t) {
            var n = t || [];
            return null != e && (M(Object(e)) ? x.merge(n, "string" == typeof e ? [e] : e) : h.call(n, e)), n
        },
        inArray: function(e, t, n) {
            var r;
            if (t) {
                if (m) return m.call(t, e, n);
                for (r = t.length, n = n ? 0 > n ? Math.max(0, r + n) : n : 0; r > n; n++)
                    if (n in t && t[n] === e) return n
            }
            return -1
        },
        merge: function(e, n) {
            var r = n.length,
                i = e.length,
                o = 0;
            if ("number" == typeof r)
                for (; r > o; o++) e[i++] = n[o];
            else
                while (n[o] !== t) e[i++] = n[o++];
            return e.length = i, e
        },
        grep: function(e, t, n) {
            var r, i = [],
                o = 0,
                a = e.length;
            for (n = !!n; a > o; o++) r = !!t(e[o], o), n !== r && i.push(e[o]);
            return i
        },
        map: function(e, t, n) {
            var r, i = 0,
                o = e.length,
                a = M(e),
                s = [];
            if (a)
                for (; o > i; i++) r = t(e[i], i, n), null != r && (s[s.length] = r);
            else
                for (i in e) r = t(e[i], i, n), null != r && (s[s.length] = r);
            return d.apply([], s)
        },
        guid: 1,
        proxy: function(e, n) {
            var r, i, o;
            return "string" == typeof n && (o = e[n], n = e, e = o), x.isFunction(e) ? (r = g.call(arguments, 2), i = function() {
                return e.apply(n || this, r.concat(g.call(arguments)))
            }, i.guid = e.guid = e.guid || x.guid++, i) : t
        },
        access: function(e, n, r, i, o, a, s) {
            var l = 0,
                u = e.length,
                c = null == r;
            if ("object" === x.type(r)) {
                o = !0;
                for (l in r) x.access(e, n, l, r[l], !0, a, s)
            } else if (i !== t && (o = !0, x.isFunction(i) || (s = !0), c && (s ? (n.call(e, i), n = null) : (c = n, n = function(e, t, n) {
                    return c.call(x(e), n)
                })), n))
                for (; u > l; l++) n(e[l], r, s ? i : i.call(e[l], l, n(e[l], r)));
            return o ? e : c ? n.call(e) : u ? n(e[0], r) : a
        },
        now: function() {
            return (new Date).getTime()
        },
        swap: function(e, t, n, r) {
            var i, o, a = {};
            for (o in t) a[o] = e.style[o], e.style[o] = t[o];
            i = n.apply(e, r || []);
            for (o in t) e.style[o] = a[o];
            return i
        }
    }), x.ready.promise = function(t) {
        if (!n)
            if (n = x.Deferred(), "complete" === a.readyState) setTimeout(x.ready);
            else if (a.addEventListener) a.addEventListener("DOMContentLoaded", q, !1), e.addEventListener("load", q, !1);
        else {
            a.attachEvent("onreadystatechange", q), e.attachEvent("onload", q);
            var r = !1;
            try {
                r = null == e.frameElement && a.documentElement
            } catch (i) {}
            r && r.doScroll && function o() {
                if (!x.isReady) {
                    try {
                        r.doScroll("left")
                    } catch (e) {
                        return setTimeout(o, 50)
                    }
                    _(), x.ready()
                }
            }()
        }
        return n.promise(t)
    }, x.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(e, t) {
        c["[object " + t + "]"] = t.toLowerCase()
    });

    function M(e) {
        var t = e.length,
            n = x.type(e);
        return x.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === n || "function" !== n && (0 === t || "number" == typeof t && t > 0 && t - 1 in e)
    }
    r = x(a),
        function(e, t) {
            var n, r, i, o, a, s, l, u, c, p, f, d, h, g, m, y, v, b = "sizzle" + -new Date,
                w = e.document,
                T = 0,
                C = 0,
                N = st(),
                k = st(),
                E = st(),
                S = !1,
                A = function(e, t) {
                    return e === t ? (S = !0, 0) : 0
                },
                j = typeof t,
                D = 1 << 31,
                L = {}.hasOwnProperty,
                H = [],
                q = H.pop,
                _ = H.push,
                M = H.push,
                O = H.slice,
                F = H.indexOf || function(e) {
                    var t = 0,
                        n = this.length;
                    for (; n > t; t++)
                        if (this[t] === e) return t;
                    return -1
                },
                B = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                P = "[\\x20\\t\\r\\n\\f]",
                R = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                W = R.replace("w", "w#"),
                $ = "\\[" + P + "*(" + R + ")" + P + "*(?:([*^$|!~]?=)" + P + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + W + ")|)|)" + P + "*\\]",
                I = ":(" + R + ")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|" + $.replace(3, 8) + ")*)|.*)\\)|)",
                z = RegExp("^" + P + "+|((?:^|[^\\\\])(?:\\\\.)*)" + P + "+$", "g"),
                X = RegExp("^" + P + "*," + P + "*"),
                U = RegExp("^" + P + "*([>+~]|" + P + ")" + P + "*"),
                V = RegExp(P + "*[+~]"),
                Y = RegExp("=" + P + "*([^\\]'\"]*)" + P + "*\\]", "g"),
                J = RegExp(I),
                G = RegExp("^" + W + "$"),
                Q = {
                    ID: RegExp("^#(" + R + ")"),
                    CLASS: RegExp("^\\.(" + R + ")"),
                    TAG: RegExp("^(" + R.replace("w", "w*") + ")"),
                    ATTR: RegExp("^" + $),
                    PSEUDO: RegExp("^" + I),
                    CHILD: RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + P + "*(even|odd|(([+-]|)(\\d*)n|)" + P + "*(?:([+-]|)" + P + "*(\\d+)|))" + P + "*\\)|)", "i"),
                    bool: RegExp("^(?:" + B + ")$", "i"),
                    needsContext: RegExp("^" + P + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + P + "*((?:-\\d)?\\d*)" + P + "*\\)|)(?=[^-]|$)", "i")
                },
                K = /^[^{]+\{\s*\[native \w/,
                Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                et = /^(?:input|select|textarea|button)$/i,
                tt = /^h\d$/i,
                nt = /'|\\/g,
                rt = RegExp("\\\\([\\da-f]{1,6}" + P + "?|(" + P + ")|.)", "ig"),
                it = function(e, t, n) {
                    var r = "0x" + t - 65536;
                    return r !== r || n ? t : 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(55296 | r >> 10, 56320 | 1023 & r)
                };
            try {
                M.apply(H = O.call(w.childNodes), w.childNodes), H[w.childNodes.length].nodeType
            } catch (ot) {
                M = {
                    apply: H.length ? function(e, t) {
                        _.apply(e, O.call(t))
                    } : function(e, t) {
                        var n = e.length,
                            r = 0;
                        while (e[n++] = t[r++]);
                        e.length = n - 1
                    }
                }
            }

            function at(e, t, n, i) {
                var o, a, s, l, u, c, d, m, y, x;
                if ((t ? t.ownerDocument || t : w) !== f && p(t), t = t || f, n = n || [], !e || "string" != typeof e) return n;
                if (1 !== (l = t.nodeType) && 9 !== l) return [];
                if (h && !i) {
                    if (o = Z.exec(e))
                        if (s = o[1]) {
                            if (9 === l) {
                                if (a = t.getElementById(s), !a || !a.parentNode) return n;
                                if (a.id === s) return n.push(a), n
                            } else if (t.ownerDocument && (a = t.ownerDocument.getElementById(s)) && v(t, a) && a.id === s) return n.push(a), n
                        } else {
                            if (o[2]) return M.apply(n, t.getElementsByTagName(e)), n;
                            if ((s = o[3]) && r.getElementsByClassName && t.getElementsByClassName) return M.apply(n, t.getElementsByClassName(s)), n
                        }
                    if (r.qsa && (!g || !g.test(e))) {
                        if (m = d = b, y = t, x = 9 === l && e, 1 === l && "object" !== t.nodeName.toLowerCase()) {
                            c = mt(e), (d = t.getAttribute("id")) ? m = d.replace(nt, "\\$&") : t.setAttribute("id", m), m = "[id='" + m + "'] ", u = c.length;
                            while (u--) c[u] = m + yt(c[u]);
                            y = V.test(e) && t.parentNode || t, x = c.join(",")
                        }
                        if (x) try {
                            return M.apply(n, y.querySelectorAll(x)), n
                        } catch (T) {} finally {
                            d || t.removeAttribute("id")
                        }
                    }
                }
                return kt(e.replace(z, "$1"), t, n, i)
            }

            function st() {
                var e = [];

                function t(n, r) {
                    return e.push(n += " ") > o.cacheLength && delete t[e.shift()], t[n] = r
                }
                return t
            }

            function lt(e) {
                return e[b] = !0, e
            }

            function ut(e) {
                var t = f.createElement("div");
                try {
                    return !!e(t)
                } catch (n) {
                    return !1
                } finally {
                    t.parentNode && t.parentNode.removeChild(t), t = null
                }
            }

            function ct(e, t) {
                var n = e.split("|"),
                    r = e.length;
                while (r--) o.attrHandle[n[r]] = t
            }

            function pt(e, t) {
                var n = t && e,
                    r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || D) - (~e.sourceIndex || D);
                if (r) return r;
                if (n)
                    while (n = n.nextSibling)
                        if (n === t) return -1;
                return e ? 1 : -1
            }

            function ft(e) {
                return function(t) {
                    var n = t.nodeName.toLowerCase();
                    return "input" === n && t.type === e
                }
            }

            function dt(e) {
                return function(t) {
                    var n = t.nodeName.toLowerCase();
                    return ("input" === n || "button" === n) && t.type === e
                }
            }

            function ht(e) {
                return lt(function(t) {
                    return t = +t, lt(function(n, r) {
                        var i, o = e([], n.length, t),
                            a = o.length;
                        while (a--) n[i = o[a]] && (n[i] = !(r[i] = n[i]))
                    })
                })
            }
            s = at.isXML = function(e) {
                var t = e && (e.ownerDocument || e).documentElement;
                return t ? "HTML" !== t.nodeName : !1
            }, r = at.support = {}, p = at.setDocument = function(e) {
                var n = e ? e.ownerDocument || e : w,
                    i = n.defaultView;
                return n !== f && 9 === n.nodeType && n.documentElement ? (f = n, d = n.documentElement, h = !s(n), i && i.attachEvent && i !== i.top && i.attachEvent("onbeforeunload", function() {
                    p()
                }), r.attributes = ut(function(e) {
                    return e.className = "i", !e.getAttribute("className")
                }), r.getElementsByTagName = ut(function(e) {
                    return e.appendChild(n.createComment("")), !e.getElementsByTagName("*").length
                }), r.getElementsByClassName = ut(function(e) {
                    return e.innerHTML = "<div class='a'></div><div class='a i'></div>", e.firstChild.className = "i", 2 === e.getElementsByClassName("i").length
                }), r.getById = ut(function(e) {
                    return d.appendChild(e).id = b, !n.getElementsByName || !n.getElementsByName(b).length
                }), r.getById ? (o.find.ID = function(e, t) {
                    if (typeof t.getElementById !== j && h) {
                        var n = t.getElementById(e);
                        return n && n.parentNode ? [n] : []
                    }
                }, o.filter.ID = function(e) {
                    var t = e.replace(rt, it);
                    return function(e) {
                        return e.getAttribute("id") === t
                    }
                }) : (delete o.find.ID, o.filter.ID = function(e) {
                    var t = e.replace(rt, it);
                    return function(e) {
                        var n = typeof e.getAttributeNode !== j && e.getAttributeNode("id");
                        return n && n.value === t
                    }
                }), o.find.TAG = r.getElementsByTagName ? function(e, n) {
                    return typeof n.getElementsByTagName !== j ? n.getElementsByTagName(e) : t
                } : function(e, t) {
                    var n, r = [],
                        i = 0,
                        o = t.getElementsByTagName(e);
                    if ("*" === e) {
                        while (n = o[i++]) 1 === n.nodeType && r.push(n);
                        return r
                    }
                    return o
                }, o.find.CLASS = r.getElementsByClassName && function(e, n) {
                    return typeof n.getElementsByClassName !== j && h ? n.getElementsByClassName(e) : t
                }, m = [], g = [], (r.qsa = K.test(n.querySelectorAll)) && (ut(function(e) {
                    e.innerHTML = "<select><option selected=''></option></select>", e.querySelectorAll("[selected]").length || g.push("\\[" + P + "*(?:value|" + B + ")"), e.querySelectorAll(":checked").length || g.push(":checked")
                }), ut(function(e) {
                    var t = n.createElement("input");
                    t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("t", ""), e.querySelectorAll("[t^='']").length && g.push("[*^$]=" + P + "*(?:''|\"\")"), e.querySelectorAll(":enabled").length || g.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), g.push(",.*:")
                })), (r.matchesSelector = K.test(y = d.webkitMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d.msMatchesSelector)) && ut(function(e) {
                    r.disconnectedMatch = y.call(e, "div"), y.call(e, "[s!='']:x"), m.push("!=", I)
                }), g = g.length && RegExp(g.join("|")), m = m.length && RegExp(m.join("|")), v = K.test(d.contains) || d.compareDocumentPosition ? function(e, t) {
                    var n = 9 === e.nodeType ? e.documentElement : e,
                        r = t && t.parentNode;
                    return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
                } : function(e, t) {
                    if (t)
                        while (t = t.parentNode)
                            if (t === e) return !0;
                    return !1
                }, A = d.compareDocumentPosition ? function(e, t) {
                    if (e === t) return S = !0, 0;
                    var i = t.compareDocumentPosition && e.compareDocumentPosition && e.compareDocumentPosition(t);
                    return i ? 1 & i || !r.sortDetached && t.compareDocumentPosition(e) === i ? e === n || v(w, e) ? -1 : t === n || v(w, t) ? 1 : c ? F.call(c, e) - F.call(c, t) : 0 : 4 & i ? -1 : 1 : e.compareDocumentPosition ? -1 : 1
                } : function(e, t) {
                    var r, i = 0,
                        o = e.parentNode,
                        a = t.parentNode,
                        s = [e],
                        l = [t];
                    if (e === t) return S = !0, 0;
                    if (!o || !a) return e === n ? -1 : t === n ? 1 : o ? -1 : a ? 1 : c ? F.call(c, e) - F.call(c, t) : 0;
                    if (o === a) return pt(e, t);
                    r = e;
                    while (r = r.parentNode) s.unshift(r);
                    r = t;
                    while (r = r.parentNode) l.unshift(r);
                    while (s[i] === l[i]) i++;
                    return i ? pt(s[i], l[i]) : s[i] === w ? -1 : l[i] === w ? 1 : 0
                }, n) : f
            }, at.matches = function(e, t) {
                return at(e, null, null, t)
            }, at.matchesSelector = function(e, t) {
                if ((e.ownerDocument || e) !== f && p(e), t = t.replace(Y, "='$1']"), !(!r.matchesSelector || !h || m && m.test(t) || g && g.test(t))) try {
                    var n = y.call(e, t);
                    if (n || r.disconnectedMatch || e.document && 11 !== e.document.nodeType) return n
                } catch (i) {}
                return at(t, f, null, [e]).length > 0
            }, at.contains = function(e, t) {
                return (e.ownerDocument || e) !== f && p(e), v(e, t)
            }, at.attr = function(e, n) {
                (e.ownerDocument || e) !== f && p(e);
                var i = o.attrHandle[n.toLowerCase()],
                    a = i && L.call(o.attrHandle, n.toLowerCase()) ? i(e, n, !h) : t;
                return a === t ? r.attributes || !h ? e.getAttribute(n) : (a = e.getAttributeNode(n)) && a.specified ? a.value : null : a
            }, at.error = function(e) {
                throw Error("Syntax error, unrecognized expression: " + e)
            }, at.uniqueSort = function(e) {
                var t, n = [],
                    i = 0,
                    o = 0;
                if (S = !r.detectDuplicates, c = !r.sortStable && e.slice(0), e.sort(A), S) {
                    while (t = e[o++]) t === e[o] && (i = n.push(o));
                    while (i--) e.splice(n[i], 1)
                }
                return e
            }, a = at.getText = function(e) {
                var t, n = "",
                    r = 0,
                    i = e.nodeType;
                if (i) {
                    if (1 === i || 9 === i || 11 === i) {
                        if ("string" == typeof e.textContent) return e.textContent;
                        for (e = e.firstChild; e; e = e.nextSibling) n += a(e)
                    } else if (3 === i || 4 === i) return e.nodeValue
                } else
                    for (; t = e[r]; r++) n += a(t);
                return n
            }, o = at.selectors = {
                cacheLength: 50,
                createPseudo: lt,
                match: Q,
                attrHandle: {},
                find: {},
                relative: {
                    ">": {
                        dir: "parentNode",
                        first: !0
                    },
                    " ": {
                        dir: "parentNode"
                    },
                    "+": {
                        dir: "previousSibling",
                        first: !0
                    },
                    "~": {
                        dir: "previousSibling"
                    }
                },
                preFilter: {
                    ATTR: function(e) {
                        return e[1] = e[1].replace(rt, it), e[3] = (e[4] || e[5] || "").replace(rt, it), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                    },
                    CHILD: function(e) {
                        return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || at.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && at.error(e[0]), e
                    },
                    PSEUDO: function(e) {
                        var n, r = !e[5] && e[2];
                        return Q.CHILD.test(e[0]) ? null : (e[3] && e[4] !== t ? e[2] = e[4] : r && J.test(r) && (n = mt(r, !0)) && (n = r.indexOf(")", r.length - n) - r.length) && (e[0] = e[0].slice(0, n), e[2] = r.slice(0, n)), e.slice(0, 3))
                    }
                },
                filter: {
                    TAG: function(e) {
                        var t = e.replace(rt, it).toLowerCase();
                        return "*" === e ? function() {
                            return !0
                        } : function(e) {
                            return e.nodeName && e.nodeName.toLowerCase() === t
                        }
                    },
                    CLASS: function(e) {
                        var t = N[e + " "];
                        return t || (t = RegExp("(^|" + P + ")" + e + "(" + P + "|$)")) && N(e, function(e) {
                            return t.test("string" == typeof e.className && e.className || typeof e.getAttribute !== j && e.getAttribute("class") || "")
                        })
                    },
                    ATTR: function(e, t, n) {
                        return function(r) {
                            var i = at.attr(r, e);
                            return null == i ? "!=" === t : t ? (i += "", "=" === t ? i === n : "!=" === t ? i !== n : "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice(-n.length) === n : "~=" === t ? (" " + i + " ").indexOf(n) > -1 : "|=" === t ? i === n || i.slice(0, n.length + 1) === n + "-" : !1) : !0
                        }
                    },
                    CHILD: function(e, t, n, r, i) {
                        var o = "nth" !== e.slice(0, 3),
                            a = "last" !== e.slice(-4),
                            s = "of-type" === t;
                        return 1 === r && 0 === i ? function(e) {
                            return !!e.parentNode
                        } : function(t, n, l) {
                            var u, c, p, f, d, h, g = o !== a ? "nextSibling" : "previousSibling",
                                m = t.parentNode,
                                y = s && t.nodeName.toLowerCase(),
                                v = !l && !s;
                            if (m) {
                                if (o) {
                                    while (g) {
                                        p = t;
                                        while (p = p[g])
                                            if (s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType) return !1;
                                        h = g = "only" === e && !h && "nextSibling"
                                    }
                                    return !0
                                }
                                if (h = [a ? m.firstChild : m.lastChild], a && v) {
                                    c = m[b] || (m[b] = {}), u = c[e] || [], d = u[0] === T && u[1], f = u[0] === T && u[2], p = d && m.childNodes[d];
                                    while (p = ++d && p && p[g] || (f = d = 0) || h.pop())
                                        if (1 === p.nodeType && ++f && p === t) {
                                            c[e] = [T, d, f];
                                            break
                                        }
                                } else if (v && (u = (t[b] || (t[b] = {}))[e]) && u[0] === T) f = u[1];
                                else
                                    while (p = ++d && p && p[g] || (f = d = 0) || h.pop())
                                        if ((s ? p.nodeName.toLowerCase() === y : 1 === p.nodeType) && ++f && (v && ((p[b] || (p[b] = {}))[e] = [T, f]), p === t)) break;
                                return f -= i, f === r || 0 === f % r && f / r >= 0
                            }
                        }
                    },
                    PSEUDO: function(e, t) {
                        var n, r = o.pseudos[e] || o.setFilters[e.toLowerCase()] || at.error("unsupported pseudo: " + e);
                        return r[b] ? r(t) : r.length > 1 ? (n = [e, e, "", t], o.setFilters.hasOwnProperty(e.toLowerCase()) ? lt(function(e, n) {
                            var i, o = r(e, t),
                                a = o.length;
                            while (a--) i = F.call(e, o[a]), e[i] = !(n[i] = o[a])
                        }) : function(e) {
                            return r(e, 0, n)
                        }) : r
                    }
                },
                pseudos: {
                    not: lt(function(e) {
                        var t = [],
                            n = [],
                            r = l(e.replace(z, "$1"));
                        return r[b] ? lt(function(e, t, n, i) {
                            var o, a = r(e, null, i, []),
                                s = e.length;
                            while (s--)(o = a[s]) && (e[s] = !(t[s] = o))
                        }) : function(e, i, o) {
                            return t[0] = e, r(t, null, o, n), !n.pop()
                        }
                    }),
                    has: lt(function(e) {
                        return function(t) {
                            return at(e, t).length > 0
                        }
                    }),
                    contains: lt(function(e) {
                        return function(t) {
                            return (t.textContent || t.innerText || a(t)).indexOf(e) > -1
                        }
                    }),
                    lang: lt(function(e) {
                        return G.test(e || "") || at.error("unsupported lang: " + e), e = e.replace(rt, it).toLowerCase(),
                            function(t) {
                                var n;
                                do
                                    if (n = h ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return n = n.toLowerCase(), n === e || 0 === n.indexOf(e + "-"); while ((t = t.parentNode) && 1 === t.nodeType);
                                return !1
                            }
                    }),
                    target: function(t) {
                        var n = e.location && e.location.hash;
                        return n && n.slice(1) === t.id
                    },
                    root: function(e) {
                        return e === d
                    },
                    focus: function(e) {
                        return e === f.activeElement && (!f.hasFocus || f.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                    },
                    enabled: function(e) {
                        return e.disabled === !1
                    },
                    disabled: function(e) {
                        return e.disabled === !0
                    },
                    checked: function(e) {
                        var t = e.nodeName.toLowerCase();
                        return "input" === t && !!e.checked || "option" === t && !!e.selected
                    },
                    selected: function(e) {
                        return e.parentNode && e.parentNode.selectedIndex, e.selected === !0
                    },
                    empty: function(e) {
                        for (e = e.firstChild; e; e = e.nextSibling)
                            if (e.nodeName > "@" || 3 === e.nodeType || 4 === e.nodeType) return !1;
                        return !0
                    },
                    parent: function(e) {
                        return !o.pseudos.empty(e)
                    },
                    header: function(e) {
                        return tt.test(e.nodeName)
                    },
                    input: function(e) {
                        return et.test(e.nodeName)
                    },
                    button: function(e) {
                        var t = e.nodeName.toLowerCase();
                        return "input" === t && "button" === e.type || "button" === t
                    },
                    text: function(e) {
                        var t;
                        return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || t.toLowerCase() === e.type)
                    },
                    first: ht(function() {
                        return [0]
                    }),
                    last: ht(function(e, t) {
                        return [t - 1]
                    }),
                    eq: ht(function(e, t, n) {
                        return [0 > n ? n + t : n]
                    }),
                    even: ht(function(e, t) {
                        var n = 0;
                        for (; t > n; n += 2) e.push(n);
                        return e
                    }),
                    odd: ht(function(e, t) {
                        var n = 1;
                        for (; t > n; n += 2) e.push(n);
                        return e
                    }),
                    lt: ht(function(e, t, n) {
                        var r = 0 > n ? n + t : n;
                        for (; --r >= 0;) e.push(r);
                        return e
                    }),
                    gt: ht(function(e, t, n) {
                        var r = 0 > n ? n + t : n;
                        for (; t > ++r;) e.push(r);
                        return e
                    })
                }
            }, o.pseudos.nth = o.pseudos.eq;
            for (n in {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) o.pseudos[n] = ft(n);
            for (n in {
                    submit: !0,
                    reset: !0
                }) o.pseudos[n] = dt(n);

            function gt() {}
            gt.prototype = o.filters = o.pseudos, o.setFilters = new gt;

            function mt(e, t) {
                var n, r, i, a, s, l, u, c = k[e + " "];
                if (c) return t ? 0 : c.slice(0);
                s = e, l = [], u = o.preFilter;
                while (s) {
                    (!n || (r = X.exec(s))) && (r && (s = s.slice(r[0].length) || s), l.push(i = [])), n = !1, (r = U.exec(s)) && (n = r.shift(), i.push({
                        value: n,
                        type: r[0].replace(z, " ")
                    }), s = s.slice(n.length));
                    for (a in o.filter) !(r = Q[a].exec(s)) || u[a] && !(r = u[a](r)) || (n = r.shift(), i.push({
                        value: n,
                        type: a,
                        matches: r
                    }), s = s.slice(n.length));
                    if (!n) break
                }
                return t ? s.length : s ? at.error(e) : k(e, l).slice(0)
            }

            function yt(e) {
                var t = 0,
                    n = e.length,
                    r = "";
                for (; n > t; t++) r += e[t].value;
                return r
            }

            function vt(e, t, n) {
                var r = t.dir,
                    o = n && "parentNode" === r,
                    a = C++;
                return t.first ? function(t, n, i) {
                    while (t = t[r])
                        if (1 === t.nodeType || o) return e(t, n, i)
                } : function(t, n, s) {
                    var l, u, c, p = T + " " + a;
                    if (s) {
                        while (t = t[r])
                            if ((1 === t.nodeType || o) && e(t, n, s)) return !0
                    } else
                        while (t = t[r])
                            if (1 === t.nodeType || o)
                                if (c = t[b] || (t[b] = {}), (u = c[r]) && u[0] === p) {
                                    if ((l = u[1]) === !0 || l === i) return l === !0
                                } else if (u = c[r] = [p], u[1] = e(t, n, s) || i, u[1] === !0) return !0
                }
            }

            function bt(e) {
                return e.length > 1 ? function(t, n, r) {
                    var i = e.length;
                    while (i--)
                        if (!e[i](t, n, r)) return !1;
                    return !0
                } : e[0]
            }

            function xt(e, t, n, r, i) {
                var o, a = [],
                    s = 0,
                    l = e.length,
                    u = null != t;
                for (; l > s; s++)(o = e[s]) && (!n || n(o, r, i)) && (a.push(o), u && t.push(s));
                return a
            }

            function wt(e, t, n, r, i, o) {
                return r && !r[b] && (r = wt(r)), i && !i[b] && (i = wt(i, o)), lt(function(o, a, s, l) {
                    var u, c, p, f = [],
                        d = [],
                        h = a.length,
                        g = o || Nt(t || "*", s.nodeType ? [s] : s, []),
                        m = !e || !o && t ? g : xt(g, f, e, s, l),
                        y = n ? i || (o ? e : h || r) ? [] : a : m;
                    if (n && n(m, y, s, l), r) {
                        u = xt(y, d), r(u, [], s, l), c = u.length;
                        while (c--)(p = u[c]) && (y[d[c]] = !(m[d[c]] = p))
                    }
                    if (o) {
                        if (i || e) {
                            if (i) {
                                u = [], c = y.length;
                                while (c--)(p = y[c]) && u.push(m[c] = p);
                                i(null, y = [], u, l)
                            }
                            c = y.length;
                            while (c--)(p = y[c]) && (u = i ? F.call(o, p) : f[c]) > -1 && (o[u] = !(a[u] = p))
                        }
                    } else y = xt(y === a ? y.splice(h, y.length) : y), i ? i(null, a, y, l) : M.apply(a, y)
                })
            }

            function Tt(e) {
                var t, n, r, i = e.length,
                    a = o.relative[e[0].type],
                    s = a || o.relative[" "],
                    l = a ? 1 : 0,
                    c = vt(function(e) {
                        return e === t
                    }, s, !0),
                    p = vt(function(e) {
                        return F.call(t, e) > -1
                    }, s, !0),
                    f = [function(e, n, r) {
                        return !a && (r || n !== u) || ((t = n).nodeType ? c(e, n, r) : p(e, n, r))
                    }];
                for (; i > l; l++)
                    if (n = o.relative[e[l].type]) f = [vt(bt(f), n)];
                    else {
                        if (n = o.filter[e[l].type].apply(null, e[l].matches), n[b]) {
                            for (r = ++l; i > r; r++)
                                if (o.relative[e[r].type]) break;
                            return wt(l > 1 && bt(f), l > 1 && yt(e.slice(0, l - 1).concat({
                                value: " " === e[l - 2].type ? "*" : ""
                            })).replace(z, "$1"), n, r > l && Tt(e.slice(l, r)), i > r && Tt(e = e.slice(r)), i > r && yt(e))
                        }
                        f.push(n)
                    }
                return bt(f)
            }

            function Ct(e, t) {
                var n = 0,
                    r = t.length > 0,
                    a = e.length > 0,
                    s = function(s, l, c, p, d) {
                        var h, g, m, y = [],
                            v = 0,
                            b = "0",
                            x = s && [],
                            w = null != d,
                            C = u,
                            N = s || a && o.find.TAG("*", d && l.parentNode || l),
                            k = T += null == C ? 1 : Math.random() || .1;
                        for (w && (u = l !== f && l, i = n); null != (h = N[b]); b++) {
                            if (a && h) {
                                g = 0;
                                while (m = e[g++])
                                    if (m(h, l, c)) {
                                        p.push(h);
                                        break
                                    }
                                w && (T = k, i = ++n)
                            }
                            r && ((h = !m && h) && v--, s && x.push(h))
                        }
                        if (v += b, r && b !== v) {
                            g = 0;
                            while (m = t[g++]) m(x, y, l, c);
                            if (s) {
                                if (v > 0)
                                    while (b--) x[b] || y[b] || (y[b] = q.call(p));
                                y = xt(y)
                            }
                            M.apply(p, y), w && !s && y.length > 0 && v + t.length > 1 && at.uniqueSort(p)
                        }
                        return w && (T = k, u = C), x
                    };
                return r ? lt(s) : s
            }
            l = at.compile = function(e, t) {
                var n, r = [],
                    i = [],
                    o = E[e + " "];
                if (!o) {
                    t || (t = mt(e)), n = t.length;
                    while (n--) o = Tt(t[n]), o[b] ? r.push(o) : i.push(o);
                    o = E(e, Ct(i, r))
                }
                return o
            };

            function Nt(e, t, n) {
                var r = 0,
                    i = t.length;
                for (; i > r; r++) at(e, t[r], n);
                return n
            }

            function kt(e, t, n, i) {
                var a, s, u, c, p, f = mt(e);
                if (!i && 1 === f.length) {
                    if (s = f[0] = f[0].slice(0), s.length > 2 && "ID" === (u = s[0]).type && r.getById && 9 === t.nodeType && h && o.relative[s[1].type]) {
                        if (t = (o.find.ID(u.matches[0].replace(rt, it), t) || [])[0], !t) return n;
                        e = e.slice(s.shift().value.length)
                    }
                    a = Q.needsContext.test(e) ? 0 : s.length;
                    while (a--) {
                        if (u = s[a], o.relative[c = u.type]) break;
                        if ((p = o.find[c]) && (i = p(u.matches[0].replace(rt, it), V.test(s[0].type) && t.parentNode || t))) {
                            if (s.splice(a, 1), e = i.length && yt(s), !e) return M.apply(n, i), n;
                            break
                        }
                    }
                }
                return l(e, f)(i, t, !h, n, V.test(e)), n
            }
            r.sortStable = b.split("").sort(A).join("") === b, r.detectDuplicates = S, p(), r.sortDetached = ut(function(e) {
                return 1 & e.compareDocumentPosition(f.createElement("div"))
            }), ut(function(e) {
                return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
            }) || ct("type|href|height|width", function(e, n, r) {
                return r ? t : e.getAttribute(n, "type" === n.toLowerCase() ? 1 : 2)
            }), r.attributes && ut(function(e) {
                return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
            }) || ct("value", function(e, n, r) {
                return r || "input" !== e.nodeName.toLowerCase() ? t : e.defaultValue
            }), ut(function(e) {
                return null == e.getAttribute("disabled")
            }) || ct(B, function(e, n, r) {
                var i;
                return r ? t : (i = e.getAttributeNode(n)) && i.specified ? i.value : e[n] === !0 ? n.toLowerCase() : null
            }), x.find = at, x.expr = at.selectors, x.expr[":"] = x.expr.pseudos, x.unique = at.uniqueSort, x.text = at.getText, x.isXMLDoc = at.isXML, x.contains = at.contains
        }(e);
    var O = {};

    function F(e) {
        var t = O[e] = {};
        return x.each(e.match(T) || [], function(e, n) {
            t[n] = !0
        }), t
    }
    x.Callbacks = function(e) {
        e = "string" == typeof e ? O[e] || F(e) : x.extend({}, e);
        var n, r, i, o, a, s, l = [],
            u = !e.once && [],
            c = function(t) {
                for (r = e.memory && t, i = !0, a = s || 0, s = 0, o = l.length, n = !0; l && o > a; a++)
                    if (l[a].apply(t[0], t[1]) === !1 && e.stopOnFalse) {
                        r = !1;
                        break
                    }
                n = !1, l && (u ? u.length && c(u.shift()) : r ? l = [] : p.disable())
            },
            p = {
                add: function() {
                    if (l) {
                        var t = l.length;
                        (function i(t) {
                            x.each(t, function(t, n) {
                                var r = x.type(n);
                                "function" === r ? e.unique && p.has(n) || l.push(n) : n && n.length && "string" !== r && i(n)
                            })
                        })(arguments), n ? o = l.length : r && (s = t, c(r))
                    }
                    return this
                },
                remove: function() {
                    return l && x.each(arguments, function(e, t) {
                        var r;
                        while ((r = x.inArray(t, l, r)) > -1) l.splice(r, 1), n && (o >= r && o--, a >= r && a--)
                    }), this
                },
                has: function(e) {
                    return e ? x.inArray(e, l) > -1 : !(!l || !l.length)
                },
                empty: function() {
                    return l = [], o = 0, this
                },
                disable: function() {
                    return l = u = r = t, this
                },
                disabled: function() {
                    return !l
                },
                lock: function() {
                    return u = t, r || p.disable(), this
                },
                locked: function() {
                    return !u
                },
                fireWith: function(e, t) {
                    return !l || i && !u || (t = t || [], t = [e, t.slice ? t.slice() : t], n ? u.push(t) : c(t)), this
                },
                fire: function() {
                    return p.fireWith(this, arguments), this
                },
                fired: function() {
                    return !!i
                }
            };
        return p
    }, x.extend({
        Deferred: function(e) {
            var t = [
                    ["resolve", "done", x.Callbacks("once memory"), "resolved"],
                    ["reject", "fail", x.Callbacks("once memory"), "rejected"],
                    ["notify", "progress", x.Callbacks("memory")]
                ],
                n = "pending",
                r = {
                    state: function() {
                        return n
                    },
                    always: function() {
                        return i.done(arguments).fail(arguments), this
                    },
                    then: function() {
                        var e = arguments;
                        return x.Deferred(function(n) {
                            x.each(t, function(t, o) {
                                var a = o[0],
                                    s = x.isFunction(e[t]) && e[t];
                                i[o[1]](function() {
                                    var e = s && s.apply(this, arguments);
                                    e && x.isFunction(e.promise) ? e.promise().done(n.resolve).fail(n.reject).progress(n.notify) : n[a + "With"](this === r ? n.promise() : this, s ? [e] : arguments)
                                })
                            }), e = null
                        }).promise()
                    },
                    promise: function(e) {
                        return null != e ? x.extend(e, r) : r
                    }
                },
                i = {};
            return r.pipe = r.then, x.each(t, function(e, o) {
                var a = o[2],
                    s = o[3];
                r[o[1]] = a.add, s && a.add(function() {
                    n = s
                }, t[1 ^ e][2].disable, t[2][2].lock), i[o[0]] = function() {
                    return i[o[0] + "With"](this === i ? r : this, arguments), this
                }, i[o[0] + "With"] = a.fireWith
            }), r.promise(i), e && e.call(i, i), i
        },
        when: function(e) {
            var t = 0,
                n = g.call(arguments),
                r = n.length,
                i = 1 !== r || e && x.isFunction(e.promise) ? r : 0,
                o = 1 === i ? e : x.Deferred(),
                a = function(e, t, n) {
                    return function(r) {
                        t[e] = this, n[e] = arguments.length > 1 ? g.call(arguments) : r, n === s ? o.notifyWith(t, n) : --i || o.resolveWith(t, n)
                    }
                },
                s, l, u;
            if (r > 1)
                for (s = Array(r), l = Array(r), u = Array(r); r > t; t++) n[t] && x.isFunction(n[t].promise) ? n[t].promise().done(a(t, u, n)).fail(o.reject).progress(a(t, l, s)) : --i;
            return i || o.resolveWith(u, n), o.promise()
        }
    }), x.support = function(t) {
        var n, r, o, s, l, u, c, p, f, d = a.createElement("div");
        if (d.setAttribute("className", "t"), d.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", n = d.getElementsByTagName("*") || [], r = d.getElementsByTagName("a")[0], !r || !r.style || !n.length) return t;
        s = a.createElement("select"), u = s.appendChild(a.createElement("option")), o = d.getElementsByTagName("input")[0], r.style.cssText = "top:1px;float:left;opacity:.5", t.getSetAttribute = "t" !== d.className, t.leadingWhitespace = 3 === d.firstChild.nodeType, t.tbody = !d.getElementsByTagName("tbody").length, t.htmlSerialize = !!d.getElementsByTagName("link").length, t.style = /top/.test(r.getAttribute("style")), t.hrefNormalized = "/a" === r.getAttribute("href"), t.opacity = /^0.5/.test(r.style.opacity), t.cssFloat = !!r.style.cssFloat, t.checkOn = !!o.value, t.optSelected = u.selected, t.enctype = !!a.createElement("form").enctype, t.html5Clone = "<:nav></:nav>" !== a.createElement("nav").cloneNode(!0).outerHTML, t.inlineBlockNeedsLayout = !1, t.shrinkWrapBlocks = !1, t.pixelPosition = !1, t.deleteExpando = !0, t.noCloneEvent = !0, t.reliableMarginRight = !0, t.boxSizingReliable = !0, o.checked = !0, t.noCloneChecked = o.cloneNode(!0).checked, s.disabled = !0, t.optDisabled = !u.disabled;
        try {
            delete d.test
        } catch (h) {
            t.deleteExpando = !1
        }
        o = a.createElement("input"), o.setAttribute("value", ""), t.input = "" === o.getAttribute("value"), o.value = "t", o.setAttribute("type", "radio"), t.radioValue = "t" === o.value, o.setAttribute("checked", "t"), o.setAttribute("name", "t"), l = a.createDocumentFragment(), l.appendChild(o), t.appendChecked = o.checked, t.checkClone = l.cloneNode(!0).cloneNode(!0).lastChild.checked, d.attachEvent && (d.attachEvent("onclick", function() {
            t.noCloneEvent = !1
        }), d.cloneNode(!0).click());
        for (f in {
                submit: !0,
                change: !0,
                focusin: !0
            }) d.setAttribute(c = "on" + f, "t"), t[f + "Bubbles"] = c in e || d.attributes[c].expando === !1;
        d.style.backgroundClip = "content-box", d.cloneNode(!0).style.backgroundClip = "", t.clearCloneStyle = "content-box" === d.style.backgroundClip;
        for (f in x(t)) break;
        return t.ownLast = "0" !== f, x(function() {
            var n, r, o, s = "padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",
                l = a.getElementsByTagName("body")[0];
            l && (n = a.createElement("div"), n.style.cssText = "border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px", l.appendChild(n).appendChild(d), d.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", o = d.getElementsByTagName("td"), o[0].style.cssText = "padding:0;margin:0;border:0;display:none", p = 0 === o[0].offsetHeight, o[0].style.display = "", o[1].style.display = "none", t.reliableHiddenOffsets = p && 0 === o[0].offsetHeight, d.innerHTML = "", d.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;", x.swap(l, null != l.style.zoom ? {
                zoom: 1
            } : {}, function() {
                t.boxSizing = 4 === d.offsetWidth
            }), e.getComputedStyle && (t.pixelPosition = "1%" !== (e.getComputedStyle(d, null) || {}).top, t.boxSizingReliable = "4px" === (e.getComputedStyle(d, null) || {
                width: "4px"
            }).width, r = d.appendChild(a.createElement("div")), r.style.cssText = d.style.cssText = s, r.style.marginRight = r.style.width = "0", d.style.width = "1px", t.reliableMarginRight = !parseFloat((e.getComputedStyle(r, null) || {}).marginRight)), typeof d.style.zoom !== i && (d.innerHTML = "", d.style.cssText = s + "width:1px;padding:1px;display:inline;zoom:1", t.inlineBlockNeedsLayout = 3 === d.offsetWidth, d.style.display = "block", d.innerHTML = "<div></div>", d.firstChild.style.width = "5px", t.shrinkWrapBlocks = 3 !== d.offsetWidth, t.inlineBlockNeedsLayout && (l.style.zoom = 1)), l.removeChild(n), n = d = o = r = null)
        }), n = s = l = u = r = o = null, t
    }({});
    var B = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
        P = /([A-Z])/g;

    function R(e, n, r, i) {
        if (x.acceptData(e)) {
            var o, a, s = x.expando,
                l = e.nodeType,
                u = l ? x.cache : e,
                c = l ? e[s] : e[s] && s;
            if (c && u[c] && (i || u[c].data) || r !== t || "string" != typeof n) return c || (c = l ? e[s] = p.pop() || x.guid++ : s), u[c] || (u[c] = l ? {} : {
                toJSON: x.noop
            }), ("object" == typeof n || "function" == typeof n) && (i ? u[c] = x.extend(u[c], n) : u[c].data = x.extend(u[c].data, n)), a = u[c], i || (a.data || (a.data = {}), a = a.data), r !== t && (a[x.camelCase(n)] = r), "string" == typeof n ? (o = a[n], null == o && (o = a[x.camelCase(n)])) : o = a, o
        }
    }

    function W(e, t, n) {
        if (x.acceptData(e)) {
            var r, i, o = e.nodeType,
                a = o ? x.cache : e,
                s = o ? e[x.expando] : x.expando;
            if (a[s]) {
                if (t && (r = n ? a[s] : a[s].data)) {
                    x.isArray(t) ? t = t.concat(x.map(t, x.camelCase)) : t in r ? t = [t] : (t = x.camelCase(t), t = t in r ? [t] : t.split(" ")), i = t.length;
                    while (i--) delete r[t[i]];
                    if (n ? !I(r) : !x.isEmptyObject(r)) return
                }(n || (delete a[s].data, I(a[s]))) && (o ? x.cleanData([e], !0) : x.support.deleteExpando || a != a.window ? delete a[s] : a[s] = null)
            }
        }
    }
    x.extend({
        cache: {},
        noData: {
            applet: !0,
            embed: !0,
            object: "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function(e) {
            return e = e.nodeType ? x.cache[e[x.expando]] : e[x.expando], !!e && !I(e)
        },
        data: function(e, t, n) {
            return R(e, t, n)
        },
        removeData: function(e, t) {
            return W(e, t)
        },
        _data: function(e, t, n) {
            return R(e, t, n, !0)
        },
        _removeData: function(e, t) {
            return W(e, t, !0)
        },
        acceptData: function(e) {
            if (e.nodeType && 1 !== e.nodeType && 9 !== e.nodeType) return !1;
            var t = e.nodeName && x.noData[e.nodeName.toLowerCase()];
            return !t || t !== !0 && e.getAttribute("classid") === t
        }
    }), x.fn.extend({
        data: function(e, n) {
            var r, i, o = null,
                a = 0,
                s = this[0];
            if (e === t) {
                if (this.length && (o = x.data(s), 1 === s.nodeType && !x._data(s, "parsedAttrs"))) {
                    for (r = s.attributes; r.length > a; a++) i = r[a].name, 0 === i.indexOf("data-") && (i = x.camelCase(i.slice(5)), $(s, i, o[i]));
                    x._data(s, "parsedAttrs", !0)
                }
                return o
            }
            return "object" == typeof e ? this.each(function() {
                x.data(this, e)
            }) : arguments.length > 1 ? this.each(function() {
                x.data(this, e, n)
            }) : s ? $(s, e, x.data(s, e)) : null
        },
        removeData: function(e) {
            return this.each(function() {
                x.removeData(this, e)
            })
        }
    });

    function $(e, n, r) {
        if (r === t && 1 === e.nodeType) {
            var i = "data-" + n.replace(P, "-$1").toLowerCase();
            if (r = e.getAttribute(i), "string" == typeof r) {
                try {
                    r = "true" === r ? !0 : "false" === r ? !1 : "null" === r ? null : +r + "" === r ? +r : B.test(r) ? x.parseJSON(r) : r
                } catch (o) {}
                x.data(e, n, r)
            } else r = t
        }
        return r
    }

    function I(e) {
        var t;
        for (t in e)
            if (("data" !== t || !x.isEmptyObject(e[t])) && "toJSON" !== t) return !1;
        return !0
    }
    x.extend({
        queue: function(e, n, r) {
            var i;
            return e ? (n = (n || "fx") + "queue", i = x._data(e, n), r && (!i || x.isArray(r) ? i = x._data(e, n, x.makeArray(r)) : i.push(r)), i || []) : t
        },
        dequeue: function(e, t) {
            t = t || "fx";
            var n = x.queue(e, t),
                r = n.length,
                i = n.shift(),
                o = x._queueHooks(e, t),
                a = function() {
                    x.dequeue(e, t)
                };
            "inprogress" === i && (i = n.shift(), r--), i && ("fx" === t && n.unshift("inprogress"), delete o.stop, i.call(e, a, o)), !r && o && o.empty.fire()
        },
        _queueHooks: function(e, t) {
            var n = t + "queueHooks";
            return x._data(e, n) || x._data(e, n, {
                empty: x.Callbacks("once memory").add(function() {
                    x._removeData(e, t + "queue"), x._removeData(e, n)
                })
            })
        }
    }), x.fn.extend({
        queue: function(e, n) {
            var r = 2;
            return "string" != typeof e && (n = e, e = "fx", r--), r > arguments.length ? x.queue(this[0], e) : n === t ? this : this.each(function() {
                var t = x.queue(this, e, n);
                x._queueHooks(this, e), "fx" === e && "inprogress" !== t[0] && x.dequeue(this, e)
            })
        },
        dequeue: function(e) {
            return this.each(function() {
                x.dequeue(this, e)
            })
        },
        delay: function(e, t) {
            return e = x.fx ? x.fx.speeds[e] || e : e, t = t || "fx", this.queue(t, function(t, n) {
                var r = setTimeout(t, e);
                n.stop = function() {
                    clearTimeout(r)
                }
            })
        },
        clearQueue: function(e) {
            return this.queue(e || "fx", [])
        },
        promise: function(e, n) {
            var r, i = 1,
                o = x.Deferred(),
                a = this,
                s = this.length,
                l = function() {
                    --i || o.resolveWith(a, [a])
                };
            "string" != typeof e && (n = e, e = t), e = e || "fx";
            while (s--) r = x._data(a[s], e + "queueHooks"), r && r.empty && (i++, r.empty.add(l));
            return l(), o.promise(n)
        }
    });
    var z, X, U = /[\t\r\n\f]/g,
        V = /\r/g,
        Y = /^(?:input|select|textarea|button|object)$/i,
        J = /^(?:a|area)$/i,
        G = /^(?:checked|selected)$/i,
        Q = x.support.getSetAttribute,
        K = x.support.input;
    x.fn.extend({
        attr: function(e, t) {
            return x.access(this, x.attr, e, t, arguments.length > 1)
        },
        removeAttr: function(e) {
            return this.each(function() {
                x.removeAttr(this, e)
            })
        },
        prop: function(e, t) {
            return x.access(this, x.prop, e, t, arguments.length > 1)
        },
        removeProp: function(e) {
            return e = x.propFix[e] || e, this.each(function() {
                try {
                    this[e] = t, delete this[e]
                } catch (n) {}
            })
        },
        addClass: function(e) {
            var t, n, r, i, o, a = 0,
                s = this.length,
                l = "string" == typeof e && e;
            if (x.isFunction(e)) return this.each(function(t) {
                x(this).addClass(e.call(this, t, this.className))
            });
            if (l)
                for (t = (e || "").match(T) || []; s > a; a++)
                    if (n = this[a], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(U, " ") : " ")) {
                        o = 0;
                        while (i = t[o++]) 0 > r.indexOf(" " + i + " ") && (r += i + " ");
                        n.className = x.trim(r)
                    }
            return this
        },
        removeClass: function(e) {
            var t, n, r, i, o, a = 0,
                s = this.length,
                l = 0 === arguments.length || "string" == typeof e && e;
            if (x.isFunction(e)) return this.each(function(t) {
                x(this).removeClass(e.call(this, t, this.className))
            });
            if (l)
                for (t = (e || "").match(T) || []; s > a; a++)
                    if (n = this[a], r = 1 === n.nodeType && (n.className ? (" " + n.className + " ").replace(U, " ") : "")) {
                        o = 0;
                        while (i = t[o++])
                            while (r.indexOf(" " + i + " ") >= 0) r = r.replace(" " + i + " ", " ");
                        n.className = e ? x.trim(r) : ""
                    }
            return this
        },
        toggleClass: function(e, t) {
            var n = typeof e;
            return "boolean" == typeof t && "string" === n ? t ? this.addClass(e) : this.removeClass(e) : x.isFunction(e) ? this.each(function(n) {
                x(this).toggleClass(e.call(this, n, this.className, t), t)
            }) : this.each(function() {
                if ("string" === n) {
                    var t, r = 0,
                        o = x(this),
                        a = e.match(T) || [];
                    while (t = a[r++]) o.hasClass(t) ? o.removeClass(t) : o.addClass(t)
                } else(n === i || "boolean" === n) && (this.className && x._data(this, "__className__", this.className), this.className = this.className || e === !1 ? "" : x._data(this, "__className__") || "")
            })
        },
        hasClass: function(e) {
            var t = " " + e + " ",
                n = 0,
                r = this.length;
            for (; r > n; n++)
                if (1 === this[n].nodeType && (" " + this[n].className + " ").replace(U, " ").indexOf(t) >= 0) return !0;
            return !1
        },
        val: function(e) {
            var n, r, i, o = this[0]; {
                if (arguments.length) return i = x.isFunction(e), this.each(function(n) {
                    var o;
                    1 === this.nodeType && (o = i ? e.call(this, n, x(this).val()) : e, null == o ? o = "" : "number" == typeof o ? o += "" : x.isArray(o) && (o = x.map(o, function(e) {
                        return null == e ? "" : e + ""
                    })), r = x.valHooks[this.type] || x.valHooks[this.nodeName.toLowerCase()], r && "set" in r && r.set(this, o, "value") !== t || (this.value = o))
                });
                if (o) return r = x.valHooks[o.type] || x.valHooks[o.nodeName.toLowerCase()], r && "get" in r && (n = r.get(o, "value")) !== t ? n : (n = o.value, "string" == typeof n ? n.replace(V, "") : null == n ? "" : n)
            }
        }
    }), x.extend({
        valHooks: {
            option: {
                get: function(e) {
                    var t = x.find.attr(e, "value");
                    return null != t ? t : e.text
                }
            },
            select: {
                get: function(e) {
                    var t, n, r = e.options,
                        i = e.selectedIndex,
                        o = "select-one" === e.type || 0 > i,
                        a = o ? null : [],
                        s = o ? i + 1 : r.length,
                        l = 0 > i ? s : o ? i : 0;
                    for (; s > l; l++)
                        if (n = r[l], !(!n.selected && l !== i || (x.support.optDisabled ? n.disabled : null !== n.getAttribute("disabled")) || n.parentNode.disabled && x.nodeName(n.parentNode, "optgroup"))) {
                            if (t = x(n).val(), o) return t;
                            a.push(t)
                        }
                    return a
                },
                set: function(e, t) {
                    var n, r, i = e.options,
                        o = x.makeArray(t),
                        a = i.length;
                    while (a--) r = i[a], (r.selected = x.inArray(x(r).val(), o) >= 0) && (n = !0);
                    return n || (e.selectedIndex = -1), o
                }
            }
        },
        attr: function(e, n, r) {
            var o, a, s = e.nodeType;
            if (e && 3 !== s && 8 !== s && 2 !== s) return typeof e.getAttribute === i ? x.prop(e, n, r) : (1 === s && x.isXMLDoc(e) || (n = n.toLowerCase(), o = x.attrHooks[n] || (x.expr.match.bool.test(n) ? X : z)), r === t ? o && "get" in o && null !== (a = o.get(e, n)) ? a : (a = x.find.attr(e, n), null == a ? t : a) : null !== r ? o && "set" in o && (a = o.set(e, r, n)) !== t ? a : (e.setAttribute(n, r + ""), r) : (x.removeAttr(e, n), t))
        },
        removeAttr: function(e, t) {
            var n, r, i = 0,
                o = t && t.match(T);
            if (o && 1 === e.nodeType)
                while (n = o[i++]) r = x.propFix[n] || n, x.expr.match.bool.test(n) ? K && Q || !G.test(n) ? e[r] = !1 : e[x.camelCase("default-" + n)] = e[r] = !1 : x.attr(e, n, ""), e.removeAttribute(Q ? n : r)
        },
        attrHooks: {
            type: {
                set: function(e, t) {
                    if (!x.support.radioValue && "radio" === t && x.nodeName(e, "input")) {
                        var n = e.value;
                        return e.setAttribute("type", t), n && (e.value = n), t
                    }
                }
            }
        },
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(e, n, r) {
            var i, o, a, s = e.nodeType;
            if (e && 3 !== s && 8 !== s && 2 !== s) return a = 1 !== s || !x.isXMLDoc(e), a && (n = x.propFix[n] || n, o = x.propHooks[n]), r !== t ? o && "set" in o && (i = o.set(e, r, n)) !== t ? i : e[n] = r : o && "get" in o && null !== (i = o.get(e, n)) ? i : e[n]
        },
        propHooks: {
            tabIndex: {
                get: function(e) {
                    var t = x.find.attr(e, "tabindex");
                    return t ? parseInt(t, 10) : Y.test(e.nodeName) || J.test(e.nodeName) && e.href ? 0 : -1
                }
            }
        }
    }), X = {
        set: function(e, t, n) {
            return t === !1 ? x.removeAttr(e, n) : K && Q || !G.test(n) ? e.setAttribute(!Q && x.propFix[n] || n, n) : e[x.camelCase("default-" + n)] = e[n] = !0, n
        }
    }, x.each(x.expr.match.bool.source.match(/\w+/g), function(e, n) {
        var r = x.expr.attrHandle[n] || x.find.attr;
        x.expr.attrHandle[n] = K && Q || !G.test(n) ? function(e, n, i) {
            var o = x.expr.attrHandle[n],
                a = i ? t : (x.expr.attrHandle[n] = t) != r(e, n, i) ? n.toLowerCase() : null;
            return x.expr.attrHandle[n] = o, a
        } : function(e, n, r) {
            return r ? t : e[x.camelCase("default-" + n)] ? n.toLowerCase() : null
        }
    }), K && Q || (x.attrHooks.value = {
        set: function(e, n, r) {
            return x.nodeName(e, "input") ? (e.defaultValue = n, t) : z && z.set(e, n, r)
        }
    }), Q || (z = {
        set: function(e, n, r) {
            var i = e.getAttributeNode(r);
            return i || e.setAttributeNode(i = e.ownerDocument.createAttribute(r)), i.value = n += "", "value" === r || n === e.getAttribute(r) ? n : t
        }
    }, x.expr.attrHandle.id = x.expr.attrHandle.name = x.expr.attrHandle.coords = function(e, n, r) {
        var i;
        return r ? t : (i = e.getAttributeNode(n)) && "" !== i.value ? i.value : null
    }, x.valHooks.button = {
        get: function(e, n) {
            var r = e.getAttributeNode(n);
            return r && r.specified ? r.value : t
        },
        set: z.set
    }, x.attrHooks.contenteditable = {
        set: function(e, t, n) {
            z.set(e, "" === t ? !1 : t, n)
        }
    }, x.each(["width", "height"], function(e, n) {
        x.attrHooks[n] = {
            set: function(e, r) {
                return "" === r ? (e.setAttribute(n, "auto"), r) : t
            }
        }
    })), x.support.hrefNormalized || x.each(["href", "src"], function(e, t) {
        x.propHooks[t] = {
            get: function(e) {
                return e.getAttribute(t, 4)
            }
        }
    }), x.support.style || (x.attrHooks.style = {
        get: function(e) {
            return e.style.cssText || t
        },
        set: function(e, t) {
            return e.style.cssText = t + ""
        }
    }), x.support.optSelected || (x.propHooks.selected = {
        get: function(e) {
            var t = e.parentNode;
            return t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex), null
        }
    }), x.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        x.propFix[this.toLowerCase()] = this
    }), x.support.enctype || (x.propFix.enctype = "encoding"), x.each(["radio", "checkbox"], function() {
        x.valHooks[this] = {
            set: function(e, n) {
                return x.isArray(n) ? e.checked = x.inArray(x(e).val(), n) >= 0 : t
            }
        }, x.support.checkOn || (x.valHooks[this].get = function(e) {
            return null === e.getAttribute("value") ? "on" : e.value
        })
    });
    var Z = /^(?:input|select|textarea)$/i,
        et = /^key/,
        tt = /^(?:mouse|contextmenu)|click/,
        nt = /^(?:focusinfocus|focusoutblur)$/,
        rt = /^([^.]*)(?:\.(.+)|)$/;

    function it() {
        return !0
    }

    function ot() {
        return !1
    }

    function at() {
        try {
            return a.activeElement
        } catch (e) {}
    }
    x.event = {
        global: {},
        add: function(e, n, r, o, a) {
            var s, l, u, c, p, f, d, h, g, m, y, v = x._data(e);
            if (v) {
                r.handler && (c = r, r = c.handler, a = c.selector), r.guid || (r.guid = x.guid++), (l = v.events) || (l = v.events = {}), (f = v.handle) || (f = v.handle = function(e) {
                    return typeof x === i || e && x.event.triggered === e.type ? t : x.event.dispatch.apply(f.elem, arguments)
                }, f.elem = e), n = (n || "").match(T) || [""], u = n.length;
                while (u--) s = rt.exec(n[u]) || [], g = y = s[1], m = (s[2] || "").split(".").sort(), g && (p = x.event.special[g] || {}, g = (a ? p.delegateType : p.bindType) || g, p = x.event.special[g] || {}, d = x.extend({
                    type: g,
                    origType: y,
                    data: o,
                    handler: r,
                    guid: r.guid,
                    selector: a,
                    needsContext: a && x.expr.match.needsContext.test(a),
                    namespace: m.join(".")
                }, c), (h = l[g]) || (h = l[g] = [], h.delegateCount = 0, p.setup && p.setup.call(e, o, m, f) !== !1 || (e.addEventListener ? e.addEventListener(g, f, !1) : e.attachEvent && e.attachEvent("on" + g, f))), p.add && (p.add.call(e, d), d.handler.guid || (d.handler.guid = r.guid)), a ? h.splice(h.delegateCount++, 0, d) : h.push(d), x.event.global[g] = !0);
                e = null
            }
        },
        remove: function(e, t, n, r, i) {
            var o, a, s, l, u, c, p, f, d, h, g, m = x.hasData(e) && x._data(e);
            if (m && (c = m.events)) {
                t = (t || "").match(T) || [""], u = t.length;
                while (u--)
                    if (s = rt.exec(t[u]) || [], d = g = s[1], h = (s[2] || "").split(".").sort(), d) {
                        p = x.event.special[d] || {}, d = (r ? p.delegateType : p.bindType) || d, f = c[d] || [], s = s[2] && RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)"), l = o = f.length;
                        while (o--) a = f[o], !i && g !== a.origType || n && n.guid !== a.guid || s && !s.test(a.namespace) || r && r !== a.selector && ("**" !== r || !a.selector) || (f.splice(o, 1), a.selector && f.delegateCount--, p.remove && p.remove.call(e, a));
                        l && !f.length && (p.teardown && p.teardown.call(e, h, m.handle) !== !1 || x.removeEvent(e, d, m.handle), delete c[d])
                    } else
                        for (d in c) x.event.remove(e, d + t[u], n, r, !0);
                x.isEmptyObject(c) && (delete m.handle, x._removeData(e, "events"))
            }
        },
        trigger: function(n, r, i, o) {
            var s, l, u, c, p, f, d, h = [i || a],
                g = v.call(n, "type") ? n.type : n,
                m = v.call(n, "namespace") ? n.namespace.split(".") : [];
            if (u = f = i = i || a, 3 !== i.nodeType && 8 !== i.nodeType && !nt.test(g + x.event.triggered) && (g.indexOf(".") >= 0 && (m = g.split("."), g = m.shift(), m.sort()), l = 0 > g.indexOf(":") && "on" + g, n = n[x.expando] ? n : new x.Event(g, "object" == typeof n && n), n.isTrigger = o ? 2 : 3, n.namespace = m.join("."), n.namespace_re = n.namespace ? RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, n.result = t, n.target || (n.target = i), r = null == r ? [n] : x.makeArray(r, [n]), p = x.event.special[g] || {}, o || !p.trigger || p.trigger.apply(i, r) !== !1)) {
                if (!o && !p.noBubble && !x.isWindow(i)) {
                    for (c = p.delegateType || g, nt.test(c + g) || (u = u.parentNode); u; u = u.parentNode) h.push(u), f = u;
                    f === (i.ownerDocument || a) && h.push(f.defaultView || f.parentWindow || e)
                }
                d = 0;
                while ((u = h[d++]) && !n.isPropagationStopped()) n.type = d > 1 ? c : p.bindType || g, s = (x._data(u, "events") || {})[n.type] && x._data(u, "handle"), s && s.apply(u, r), s = l && u[l], s && x.acceptData(u) && s.apply && s.apply(u, r) === !1 && n.preventDefault();
                if (n.type = g, !o && !n.isDefaultPrevented() && (!p._default || p._default.apply(h.pop(), r) === !1) && x.acceptData(i) && l && i[g] && !x.isWindow(i)) {
                    f = i[l], f && (i[l] = null), x.event.triggered = g;
                    try {
                        i[g]()
                    } catch (y) {}
                    x.event.triggered = t, f && (i[l] = f)
                }
                return n.result
            }
        },
        dispatch: function(e) {
            e = x.event.fix(e);
            var n, r, i, o, a, s = [],
                l = g.call(arguments),
                u = (x._data(this, "events") || {})[e.type] || [],
                c = x.event.special[e.type] || {};
            if (l[0] = e, e.delegateTarget = this, !c.preDispatch || c.preDispatch.call(this, e) !== !1) {
                s = x.event.handlers.call(this, e, u), n = 0;
                while ((o = s[n++]) && !e.isPropagationStopped()) {
                    e.currentTarget = o.elem, a = 0;
                    while ((i = o.handlers[a++]) && !e.isImmediatePropagationStopped())(!e.namespace_re || e.namespace_re.test(i.namespace)) && (e.handleObj = i, e.data = i.data, r = ((x.event.special[i.origType] || {}).handle || i.handler).apply(o.elem, l), r !== t && (e.result = r) === !1 && (e.preventDefault(), e.stopPropagation()))
                }
                return c.postDispatch && c.postDispatch.call(this, e), e.result
            }
        },
        handlers: function(e, n) {
            var r, i, o, a, s = [],
                l = n.delegateCount,
                u = e.target;
            if (l && u.nodeType && (!e.button || "click" !== e.type))
                for (; u != this; u = u.parentNode || this)
                    if (1 === u.nodeType && (u.disabled !== !0 || "click" !== e.type)) {
                        for (o = [], a = 0; l > a; a++) i = n[a], r = i.selector + " ", o[r] === t && (o[r] = i.needsContext ? x(r, this).index(u) >= 0 : x.find(r, this, null, [u]).length), o[r] && o.push(i);
                        o.length && s.push({
                            elem: u,
                            handlers: o
                        })
                    }
            return n.length > l && s.push({
                elem: this,
                handlers: n.slice(l)
            }), s
        },
        fix: function(e) {
            if (e[x.expando]) return e;
            var t, n, r, i = e.type,
                o = e,
                s = this.fixHooks[i];
            s || (this.fixHooks[i] = s = tt.test(i) ? this.mouseHooks : et.test(i) ? this.keyHooks : {}), r = s.props ? this.props.concat(s.props) : this.props, e = new x.Event(o), t = r.length;
            while (t--) n = r[t], e[n] = o[n];
            return e.target || (e.target = o.srcElement || a), 3 === e.target.nodeType && (e.target = e.target.parentNode), e.metaKey = !!e.metaKey, s.filter ? s.filter(e, o) : e
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(e, t) {
                return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(e, n) {
                var r, i, o, s = n.button,
                    l = n.fromElement;
                return null == e.pageX && null != n.clientX && (i = e.target.ownerDocument || a, o = i.documentElement, r = i.body, e.pageX = n.clientX + (o && o.scrollLeft || r && r.scrollLeft || 0) - (o && o.clientLeft || r && r.clientLeft || 0), e.pageY = n.clientY + (o && o.scrollTop || r && r.scrollTop || 0) - (o && o.clientTop || r && r.clientTop || 0)), !e.relatedTarget && l && (e.relatedTarget = l === e.target ? n.toElement : l), e.which || s === t || (e.which = 1 & s ? 1 : 2 & s ? 3 : 4 & s ? 2 : 0), e
            }
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== at() && this.focus) try {
                        return this.focus(), !1
                    } catch (e) {}
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === at() && this.blur ? (this.blur(), !1) : t
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return x.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : t
                },
                _default: function(e) {
                    return x.nodeName(e.target, "a")
                }
            },
            beforeunload: {
                postDispatch: function(e) {
                    e.result !== t && (e.originalEvent.returnValue = e.result)
                }
            }
        },
        simulate: function(e, t, n, r) {
            var i = x.extend(new x.Event, n, {
                type: e,
                isSimulated: !0,
                originalEvent: {}
            });
            r ? x.event.trigger(i, null, t) : x.event.dispatch.call(t, i), i.isDefaultPrevented() && n.preventDefault()
        }
    }, x.removeEvent = a.removeEventListener ? function(e, t, n) {
        e.removeEventListener && e.removeEventListener(t, n, !1)
    } : function(e, t, n) {
        var r = "on" + t;
        e.detachEvent && (typeof e[r] === i && (e[r] = null), e.detachEvent(r, n))
    }, x.Event = function(e, n) {
        return this instanceof x.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || e.returnValue === !1 || e.getPreventDefault && e.getPreventDefault() ? it : ot) : this.type = e, n && x.extend(this, n), this.timeStamp = e && e.timeStamp || x.now(), this[x.expando] = !0, t) : new x.Event(e, n)
    }, x.Event.prototype = {
        isDefaultPrevented: ot,
        isPropagationStopped: ot,
        isImmediatePropagationStopped: ot,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = it, e && (e.preventDefault ? e.preventDefault() : e.returnValue = !1)
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = it, e && (e.stopPropagation && e.stopPropagation(), e.cancelBubble = !0)
        },
        stopImmediatePropagation: function() {
            this.isImmediatePropagationStopped = it, this.stopPropagation()
        }
    }, x.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    }, function(e, t) {
        x.event.special[e] = {
            delegateType: t,
            bindType: t,
            handle: function(e) {
                var n, r = this,
                    i = e.relatedTarget,
                    o = e.handleObj;
                return (!i || i !== r && !x.contains(r, i)) && (e.type = o.origType, n = o.handler.apply(this, arguments), e.type = t), n
            }
        }
    }), x.support.submitBubbles || (x.event.special.submit = {
        setup: function() {
            return x.nodeName(this, "form") ? !1 : (x.event.add(this, "click._submit keypress._submit", function(e) {
                var n = e.target,
                    r = x.nodeName(n, "input") || x.nodeName(n, "button") ? n.form : t;
                r && !x._data(r, "submitBubbles") && (x.event.add(r, "submit._submit", function(e) {
                    e._submit_bubble = !0
                }), x._data(r, "submitBubbles", !0))
            }), t)
        },
        postDispatch: function(e) {
            e._submit_bubble && (delete e._submit_bubble, this.parentNode && !e.isTrigger && x.event.simulate("submit", this.parentNode, e, !0))
        },
        teardown: function() {
            return x.nodeName(this, "form") ? !1 : (x.event.remove(this, "._submit"), t)
        }
    }), x.support.changeBubbles || (x.event.special.change = {
        setup: function() {
            return Z.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (x.event.add(this, "propertychange._change", function(e) {
                "checked" === e.originalEvent.propertyName && (this._just_changed = !0)
            }), x.event.add(this, "click._change", function(e) {
                this._just_changed && !e.isTrigger && (this._just_changed = !1), x.event.simulate("change", this, e, !0)
            })), !1) : (x.event.add(this, "beforeactivate._change", function(e) {
                var t = e.target;
                Z.test(t.nodeName) && !x._data(t, "changeBubbles") && (x.event.add(t, "change._change", function(e) {
                    !this.parentNode || e.isSimulated || e.isTrigger || x.event.simulate("change", this.parentNode, e, !0)
                }), x._data(t, "changeBubbles", !0))
            }), t)
        },
        handle: function(e) {
            var n = e.target;
            return this !== n || e.isSimulated || e.isTrigger || "radio" !== n.type && "checkbox" !== n.type ? e.handleObj.handler.apply(this, arguments) : t
        },
        teardown: function() {
            return x.event.remove(this, "._change"), !Z.test(this.nodeName)
        }
    }), x.support.focusinBubbles || x.each({
        focus: "focusin",
        blur: "focusout"
    }, function(e, t) {
        var n = 0,
            r = function(e) {
                x.event.simulate(t, e.target, x.event.fix(e), !0)
            };
        x.event.special[t] = {
            setup: function() {
                0 === n++ && a.addEventListener(e, r, !0)
            },
            teardown: function() {
                0 === --n && a.removeEventListener(e, r, !0)
            }
        }
    }), x.fn.extend({
        on: function(e, n, r, i, o) {
            var a, s;
            if ("object" == typeof e) {
                "string" != typeof n && (r = r || n, n = t);
                for (a in e) this.on(a, n, r, e[a], o);
                return this
            }
            if (null == r && null == i ? (i = n, r = n = t) : null == i && ("string" == typeof n ? (i = r, r = t) : (i = r, r = n, n = t)), i === !1) i = ot;
            else if (!i) return this;
            return 1 === o && (s = i, i = function(e) {
                return x().off(e), s.apply(this, arguments)
            }, i.guid = s.guid || (s.guid = x.guid++)), this.each(function() {
                x.event.add(this, e, i, r, n)
            })
        },
        one: function(e, t, n, r) {
            return this.on(e, t, n, r, 1)
        },
        off: function(e, n, r) {
            var i, o;
            if (e && e.preventDefault && e.handleObj) return i = e.handleObj, x(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler), this;
            if ("object" == typeof e) {
                for (o in e) this.off(o, n, e[o]);
                return this
            }
            return (n === !1 || "function" == typeof n) && (r = n, n = t), r === !1 && (r = ot), this.each(function() {
                x.event.remove(this, e, r, n)
            })
        },
        trigger: function(e, t) {
            return this.each(function() {
                x.event.trigger(e, t, this)
            })
        },
        triggerHandler: function(e, n) {
            var r = this[0];
            return r ? x.event.trigger(e, n, r, !0) : t
        }
    });
    var st = /^.[^:#\[\.,]*$/,
        lt = /^(?:parents|prev(?:Until|All))/,
        ut = x.expr.match.needsContext,
        ct = {
            children: !0,
            contents: !0,
            next: !0,
            prev: !0
        };
    x.fn.extend({
        find: function(e) {
            var t, n = [],
                r = this,
                i = r.length;
            if ("string" != typeof e) return this.pushStack(x(e).filter(function() {
                for (t = 0; i > t; t++)
                    if (x.contains(r[t], this)) return !0
            }));
            for (t = 0; i > t; t++) x.find(e, r[t], n);
            return n = this.pushStack(i > 1 ? x.unique(n) : n), n.selector = this.selector ? this.selector + " " + e : e, n
        },
        has: function(e) {
            var t, n = x(e, this),
                r = n.length;
            return this.filter(function() {
                for (t = 0; r > t; t++)
                    if (x.contains(this, n[t])) return !0
            })
        },
        not: function(e) {
            return this.pushStack(ft(this, e || [], !0))
        },
        filter: function(e) {
            return this.pushStack(ft(this, e || [], !1))
        },
        is: function(e) {
            return !!ft(this, "string" == typeof e && ut.test(e) ? x(e) : e || [], !1).length
        },
        closest: function(e, t) {
            var n, r = 0,
                i = this.length,
                o = [],
                a = ut.test(e) || "string" != typeof e ? x(e, t || this.context) : 0;
            for (; i > r; r++)
                for (n = this[r]; n && n !== t; n = n.parentNode)
                    if (11 > n.nodeType && (a ? a.index(n) > -1 : 1 === n.nodeType && x.find.matchesSelector(n, e))) {
                        n = o.push(n);
                        break
                    }
            return this.pushStack(o.length > 1 ? x.unique(o) : o)
        },
        index: function(e) {
            return e ? "string" == typeof e ? x.inArray(this[0], x(e)) : x.inArray(e.jquery ? e[0] : e, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        },
        add: function(e, t) {
            var n = "string" == typeof e ? x(e, t) : x.makeArray(e && e.nodeType ? [e] : e),
                r = x.merge(this.get(), n);
            return this.pushStack(x.unique(r))
        },
        addBack: function(e) {
            return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
        }
    });

    function pt(e, t) {
        do e = e[t]; while (e && 1 !== e.nodeType);
        return e
    }
    x.each({
        parent: function(e) {
            var t = e.parentNode;
            return t && 11 !== t.nodeType ? t : null
        },
        parents: function(e) {
            return x.dir(e, "parentNode")
        },
        parentsUntil: function(e, t, n) {
            return x.dir(e, "parentNode", n)
        },
        next: function(e) {
            return pt(e, "nextSibling")
        },
        prev: function(e) {
            return pt(e, "previousSibling")
        },
        nextAll: function(e) {
            return x.dir(e, "nextSibling")
        },
        prevAll: function(e) {
            return x.dir(e, "previousSibling")
        },
        nextUntil: function(e, t, n) {
            return x.dir(e, "nextSibling", n)
        },
        prevUntil: function(e, t, n) {
            return x.dir(e, "previousSibling", n)
        },
        siblings: function(e) {
            return x.sibling((e.parentNode || {}).firstChild, e)
        },
        children: function(e) {
            return x.sibling(e.firstChild)
        },
        contents: function(e) {
            return x.nodeName(e, "iframe") ? e.contentDocument || e.contentWindow.document : x.merge([], e.childNodes)
        }
    }, function(e, t) {
        x.fn[e] = function(n, r) {
            var i = x.map(this, t, n);
            return "Until" !== e.slice(-5) && (r = n), r && "string" == typeof r && (i = x.filter(r, i)), this.length > 1 && (ct[e] || (i = x.unique(i)), lt.test(e) && (i = i.reverse())), this.pushStack(i)
        }
    }), x.extend({
        filter: function(e, t, n) {
            var r = t[0];
            return n && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? x.find.matchesSelector(r, e) ? [r] : [] : x.find.matches(e, x.grep(t, function(e) {
                return 1 === e.nodeType
            }))
        },
        dir: function(e, n, r) {
            var i = [],
                o = e[n];
            while (o && 9 !== o.nodeType && (r === t || 1 !== o.nodeType || !x(o).is(r))) 1 === o.nodeType && i.push(o), o = o[n];
            return i
        },
        sibling: function(e, t) {
            var n = [];
            for (; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
            return n
        }
    });

    function ft(e, t, n) {
        if (x.isFunction(t)) return x.grep(e, function(e, r) {
            return !!t.call(e, r, e) !== n
        });
        if (t.nodeType) return x.grep(e, function(e) {
            return e === t !== n
        });
        if ("string" == typeof t) {
            if (st.test(t)) return x.filter(t, e, n);
            t = x.filter(t, e)
        }
        return x.grep(e, function(e) {
            return x.inArray(e, t) >= 0 !== n
        })
    }

    function dt(e) {
        var t = ht.split("|"),
            n = e.createDocumentFragment();
        if (n.createElement)
            while (t.length) n.createElement(t.pop());
        return n
    }
    var ht = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
        gt = / jQuery\d+="(?:null|\d+)"/g,
        mt = RegExp("<(?:" + ht + ")[\\s/>]", "i"),
        yt = /^\s+/,
        vt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
        bt = /<([\w:]+)/,
        xt = /<tbody/i,
        wt = /<|&#?\w+;/,
        Tt = /<(?:script|style|link)/i,
        Ct = /^(?:checkbox|radio)$/i,
        Nt = /checked\s*(?:[^=]|=\s*.checked.)/i,
        kt = /^$|\/(?:java|ecma)script/i,
        Et = /^true\/(.*)/,
        St = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
        At = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            legend: [1, "<fieldset>", "</fieldset>"],
            area: [1, "<map>", "</map>"],
            param: [1, "<object>", "</object>"],
            thead: [1, "<table>", "</table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: x.support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
        },
        jt = dt(a),
        Dt = jt.appendChild(a.createElement("div"));
    At.optgroup = At.option, At.tbody = At.tfoot = At.colgroup = At.caption = At.thead, At.th = At.td, x.fn.extend({
        text: function(e) {
            return x.access(this, function(e) {
                return e === t ? x.text(this) : this.empty().append((this[0] && this[0].ownerDocument || a).createTextNode(e))
            }, null, e, arguments.length)
        },
        append: function() {
            return this.domManip(arguments, function(e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = Lt(this, e);
                    t.appendChild(e)
                }
            })
        },
        prepend: function() {
            return this.domManip(arguments, function(e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = Lt(this, e);
                    t.insertBefore(e, t.firstChild)
                }
            })
        },
        before: function() {
            return this.domManip(arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this)
            })
        },
        after: function() {
            return this.domManip(arguments, function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
            })
        },
        remove: function(e, t) {
            var n, r = e ? x.filter(e, this) : this,
                i = 0;
            for (; null != (n = r[i]); i++) t || 1 !== n.nodeType || x.cleanData(Ft(n)), n.parentNode && (t && x.contains(n.ownerDocument, n) && _t(Ft(n, "script")), n.parentNode.removeChild(n));
            return this
        },
        empty: function() {
            var e, t = 0;
            for (; null != (e = this[t]); t++) {
                1 === e.nodeType && x.cleanData(Ft(e, !1));
                while (e.firstChild) e.removeChild(e.firstChild);
                e.options && x.nodeName(e, "select") && (e.options.length = 0)
            }
            return this
        },
        clone: function(e, t) {
            return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function() {
                return x.clone(this, e, t)
            })
        },
        html: function(e) {
            return x.access(this, function(e) {
                var n = this[0] || {},
                    r = 0,
                    i = this.length;
                if (e === t) return 1 === n.nodeType ? n.innerHTML.replace(gt, "") : t;
                if (!("string" != typeof e || Tt.test(e) || !x.support.htmlSerialize && mt.test(e) || !x.support.leadingWhitespace && yt.test(e) || At[(bt.exec(e) || ["", ""])[1].toLowerCase()])) {
                    e = e.replace(vt, "<$1></$2>");
                    try {
                        for (; i > r; r++) n = this[r] || {}, 1 === n.nodeType && (x.cleanData(Ft(n, !1)), n.innerHTML = e);
                        n = 0
                    } catch (o) {}
                }
                n && this.empty().append(e)
            }, null, e, arguments.length)
        },
        replaceWith: function() {
            var e = x.map(this, function(e) {
                    return [e.nextSibling, e.parentNode]
                }),
                t = 0;
            return this.domManip(arguments, function(n) {
                var r = e[t++],
                    i = e[t++];
                i && (r && r.parentNode !== i && (r = this.nextSibling), x(this).remove(), i.insertBefore(n, r))
            }, !0), t ? this : this.remove()
        },
        detach: function(e) {
            return this.remove(e, !0)
        },
        domManip: function(e, t, n) {
            e = d.apply([], e);
            var r, i, o, a, s, l, u = 0,
                c = this.length,
                p = this,
                f = c - 1,
                h = e[0],
                g = x.isFunction(h);
            if (g || !(1 >= c || "string" != typeof h || x.support.checkClone) && Nt.test(h)) return this.each(function(r) {
                var i = p.eq(r);
                g && (e[0] = h.call(this, r, i.html())), i.domManip(e, t, n)
            });
            if (c && (l = x.buildFragment(e, this[0].ownerDocument, !1, !n && this), r = l.firstChild, 1 === l.childNodes.length && (l = r), r)) {
                for (a = x.map(Ft(l, "script"), Ht), o = a.length; c > u; u++) i = l, u !== f && (i = x.clone(i, !0, !0), o && x.merge(a, Ft(i, "script"))), t.call(this[u], i, u);
                if (o)
                    for (s = a[a.length - 1].ownerDocument, x.map(a, qt), u = 0; o > u; u++) i = a[u], kt.test(i.type || "") && !x._data(i, "globalEval") && x.contains(s, i) && (i.src ? x._evalUrl(i.src) : x.globalEval((i.text || i.textContent || i.innerHTML || "").replace(St, "")));
                l = r = null
            }
            return this
        }
    });

    function Lt(e, t) {
        return x.nodeName(e, "table") && x.nodeName(1 === t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e
    }

    function Ht(e) {
        return e.type = (null !== x.find.attr(e, "type")) + "/" + e.type, e
    }

    function qt(e) {
        var t = Et.exec(e.type);
        return t ? e.type = t[1] : e.removeAttribute("type"), e
    }

    function _t(e, t) {
        var n, r = 0;
        for (; null != (n = e[r]); r++) x._data(n, "globalEval", !t || x._data(t[r], "globalEval"))
    }

    function Mt(e, t) {
        if (1 === t.nodeType && x.hasData(e)) {
            var n, r, i, o = x._data(e),
                a = x._data(t, o),
                s = o.events;
            if (s) {
                delete a.handle, a.events = {};
                for (n in s)
                    for (r = 0, i = s[n].length; i > r; r++) x.event.add(t, n, s[n][r])
            }
            a.data && (a.data = x.extend({}, a.data))
        }
    }

    function Ot(e, t) {
        var n, r, i;
        if (1 === t.nodeType) {
            if (n = t.nodeName.toLowerCase(), !x.support.noCloneEvent && t[x.expando]) {
                i = x._data(t);
                for (r in i.events) x.removeEvent(t, r, i.handle);
                t.removeAttribute(x.expando)
            }
            "script" === n && t.text !== e.text ? (Ht(t).text = e.text, qt(t)) : "object" === n ? (t.parentNode && (t.outerHTML = e.outerHTML), x.support.html5Clone && e.innerHTML && !x.trim(t.innerHTML) && (t.innerHTML = e.innerHTML)) : "input" === n && Ct.test(e.type) ? (t.defaultChecked = t.checked = e.checked, t.value !== e.value && (t.value = e.value)) : "option" === n ? t.defaultSelected = t.selected = e.defaultSelected : ("input" === n || "textarea" === n) && (t.defaultValue = e.defaultValue)
        }
    }
    x.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(e, t) {
        x.fn[e] = function(e) {
            var n, r = 0,
                i = [],
                o = x(e),
                a = o.length - 1;
            for (; a >= r; r++) n = r === a ? this : this.clone(!0), x(o[r])[t](n), h.apply(i, n.get());
            return this.pushStack(i)
        }
    });

    function Ft(e, n) {
        var r, o, a = 0,
            s = typeof e.getElementsByTagName !== i ? e.getElementsByTagName(n || "*") : typeof e.querySelectorAll !== i ? e.querySelectorAll(n || "*") : t;
        if (!s)
            for (s = [], r = e.childNodes || e; null != (o = r[a]); a++) !n || x.nodeName(o, n) ? s.push(o) : x.merge(s, Ft(o, n));
        return n === t || n && x.nodeName(e, n) ? x.merge([e], s) : s
    }

    function Bt(e) {
        Ct.test(e.type) && (e.defaultChecked = e.checked)
    }
    x.extend({
        clone: function(e, t, n) {
            var r, i, o, a, s, l = x.contains(e.ownerDocument, e);
            if (x.support.html5Clone || x.isXMLDoc(e) || !mt.test("<" + e.nodeName + ">") ? o = e.cloneNode(!0) : (Dt.innerHTML = e.outerHTML, Dt.removeChild(o = Dt.firstChild)), !(x.support.noCloneEvent && x.support.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || x.isXMLDoc(e)))
                for (r = Ft(o), s = Ft(e), a = 0; null != (i = s[a]); ++a) r[a] && Ot(i, r[a]);
            if (t)
                if (n)
                    for (s = s || Ft(e), r = r || Ft(o), a = 0; null != (i = s[a]); a++) Mt(i, r[a]);
                else Mt(e, o);
            return r = Ft(o, "script"), r.length > 0 && _t(r, !l && Ft(e, "script")), r = s = i = null, o
        },
        buildFragment: function(e, t, n, r) {
            var i, o, a, s, l, u, c, p = e.length,
                f = dt(t),
                d = [],
                h = 0;
            for (; p > h; h++)
                if (o = e[h], o || 0 === o)
                    if ("object" === x.type(o)) x.merge(d, o.nodeType ? [o] : o);
                    else if (wt.test(o)) {
                s = s || f.appendChild(t.createElement("div")), l = (bt.exec(o) || ["", ""])[1].toLowerCase(), c = At[l] || At._default, s.innerHTML = c[1] + o.replace(vt, "<$1></$2>") + c[2], i = c[0];
                while (i--) s = s.lastChild;
                if (!x.support.leadingWhitespace && yt.test(o) && d.push(t.createTextNode(yt.exec(o)[0])), !x.support.tbody) {
                    o = "table" !== l || xt.test(o) ? "<table>" !== c[1] || xt.test(o) ? 0 : s : s.firstChild, i = o && o.childNodes.length;
                    while (i--) x.nodeName(u = o.childNodes[i], "tbody") && !u.childNodes.length && o.removeChild(u)
                }
                x.merge(d, s.childNodes), s.textContent = "";
                while (s.firstChild) s.removeChild(s.firstChild);
                s = f.lastChild
            } else d.push(t.createTextNode(o));
            s && f.removeChild(s), x.support.appendChecked || x.grep(Ft(d, "input"), Bt), h = 0;
            while (o = d[h++])
                if ((!r || -1 === x.inArray(o, r)) && (a = x.contains(o.ownerDocument, o), s = Ft(f.appendChild(o), "script"), a && _t(s), n)) {
                    i = 0;
                    while (o = s[i++]) kt.test(o.type || "") && n.push(o)
                }
            return s = null, f
        },
        cleanData: function(e, t) {
            var n, r, o, a, s = 0,
                l = x.expando,
                u = x.cache,
                c = x.support.deleteExpando,
                f = x.event.special;
            for (; null != (n = e[s]); s++)
                if ((t || x.acceptData(n)) && (o = n[l], a = o && u[o])) {
                    if (a.events)
                        for (r in a.events) f[r] ? x.event.remove(n, r) : x.removeEvent(n, r, a.handle);
                    u[o] && (delete u[o], c ? delete n[l] : typeof n.removeAttribute !== i ? n.removeAttribute(l) : n[l] = null, p.push(o))
                }
        },
        _evalUrl: function(e) {
            return x.ajax({
                url: e,
                type: "GET",
                dataType: "script",
                async: !1,
                global: !1,
                "throws": !0
            })
        }
    }), x.fn.extend({
        wrapAll: function(e) {
            if (x.isFunction(e)) return this.each(function(t) {
                x(this).wrapAll(e.call(this, t))
            });
            if (this[0]) {
                var t = x(e, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
                    var e = this;
                    while (e.firstChild && 1 === e.firstChild.nodeType) e = e.firstChild;
                    return e
                }).append(this)
            }
            return this
        },
        wrapInner: function(e) {
            return x.isFunction(e) ? this.each(function(t) {
                x(this).wrapInner(e.call(this, t))
            }) : this.each(function() {
                var t = x(this),
                    n = t.contents();
                n.length ? n.wrapAll(e) : t.append(e)
            })
        },
        wrap: function(e) {
            var t = x.isFunction(e);
            return this.each(function(n) {
                x(this).wrapAll(t ? e.call(this, n) : e)
            })
        },
        unwrap: function() {
            return this.parent().each(function() {
                x.nodeName(this, "body") || x(this).replaceWith(this.childNodes)
            }).end()
        }
    });
    var Pt, Rt, Wt, $t = /alpha\([^)]*\)/i,
        It = /opacity\s*=\s*([^)]*)/,
        zt = /^(top|right|bottom|left)$/,
        Xt = /^(none|table(?!-c[ea]).+)/,
        Ut = /^margin/,
        Vt = RegExp("^(" + w + ")(.*)$", "i"),
        Yt = RegExp("^(" + w + ")(?!px)[a-z%]+$", "i"),
        Jt = RegExp("^([+-])=(" + w + ")", "i"),
        Gt = {
            BODY: "block"
        },
        Qt = {
            position: "absolute",
            visibility: "hidden",
            display: "block"
        },
        Kt = {
            letterSpacing: 0,
            fontWeight: 400
        },
        Zt = ["Top", "Right", "Bottom", "Left"],
        en = ["Webkit", "O", "Moz", "ms"];

    function tn(e, t) {
        if (t in e) return t;
        var n = t.charAt(0).toUpperCase() + t.slice(1),
            r = t,
            i = en.length;
        while (i--)
            if (t = en[i] + n, t in e) return t;
        return r
    }

    function nn(e, t) {
        return e = t || e, "none" === x.css(e, "display") || !x.contains(e.ownerDocument, e)
    }

    function rn(e, t) {
        var n, r, i, o = [],
            a = 0,
            s = e.length;
        for (; s > a; a++) r = e[a], r.style && (o[a] = x._data(r, "olddisplay"), n = r.style.display, t ? (o[a] || "none" !== n || (r.style.display = ""), "" === r.style.display && nn(r) && (o[a] = x._data(r, "olddisplay", ln(r.nodeName)))) : o[a] || (i = nn(r), (n && "none" !== n || !i) && x._data(r, "olddisplay", i ? n : x.css(r, "display"))));
        for (a = 0; s > a; a++) r = e[a], r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? o[a] || "" : "none"));
        return e
    }
    x.fn.extend({
        css: function(e, n) {
            return x.access(this, function(e, n, r) {
                var i, o, a = {},
                    s = 0;
                if (x.isArray(n)) {
                    for (o = Rt(e), i = n.length; i > s; s++) a[n[s]] = x.css(e, n[s], !1, o);
                    return a
                }
                return r !== t ? x.style(e, n, r) : x.css(e, n)
            }, e, n, arguments.length > 1)
        },
        show: function() {
            return rn(this, !0)
        },
        hide: function() {
            return rn(this)
        },
        toggle: function(e) {
            return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
                nn(this) ? x(this).show() : x(this).hide()
            })
        }
    }), x.extend({
        cssHooks: {
            opacity: {
                get: function(e, t) {
                    if (t) {
                        var n = Wt(e, "opacity");
                        return "" === n ? "1" : n
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            "float": x.support.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function(e, n, r, i) {
            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                var o, a, s, l = x.camelCase(n),
                    u = e.style;
                if (n = x.cssProps[l] || (x.cssProps[l] = tn(u, l)), s = x.cssHooks[n] || x.cssHooks[l], r === t) return s && "get" in s && (o = s.get(e, !1, i)) !== t ? o : u[n];
                if (a = typeof r, "string" === a && (o = Jt.exec(r)) && (r = (o[1] + 1) * o[2] + parseFloat(x.css(e, n)), a = "number"), !(null == r || "number" === a && isNaN(r) || ("number" !== a || x.cssNumber[l] || (r += "px"), x.support.clearCloneStyle || "" !== r || 0 !== n.indexOf("background") || (u[n] = "inherit"), s && "set" in s && (r = s.set(e, r, i)) === t))) try {
                    u[n] = r
                } catch (c) {}
            }
        },
        css: function(e, n, r, i) {
            var o, a, s, l = x.camelCase(n);
            return n = x.cssProps[l] || (x.cssProps[l] = tn(e.style, l)), s = x.cssHooks[n] || x.cssHooks[l], s && "get" in s && (a = s.get(e, !0, r)), a === t && (a = Wt(e, n, i)), "normal" === a && n in Kt && (a = Kt[n]), "" === r || r ? (o = parseFloat(a), r === !0 || x.isNumeric(o) ? o || 0 : a) : a
        }
    }), e.getComputedStyle ? (Rt = function(t) {
        return e.getComputedStyle(t, null)
    }, Wt = function(e, n, r) {
        var i, o, a, s = r || Rt(e),
            l = s ? s.getPropertyValue(n) || s[n] : t,
            u = e.style;
        return s && ("" !== l || x.contains(e.ownerDocument, e) || (l = x.style(e, n)), Yt.test(l) && Ut.test(n) && (i = u.width, o = u.minWidth, a = u.maxWidth, u.minWidth = u.maxWidth = u.width = l, l = s.width, u.width = i, u.minWidth = o, u.maxWidth = a)), l
    }) : a.documentElement.currentStyle && (Rt = function(e) {
        return e.currentStyle
    }, Wt = function(e, n, r) {
        var i, o, a, s = r || Rt(e),
            l = s ? s[n] : t,
            u = e.style;
        return null == l && u && u[n] && (l = u[n]), Yt.test(l) && !zt.test(n) && (i = u.left, o = e.runtimeStyle, a = o && o.left, a && (o.left = e.currentStyle.left), u.left = "fontSize" === n ? "1em" : l, l = u.pixelLeft + "px", u.left = i, a && (o.left = a)), "" === l ? "auto" : l
    });

    function on(e, t, n) {
        var r = Vt.exec(t);
        return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t
    }

    function an(e, t, n, r, i) {
        var o = n === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0,
            a = 0;
        for (; 4 > o; o += 2) "margin" === n && (a += x.css(e, n + Zt[o], !0, i)), r ? ("content" === n && (a -= x.css(e, "padding" + Zt[o], !0, i)), "margin" !== n && (a -= x.css(e, "border" + Zt[o] + "Width", !0, i))) : (a += x.css(e, "padding" + Zt[o], !0, i), "padding" !== n && (a += x.css(e, "border" + Zt[o] + "Width", !0, i)));
        return a
    }

    function sn(e, t, n) {
        var r = !0,
            i = "width" === t ? e.offsetWidth : e.offsetHeight,
            o = Rt(e),
            a = x.support.boxSizing && "border-box" === x.css(e, "boxSizing", !1, o);
        if (0 >= i || null == i) {
            if (i = Wt(e, t, o), (0 > i || null == i) && (i = e.style[t]), Yt.test(i)) return i;
            r = a && (x.support.boxSizingReliable || i === e.style[t]), i = parseFloat(i) || 0
        }
        return i + an(e, t, n || (a ? "border" : "content"), r, o) + "px"
    }

    function ln(e) {
        var t = a,
            n = Gt[e];
        return n || (n = un(e, t), "none" !== n && n || (Pt = (Pt || x("<iframe frameborder='0' width='0' height='0'/>").css("cssText", "display:block !important")).appendTo(t.documentElement), t = (Pt[0].contentWindow || Pt[0].contentDocument).document, t.write("<!doctype html><html><body>"), t.close(), n = un(e, t), Pt.detach()), Gt[e] = n), n
    }

    function un(e, t) {
        var n = x(t.createElement(e)).appendTo(t.body),
            r = x.css(n[0], "display");
        return n.remove(), r
    }
    x.each(["height", "width"], function(e, n) {
        x.cssHooks[n] = {
            get: function(e, r, i) {
                return r ? 0 === e.offsetWidth && Xt.test(x.css(e, "display")) ? x.swap(e, Qt, function() {
                    return sn(e, n, i)
                }) : sn(e, n, i) : t
            },
            set: function(e, t, r) {
                var i = r && Rt(e);
                return on(e, t, r ? an(e, n, r, x.support.boxSizing && "border-box" === x.css(e, "boxSizing", !1, i), i) : 0)
            }
        }
    }), x.support.opacity || (x.cssHooks.opacity = {
        get: function(e, t) {
            return It.test((t && e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : t ? "1" : ""
        },
        set: function(e, t) {
            var n = e.style,
                r = e.currentStyle,
                i = x.isNumeric(t) ? "alpha(opacity=" + 100 * t + ")" : "",
                o = r && r.filter || n.filter || "";
            n.zoom = 1, (t >= 1 || "" === t) && "" === x.trim(o.replace($t, "")) && n.removeAttribute && (n.removeAttribute("filter"), "" === t || r && !r.filter) || (n.filter = $t.test(o) ? o.replace($t, i) : o + " " + i)
        }
    }), x(function() {
        x.support.reliableMarginRight || (x.cssHooks.marginRight = {
            get: function(e, n) {
                return n ? x.swap(e, {
                    display: "inline-block"
                }, Wt, [e, "marginRight"]) : t
            }
        }), !x.support.pixelPosition && x.fn.position && x.each(["top", "left"], function(e, n) {
            x.cssHooks[n] = {
                get: function(e, r) {
                    return r ? (r = Wt(e, n), Yt.test(r) ? x(e).position()[n] + "px" : r) : t
                }
            }
        })
    }), x.expr && x.expr.filters && (x.expr.filters.hidden = function(e) {
        return 0 >= e.offsetWidth && 0 >= e.offsetHeight || !x.support.reliableHiddenOffsets && "none" === (e.style && e.style.display || x.css(e, "display"))
    }, x.expr.filters.visible = function(e) {
        return !x.expr.filters.hidden(e)
    }), x.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(e, t) {
        x.cssHooks[e + t] = {
            expand: function(n) {
                var r = 0,
                    i = {},
                    o = "string" == typeof n ? n.split(" ") : [n];
                for (; 4 > r; r++) i[e + Zt[r] + t] = o[r] || o[r - 2] || o[0];
                return i
            }
        }, Ut.test(e) || (x.cssHooks[e + t].set = on)
    });
    var cn = /%20/g,
        pn = /\[\]$/,
        fn = /\r?\n/g,
        dn = /^(?:submit|button|image|reset|file)$/i,
        hn = /^(?:input|select|textarea|keygen)/i;
    x.fn.extend({
        serialize: function() {
            return x.param(this.serializeArray())
        },
        serializeArray: function() {
            return this.map(function() {
                var e = x.prop(this, "elements");
                return e ? x.makeArray(e) : this
            }).filter(function() {
                var e = this.type;
                return this.name && !x(this).is(":disabled") && hn.test(this.nodeName) && !dn.test(e) && (this.checked || !Ct.test(e))
            }).map(function(e, t) {
                var n = x(this).val();
                return null == n ? null : x.isArray(n) ? x.map(n, function(e) {
                    return {
                        name: t.name,
                        value: e.replace(fn, "\r\n")
                    }
                }) : {
                    name: t.name,
                    value: n.replace(fn, "\r\n")
                }
            }).get()
        }
    }), x.param = function(e, n) {
        var r, i = [],
            o = function(e, t) {
                t = x.isFunction(t) ? t() : null == t ? "" : t, i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)
            };
        if (n === t && (n = x.ajaxSettings && x.ajaxSettings.traditional), x.isArray(e) || e.jquery && !x.isPlainObject(e)) x.each(e, function() {
            o(this.name, this.value)
        });
        else
            for (r in e) gn(r, e[r], n, o);
        return i.join("&").replace(cn, "+")
    };

    function gn(e, t, n, r) {
        var i;
        if (x.isArray(t)) x.each(t, function(t, i) {
            n || pn.test(e) ? r(e, i) : gn(e + "[" + ("object" == typeof i ? t : "") + "]", i, n, r)
        });
        else if (n || "object" !== x.type(t)) r(e, t);
        else
            for (i in t) gn(e + "[" + i + "]", t[i], n, r)
    }
    x.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(e, t) {
        x.fn[t] = function(e, n) {
            return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
        }
    }), x.fn.extend({
        hover: function(e, t) {
            return this.mouseenter(e).mouseleave(t || e)
        },
        bind: function(e, t, n) {
            return this.on(e, null, t, n)
        },
        unbind: function(e, t) {
            return this.off(e, null, t)
        },
        delegate: function(e, t, n, r) {
            return this.on(t, e, n, r)
        },
        undelegate: function(e, t, n) {
            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
        }
    });
    var mn, yn, vn = x.now(),
        bn = /\?/,
        xn = /#.*$/,
        wn = /([?&])_=[^&]*/,
        Tn = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
        Cn = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        Nn = /^(?:GET|HEAD)$/,
        kn = /^\/\//,
        En = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
        Sn = x.fn.load,
        An = {},
        jn = {},
        Dn = "*/".concat("*");
    try {
        yn = o.href
    } catch (Ln) {
        yn = a.createElement("a"), yn.href = "", yn = yn.href
    }
    mn = En.exec(yn.toLowerCase()) || [];

    function Hn(e) {
        return function(t, n) {
            "string" != typeof t && (n = t, t = "*");
            var r, i = 0,
                o = t.toLowerCase().match(T) || [];
            if (x.isFunction(n))
                while (r = o[i++]) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(n)) : (e[r] = e[r] || []).push(n)
        }
    }

    function qn(e, n, r, i) {
        var o = {},
            a = e === jn;

        function s(l) {
            var u;
            return o[l] = !0, x.each(e[l] || [], function(e, l) {
                var c = l(n, r, i);
                return "string" != typeof c || a || o[c] ? a ? !(u = c) : t : (n.dataTypes.unshift(c), s(c), !1)
            }), u
        }
        return s(n.dataTypes[0]) || !o["*"] && s("*")
    }

    function _n(e, n) {
        var r, i, o = x.ajaxSettings.flatOptions || {};
        for (i in n) n[i] !== t && ((o[i] ? e : r || (r = {}))[i] = n[i]);
        return r && x.extend(!0, e, r), e
    }
    x.fn.load = function(e, n, r) {
        if ("string" != typeof e && Sn) return Sn.apply(this, arguments);
        var i, o, a, s = this,
            l = e.indexOf(" ");
        return l >= 0 && (i = e.slice(l, e.length), e = e.slice(0, l)), x.isFunction(n) ? (r = n, n = t) : n && "object" == typeof n && (a = "POST"), s.length > 0 && x.ajax({
            url: e,
            type: a,
            dataType: "html",
            data: n
        }).done(function(e) {
            o = arguments, s.html(i ? x("<div>").append(x.parseHTML(e)).find(i) : e)
        }).complete(r && function(e, t) {
            s.each(r, o || [e.responseText, t, e])
        }), this
    }, x.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) {
        x.fn[t] = function(e) {
            return this.on(t, e)
        }
    }), x.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: yn,
            type: "GET",
            isLocal: Cn.test(mn[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Dn,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": x.parseJSON,
                "text xml": x.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(e, t) {
            return t ? _n(_n(e, x.ajaxSettings), t) : _n(x.ajaxSettings, e)
        },
        ajaxPrefilter: Hn(An),
        ajaxTransport: Hn(jn),
        ajax: function(e, n) {
            "object" == typeof e && (n = e, e = t), n = n || {};
            var r, i, o, a, s, l, u, c, p = x.ajaxSetup({}, n),
                f = p.context || p,
                d = p.context && (f.nodeType || f.jquery) ? x(f) : x.event,
                h = x.Deferred(),
                g = x.Callbacks("once memory"),
                m = p.statusCode || {},
                y = {},
                v = {},
                b = 0,
                w = "canceled",
                C = {
                    readyState: 0,
                    getResponseHeader: function(e) {
                        var t;
                        if (2 === b) {
                            if (!c) {
                                c = {};
                                while (t = Tn.exec(a)) c[t[1].toLowerCase()] = t[2]
                            }
                            t = c[e.toLowerCase()]
                        }
                        return null == t ? null : t
                    },
                    getAllResponseHeaders: function() {
                        return 2 === b ? a : null
                    },
                    setRequestHeader: function(e, t) {
                        var n = e.toLowerCase();
                        return b || (e = v[n] = v[n] || e, y[e] = t), this
                    },
                    overrideMimeType: function(e) {
                        return b || (p.mimeType = e), this
                    },
                    statusCode: function(e) {
                        var t;
                        if (e)
                            if (2 > b)
                                for (t in e) m[t] = [m[t], e[t]];
                            else C.always(e[C.status]);
                        return this
                    },
                    abort: function(e) {
                        var t = e || w;
                        return u && u.abort(t), k(0, t), this
                    }
                };
            if (h.promise(C).complete = g.add, C.success = C.done, C.error = C.fail, p.url = ((e || p.url || yn) + "").replace(xn, "").replace(kn, mn[1] + "//"), p.type = n.method || n.type || p.method || p.type, p.dataTypes = x.trim(p.dataType || "*").toLowerCase().match(T) || [""], null == p.crossDomain && (r = En.exec(p.url.toLowerCase()), p.crossDomain = !(!r || r[1] === mn[1] && r[2] === mn[2] && (r[3] || ("http:" === r[1] ? "80" : "443")) === (mn[3] || ("http:" === mn[1] ? "80" : "443")))), p.data && p.processData && "string" != typeof p.data && (p.data = x.param(p.data, p.traditional)), qn(An, p, n, C), 2 === b) return C;
            l = p.global, l && 0 === x.active++ && x.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Nn.test(p.type), o = p.url, p.hasContent || (p.data && (o = p.url += (bn.test(o) ? "&" : "?") + p.data, delete p.data), p.cache === !1 && (p.url = wn.test(o) ? o.replace(wn, "$1_=" + vn++) : o + (bn.test(o) ? "&" : "?") + "_=" + vn++)), p.ifModified && (x.lastModified[o] && C.setRequestHeader("If-Modified-Since", x.lastModified[o]), x.etag[o] && C.setRequestHeader("If-None-Match", x.etag[o])), (p.data && p.hasContent && p.contentType !== !1 || n.contentType) && C.setRequestHeader("Content-Type", p.contentType), C.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + Dn + "; q=0.01" : "") : p.accepts["*"]);
            for (i in p.headers) C.setRequestHeader(i, p.headers[i]);
            if (p.beforeSend && (p.beforeSend.call(f, C, p) === !1 || 2 === b)) return C.abort();
            w = "abort";
            for (i in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) C[i](p[i]);
            if (u = qn(jn, p, n, C)) {
                C.readyState = 1, l && d.trigger("ajaxSend", [C, p]), p.async && p.timeout > 0 && (s = setTimeout(function() {
                    C.abort("timeout")
                }, p.timeout));
                try {
                    b = 1, u.send(y, k)
                } catch (N) {
                    if (!(2 > b)) throw N;
                    k(-1, N)
                }
            } else k(-1, "No Transport");

            function k(e, n, r, i) {
                var c, y, v, w, T, N = n;
                2 !== b && (b = 2, s && clearTimeout(s), u = t, a = i || "", C.readyState = e > 0 ? 4 : 0, c = e >= 200 && 300 > e || 304 === e, r && (w = Mn(p, C, r)), w = On(p, w, C, c), c ? (p.ifModified && (T = C.getResponseHeader("Last-Modified"), T && (x.lastModified[o] = T), T = C.getResponseHeader("etag"), T && (x.etag[o] = T)), 204 === e || "HEAD" === p.type ? N = "nocontent" : 304 === e ? N = "notmodified" : (N = w.state, y = w.data, v = w.error, c = !v)) : (v = N, (e || !N) && (N = "error", 0 > e && (e = 0))), C.status = e, C.statusText = (n || N) + "", c ? h.resolveWith(f, [y, N, C]) : h.rejectWith(f, [C, N, v]), C.statusCode(m), m = t, l && d.trigger(c ? "ajaxSuccess" : "ajaxError", [C, p, c ? y : v]), g.fireWith(f, [C, N]), l && (d.trigger("ajaxComplete", [C, p]), --x.active || x.event.trigger("ajaxStop")))
            }
            return C
        },
        getJSON: function(e, t, n) {
            return x.get(e, t, n, "json")
        },
        getScript: function(e, n) {
            return x.get(e, t, n, "script")
        }
    }), x.each(["get", "post"], function(e, n) {
        x[n] = function(e, r, i, o) {
            return x.isFunction(r) && (o = o || i, i = r, r = t), x.ajax({
                url: e,
                type: n,
                dataType: o,
                data: r,
                success: i
            })
        }
    });

    function Mn(e, n, r) {
        var i, o, a, s, l = e.contents,
            u = e.dataTypes;
        while ("*" === u[0]) u.shift(), o === t && (o = e.mimeType || n.getResponseHeader("Content-Type"));
        if (o)
            for (s in l)
                if (l[s] && l[s].test(o)) {
                    u.unshift(s);
                    break
                }
        if (u[0] in r) a = u[0];
        else {
            for (s in r) {
                if (!u[0] || e.converters[s + " " + u[0]]) {
                    a = s;
                    break
                }
                i || (i = s)
            }
            a = a || i
        }
        return a ? (a !== u[0] && u.unshift(a), r[a]) : t
    }

    function On(e, t, n, r) {
        var i, o, a, s, l, u = {},
            c = e.dataTypes.slice();
        if (c[1])
            for (a in e.converters) u[a.toLowerCase()] = e.converters[a];
        o = c.shift();
        while (o)
            if (e.responseFields[o] && (n[e.responseFields[o]] = t), !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = c.shift())
                if ("*" === o) o = l;
                else if ("*" !== l && l !== o) {
            if (a = u[l + " " + o] || u["* " + o], !a)
                for (i in u)
                    if (s = i.split(" "), s[1] === o && (a = u[l + " " + s[0]] || u["* " + s[0]])) {
                        a === !0 ? a = u[i] : u[i] !== !0 && (o = s[0], c.unshift(s[1]));
                        break
                    }
            if (a !== !0)
                if (a && e["throws"]) t = a(t);
                else try {
                    t = a(t)
                } catch (p) {
                    return {
                        state: "parsererror",
                        error: a ? p : "No conversion from " + l + " to " + o
                    }
                }
        }
        return {
            state: "success",
            data: t
        }
    }
    x.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(e) {
                return x.globalEval(e), e
            }
        }
    }), x.ajaxPrefilter("script", function(e) {
        e.cache === t && (e.cache = !1), e.crossDomain && (e.type = "GET", e.global = !1)
    }), x.ajaxTransport("script", function(e) {
        if (e.crossDomain) {
            var n, r = a.head || x("head")[0] || a.documentElement;
            return {
                send: function(t, i) {
                    n = a.createElement("script"), n.async = !0, e.scriptCharset && (n.charset = e.scriptCharset), n.src = e.url, n.onload = n.onreadystatechange = function(e, t) {
                        (t || !n.readyState || /loaded|complete/.test(n.readyState)) && (n.onload = n.onreadystatechange = null, n.parentNode && n.parentNode.removeChild(n), n = null, t || i(200, "success"))
                    }, r.insertBefore(n, r.firstChild)
                },
                abort: function() {
                    n && n.onload(t, !0)
                }
            }
        }
    });
    var Fn = [],
        Bn = /(=)\?(?=&|$)|\?\?/;
    x.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var e = Fn.pop() || x.expando + "_" + vn++;
            return this[e] = !0, e
        }
    }), x.ajaxPrefilter("json jsonp", function(n, r, i) {
        var o, a, s, l = n.jsonp !== !1 && (Bn.test(n.url) ? "url" : "string" == typeof n.data && !(n.contentType || "").indexOf("application/x-www-form-urlencoded") && Bn.test(n.data) && "data");
        return l || "jsonp" === n.dataTypes[0] ? (o = n.jsonpCallback = x.isFunction(n.jsonpCallback) ? n.jsonpCallback() : n.jsonpCallback, l ? n[l] = n[l].replace(Bn, "$1" + o) : n.jsonp !== !1 && (n.url += (bn.test(n.url) ? "&" : "?") + n.jsonp + "=" + o), n.converters["script json"] = function() {
            return s || x.error(o + " was not called"), s[0]
        }, n.dataTypes[0] = "json", a = e[o], e[o] = function() {
            s = arguments
        }, i.always(function() {
            e[o] = a, n[o] && (n.jsonpCallback = r.jsonpCallback, Fn.push(o)), s && x.isFunction(a) && a(s[0]), s = a = t
        }), "script") : t
    });
    var Pn, Rn, Wn = 0,
        $n = e.ActiveXObject && function() {
            var e;
            for (e in Pn) Pn[e](t, !0)
        };

    function In() {
        try {
            return new e.XMLHttpRequest
        } catch (t) {}
    }

    function zn() {
        try {
            return new e.ActiveXObject("Microsoft.XMLHTTP")
        } catch (t) {}
    }
    x.ajaxSettings.xhr = e.ActiveXObject ? function() {
        return !this.isLocal && In() || zn()
    } : In, Rn = x.ajaxSettings.xhr(), x.support.cors = !!Rn && "withCredentials" in Rn, Rn = x.support.ajax = !!Rn, Rn && x.ajaxTransport(function(n) {
        if (!n.crossDomain || x.support.cors) {
            var r;
            return {
                send: function(i, o) {
                    var a, s, l = n.xhr();
                    if (n.username ? l.open(n.type, n.url, n.async, n.username, n.password) : l.open(n.type, n.url, n.async), n.xhrFields)
                        for (s in n.xhrFields) l[s] = n.xhrFields[s];
                    n.mimeType && l.overrideMimeType && l.overrideMimeType(n.mimeType), n.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest");
                    try {
                        for (s in i) l.setRequestHeader(s, i[s])
                    } catch (u) {}
                    l.send(n.hasContent && n.data || null), r = function(e, i) {
                        var s, u, c, p;
                        try {
                            if (r && (i || 4 === l.readyState))
                                if (r = t, a && (l.onreadystatechange = x.noop, $n && delete Pn[a]), i) 4 !== l.readyState && l.abort();
                                else {
                                    p = {}, s = l.status, u = l.getAllResponseHeaders(), "string" == typeof l.responseText && (p.text = l.responseText);
                                    try {
                                        c = l.statusText
                                    } catch (f) {
                                        c = ""
                                    }
                                    s || !n.isLocal || n.crossDomain ? 1223 === s && (s = 204) : s = p.text ? 200 : 404
                                }
                        } catch (d) {
                            i || o(-1, d)
                        }
                        p && o(s, c, p, u)
                    }, n.async ? 4 === l.readyState ? setTimeout(r) : (a = ++Wn, $n && (Pn || (Pn = {}, x(e).unload($n)), Pn[a] = r), l.onreadystatechange = r) : r()
                },
                abort: function() {
                    r && r(t, !0)
                }
            }
        }
    });
    var Xn, Un, Vn = /^(?:toggle|show|hide)$/,
        Yn = RegExp("^(?:([+-])=|)(" + w + ")([a-z%]*)$", "i"),
        Jn = /queueHooks$/,
        Gn = [nr],
        Qn = {
            "*": [function(e, t) {
                var n = this.createTween(e, t),
                    r = n.cur(),
                    i = Yn.exec(t),
                    o = i && i[3] || (x.cssNumber[e] ? "" : "px"),
                    a = (x.cssNumber[e] || "px" !== o && +r) && Yn.exec(x.css(n.elem, e)),
                    s = 1,
                    l = 20;
                if (a && a[3] !== o) {
                    o = o || a[3], i = i || [], a = +r || 1;
                    do s = s || ".5", a /= s, x.style(n.elem, e, a + o); while (s !== (s = n.cur() / r) && 1 !== s && --l)
                }
                return i && (a = n.start = +a || +r || 0, n.unit = o, n.end = i[1] ? a + (i[1] + 1) * i[2] : +i[2]), n
            }]
        };

    function Kn() {
        return setTimeout(function() {
            Xn = t
        }), Xn = x.now()
    }

    function Zn(e, t, n) {
        var r, i = (Qn[t] || []).concat(Qn["*"]),
            o = 0,
            a = i.length;
        for (; a > o; o++)
            if (r = i[o].call(n, t, e)) return r
    }

    function er(e, t, n) {
        var r, i, o = 0,
            a = Gn.length,
            s = x.Deferred().always(function() {
                delete l.elem
            }),
            l = function() {
                if (i) return !1;
                var t = Xn || Kn(),
                    n = Math.max(0, u.startTime + u.duration - t),
                    r = n / u.duration || 0,
                    o = 1 - r,
                    a = 0,
                    l = u.tweens.length;
                for (; l > a; a++) u.tweens[a].run(o);
                return s.notifyWith(e, [u, o, n]), 1 > o && l ? n : (s.resolveWith(e, [u]), !1)
            },
            u = s.promise({
                elem: e,
                props: x.extend({}, t),
                opts: x.extend(!0, {
                    specialEasing: {}
                }, n),
                originalProperties: t,
                originalOptions: n,
                startTime: Xn || Kn(),
                duration: n.duration,
                tweens: [],
                createTween: function(t, n) {
                    var r = x.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing);
                    return u.tweens.push(r), r
                },
                stop: function(t) {
                    var n = 0,
                        r = t ? u.tweens.length : 0;
                    if (i) return this;
                    for (i = !0; r > n; n++) u.tweens[n].run(1);
                    return t ? s.resolveWith(e, [u, t]) : s.rejectWith(e, [u, t]), this
                }
            }),
            c = u.props;
        for (tr(c, u.opts.specialEasing); a > o; o++)
            if (r = Gn[o].call(u, e, c, u.opts)) return r;
        return x.map(c, Zn, u), x.isFunction(u.opts.start) && u.opts.start.call(e, u), x.fx.timer(x.extend(l, {
            elem: e,
            anim: u,
            queue: u.opts.queue
        })), u.progress(u.opts.progress).done(u.opts.done, u.opts.complete).fail(u.opts.fail).always(u.opts.always)
    }

    function tr(e, t) {
        var n, r, i, o, a;
        for (n in e)
            if (r = x.camelCase(n), i = t[r], o = e[n], x.isArray(o) && (i = o[1], o = e[n] = o[0]), n !== r && (e[r] = o, delete e[n]), a = x.cssHooks[r], a && "expand" in a) {
                o = a.expand(o), delete e[r];
                for (n in o) n in e || (e[n] = o[n], t[n] = i)
            } else t[r] = i
    }
    x.Animation = x.extend(er, {
        tweener: function(e, t) {
            x.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");
            var n, r = 0,
                i = e.length;
            for (; i > r; r++) n = e[r], Qn[n] = Qn[n] || [], Qn[n].unshift(t)
        },
        prefilter: function(e, t) {
            t ? Gn.unshift(e) : Gn.push(e)
        }
    });

    function nr(e, t, n) {
        var r, i, o, a, s, l, u = this,
            c = {},
            p = e.style,
            f = e.nodeType && nn(e),
            d = x._data(e, "fxshow");
        n.queue || (s = x._queueHooks(e, "fx"), null == s.unqueued && (s.unqueued = 0, l = s.empty.fire, s.empty.fire = function() {
            s.unqueued || l()
        }), s.unqueued++, u.always(function() {
            u.always(function() {
                s.unqueued--, x.queue(e, "fx").length || s.empty.fire()
            })
        })), 1 === e.nodeType && ("height" in t || "width" in t) && (n.overflow = [p.overflow, p.overflowX, p.overflowY], "inline" === x.css(e, "display") && "none" === x.css(e, "float") && (x.support.inlineBlockNeedsLayout && "inline" !== ln(e.nodeName) ? p.zoom = 1 : p.display = "inline-block")), n.overflow && (p.overflow = "hidden", x.support.shrinkWrapBlocks || u.always(function() {
            p.overflow = n.overflow[0], p.overflowX = n.overflow[1], p.overflowY = n.overflow[2]
        }));
        for (r in t)
            if (i = t[r], Vn.exec(i)) {
                if (delete t[r], o = o || "toggle" === i, i === (f ? "hide" : "show")) continue;
                c[r] = d && d[r] || x.style(e, r)
            }
        if (!x.isEmptyObject(c)) {
            d ? "hidden" in d && (f = d.hidden) : d = x._data(e, "fxshow", {}), o && (d.hidden = !f), f ? x(e).show() : u.done(function() {
                x(e).hide()
            }), u.done(function() {
                var t;
                x._removeData(e, "fxshow");
                for (t in c) x.style(e, t, c[t])
            });
            for (r in c) a = Zn(f ? d[r] : 0, r, u), r in d || (d[r] = a.start, f && (a.end = a.start, a.start = "width" === r || "height" === r ? 1 : 0))
        }
    }

    function rr(e, t, n, r, i) {
        return new rr.prototype.init(e, t, n, r, i)
    }
    x.Tween = rr, rr.prototype = {
        constructor: rr,
        init: function(e, t, n, r, i, o) {
            this.elem = e, this.prop = n, this.easing = i || "swing", this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (x.cssNumber[n] ? "" : "px")
        },
        cur: function() {
            var e = rr.propHooks[this.prop];
            return e && e.get ? e.get(this) : rr.propHooks._default.get(this)
        },
        run: function(e) {
            var t, n = rr.propHooks[this.prop];
            return this.pos = t = this.options.duration ? x.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : rr.propHooks._default.set(this), this
        }
    }, rr.prototype.init.prototype = rr.prototype, rr.propHooks = {
        _default: {
            get: function(e) {
                var t;
                return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = x.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0) : e.elem[e.prop]
            },
            set: function(e) {
                x.fx.step[e.prop] ? x.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[x.cssProps[e.prop]] || x.cssHooks[e.prop]) ? x.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now
            }
        }
    }, rr.propHooks.scrollTop = rr.propHooks.scrollLeft = {
        set: function(e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
        }
    }, x.each(["toggle", "show", "hide"], function(e, t) {
        var n = x.fn[t];
        x.fn[t] = function(e, r, i) {
            return null == e || "boolean" == typeof e ? n.apply(this, arguments) : this.animate(ir(t, !0), e, r, i)
        }
    }), x.fn.extend({
        fadeTo: function(e, t, n, r) {
            return this.filter(nn).css("opacity", 0).show().end().animate({
                opacity: t
            }, e, n, r)
        },
        animate: function(e, t, n, r) {
            var i = x.isEmptyObject(e),
                o = x.speed(t, n, r),
                a = function() {
                    var t = er(this, x.extend({}, e), o);
                    (i || x._data(this, "finish")) && t.stop(!0)
                };
            return a.finish = a, i || o.queue === !1 ? this.each(a) : this.queue(o.queue, a)
        },
        stop: function(e, n, r) {
            var i = function(e) {
                var t = e.stop;
                delete e.stop, t(r)
            };
            return "string" != typeof e && (r = n, n = e, e = t), n && e !== !1 && this.queue(e || "fx", []), this.each(function() {
                var t = !0,
                    n = null != e && e + "queueHooks",
                    o = x.timers,
                    a = x._data(this);
                if (n) a[n] && a[n].stop && i(a[n]);
                else
                    for (n in a) a[n] && a[n].stop && Jn.test(n) && i(a[n]);
                for (n = o.length; n--;) o[n].elem !== this || null != e && o[n].queue !== e || (o[n].anim.stop(r), t = !1, o.splice(n, 1));
                (t || !r) && x.dequeue(this, e)
            })
        },
        finish: function(e) {
            return e !== !1 && (e = e || "fx"), this.each(function() {
                var t, n = x._data(this),
                    r = n[e + "queue"],
                    i = n[e + "queueHooks"],
                    o = x.timers,
                    a = r ? r.length : 0;
                for (n.finish = !0, x.queue(this, e, []), i && i.stop && i.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
                for (t = 0; a > t; t++) r[t] && r[t].finish && r[t].finish.call(this);
                delete n.finish
            })
        }
    });

    function ir(e, t) {
        var n, r = {
                height: e
            },
            i = 0;
        for (t = t ? 1 : 0; 4 > i; i += 2 - t) n = Zt[i], r["margin" + n] = r["padding" + n] = e;
        return t && (r.opacity = r.width = e), r
    }
    x.each({
        slideDown: ir("show"),
        slideUp: ir("hide"),
        slideToggle: ir("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(e, t) {
        x.fn[e] = function(e, n, r) {
            return this.animate(t, e, n, r)
        }
    }), x.speed = function(e, t, n) {
        var r = e && "object" == typeof e ? x.extend({}, e) : {
            complete: n || !n && t || x.isFunction(e) && e,
            duration: e,
            easing: n && t || t && !x.isFunction(t) && t
        };
        return r.duration = x.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in x.fx.speeds ? x.fx.speeds[r.duration] : x.fx.speeds._default, (null == r.queue || r.queue === !0) && (r.queue = "fx"), r.old = r.complete, r.complete = function() {
            x.isFunction(r.old) && r.old.call(this), r.queue && x.dequeue(this, r.queue)
        }, r
    }, x.easing = {
        linear: function(e) {
            return e
        },
        swing: function(e) {
            return .5 - Math.cos(e * Math.PI) / 2
        }
    }, x.timers = [], x.fx = rr.prototype.init, x.fx.tick = function() {
        var e, n = x.timers,
            r = 0;
        for (Xn = x.now(); n.length > r; r++) e = n[r], e() || n[r] !== e || n.splice(r--, 1);
        n.length || x.fx.stop(), Xn = t
    }, x.fx.timer = function(e) {
        e() && x.timers.push(e) && x.fx.start()
    }, x.fx.interval = 13, x.fx.start = function() {
        Un || (Un = setInterval(x.fx.tick, x.fx.interval))
    }, x.fx.stop = function() {
        clearInterval(Un), Un = null
    }, x.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, x.fx.step = {}, x.expr && x.expr.filters && (x.expr.filters.animated = function(e) {
        return x.grep(x.timers, function(t) {
            return e === t.elem
        }).length
    }), x.fn.offset = function(e) {
        if (arguments.length) return e === t ? this : this.each(function(t) {
            x.offset.setOffset(this, e, t)
        });
        var n, r, o = {
                top: 0,
                left: 0
            },
            a = this[0],
            s = a && a.ownerDocument;
        if (s) return n = s.documentElement, x.contains(n, a) ? (typeof a.getBoundingClientRect !== i && (o = a.getBoundingClientRect()), r = or(s), {
            top: o.top + (r.pageYOffset || n.scrollTop) - (n.clientTop || 0),
            left: o.left + (r.pageXOffset || n.scrollLeft) - (n.clientLeft || 0)
        }) : o
    }, x.offset = {
        setOffset: function(e, t, n) {
            var r = x.css(e, "position");
            "static" === r && (e.style.position = "relative");
            var i = x(e),
                o = i.offset(),
                a = x.css(e, "top"),
                s = x.css(e, "left"),
                l = ("absolute" === r || "fixed" === r) && x.inArray("auto", [a, s]) > -1,
                u = {},
                c = {},
                p, f;
            l ? (c = i.position(), p = c.top, f = c.left) : (p = parseFloat(a) || 0, f = parseFloat(s) || 0), x.isFunction(t) && (t = t.call(e, n, o)), null != t.top && (u.top = t.top - o.top + p), null != t.left && (u.left = t.left - o.left + f), "using" in t ? t.using.call(e, u) : i.css(u)
        }
    }, x.fn.extend({
        position: function() {
            if (this[0]) {
                var e, t, n = {
                        top: 0,
                        left: 0
                    },
                    r = this[0];
                return "fixed" === x.css(r, "position") ? t = r.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), x.nodeName(e[0], "html") || (n = e.offset()), n.top += x.css(e[0], "borderTopWidth", !0), n.left += x.css(e[0], "borderLeftWidth", !0)), {
                    top: t.top - n.top - x.css(r, "marginTop", !0),
                    left: t.left - n.left - x.css(r, "marginLeft", !0)
                }
            }
        },
        offsetParent: function() {
            return this.map(function() {
                var e = this.offsetParent || s;
                while (e && !x.nodeName(e, "html") && "static" === x.css(e, "position")) e = e.offsetParent;
                return e || s
            })
        }
    }), x.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(e, n) {
        var r = /Y/.test(n);
        x.fn[e] = function(i) {
            return x.access(this, function(e, i, o) {
                var a = or(e);
                return o === t ? a ? n in a ? a[n] : a.document.documentElement[i] : e[i] : (a ? a.scrollTo(r ? x(a).scrollLeft() : o, r ? o : x(a).scrollTop()) : e[i] = o, t)
            }, e, i, arguments.length, null)
        }
    });

    function or(e) {
        return x.isWindow(e) ? e : 9 === e.nodeType ? e.defaultView || e.parentWindow : !1
    }
    x.each({
        Height: "height",
        Width: "width"
    }, function(e, n) {
        x.each({
            padding: "inner" + e,
            content: n,
            "": "outer" + e
        }, function(r, i) {
            x.fn[i] = function(i, o) {
                var a = arguments.length && (r || "boolean" != typeof i),
                    s = r || (i === !0 || o === !0 ? "margin" : "border");
                return x.access(this, function(n, r, i) {
                    var o;
                    return x.isWindow(n) ? n.document.documentElement["client" + e] : 9 === n.nodeType ? (o = n.documentElement, Math.max(n.body["scroll" + e], o["scroll" + e], n.body["offset" + e], o["offset" + e], o["client" + e])) : i === t ? x.css(n, r, s) : x.style(n, r, i, s)
                }, n, a ? i : t, a, null)
            }
        })
    }), x.fn.size = function() {
        return this.length
    }, x.fn.andSelf = x.fn.addBack, "object" == typeof module && module && "object" == typeof module.exports ? module.exports = x : (e.jQuery = e.$ = x, "function" == typeof define && define.amd && define("jquery", [], function() {
        return x
    }))
})(window);;;
(function($, doc, win) {
    'use strict';
    var debug = false;
    var lmb = 1,
        px = "px";
    var browser = {
        "data": {},
        "macosx": win.navigator.platform.toLowerCase().indexOf('mac') !== -1,
        "mobile": /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(win.navigator.userAgent),
        "overlay": null,
        "scroll": null,
        "scrolls": [],
        "webkit": /WebKit/.test(win.navigator.userAgent),
        "log": debug ? function(data, toString) {
            var output = data;
            if (toString && typeof data != "string") {
                output = [];
                $.each(data, function(i, v) {
                    output.push('"' + i + '": ' + v);
                });
                output = output.join(", ");
            }
            if (win.console && win.console.log) {
                win.console.log(output);
            } else {
                alert(output);
            }
        } : function() {}
    };
    var defaults = {
        "autoScrollSize": true,
        "autoUpdate": true,
        "debug": false,
        "disableBodyScroll": false,
        "duration": 200,
        "ignoreMobile": true,
        "ignoreOverlay": true,
        "scrollStep": 30,
        "showArrows": false,
        "stepScrolling": true,
        "type": "simple",
        "scrollx": null,
        "scrolly": null,
        "onDestroy": null,
        "onInit": null,
        "onScroll": null,
        "onUpdate": null
    };
    var customScrollbar = function(container, options) {
        if (!browser.scroll) {
            browser.log("Init jQuery Scrollbar v0.2.6");
            browser.overlay = isScrollOverlaysContent();
            browser.scroll = getBrowserScrollSize();
            updateScrollbars();
            $(win).resize(function() {
                var forceUpdate = false;
                if (browser.scroll && (browser.scroll.height || browser.scroll.width)) {
                    var scroll = getBrowserScrollSize();
                    if (scroll.height != browser.scroll.height || scroll.width != browser.scroll.width) {
                        browser.scroll = scroll;
                        forceUpdate = true;
                    }
                }
                updateScrollbars(forceUpdate);
            });
        }
        this.container = container;
        this.options = $.extend({}, defaults, win.jQueryScrollbarOptions || {});
        this.scrollTo = null;
        this.scrollx = {};
        this.scrolly = {};
        this.init(options);
    };
    customScrollbar.prototype = {
        destroy: function() {
            if (!this.wrapper) {
                return;
            }
            var scrollLeft = this.container.scrollLeft();
            var scrollTop = this.container.scrollTop();
            this.container.insertBefore(this.wrapper).css({
                "height": "",
                "margin": ""
            }).removeClass("scroll-content").removeClass("scroll-scrollx_visible").removeClass("scroll-scrolly_visible").off(".scrollbar").scrollLeft(scrollLeft).scrollTop(scrollTop);
            this.scrollx.scrollbar.removeClass("scroll-scrollx_visible").find("div").andSelf().off(".scrollbar");
            this.scrolly.scrollbar.removeClass("scroll-scrolly_visible").find("div").andSelf().off(".scrollbar");
            this.wrapper.remove();
            $(doc).add("body").off(".scrollbar");
            if ($.isFunction(this.options.onDestroy)) {
                this.options.onDestroy.apply(this, [this.container]);
            }
        },
        getScrollbar: function(d) {
            var scrollbar = this.options["scroll" + d];
            var html = {
                "advanced": '<div class="scroll-element_corner"></div>' + '<div class="scroll-arrow scroll-arrow_less"></div>' + '<div class="scroll-arrow scroll-arrow_more"></div>' + '<div class="scroll-element_outer">' + '    <div class="scroll-element_size"></div>' + '    <div class="scroll-element_inner-wrapper">' + '        <div class="scroll-element_inner scroll-element_track">' + '            <div class="scroll-element_inner-bottom"></div>' + '        </div>' + '    </div>' + '    <div class="scroll-bar">' + '        <div class="scroll-bar_body">' + '            <div class="scroll-bar_body-inner"></div>' + '        </div>' + '        <div class="scroll-bar_bottom"></div>' + '        <div class="scroll-bar_center"></div>' + '    </div>' + '</div>',
                "simple": '<div class="scroll-element_outer">' + '    <div class="scroll-element_size"></div>' + '    <div class="scroll-element_track"></div>' + '    <div class="scroll-bar"></div>' + '</div>'
            };
            var type = html[this.options.type] ? this.options.type : "advanced";
            if (scrollbar) {
                if (typeof(scrollbar) == "string") {
                    scrollbar = $(scrollbar).appendTo(this.wrapper);
                } else {
                    scrollbar = $(scrollbar);
                }
            } else {
                scrollbar = $("<div>").addClass("scroll-element").html(html[type]).appendTo(this.wrapper);
            }
            if (this.options.showArrows) {
                scrollbar.addClass("scroll-element_arrows_visible");
            }
            return scrollbar.addClass("scroll-" + d);
        },
        init: function(options) {
            var S = this;
            var c = this.container;
            var cw = this.containerWrapper || c;
            var o = $.extend(this.options, options || {});
            var s = {
                "x": this.scrollx,
                "y": this.scrolly
            };
            var w = this.wrapper;
            var initScroll = {
                "scrollLeft": c.scrollLeft(),
                "scrollTop": c.scrollTop()
            };
            if ((browser.mobile && o.ignoreMobile) || (browser.overlay && o.ignoreOverlay) || (browser.macosx && !browser.webkit)) {
                return false;
            }
            if (!w) {
                this.wrapper = w = $('<div>').addClass('scroll-wrapper').addClass(c.attr('class')).css('position', c.css('position') == 'absolute' ? 'absolute' : 'relative').insertBefore(c).append(c);
                if (c.is('textarea')) {
                    this.containerWrapper = cw = $('<div>').insertBefore(c).append(c);
                    w.addClass('scroll-textarea');
                }
                cw.addClass("scroll-content").css({
                    "height": "",
                    "margin-bottom": browser.scroll.height * -1 + px,
                    "margin-right": browser.scroll.width * -1 + px
                });
                c.on("scroll.scrollbar", function(event) {
                    if ($.isFunction(o.onScroll)) {
                        o.onScroll.call(S, {
                            "maxScroll": s.y.maxScrollOffset,
                            "scroll": c.scrollTop(),
                            "size": s.y.size,
                            "visible": s.y.visible
                        }, {
                            "maxScroll": s.x.maxScrollOffset,
                            "scroll": c.scrollLeft(),
                            "size": s.x.size,
                            "visible": s.x.visible
                        });
                    }
                    s.x.isVisible && s.x.scroller.css("left", c.scrollLeft() * s.x.kx + px);
                    s.y.isVisible && s.y.scroller.css("top", c.scrollTop() * s.y.kx + px);
                });
                w.on("scroll", function() {
                    w.scrollTop(0).scrollLeft(0);
                });
                if (o.disableBodyScroll) {
                    var handleMouseScroll = function(event) {
                        isVerticalScroll(event) ? s.y.isVisible && s.y.mousewheel(event) : s.x.isVisible && s.x.mousewheel(event);
                    };
                    w.on({
                        "MozMousePixelScroll.scrollbar": handleMouseScroll,
                        "mousewheel.scrollbar": handleMouseScroll
                    });
                    if (browser.mobile) {
                        w.on("touchstart.scrollbar", function(event) {
                            var touch = event.originalEvent.touches && event.originalEvent.touches[0] || event;
                            var originalTouch = {
                                "pageX": touch.pageX,
                                "pageY": touch.pageY
                            };
                            var originalScroll = {
                                "left": c.scrollLeft(),
                                "top": c.scrollTop()
                            };
                            $(doc).on({
                                "touchmove.scrollbar": function(event) {
                                    var touch = event.originalEvent.targetTouches && event.originalEvent.targetTouches[0] || event;
                                    c.scrollLeft(originalScroll.left + originalTouch.pageX - touch.pageX);
                                    c.scrollTop(originalScroll.top + originalTouch.pageY - touch.pageY);
                                    event.preventDefault();
                                },
                                "touchend.scrollbar": function() {
                                    $(doc).off(".scrollbar");
                                }
                            });
                        });
                    }
                }
                if ($.isFunction(o.onInit)) {
                    o.onInit.apply(this, [c]);
                }
            } else {
                cw.css({
                    "height": "",
                    "margin-bottom": browser.scroll.height * -1 + px,
                    "margin-right": browser.scroll.width * -1 + px
                });
            }
            $.each(s, function(d, scrollx) {
                var scrollCallback = null;
                var scrollForward = 1;
                var scrollOffset = (d == "x") ? "scrollLeft" : "scrollTop";
                var scrollStep = o.scrollStep;
                var scrollTo = function() {
                    var currentOffset = c[scrollOffset]();
                    c[scrollOffset](currentOffset + scrollStep);
                    if (scrollForward == 1 && (currentOffset + scrollStep) >= scrollToValue) {
                        currentOffset = c[scrollOffset]();
                    }
                    if (scrollForward == -1 && (currentOffset + scrollStep) <= scrollToValue) {
                        currentOffset = c[scrollOffset]();
                    }
                    if (c[scrollOffset]() == currentOffset && scrollCallback) {
                        scrollCallback();
                    }
                }
                var scrollToValue = 0;
                if (!scrollx.scrollbar) {
                    scrollx.scrollbar = S.getScrollbar(d);
                    scrollx.scroller = scrollx.scrollbar.find(".scroll-bar");
                    scrollx.mousewheel = function(event) {
                        if (!scrollx.isVisible || (d == 'x' && isVerticalScroll(event))) {
                            return true;
                        }
                        if (d == 'y' && !isVerticalScroll(event)) {
                            s.x.mousewheel(event);
                            return true;
                        }
                        var delta = event.originalEvent.wheelDelta * -1 || event.originalEvent.detail;
                        var maxScrollValue = scrollx.size - scrollx.visible - scrollx.offset;
                        if (!((scrollToValue <= 0 && delta < 0) || (scrollToValue >= maxScrollValue && delta > 0))) {
                            scrollToValue = scrollToValue + delta;
                            if (scrollToValue < 0) {
                                scrollToValue = 0;
                            }
                            if (scrollToValue > maxScrollValue) {
                                scrollToValue = maxScrollValue;
                            }
                            S.scrollTo = S.scrollTo || {};
                            S.scrollTo[scrollOffset] = scrollToValue;
                            setTimeout(function() {
                                if (S.scrollTo) {
                                    c.stop().animate(S.scrollTo, 240, 'linear', function() {
                                        scrollToValue = c[scrollOffset]();
                                    });
                                    S.scrollTo = null;
                                }
                            }, 1);
                        }
                        event.preventDefault();
                        return false;
                    };
                    scrollx.scrollbar.on({
                        "MozMousePixelScroll.scrollbar": scrollx.mousewheel,
                        "mousewheel.scrollbar": scrollx.mousewheel,
                        "mouseenter.scrollbar": function() {
                            scrollToValue = c[scrollOffset]();
                        }
                    });
                    scrollx.scrollbar.find(".scroll-arrow, .scroll-element_track").on("mousedown.scrollbar", function(event) {
                        if (event.which != lmb) {
                            return true;
                        }
                        scrollForward = 1;
                        var data = {
                            "eventOffset": event[(d == "x") ? "pageX" : "pageY"],
                            "maxScrollValue": scrollx.size - scrollx.visible - scrollx.offset,
                            "scrollbarOffset": scrollx.scroller.offset()[(d == "x") ? "left" : "top"],
                            "scrollbarSize": scrollx.scroller[(d == "x") ? "outerWidth" : "outerHeight"]()
                        };
                        var timeout = 0,
                            timer = 0;
                        if ($(this).hasClass('scroll-arrow')) {
                            scrollForward = $(this).hasClass("scroll-arrow_more") ? 1 : -1;
                            scrollStep = o.scrollStep * scrollForward;
                            scrollToValue = scrollForward > 0 ? data.maxScrollValue : 0;
                        } else {
                            scrollForward = (data.eventOffset > (data.scrollbarOffset + data.scrollbarSize) ? 1 : (data.eventOffset < data.scrollbarOffset ? -1 : 0));
                            scrollStep = Math.round(scrollx.visible * 0.75) * scrollForward;
                            scrollToValue = (data.eventOffset - data.scrollbarOffset - (o.stepScrolling ? (scrollForward == 1 ? data.scrollbarSize : 0) : Math.round(data.scrollbarSize / 2)));
                            scrollToValue = c[scrollOffset]() + (scrollToValue / scrollx.kx);
                        }
                        S.scrollTo = S.scrollTo || {};
                        S.scrollTo[scrollOffset] = o.stepScrolling ? c[scrollOffset]() + scrollStep : scrollToValue;
                        if (o.stepScrolling) {
                            scrollCallback = function() {
                                scrollToValue = c[scrollOffset]();
                                clearInterval(timer);
                                clearTimeout(timeout);
                                timeout = 0;
                                timer = 0;
                            };
                            timeout = setTimeout(function() {
                                timer = setInterval(scrollTo, 40);
                            }, o.duration + 100);
                        }
                        setTimeout(function() {
                            if (S.scrollTo) {
                                c.animate(S.scrollTo, o.duration);
                                S.scrollTo = null;
                            }
                        }, 1);
                        return handleMouseDown(scrollCallback, event);
                    });
                    scrollx.scroller.on("mousedown.scrollbar", function(event) {
                        if (event.which != lmb) {
                            return true;
                        }
                        var eventPosition = event[(d == "x") ? "pageX" : "pageY"];
                        var initOffset = c[scrollOffset]();
                        scrollx.scrollbar.addClass("scroll-draggable");
                        $(doc).on("mousemove.scrollbar", function(event) {
                            var diff = parseInt((event[(d == "x") ? "pageX" : "pageY"] - eventPosition) / scrollx.kx, 10);
                            c[scrollOffset](initOffset + diff);
                        });
                        return handleMouseDown(function() {
                            scrollx.scrollbar.removeClass("scroll-draggable");
                            scrollToValue = c[scrollOffset]();
                        }, event);
                    });
                }
            });
            $.each(s, function(d, scrollx) {
                var scrollClass = "scroll-scroll" + d + "_visible";
                var scrolly = (d == "x") ? s.y : s.x;
                scrollx.scrollbar.removeClass(scrollClass);
                scrolly.scrollbar.removeClass(scrollClass);
                cw.removeClass(scrollClass);
            });
            $.each(s, function(d, scrollx) {
                $.extend(scrollx, (d == "x") ? {
                    "offset": parseInt(c.css("left"), 10) || 0,
                    "size": c.prop("scrollWidth"),
                    "visible": w.width()
                } : {
                    "offset": parseInt(c.css("top"), 10) || 0,
                    "size": c.prop("scrollHeight"),
                    "visible": w.height()
                });
            });
            var updateScroll = function(d, scrollx) {
                var scrollClass = "scroll-scroll" + d + "_visible";
                var scrolly = (d == "x") ? s.y : s.x;
                var offset = parseInt(c.css((d == "x") ? "left" : "top"), 10) || 0;
                var AreaSize = scrollx.size;
                var AreaVisible = scrollx.visible + offset;
                scrollx.isVisible = (AreaSize - AreaVisible) > 1;
                if (scrollx.isVisible) {
                    scrollx.scrollbar.addClass(scrollClass);
                    scrolly.scrollbar.addClass(scrollClass);
                    cw.addClass(scrollClass);
                } else {
                    scrollx.scrollbar.removeClass(scrollClass);
                    scrolly.scrollbar.removeClass(scrollClass);
                    cw.removeClass(scrollClass);
                }
                if (d == "y" && (scrollx.isVisible || scrollx.size < scrollx.visible)) {
                    cw.css("height", (AreaVisible + browser.scroll.height) + px);
                }
                if (s.x.size != c.prop("scrollWidth") || s.y.size != c.prop("scrollHeight") || s.x.visible != w.width() || s.y.visible != w.height() || s.x.offset != (parseInt(c.css("left"), 10) || 0) || s.y.offset != (parseInt(c.css("top"), 10) || 0)) {
                    $.each(s, function(d, scrollx) {
                        $.extend(scrollx, (d == "x") ? {
                            "offset": parseInt(c.css("left"), 10) || 0,
                            "size": c.prop("scrollWidth"),
                            "visible": w.width()
                        } : {
                            "offset": parseInt(c.css("top"), 10) || 0,
                            "size": c.prop("scrollHeight"),
                            "visible": w.height()
                        });
                    });
                    updateScroll(d == "x" ? "y" : "x", scrolly);
                }
            };
            $.each(s, updateScroll);
            if ($.isFunction(o.onUpdate)) {
                o.onUpdate.apply(this, [c]);
            }
            $.each(s, function(d, scrollx) {
                var cssOffset = (d == "x") ? "left" : "top";
                var cssFullSize = (d == "x") ? "outerWidth" : "outerHeight";
                var cssSize = (d == "x") ? "width" : "height";
                var offset = parseInt(c.css(cssOffset), 10) || 0;
                var AreaSize = scrollx.size;
                var AreaVisible = scrollx.visible + offset;
                var scrollSize = scrollx.scrollbar.find(".scroll-element_size");
                scrollSize = scrollSize[cssFullSize]() + (parseInt(scrollSize.css(cssOffset), 10) || 0);
                if (o.autoScrollSize) {
                    scrollx.scrollbarSize = parseInt(scrollSize * AreaVisible / AreaSize, 10);
                    scrollx.scroller.css(cssSize, scrollx.scrollbarSize + px);
                }
                scrollx.scrollbarSize = scrollx.scroller[cssFullSize]();
                scrollx.kx = ((scrollSize - scrollx.scrollbarSize) / (AreaSize - AreaVisible)) || 1;
                scrollx.maxScrollOffset = AreaSize - AreaVisible;
            });
            c.scrollLeft(initScroll.scrollLeft).scrollTop(initScroll.scrollTop).trigger("scroll");
        }
    };
    $.fn.scrollbar = function(options, args) {
        var toReturn = this;
        if (options === "get") {
            toReturn = null;
        }
        this.each(function() {
            var container = $(this);
            if (container.hasClass("scroll-wrapper") || container.get(0).nodeName == "body") {
                return true;
            }
            var instance = container.data("scrollbar");
            if (instance) {
                if (options === "get") {
                    toReturn = instance;
                    return false;
                }
                var func = (typeof options == "string" && instance[options]) ? options : "init";
                instance[func].apply(instance, $.isArray(args) ? args : []);
                if (options === "destroy") {
                    container.removeData("scrollbar");
                    while ($.inArray(instance, browser.scrolls) >= 0) {
                        browser.scrolls.splice($.inArray(instance, browser.scrolls), 1);
                    }
                }
            } else {
                if (typeof options != "string") {
                    instance = new customScrollbar(container, options);
                    container.data("scrollbar", instance);
                    browser.scrolls.push(instance);
                }
            }
            return true;
        });
        return toReturn;
    };
    $.fn.scrollbar.options = defaults;
    if (win.angular) {
        (function(angular) {
            var app = angular.module('jQueryScrollbar', []);
            app.directive('jqueryScrollbar', function() {
                return {
                    "link": function(scope, element) {
                        element.scrollbar(scope.options).on('$destroy', function() {
                            element.scrollbar('destroy');
                        });
                    },
                    "restring": "AC",
                    "scope": {
                        "options": "=jqueryScrollbar"
                    }
                };
            });
        })(win.angular);
    }
    var timer = 0,
        timerCounter = 0;
    var updateScrollbars = function(force) {
        var i, c, o, s, w, x, y;
        for (i = 0; i < browser.scrolls.length; i++) {
            s = browser.scrolls[i];
            c = s.container;
            o = s.options;
            w = s.wrapper;
            x = s.scrollx;
            y = s.scrolly;
            if (force || (o.autoUpdate && w && w.is(":visible") && (c.prop("scrollWidth") != x.size || c.prop("scrollHeight") != y.size || w.width() != x.visible || w.height() != y.visible))) {
                s.init();
                if (debug) {
                    browser.log({
                        "scrollHeight": c.prop("scrollHeight") + ":" + s.scrolly.size,
                        "scrollWidth": c.prop("scrollWidth") + ":" + s.scrollx.size,
                        "visibleHeight": w.height() + ":" + s.scrolly.visible,
                        "visibleWidth": w.width() + ":" + s.scrollx.visible
                    }, true);
                    timerCounter++;
                }
            }
        }
        if (debug && timerCounter > 10) {
            browser.log("Scroll updates exceed 10");
            updateScrollbars = function() {};
        } else {
            clearTimeout(timer);
            timer = setTimeout(updateScrollbars, 300);
        }
    };

    function getBrowserScrollSize(actualSize) {
        if (browser.webkit && !actualSize) {
            return {
                "height": 0,
                "width": 0
            };
        }
        if (!browser.data.outer) {
            var css = {
                "border": "none",
                "box-sizing": "content-box",
                "height": "200px",
                "margin": "0",
                "padding": "0",
                "width": "200px"
            };
            browser.data.inner = $("<div>").css($.extend({}, css));
            browser.data.outer = $("<div>").css($.extend({
                "left": "-1000px",
                "overflow": "scroll",
                "position": "absolute",
                "top": "-1000px"
            }, css)).append(browser.data.inner).appendTo("body");
        }
        browser.data.outer.scrollLeft(1000).scrollTop(1000);
        return {
            "height": Math.ceil((browser.data.outer.offset().top - browser.data.inner.offset().top) || 0),
            "width": Math.ceil((browser.data.outer.offset().left - browser.data.inner.offset().left) || 0)
        };
    }

    function handleMouseDown(callback, event) {
        $(doc).on({
            "blur.scrollbar": function() {
                $(doc).add('body').off('.scrollbar');
                callback && callback();
            },
            "dragstart.scrollbar": function(event) {
                event.preventDefault();
                return false;
            },
            "mouseup.scrollbar": function() {
                $(doc).add('body').off('.scrollbar');
                callback && callback();
            }
        });
        $("body").on({
            "selectstart.scrollbar": function(event) {
                event.preventDefault();
                return false;
            }
        });
        event && event.preventDefault();
        return false;
    }

    function isScrollOverlaysContent() {
        var scrollSize = getBrowserScrollSize(true);
        return !(scrollSize.height || scrollSize.width);
    }

    function isVerticalScroll(event) {
        var e = event.originalEvent;
        if (e.axis && e.axis === e.HORIZONTAL_AXIS) {
            return false;
        }
        if (e.wheelDeltaX) {
            return false;
        }
        return true;
    }
})(jQuery, document, window);;
(function() {
    var d;
    window.AmCharts ? d = window.AmCharts : (d = {}, window.AmCharts = d, d.themes = {}, d.maps = {}, d.inheriting = {}, d.charts = [], d.onReadyArray = [], d.useUTC = !1, d.updateRate = 30, d.uid = 0, d.lang = {}, d.translations = {}, d.mapTranslations = {}, d.windows = {}, d.initHandlers = []);
    d.Class = function(a) {
        var b = function() {
            arguments[0] !== d.inheriting && (this.events = {}, this.construct.apply(this, arguments))
        };
        a.inherits ? (b.prototype = new a.inherits(d.inheriting), b.base = a.inherits.prototype, delete a.inherits) : (b.prototype.createEvents = function() {
            for (var a = 0, b = arguments.length; a < b; a++) {
                this.events[arguments[a]] = []
            }
        }, b.prototype.listenTo = function(a, b, c) {
            this.removeListener(a, b, c);
            a.events[b].push({
                handler: c,
                scope: this
            })
        }, b.prototype.addListener = function(a, b, c) {
            this.removeListener(this, a, b);
            this.events[a].push({
                handler: b,
                scope: c
            })
        }, b.prototype.removeListener = function(a, b, c) {
            if (a && a.events) {
                for (a = a.events[b], b = a.length - 1; 0 <= b; b--) {
                    a[b].handler === c && a.splice(b, 1)
                }
            }
        }, b.prototype.fire = function(a, b) {
            for (var c = this.events[a], d = 0, k = c.length; d < k; d++) {
                var l = c[d];
                l.handler.call(l.scope, b)
            }
        });
        for (var c in a) {
            b.prototype[c] = a[c];
        }
        return b
    };
    d.addChart = function(a) {
        d.updateInt || (d.updateInt = setInterval(function() {
            d.update()
        }, Math.round(1E3 / d.updateRate)));
        d.charts.push(a)
    };
    d.removeChart = function(a) {
        for (var b = d.charts, c = b.length - 1; 0 <= c; c--) {
            b[c] == a && b.splice(c, 1);
        }
        0 === b.length && d.updateInt && (clearInterval(d.updateInt), d.updateInt = NaN)
    };
    d.isModern = !0;
    d.getIEVersion = function() {
        var a = 0,
            b, c;
        "Microsoft Internet Explorer" == navigator.appName && (b = navigator.userAgent, c = /MSIE ([0-9]{1,}[.0-9]{0,})/, null !== c.exec(b) && (a = parseFloat(RegExp.$1)));
        return a
    };
    d.applyLang = function(a, b) {
        var c = d.translations;
        b.dayNames = d.extend({}, d.dayNames);
        b.shortDayNames = d.extend({}, d.shortDayNames);
        b.monthNames = d.extend({}, d.monthNames);
        b.shortMonthNames = d.extend({}, d.shortMonthNames);
        c && (c = c[a]) && (d.lang = c, c.monthNames && (b.dayNames = d.extend({}, c.dayNames), b.shortDayNames = d.extend({}, c.shortDayNames), b.monthNames = d.extend({}, c.monthNames), b.shortMonthNames = d.extend({}, c.shortMonthNames)))
    };
    d.IEversion = d.getIEVersion();
    9 > d.IEversion && 0 < d.IEversion && (d.isModern = !1, d.isIE = !0);
    d.dx = 0;
    d.dy = 0;
    if (document.addEventListener || window.opera) {
        d.isNN = !0, d.isIE = !1, d.dx = .5, d.dy = .5;
    }
    document.attachEvent && (d.isNN = !1, d.isIE = !0, d.isModern || (d.dx = 0, d.dy = 0));
    window.chrome && (d.chrome = !0);
    d.handleMouseUp = function(a) {
        for (var b = d.charts, c = 0; c < b.length; c++) {
            var e = b[c];
            e && e.handleReleaseOutside && e.handleReleaseOutside(a)
        }
    };
    d.handleMouseMove = function(a) {
        for (var b = d.charts, c = 0; c < b.length; c++) {
            var e = b[c];
            e && e.handleMouseMove && e.handleMouseMove(a)
        }
    };
    d.handleWheel = function(a) {
        for (var b = d.charts, c = 0; c < b.length; c++) {
            var e = b[c];
            if (e && e.mouseIsOver) {
                e.mouseWheelScrollEnabled || e.mouseWheelZoomEnabled ? e.handleWheel && e.handleWheel(a) : a.stopPropagation && a.stopPropagation();
                break
            }
        }
    };
    d.resetMouseOver = function() {
        for (var a = d.charts, b = 0; b < a.length; b++) {
            var c = a[b];
            c && (c.mouseIsOver = !1)
        }
    };
    d.ready = function(a) {
        d.onReadyArray.push(a)
    };
    d.handleLoad = function() {
        d.isReady = !0;
        for (var a = d.onReadyArray, b = 0; b < a.length; b++) {
            var c = a[b];
            isNaN(d.processDelay) ? c() : setTimeout(c, d.processDelay * b)
        }
    };
    d.addInitHandler = function(a, b) {
        d.initHandlers.push({
            method: a,
            types: b
        })
    };
    d.callInitHandler = function(a) {
        var b = d.initHandlers;
        if (d.initHandlers) {
            for (var c = 0; c < b.length; c++) {
                var e = b[c];
                e.types ? d.isInArray(e.types, a.type) && e.method(a) : e.method(a)
            }
        }
    };
    d.getUniqueId = function() {
        d.uid++;
        return "AmChartsEl-" + d.uid
    };
    d.isNN && (document.addEventListener("mousemove", d.handleMouseMove, !0), document.addEventListener("mouseup", d.handleMouseUp, !0), window.addEventListener("load", d.handleLoad, !0), window.addEventListener("DOMMouseScroll", d.handleWheel, !0), document.addEventListener("mousewheel", d.handleWheel, !0));
    d.isIE && (document.attachEvent("onmousemove", d.handleMouseMove), document.attachEvent("onmouseup", d.handleMouseUp), window.attachEvent("onload", d.handleLoad));
    d.clear = function() {
        var a = d.charts;
        if (a) {
            for (var b = a.length - 1; 0 <= b; b--) {
                a[b].clear();
            }
        }
        d.updateInt && clearInterval(d.updateInt);
        d.charts = [];
        d.isNN && (document.removeEventListener("mousemove", d.handleMouseMove, !0), document.removeEventListener("mouseup", d.handleMouseUp, !0), window.removeEventListener("load", d.handleLoad, !0), window.removeEventListener("DOMMouseScroll", d.handleWheel, !0), document.removeEventListener("mousewheel", d.handleWheel, !0));
        d.isIE && (document.detachEvent("onmousemove", d.handleMouseMove), document.detachEvent("onmouseup", d.handleMouseUp), window.detachEvent("onload", d.handleLoad))
    };
    d.makeChart = function(a, b, c) {
        var e = b.type,
            h = b.theme;
        d.isString(h) && (h = d.themes[h], b.theme = h);
        var f;
        switch (e) {
            case "serial":
                f = new d.AmSerialChart(h);
                break;
            case "xy":
                f = new d.AmXYChart(h);
                break;
            case "pie":
                f = new d.AmPieChart(h);
                break;
            case "radar":
                f = new d.AmRadarChart(h);
                break;
            case "gauge":
                f = new d.AmAngularGauge(h);
                break;
            case "funnel":
                f = new d.AmFunnelChart(h);
                break;
            case "map":
                f = new d.AmMap(h);
                break;
            case "stock":
                f = new d.AmStockChart(h);
                break;
            case "gantt":
                f = new d.AmGanttChart(h)
        }
        d.extend(f, b);
        if (b.listeners) {
            for (var g in b.listeners) {
                e = b.listeners[g], f.addListener(e.event, e.method);
            }
        }
        d.isReady ? isNaN(c) ? f.write(a) : setTimeout(function() {
            d.realWrite(f, a)
        }, c) : d.ready(function() {
            isNaN(c) ? f.write(a) : setTimeout(function() {
                d.realWrite(f, a)
            }, c)
        });
        return f
    };
    d.realWrite = function(a, b) {
        a.write(b)
    };
    d.updateCount = 0;
    d.validateAt = Math.round(d.updateRate / 5);
    d.update = function() {
        var a = d.charts;
        d.updateCount++;
        var b = !1;
        d.updateCount == d.validateAt && (b = !0, d.updateCount = 0);
        if (a) {
            for (var c = 0; c < a.length; c++) {
                a[c].update && a[c].update(), b && a[c].autoResize && a[c].validateSize && a[c].validateSize()
            }
        }
    };
    d.bezierX = 3;
    d.bezierY = 6
})();
(function() {
    var d = window.AmCharts;
    d.toBoolean = function(a, b) {
        if (void 0 === a) {
            return b;
        }
        switch (String(a).toLowerCase()) {
            case "true":
            case "yes":
            case "1":
                return !0;
            case "false":
            case "no":
            case "0":
            case null:
                return !1;
            default:
                return Boolean(a)
        }
    };
    d.removeFromArray = function(a, b) {
        var c;
        if (void 0 !== b && void 0 !== a) {
            for (c = a.length - 1; 0 <= c; c--) {
                a[c] == b && a.splice(c, 1)
            }
        }
    };
    d.getPath = function() {
        var a = document.getElementsByTagName("script");
        if (a) {
            for (var b = 0; b < a.length; b++) {
                var c = a[b].src;
                if (-1 !== c.search(/\/(amcharts|ammap)\.js/)) {
                    return c.replace(/\/(amcharts|ammap)\.js.*/, "/")
                }
            }
        }
    };
    d.normalizeUrl = function(a) {
        return "" !== a && -1 === a.search(/\/$/) ? a + "/" : a
    };
    d.isAbsolute = function(a) {
        return 0 === a.search(/^http[s]?:|^\//)
    };
    d.isInArray = function(a, b) {
        for (var c = 0; c < a.length; c++) {
            if (a[c] == b) {
                return !0;
            }
        }
        return !1
    };
    d.getDecimals = function(a) {
        var b = 0;
        isNaN(a) || (a = String(a), -1 != a.indexOf("e-") ? b = Number(a.split("-")[1]) : -1 != a.indexOf(".") && (b = a.split(".")[1].length));
        return b
    };
    d.wordwrap = function(a, b, c, e) {
        var h, f, g, k;
        a += "";
        if (1 > b) {
            return a;
        }
        h = -1;
        for (a = (k = a.split(/\r\n|\n|\r/)).length; ++h < a; k[h] += g) {
            g = k[h];
            for (k[h] = ""; g.length > b; k[h] += d.trim(g.slice(0, f)) + ((g = g.slice(f)).length ? c : "")) {
                f = 2 == e || (f = g.slice(0, b + 1).match(/\S*(\s)?$/))[1] ? b : f.input.length - f[0].length || 1 == e && b || f.input.length + (f = g.slice(b).match(/^\S*/))[0].length;
            }
            g = d.trim(g)
        }
        return k.join(e)
    };
    d.trim = function(a) {
        return a.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
    };
    d.wrappedText = function(a, b, c, e, h, f, g, k) {
        var l = d.text(a, b, c, e, h, f, g);
        if (l) {
            var m = l.getBBox();
            if (m.width > k) {
                var n = "\n";
                d.isModern || (n = "<br>");
                k = Math.floor(k / (m.width / b.length));
                2 < k && (k -= 2);
                b = d.wordwrap(b, k, n, !0);
                l.remove();
                l = d.text(a, b, c, e, h, f, g)
            }
        }
        return l
    };
    d.getStyle = function(a, b) {
        var c = "";
        document.defaultView && document.defaultView.getComputedStyle ? c = document.defaultView.getComputedStyle(a, "").getPropertyValue(b) : a.currentStyle && (b = b.replace(/\-(\w)/g, function(a, b) {
            return b.toUpperCase()
        }), c = a.currentStyle[b]);
        return c
    };
    d.removePx = function(a) {
        if (void 0 !== a) {
            return Number(a.substring(0, a.length - 2))
        }
    };
    d.getURL = function(a, b) {
        if (a) {
            if ("_self" != b && b) {
                if ("_top" == b && window.top) {
                    window.top.location.href = a;
                } else if ("_parent" == b && window.parent) {
                    window.parent.location.href = a;
                } else if ("_blank" == b) {
                    window.open(a);
                } else {
                    var c = document.getElementsByName(b)[0];
                    c ? c.src = a : (c = d.windows[b]) ? c.opener && !c.opener.closed ? c.location.href = a : d.windows[b] = window.open(a) : d.windows[b] = window.open(a)
                }
            } else {
                window.location.href = a
            }
        }
    };
    d.ifArray = function(a) {
        return a && "object" == typeof a && 0 < a.length ? !0 : !1
    };
    d.callMethod = function(a, b) {
        var c;
        for (c = 0; c < b.length; c++) {
            var e = b[c];
            if (e) {
                if (e[a]) {
                    e[a]();
                }
                var h = e.length;
                if (0 < h) {
                    var d;
                    for (d = 0; d < h; d++) {
                        var g = e[d];
                        if (g && g[a]) {
                            g[a]()
                        }
                    }
                }
            }
        }
    };
    d.toNumber = function(a) {
        return "number" == typeof a ? a : Number(String(a).replace(/[^0-9\-.]+/g, ""))
    };
    d.toColor = function(a) {
        if ("" !== a && void 0 !== a) {
            if (-1 != a.indexOf(",")) {
                a = a.split(",");
                var b;
                for (b = 0; b < a.length; b++) {
                    var c = a[b].substring(a[b].length - 6, a[b].length);
                    a[b] = "#" + c
                }
            } else {
                a = a.substring(a.length - 6, a.length), a = "#" + a;
            }
        }
        return a
    };
    d.toCoordinate = function(a, b, c) {
        var e;
        void 0 !== a && (a = String(a), c && c < b && (b = c), e = Number(a), -1 != a.indexOf("!") && (e = b - Number(a.substr(1))), -1 != a.indexOf("%") && (e = b * Number(a.substr(0, a.length - 1)) / 100));
        return e
    };
    d.fitToBounds = function(a, b, c) {
        a < b && (a = b);
        a > c && (a = c);
        return a
    };
    d.isDefined = function(a) {
        return void 0 === a ? !1 : !0
    };
    d.stripNumbers = function(a) {
        return a.replace(/[0-9]+/g, "")
    };
    d.roundTo = function(a, b) {
        if (0 > b) {
            return a;
        }
        var c = Math.pow(10, b);
        return Math.round(a * c) / c
    };
    d.toFixed = function(a, b) {
        var c = String(Math.round(a * Math.pow(10, b)));
        if (0 < b) {
            var e = c.length;
            if (e < b) {
                var h;
                for (h = 0; h < b - e; h++) {
                    c = "0" + c
                }
            }
            e = c.substring(0, c.length - b);
            "" === e && (e = 0);
            return e + "." + c.substring(c.length - b, c.length)
        }
        return String(c)
    };
    d.formatDuration = function(a, b, c, e, h, f) {
        var g = d.intervals,
            k = f.decimalSeparator;
        if (a >= g[b].contains) {
            var l = a - Math.floor(a / g[b].contains) * g[b].contains;
            "ss" == b ? (l = d.formatNumber(l, f), 1 == l.split(k)[0].length && (l = "0" + l)) : l = d.roundTo(l, f.precision);
            ("mm" == b || "hh" == b) && 10 > l && (l = "0" + l);
            c = l + "" + e[b] + "" + c;
            a = Math.floor(a / g[b].contains);
            b = g[b].nextInterval;
            return d.formatDuration(a, b, c, e, h, f)
        }
        "ss" == b && (a = d.formatNumber(a, f), 1 == a.split(k)[0].length && (a = "0" + a));
        ("mm" == b || "hh" == b) && 10 > a && (a = "0" + a);
        c = a + "" + e[b] + "" + c;
        if (g[h].count > g[b].count) {
            for (a = g[b].count; a < g[h].count; a++) {
                b = g[b].nextInterval, "ss" == b || "mm" == b || "hh" == b ? c = "00" + e[b] + "" + c : "DD" == b && (c = "0" + e[b] + "" + c);
            }
        }
        ":" == c.charAt(c.length - 1) && (c = c.substring(0, c.length - 1));
        return c
    };
    d.formatNumber = function(a, b, c, e, h) {
        a = d.roundTo(a, b.precision);
        isNaN(c) && (c = b.precision);
        var f = b.decimalSeparator;
        b = b.thousandsSeparator;
        var g;
        g = 0 > a ? "-" : "";
        a = Math.abs(a);
        var k = String(a),
            l = !1; - 1 != k.indexOf("e") && (l = !0);
        0 <= c && !l && (k = d.toFixed(a, c));
        var m = "";
        if (l) {
            m = k;
        } else {
            var k = k.split("."),
                l = String(k[0]),
                n;
            for (n = l.length; 0 <= n; n -= 3) {
                m = n != l.length ? 0 !== n ? l.substring(n - 3, n) + b + m : l.substring(n - 3, n) + m : l.substring(n - 3, n);
            }
            void 0 !== k[1] && (m = m + f + k[1]);
            void 0 !== c && 0 < c && "0" != m && (m = d.addZeroes(m, f, c))
        }
        m = g + m;
        "" === g && !0 === e && 0 !== a && (m = "+" + m);
        !0 === h && (m += "%");
        return m
    };
    d.addZeroes = function(a, b, c) {
        a = a.split(b);
        void 0 === a[1] && 0 < c && (a[1] = "0");
        return a[1].length < c ? (a[1] += "0", d.addZeroes(a[0] + b + a[1], b, c)) : void 0 !== a[1] ? a[0] + b + a[1] : a[0]
    };
    d.scientificToNormal = function(a) {
        var b;
        a = String(a).split("e");
        var c;
        if ("-" == a[1].substr(0, 1)) {
            b = "0.";
            for (c = 0; c < Math.abs(Number(a[1])) - 1; c++) {
                b += "0";
            }
            b += a[0].split(".").join("")
        } else {
            var e = 0;
            b = a[0].split(".");
            b[1] && (e = b[1].length);
            b = a[0].split(".").join("");
            for (c = 0; c < Math.abs(Number(a[1])) - e; c++) {
                b += "0"
            }
        }
        return b
    };
    d.toScientific = function(a, b) {
        if (0 === a) {
            return "0";
        }
        var c = Math.floor(Math.log(Math.abs(a)) * Math.LOG10E),
            e = String(e).split(".").join(b);
        return String(e) + "e" + c
    };
    d.randomColor = function() {
        return "#" + ("00000" + (16777216 * Math.random() << 0).toString(16)).substr(-6)
    };
    d.hitTest = function(a, b, c) {
        var e = !1,
            h = a.x,
            f = a.x + a.width,
            g = a.y,
            k = a.y + a.height,
            l = d.isInRectangle;
        e || (e = l(h, g, b));
        e || (e = l(h, k, b));
        e || (e = l(f, g, b));
        e || (e = l(f, k, b));
        e || !0 === c || (e = d.hitTest(b, a, !0));
        return e
    };
    d.isInRectangle = function(a, b, c) {
        return a >= c.x - 5 && a <= c.x + c.width + 5 && b >= c.y - 5 && b <= c.y + c.height + 5 ? !0 : !1
    };
    d.isPercents = function(a) {
        if (-1 != String(a).indexOf("%")) {
            return !0
        }
    };
    d.findPosX = function(a) {
        var b = a,
            c = a.offsetLeft;
        if (a.offsetParent) {
            for (; a = a.offsetParent;) {
                c += a.offsetLeft;
            }
            for (;
                (b = b.parentNode) && b != document.body;) {
                c -= b.scrollLeft || 0
            }
        }
        return c
    };
    d.findPosY = function(a) {
        var b = a,
            c = a.offsetTop;
        if (a.offsetParent) {
            for (; a = a.offsetParent;) {
                c += a.offsetTop;
            }
            for (;
                (b = b.parentNode) && b != document.body;) {
                c -= b.scrollTop || 0
            }
        }
        return c
    };
    d.findIfFixed = function(a) {
        if (a.offsetParent) {
            for (; a = a.offsetParent;) {
                if ("fixed" == d.getStyle(a, "position")) {
                    return !0;
                }
            }
        }
        return !1
    };
    d.findIfAuto = function(a) {
        return a.style && "auto" == d.getStyle(a, "overflow") ? !0 : a.parentNode ? d.findIfAuto(a.parentNode) : !1
    };
    d.findScrollLeft = function(a, b) {
        a.scrollLeft && (b += a.scrollLeft);
        return a.parentNode ? d.findScrollLeft(a.parentNode, b) : b
    };
    d.findScrollTop = function(a, b) {
        a.scrollTop && (b += a.scrollTop);
        return a.parentNode ? d.findScrollTop(a.parentNode, b) : b
    };
    d.formatValue = function(a, b, c, e, h, f, g, k) {
        if (b) {
            void 0 === h && (h = "");
            var l;
            for (l = 0; l < c.length; l++) {
                var m = c[l],
                    n = b[m];
                void 0 !== n && (n = f ? d.addPrefix(n, k, g, e) : d.formatNumber(n, e), a = a.replace(new RegExp("\\[\\[" + h + "" + m + "\\]\\]", "g"), n))
            }
        }
        return a
    };
    d.formatDataContextValue = function(a, b) {
        if (a) {
            var c = a.match(/\[\[.*?\]\]/g),
                e;
            for (e = 0; e < c.length; e++) {
                var h = c[e],
                    h = h.substr(2, h.length - 4);
                void 0 !== b[h] && (a = a.replace(new RegExp("\\[\\[" + h + "\\]\\]", "g"), b[h]))
            }
        }
        return a
    };
    d.massReplace = function(a, b) {
        for (var c in b) {
            if (b.hasOwnProperty(c)) {
                var e = b[c];
                void 0 === e && (e = "");
                a = a.replace(c, e)
            }
        }
        return a
    };
    d.cleanFromEmpty = function(a) {
        return a.replace(/\[\[[^\]]*\]\]/g, "")
    };
    d.addPrefix = function(a, b, c, e, h) {
        var f = d.formatNumber(a, e),
            g = "",
            k, l, m;
        if (0 === a) {
            return "0";
        }
        0 > a && (g = "-");
        a = Math.abs(a);
        if (1 < a) {
            for (k = b.length - 1; - 1 < k; k--) {
                if (a >= b[k].number && (l = a / b[k].number, m = Number(e.precision), 1 > m && (m = 1), c = d.roundTo(l, m), m = d.formatNumber(c, {
                        precision: -1,
                        decimalSeparator: e.decimalSeparator,
                        thousandsSeparator: e.thousandsSeparator
                    }), !h || l == c)) {
                    f = g + "" + m + "" + b[k].prefix;
                    break
                }
            }
        } else {
            for (k = 0; k < c.length; k++) {
                if (a <= c[k].number) {
                    l = a / c[k].number;
                    m = Math.abs(Math.round(Math.log(l) * Math.LOG10E));
                    l = d.roundTo(l, m);
                    f = g + "" + l + "" + c[k].prefix;
                    break
                }
            }
        }
        return f
    };
    d.remove = function(a) {
        a && a.remove()
    };
    d.getEffect = function(a) {
        ">" == a && (a = "easeOutSine");
        "<" == a && (a = "easeInSine");
        "elastic" == a && (a = "easeOutElastic");
        return a
    };
    d.getObjById = function(a, b) {
        var c, e;
        for (e = 0; e < a.length; e++) {
            var h = a[e];
            h.id == b && (c = h)
        }
        return c
    };
    d.applyTheme = function(a, b, c) {
        b || (b = d.theme);
        b && b[c] && d.extend(a, b[c])
    };
    d.isString = function(a) {
        return "string" == typeof a ? !0 : !1
    };
    d.extend = function(a, b, c) {
        var e;
        a || (a = {});
        for (e in b) {
            c ? a.hasOwnProperty(e) || (a[e] = b[e]) : a[e] = b[e];
        }
        return a
    };
    d.copyProperties = function(a, b) {
        for (var c in a) {
            a.hasOwnProperty(c) && "events" != c && void 0 !== a[c] && "function" != typeof a[c] && "cname" != c && (b[c] = a[c])
        }
    };
    d.processObject = function(a, b, c, e) {
        if (!1 === a instanceof b && (a = e ? d.extend(new b(c), a) : d.extend(a, new b(c), !0), a.listeners)) {
            for (var h in a.listeners) {
                b = a.listeners[h], a.addListener(b.event, b.method);
            }
        }
        return a
    };
    d.fixNewLines = function(a) {
        var b = RegExp("\\n", "g");
        a && (a = a.replace(b, "<br />"));
        return a
    };
    d.fixBrakes = function(a) {
        if (d.isModern) {
            var b = RegExp("<br>", "g");
            a && (a = a.replace(b, "\n"))
        } else {
            a = d.fixNewLines(a);
        }
        return a
    };
    d.deleteObject = function(a, b) {
        if (a) {
            if (void 0 === b || null === b) {
                b = 20;
            }
            if (0 !== b) {
                if ("[object Array]" === Object.prototype.toString.call(a)) {
                    for (var c = 0; c < a.length; c++) {
                        d.deleteObject(a[c], b - 1), a[c] = null;
                    }
                } else if (a && !a.tagName) {
                    try {
                        for (c in a) {
                            a[c] && ("object" == typeof a[c] && d.deleteObject(a[c], b - 1), "function" != typeof a[c] && (a[c] = null))
                        }
                    } catch (e) {}
                }
            }
        }
    };
    d.bounce = function(a, b, c, e, h) {
        return (b /= h) < 1 / 2.75 ? 7.5625 * e * b * b + c : b < 2 / 2.75 ? e * (7.5625 * (b -= 1.5 / 2.75) * b + .75) + c : b < 2.5 / 2.75 ? e * (7.5625 * (b -= 2.25 / 2.75) * b + .9375) + c : e * (7.5625 * (b -= 2.625 / 2.75) * b + .984375) + c
    };
    d.easeInSine = function(a, b, c, e, h) {
        return -e * Math.cos(b / h * (Math.PI / 2)) + e + c
    };
    d.easeOutSine = function(a, b, c, e, h) {
        return e * Math.sin(b / h * (Math.PI / 2)) + c
    };
    d.easeOutElastic = function(a, b, c, e, h) {
        a = 1.70158;
        var d = 0,
            g = e;
        if (0 === b) {
            return c;
        }
        if (1 == (b /= h)) {
            return c + e;
        }
        d || (d = .3 * h);
        g < Math.abs(e) ? (g = e, a = d / 4) : a = d / (2 * Math.PI) * Math.asin(e / g);
        return g * Math.pow(2, -10 * b) * Math.sin(2 * (b * h - a) * Math.PI / d) + e + c
    };
    d.fixStepE = function(a) {
        a = a.toExponential(0).split("e");
        var b = Number(a[1]);
        9 == Number(a[0]) && b++;
        return d.generateNumber(1, b)
    };
    d.generateNumber = function(a, b) {
        var c = "",
            e;
        e = 0 > b ? Math.abs(b) - 1 : Math.abs(b);
        var h;
        for (h = 0; h < e; h++) {
            c += "0";
        }
        return 0 > b ? Number("0." + c + String(a)) : Number(String(a) + c)
    };
    d.setCN = function(a, b, c, e) {
        if (a.addClassNames && b && (b = b.node) && c) {
            var h = b.getAttribute("class");
            a = a.classNamePrefix + "-";
            e && (a = "");
            h ? b.setAttribute("class", h + " " + a + c) : b.setAttribute("class", a + c)
        }
    };
    d.parseDefs = function(a, b) {
        for (var c in a) {
            var e = typeof a[c];
            if (0 < a[c].length && "object" == e) {
                for (var h = 0; h < a[c].length; h++) {
                    e = document.createElementNS(d.SVG_NS, c), b.appendChild(e), d.parseDefs(a[c][h], e);
                }
            } else {
                "object" == e ? (e = document.createElementNS(d.SVG_NS, c), b.appendChild(e), d.parseDefs(a[c], e)) : b.setAttribute(c, a[c])
            }
        }
    }
})();
(function() {
    var d = window.AmCharts;
    d.AxisBase = d.Class({
        construct: function(a) {
            this.createEvents("clickItem", "rollOverItem", "rollOutItem");
            this.viY = this.viX = this.titleDY = this.y = this.x = this.dy = this.dx = 0;
            this.axisThickness = 1;
            this.axisColor = "#000000";
            this.axisAlpha = 1;
            this.gridCount = this.tickLength = 5;
            this.gridAlpha = .15;
            this.gridThickness = 1;
            this.gridColor = "#000000";
            this.dashLength = 0;
            this.labelFrequency = 1;
            this.showLastLabel = this.showFirstLabel = !0;
            this.fillColor = "#FFFFFF";
            this.fillAlpha = 0;
            this.labelsEnabled = !0;
            this.labelRotation = 0;
            this.autoGridCount = !0;
            this.offset = 0;
            this.guides = [];
            this.visible = !0;
            this.counter = 0;
            this.guides = [];
            this.ignoreAxisWidth = this.inside = !1;
            this.minHorizontalGap = 75;
            this.minVerticalGap = 35;
            this.titleBold = !0;
            this.minorGridEnabled = !1;
            this.minorGridAlpha = .07;
            this.autoWrap = !1;
            this.titleAlign = "middle";
            this.labelOffset = 0;
            this.bcn = "axis-";
            this.centerLabels = !1;
            this.periods = [{
                period: "ss",
                count: 1
            }, {
                period: "ss",
                count: 5
            }, {
                period: "ss",
                count: 10
            }, {
                period: "ss",
                count: 30
            }, {
                period: "mm",
                count: 1
            }, {
                period: "mm",
                count: 5
            }, {
                period: "mm",
                count: 10
            }, {
                period: "mm",
                count: 30
            }, {
                period: "hh",
                count: 1
            }, {
                period: "hh",
                count: 3
            }, {
                period: "hh",
                count: 6
            }, {
                period: "hh",
                count: 12
            }, {
                period: "DD",
                count: 1
            }, {
                period: "DD",
                count: 2
            }, {
                period: "DD",
                count: 3
            }, {
                period: "DD",
                count: 4
            }, {
                period: "DD",
                count: 5
            }, {
                period: "WW",
                count: 1
            }, {
                period: "MM",
                count: 1
            }, {
                period: "MM",
                count: 2
            }, {
                period: "MM",
                count: 3
            }, {
                period: "MM",
                count: 6
            }, {
                period: "YYYY",
                count: 1
            }, {
                period: "YYYY",
                count: 2
            }, {
                period: "YYYY",
                count: 5
            }, {
                period: "YYYY",
                count: 10
            }, {
                period: "YYYY",
                count: 50
            }, {
                period: "YYYY",
                count: 100
            }];
            this.dateFormats = [{
                period: "fff",
                format: "JJ:NN:SS"
            }, {
                period: "ss",
                format: "JJ:NN:SS"
            }, {
                period: "mm",
                format: "JJ:NN"
            }, {
                period: "hh",
                format: "JJ:NN"
            }, {
                period: "DD",
                format: "MMM DD"
            }, {
                period: "WW",
                format: "MMM DD"
            }, {
                period: "MM",
                format: "MMM"
            }, {
                period: "YYYY",
                format: "YYYY"
            }];
            this.nextPeriod = {
                fff: "ss",
                ss: "mm",
                mm: "hh",
                hh: "DD",
                DD: "MM",
                MM: "YYYY"
            };
            d.applyTheme(this, a, "AxisBase")
        },
        zoom: function(a, b) {
            this.start = a;
            this.end = b;
            this.dataChanged = !0;
            this.draw()
        },
        fixAxisPosition: function() {
            var a = this.position;
            "H" == this.orientation ? ("left" == a && (a = "bottom"), "right" == a && (a = "top")) : ("bottom" == a && (a = "left"), "top" == a && (a = "right"));
            this.position = a
        },
        draw: function() {
            var a = this.chart;
            this.allLabels = [];
            this.counter = 0;
            this.destroy();
            this.fixAxisPosition();
            this.labels = [];
            var b = a.container,
                c = b.set();
            a.gridSet.push(c);
            this.set = c;
            b = b.set();
            a.axesLabelsSet.push(b);
            this.labelsSet = b;
            this.axisLine = new this.axisRenderer(this);
            this.autoGridCount ? ("V" == this.orientation ? (a = this.height / this.minVerticalGap, 3 > a && (a = 3)) : a = this.width / this.minHorizontalGap, this.gridCountR = Math.max(a, 1)) : this.gridCountR = this.gridCount;
            this.axisWidth = this.axisLine.axisWidth;
            this.addTitle()
        },
        setOrientation: function(a) {
            this.orientation = a ? "H" : "V"
        },
        addTitle: function() {
            var a = this.title;
            this.titleLabel = null;
            if (a) {
                var b = this.chart,
                    c = this.titleColor;
                void 0 === c && (c = b.color);
                var e = this.titleFontSize;
                isNaN(e) && (e = b.fontSize + 1);
                a = d.text(b.container, a, c, b.fontFamily, e, this.titleAlign, this.titleBold);
                d.setCN(b, a, this.bcn + "title");
                this.titleLabel = a
            }
        },
        positionTitle: function() {
            var a = this.titleLabel;
            if (a) {
                var b, c, e = this.labelsSet,
                    h = {};
                0 < e.length() ? h = e.getBBox() : (h.x = 0, h.y = 0, h.width = this.viW, h.height = this.viH, d.VML && (h.y += this.y, h.x += this.x));
                e.push(a);
                var e = h.x,
                    f = h.y;
                d.VML && (this.rotate ? e -= this.x : f -= this.y);
                var g = h.width,
                    h = h.height,
                    k = this.viW,
                    l = this.viH,
                    m = 0,
                    n = a.getBBox().height / 2,
                    p = this.inside,
                    q = this.titleAlign;
                switch (this.position) {
                    case "top":
                        b = "left" == q ? -1 : "right" == q ? k : k / 2;
                        c = f - 10 - n;
                        break;
                    case "bottom":
                        b = "left" == q ? -1 : "right" == q ? k : k / 2;
                        c = f + h + 10 + n;
                        break;
                    case "left":
                        b = e - 10 - n;
                        p && (b -= 5);
                        m = -90;
                        c = ("left" == q ? l + 1 : "right" == q ? -1 : l / 2) + this.titleDY;
                        break;
                    case "right":
                        b = e + g + 10 + n, p && (b += 7), c = ("left" == q ? l + 2 : "right" == q ? -2 : l / 2) + this.titleDY, m = -90
                }
                this.marginsChanged ? (a.translate(b, c), this.tx = b, this.ty = c) : a.translate(this.tx, this.ty);
                this.marginsChanged = !1;
                isNaN(this.titleRotation) || (m = this.titleRotation);
                0 !== m && a.rotate(m)
            }
        },
        pushAxisItem: function(a, b) {
            var c = this,
                e = a.graphics();
            0 < e.length() && (b ? c.labelsSet.push(e) : c.set.push(e));
            if (e = a.getLabel()) {
                this.labelsSet.push(e), e.click(function(b) {
                    c.handleMouse(b, a, "clickItem")
                }).mouseover(function(b) {
                    c.handleMouse(b, a, "rollOverItem")
                }).mouseout(function(b) {
                    c.handleMouse(b, a, "rollOutItem")
                })
            }
        },
        handleMouse: function(a, b, c) {
            this.fire(c, {
                type: c,
                value: b.value,
                serialDataItem: b.serialDataItem,
                axis: this,
                target: b.label,
                chart: this.chart,
                event: a
            })
        },
        addGuide: function(a) {
            for (var b = this.guides, c = !1, e = b.length, h = 0; h < b.length; h++) {
                b[h] == a && (c = !0, e = h);
            }
            a = d.processObject(a, d.Guide, this.theme);
            a.id || (a.id = "guideAuto" + e + "_" + (new Date).getTime());
            c || b.push(a)
        },
        removeGuide: function(a) {
            var b = this.guides,
                c;
            for (c = 0; c < b.length; c++) {
                b[c] == a && b.splice(c, 1)
            }
        },
        handleGuideOver: function(a) {
            clearTimeout(this.chart.hoverInt);
            var b = a.graphics.getBBox(),
                c = b.x + b.width / 2,
                b = b.y + b.height / 2,
                e = a.fillColor;
            void 0 === e && (e = a.lineColor);
            this.chart.showBalloon(a.balloonText, e, !0, c, b)
        },
        handleGuideOut: function() {
            this.chart.hideBalloon()
        },
        addEventListeners: function(a, b) {
            var c = this;
            a.mouseover(function() {
                c.handleGuideOver(b)
            });
            a.touchstart(function() {
                c.handleGuideOver(b)
            });
            a.mouseout(function() {
                c.handleGuideOut(b)
            })
        },
        getBBox: function() {
            var a = this.labelsSet.getBBox();
            d.VML || (a = {
                x: a.x + this.x,
                y: a.y + this.y,
                width: a.width,
                height: a.height
            });
            return a
        },
        destroy: function() {
            d.remove(this.set);
            d.remove(this.labelsSet);
            var a = this.axisLine;
            a && d.remove(a.set);
            d.remove(this.grid0)
        },
        chooseMinorFrequency: function(a) {
            for (var b = 10; 0 < b; b--) {
                if (a / b == Math.round(a / b)) {
                    return a / b
                }
            }
        },
        parseDatesDraw: function() {
            var a, b = this.chart,
                c = this.showFirstLabel,
                e = this.showLastLabel,
                h, f = "",
                g = d.extractPeriod(this.minPeriod),
                k = d.getPeriodDuration(g.period, g.count),
                l, m, n, p, q, r = this.firstDayOfWeek,
                u = this.boldPeriodBeginning;
            a = this.minorGridEnabled;
            var t, z = this.gridAlpha,
                y, v = this.choosePeriod(0),
                w = v.period,
                v = v.count,
                A = d.getPeriodDuration(w, v);
            A < k && (w = g.period, v = g.count, A = k);
            g = w;
            "WW" == g && (g = "DD");
            this.stepWidth = this.getStepWidth(this.timeDifference);
            var B = Math.ceil(this.timeDifference / A) + 5,
                C = l = d.resetDateToMin(new Date(this.startTime - A), w, v, r).getTime();
            if (g == w && 1 == v && this.centerLabelOnFullPeriod || this.autoWrap || this.centerLabels) {
                n = A * this.stepWidth, this.autoWrap && !this.centerLabels && (n = -n);
            }
            this.cellWidth = k * this.stepWidth;
            p = Math.round(l / A);
            k = -1;
            p / 2 == Math.round(p / 2) && (k = -2, l -= A);
            p = this.firstTime;
            var D = 0,
                J = 0;
            a && 1 < v && (t = this.chooseMinorFrequency(v), y = d.getPeriodDuration(w, t));
            if (0 < this.gridCountR) {
                for (B - 5 - k > this.autoRotateCount && !isNaN(this.autoRotateAngle) && (this.labelRotationR = this.autoRotateAngle), a = k; a <= B; a++) {
                    q = p + A * (a + Math.floor((C - p) / A)) - D;
                    "DD" == w && (q += 36E5);
                    q = d.resetDateToMin(new Date(q), w, v, r).getTime();
                    "MM" == w && (h = (q - l) / A, 1.5 <= (q - l) / A && (q = q - (h - 1) * A + d.getPeriodDuration("DD", 3), q = d.resetDateToMin(new Date(q), w, 1).getTime(), D += A));
                    h = (q - this.startTime) * this.stepWidth;
                    if ("radar" == b.type) {
                        if (0 > h || h > this.axisWidth) {
                            continue;
                        }
                        h = this.y + (this.axisWidth - h)
                    } else {
                        this.rotate ? (h += this.x - this.viX, "date" == this.type && "middle" == this.gridPosition && (J = -A * this.stepWidth / 2)) : h = "date" == this.type ? this.axisWidth - h + (this.y - this.viY) : h + (this.y - this.viY);
                    }
                    f = !1;
                    this.nextPeriod[g] && (f = this.checkPeriodChange(this.nextPeriod[g], 1, q, l, g));
                    l = !1;
                    f && this.markPeriodChange ? (f = this.dateFormatsObject[this.nextPeriod[g]], this.twoLineMode && (f = this.dateFormatsObject[g] + "\n" + f, f = d.fixBrakes(f)), l = !0) : f = this.dateFormatsObject[g];
                    u || (l = !1);
                    this.currentDateFormat = f;
                    f = d.formatDate(new Date(q), f, b);
                    if (a == k && !c || a == B && !e) {
                        f = " ";
                    }
                    this.labelFunction && (f = this.labelFunction(f, new Date(q), this, w, v, m).toString());
                    this.boldLabels && (l = !0);
                    m = new this.axisItemRenderer(this, h, f, !1, n, J, !1, l);
                    this.pushAxisItem(m);
                    m = l = q;
                    if (!isNaN(t)) {
                        for (h = 1; h < v; h += t) {
                            this.gridAlpha = this.minorGridAlpha, f = q + y * h, f = d.resetDateToMin(new Date(f), w, t, r).getTime(), f = new this.axisItemRenderer(this, (f - this.startTime) * this.stepWidth, void 0, void 0, void 0, void 0, void 0, void 0, void 0, !0), this.pushAxisItem(f);
                        }
                    }
                    this.gridAlpha = z
                }
            }
        },
        choosePeriod: function(a) {
            var b = d.getPeriodDuration(this.periods[a].period, this.periods[a].count),
                c = Math.ceil(this.timeDifference / b),
                e = this.periods;
            return this.timeDifference < b && 0 < a ? e[a - 1] : c <= this.gridCountR ? e[a] : a + 1 < e.length ? this.choosePeriod(a + 1) : e[a]
        },
        getStepWidth: function(a) {
            var b;
            this.startOnAxis ? (b = this.axisWidth / (a - 1), 1 == a && (b = this.axisWidth)) : b = this.axisWidth / a;
            return b
        },
        timeZoom: function(a, b) {
            this.startTime = a;
            this.endTime = b
        },
        minDuration: function() {
            var a = d.extractPeriod(this.minPeriod);
            return d.getPeriodDuration(a.period, a.count)
        },
        checkPeriodChange: function(a, b, c, e, h) {
            c = new Date(c);
            var f = new Date(e),
                g = this.firstDayOfWeek;
            e = b;
            "DD" == a && (b = 1);
            c = d.resetDateToMin(c, a, b, g).getTime();
            b = d.resetDateToMin(f, a, b, g).getTime();
            return "DD" == a && "hh" != h && c - b < d.getPeriodDuration(a, e) ? !1 : c != b ? !0 : !1
        },
        generateDFObject: function() {
            this.dateFormatsObject = {};
            var a;
            for (a = 0; a < this.dateFormats.length; a++) {
                var b = this.dateFormats[a];
                this.dateFormatsObject[b.period] = b.format
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.ValueAxis = d.Class({
        inherits: d.AxisBase,
        construct: function(a) {
            this.cname = "ValueAxis";
            this.createEvents("axisChanged", "logarithmicAxisFailed", "axisSelfZoomed", "axisZoomed");
            d.ValueAxis.base.construct.call(this, a);
            this.dataChanged = !0;
            this.stackType = "none";
            this.position = "left";
            this.unitPosition = "right";
            this.includeAllValues = this.recalculateToPercents = this.includeHidden = this.includeGuidesInMinMax = this.integersOnly = !1;
            this.durationUnits = {
                DD: "d. ",
                hh: ":",
                mm: ":",
                ss: ""
            };
            this.scrollbar = !1;
            this.baseValue = 0;
            this.radarCategoriesEnabled = !0;
            this.gridType = "polygons";
            this.useScientificNotation = !1;
            this.axisTitleOffset = 10;
            this.pointPosition = "axis";
            this.minMaxMultiplier = 1;
            this.logGridLimit = 2;
            this.totalTextOffset = this.treatZeroAs = 0;
            this.minPeriod = "ss";
            d.applyTheme(this, a, this.cname)
        },
        updateData: function() {
            0 >= this.gridCountR && (this.gridCountR = 1);
            this.totals = [];
            this.data = this.chart.chartData;
            var a = this.chart;
            "xy" != a.type && (this.stackGraphs("smoothedLine"), this.stackGraphs("line"), this.stackGraphs("column"), this.stackGraphs("step"));
            this.recalculateToPercents && this.recalculate();
            this.synchronizationMultiplier && this.synchronizeWith ? (d.isString(this.synchronizeWith) && (this.synchronizeWith = a.getValueAxisById(this.synchronizeWith)), this.synchronizeWith && (this.synchronizeWithAxis(this.synchronizeWith), this.foundGraphs = !0)) : (this.foundGraphs = !1, this.getMinMax())
        },
        draw: function() {
            d.ValueAxis.base.draw.call(this);
            var a = this.chart,
                b = this.set;
            this.labelRotationR = this.labelRotation;
            d.setCN(a, this.set, "value-axis value-axis-" + this.id);
            d.setCN(a, this.labelsSet, "value-axis value-axis-" + this.id);
            d.setCN(a, this.axisLine.axisSet, "value-axis value-axis-" + this.id);
            var c = this.type;
            "duration" == c && (this.duration = "ss");
            !0 === this.dataChanged && (this.updateData(), this.dataChanged = !1);
            "date" == c && (this.logarithmic = !1, this.min = this.minRR, this.max = this.maxRR, this.getDateMinMax());
            if (this.logarithmic) {
                var e = this.treatZeroAs,
                    h = this.getMin(0, this.data.length - 1);
                this.minReal < h && (this.minReal = h);
                isNaN(this.minReal) && (this.minReal = h);
                0 < e && 0 === h && (this.minReal = h = e);
                if (0 >= h || 0 >= this.minimum) {
                    this.fire("logarithmicAxisFailed", {
                        type: "logarithmicAxisFailed",
                        chart: a
                    });
                    return
                }
            }
            this.grid0 = null;
            var f, g, k = a.dx,
                l = a.dy,
                e = !1,
                h = this.logarithmic;
            if (isNaN(this.min) || isNaN(this.max) || !this.foundGraphs || Infinity == this.min || -Infinity == this.max) {
                e = !0;
            } else {
                var m = this.labelFrequency,
                    n = this.showFirstLabel,
                    p = this.showLastLabel,
                    q = 1;
                f = 0;
                this.minCalc = this.min;
                this.maxCalc = this.max;
                this.strictMinMax && (isNaN(this.minimum) || (this.min = this.minimum), isNaN(this.maximum) || (this.max = this.maximum));
                isNaN(this.minZoom) || (this.min = this.minZoom);
                isNaN(this.maxZoom) || (this.max = this.maxZoom);
                var r = Math.round((this.maxCalc - this.minCalc) / this.step) + 1,
                    u;
                !0 === h ? (u = Math.log(this.max) * Math.LOG10E - Math.log(this.minReal) * Math.LOG10E, this.stepWidth = this.axisWidth / u, u > this.logGridLimit && (r = Math.ceil(Math.log(this.max) * Math.LOG10E) + 1, f = Math.round(Math.log(this.minReal) * Math.LOG10E), r > this.gridCountR && (q = Math.ceil(r / this.gridCountR)))) : this.stepWidth = this.axisWidth / (this.max - this.min);
                var t = 0;
                1 > this.step && -1 < this.step && (t = d.getDecimals(this.step));
                this.integersOnly && (t = 0);
                t > this.maxDecCount && (t = this.maxDecCount);
                var z = this.precision;
                isNaN(z) || (t = z);
                this.max = d.roundTo(this.max, this.maxDecCount);
                this.min = d.roundTo(this.min, this.maxDecCount);
                g = {};
                g.precision = t;
                g.decimalSeparator = a.nf.decimalSeparator;
                g.thousandsSeparator = a.nf.thousandsSeparator;
                this.numberFormatter = g;
                var y, v = this.guides,
                    w = v.length;
                if (0 < w) {
                    var A = this.fillAlpha;
                    for (g = this.fillAlpha = 0; g < w; g++) {
                        var B = v[g],
                            C = NaN,
                            D = B.above;
                        isNaN(B.toValue) || (C = this.getCoordinate(B.toValue), y = new this.axisItemRenderer(this, C, "", !0, NaN, NaN, B), this.pushAxisItem(y, D));
                        var J = NaN;
                        isNaN(B.value) || (J = this.getCoordinate(B.value), y = new this.axisItemRenderer(this, J, B.label, !0, NaN, (C - J) / 2, B), this.pushAxisItem(y, D));
                        isNaN(C - J) || (y = new this.guideFillRenderer(this, J, C, B), this.pushAxisItem(y, D), y = y.graphics(), B.graphics = y, B.balloonText && this.addEventListeners(y, B))
                    }
                    this.fillAlpha = A
                }
                this.exponential = !1;
                for (g = f; g < r; g += q) {
                    v = d.roundTo(this.step * g + this.min, t), -1 != String(v).indexOf("e") && (this.exponential = !0);
                }
                this.duration && (this.maxInterval = d.getMaxInterval(this.max, this.duration));
                var t = this.step,
                    E, v = this.minorGridAlpha;
                this.minorGridEnabled && (E = this.getMinorGridStep(t, this.stepWidth * t));
                if ("date" == c) {
                    this.generateDFObject(), this.timeDifference = this.max - this.min, this.maxTime = this.lastTime = this.max, this.startTime = this.firstTime = this.min, this.parseDatesDraw();
                } else {
                    for (r >= this.autoRotateCount && !isNaN(this.autoRotateAngle) && (this.labelRotationR = this.autoRotateAngle), g = f; g < r; g += q) {
                        if (c = t * g + this.minCalc, h && this.max - this.min > 10 * this.min && (c -= this.min), c = d.roundTo(c, this.maxDecCount + 1), !this.integersOnly || Math.round(c) == c) {
                            if (isNaN(z) || Number(d.toFixed(c, z)) == c) {
                                !0 === h && (0 === c && (c = this.minReal), u > this.logGridLimit && (c = Math.pow(10, g)));
                                y = this.formatValue(c, !1, g);
                                Math.round(g / m) != g / m && (y = void 0);
                                if (0 === g && !n || g == r - 1 && !p) {
                                    y = " ";
                                }
                                f = this.getCoordinate(c);
                                var O;
                                this.rotate && this.autoWrap && (O = this.stepWidth * t - 10);
                                y = new this.axisItemRenderer(this, f, y, void 0, O, void 0, void 0, this.boldLabels);
                                this.pushAxisItem(y);
                                if (c == this.baseValue && "radar" != a.type) {
                                    var I, W, A = this.viW,
                                        B = this.viH;
                                    y = this.viX;
                                    w = this.viY;
                                    "H" == this.orientation ? 0 <= f && f <= A + 1 && (I = [f, f, f + k], W = [B, 0, l]) : 0 <= f && f <= B + 1 && (I = [0, A, A + k], W = [f, f, f + l]);
                                    I && (f = d.fitToBounds(2 * this.gridAlpha, 0, 1), f = d.line(a.container, I, W, this.gridColor, f, 1, this.dashLength), f.translate(y, w), this.grid0 = f, a.axesSet.push(f), f.toBack(), d.setCN(a, f, this.bcn + "zero-grid-" + this.id), d.setCN(a, f, this.bcn + "zero-grid"))
                                }
                                if (!isNaN(E) && 0 < v && g < r - 1) {
                                    f = this.gridAlpha;
                                    this.gridAlpha = this.minorGridAlpha;
                                    for (y = 1; y < t / E; y++) {
                                        w = this.getCoordinate(c + E * y), w = new this.axisItemRenderer(this, w, "", !1, 0, 0, !1, !1, 0, !0), this.pushAxisItem(w);
                                    }
                                    this.gridAlpha = f
                                }
                            }
                        }
                    }
                }
                u = this.baseValue;
                this.min > this.baseValue && this.max > this.baseValue && (u = this.min);
                this.min < this.baseValue && this.max < this.baseValue && (u = this.max);
                h && u < this.minReal && (u = this.minReal);
                this.baseCoord = this.getCoordinate(u);
                u = {
                    type: "axisChanged",
                    target: this,
                    chart: a
                };
                u.min = h ? this.minReal : this.min;
                u.max = this.max;
                this.fire("axisChanged", u);
                this.axisCreated = !0
            }
            h = this.axisLine.set;
            u = this.labelsSet;
            this.positionTitle();
            "radar" != a.type ? (a = this.viX, E = this.viY, b.translate(a, E), u.translate(a, E)) : h.toFront();
            !this.visible || e ? (b.hide(), h.hide(), u.hide()) : (b.show(), h.show(), u.show());
            this.axisY = this.y - this.viY;
            this.axisX = this.x - this.viX
        },
        getDateMinMax: function() {
            this.minimumDate && (this.minimumDate instanceof Date || (this.minimumDate = d.getDate(this.minimumDate, this.chart.dataDateFormat, "fff")), this.min = this.minimumDate.getTime());
            this.maximumDate && (this.maximumDate instanceof Date || (this.maximumDate = d.getDate(this.maximumDate, this.chart.dataDateFormat, "fff")), this.max = this.maximumDate.getTime())
        },
        formatValue: function(a, b, c) {
            var e = this.exponential,
                h = this.logarithmic,
                f = this.numberFormatter,
                g = this.chart;
            !0 === this.logarithmic && (e = -1 != String(a).indexOf("e") ? !0 : !1);
            this.useScientificNotation && (e = !0);
            this.usePrefixes && (e = !1);
            e ? (c = -1 == String(a).indexOf("e") ? a.toExponential(15) : String(a), e = c.split("e"), c = Number(e[0]), e = Number(e[1]), c = d.roundTo(c, 14), 10 == c && (c = 1, e += 1), c = c + "e" + e, 0 === a && (c = "0"), 1 == a && (c = "1")) : (h && (e = String(a).split("."), e[1] ? (f.precision = e[1].length, 0 > c && (f.precision = Math.abs(c)), b && 1 < a && (f.precision = 0)) : f.precision = -1), c = this.usePrefixes ? d.addPrefix(a, g.prefixesOfBigNumbers, g.prefixesOfSmallNumbers, f, !b) : d.formatNumber(a, f, f.precision));
            this.duration && (b && (f.precision = 0), c = d.formatDuration(a, this.duration, "", this.durationUnits, this.maxInterval, f));
            "date" == this.type && (c = d.formatDate(new Date(a), this.currentDateFormat, g));
            this.recalculateToPercents ? c += "%" : (b = this.unit) && (c = "left" == this.unitPosition ? b + c : c + b);
            this.labelFunction && (c = this.labelFunction(a, c, this).toString());
            return c
        },
        getMinorGridStep: function(a, b) {
            var c = [5, 4, 2];
            60 > b && c.shift();
            for (var e = Math.floor(Math.log(Math.abs(a)) * Math.LOG10E), d = 0; d < c.length; d++) {
                var f = a / c[d],
                    g = Math.floor(Math.log(Math.abs(f)) * Math.LOG10E);
                if (!(1 < Math.abs(e - g))) {
                    if (1 > a) {
                        if (g = Math.pow(10, -g) * f, g == Math.round(g)) {
                            return f
                        }
                    } else if (f == Math.round(f)) {
                        return f
                    }
                }
            }
        },
        stackGraphs: function(a) {
            var b = this.stackType;
            "stacked" == b && (b = "regular");
            "line" == b && (b = "none");
            "100% stacked" == b && (b = "100%");
            this.stackType = b;
            var c = [],
                e = [],
                h = [],
                f = [],
                g, k = this.chart.graphs,
                l, m, n, p, q = this.baseValue,
                r = !1;
            if ("line" == a || "step" == a || "smoothedLine" == a) {
                r = !0;
            }
            if (r && ("regular" == b || "100%" == b)) {
                for (p = 0; p < k.length; p++) {
                    n = k[p], n.hidden || (m = n.type, n.chart == this.chart && n.valueAxis == this && a == m && n.stackable && (l && (n.stackGraph = l), l = n));
                }
            }
            for (l = this.start; l <= this.end; l++) {
                var u = 0;
                for (p = 0; p < k.length; p++) {
                    if (n = k[p], n.hidden) {
                        n.newStack && (h[l] = NaN, e[l] = NaN);
                    } else if (m = n.type, n.chart == this.chart && n.valueAxis == this && a == m && n.stackable) {
                        if (m = this.data[l].axes[this.id].graphs[n.id], g = m.values.value, isNaN(g)) {
                            n.newStack && (h[l] = NaN, e[l] = NaN);
                        } else {
                            var t = d.getDecimals(g);
                            u < t && (u = t);
                            isNaN(f[l]) ? f[l] = Math.abs(g) : f[l] += Math.abs(g);
                            f[l] = d.roundTo(f[l], u);
                            t = n.fillToGraph;
                            r && t && (t = this.data[l].axes[this.id].graphs[t.id]) && (m.values.open = t.values.value);
                            "regular" == b && (r && (isNaN(c[l]) ? (c[l] = g, m.values.close = g, m.values.open = this.baseValue) : (isNaN(g) ? m.values.close = c[l] : m.values.close = g + c[l], m.values.open = c[l], c[l] = m.values.close)), "column" == a && (n.newStack && (h[l] = NaN, e[l] = NaN), m.values.close = g, 0 > g ? (m.values.close = g, isNaN(e[l]) ? m.values.open = q : (m.values.close += e[l], m.values.open = e[l]), e[l] = m.values.close) : (m.values.close = g, isNaN(h[l]) ? m.values.open = q : (m.values.close += h[l], m.values.open = h[l]), h[l] = m.values.close)))
                        }
                    }
                }
            }
            for (l = this.start; l <= this.end; l++) {
                for (p = 0; p < k.length; p++) {
                    (n = k[p], n.hidden) ? n.newStack && (h[l] = NaN, e[l] = NaN): (m = n.type, n.chart == this.chart && n.valueAxis == this && a == m && n.stackable && (m = this.data[l].axes[this.id].graphs[n.id], g = m.values.value, isNaN(g) || (c = g / f[l] * 100, m.values.percents = c, m.values.total = f[l], n.newStack && (h[l] = NaN, e[l] = NaN), "100%" == b && (isNaN(e[l]) && (e[l] = 0), isNaN(h[l]) && (h[l] = 0), 0 > c ? (m.values.close = d.fitToBounds(c + e[l], -100, 100), m.values.open = e[l], e[l] = m.values.close) : (m.values.close = d.fitToBounds(c + h[l], -100, 100), m.values.open = h[l], h[l] = m.values.close)))))
                }
            }
        },
        recalculate: function() {
            var a = this.chart,
                b = a.graphs,
                c;
            for (c = 0; c < b.length; c++) {
                var e = b[c];
                if (e.valueAxis == this) {
                    var h = "value";
                    if ("candlestick" == e.type || "ohlc" == e.type) {
                        h = "open";
                    }
                    var f, g, k = this.end + 2,
                        k = d.fitToBounds(this.end + 1, 0, this.data.length - 1),
                        l = this.start;
                    0 < l && l--;
                    var m;
                    g = this.start;
                    e.compareFromStart && (g = 0);
                    if (!isNaN(a.startTime) && (m = a.categoryAxis)) {
                        var n = m.minDuration(),
                            n = new Date(a.startTime + n / 2),
                            p = d.resetDateToMin(new Date(a.startTime), m.minPeriod).getTime();
                        d.resetDateToMin(new Date(n), m.minPeriod).getTime() > p && g++
                    }
                    if (m = a.recalculateFromDate) {
                        m = d.getDate(m, a.dataDateFormat, "fff"), g = a.getClosestIndex(a.chartData, "time", m.getTime(), !0, 0, a.chartData.length), k = a.chartData.length - 1;
                    }
                    for (m = g; m <= k && (g = this.data[m].axes[this.id].graphs[e.id], f = g.values[h], e.recalculateValue && (f = g.dataContext["value" + e.recalculateValue]), isNaN(f)); m++) {;
                    }
                    this.recBaseValue = f;
                    for (h = l; h <= k; h++) {
                        g = this.data[h].axes[this.id].graphs[e.id];
                        g.percents = {};
                        var l = g.values,
                            q;
                        for (q in l) {
                            g.percents[q] = "percents" != q ? l[q] / f * 100 - 100 : l[q]
                        }
                    }
                }
            }
        },
        getMinMax: function() {
            var a = !1,
                b = this.chart,
                c = b.graphs,
                e;
            for (e = 0; e < c.length; e++) {
                var h = c[e].type;
                ("line" == h || "step" == h || "smoothedLine" == h) && this.expandMinMax && (a = !0)
            }
            a && (0 < this.start && this.start--, this.end < this.data.length - 1 && this.end++);
            "serial" == b.type && (!0 !== b.categoryAxis.parseDates || a || this.end < this.data.length - 1 && this.end++);
            this.includeAllValues && (this.start = 0, this.end = this.data.length - 1);
            a = this.minMaxMultiplier;
            this.min = this.getMin(this.start, this.end);
            this.max = this.getMax();
            this.minRR = this.min;
            this.maxRR = this.max;
            a = (this.max - this.min) * (a - 1);
            this.min -= a;
            this.max += a;
            a = this.guides.length;
            if (this.includeGuidesInMinMax && 0 < a) {
                for (b = 0; b < a; b++) {
                    c = this.guides[b], c.toValue < this.min && (this.min = c.toValue), c.value < this.min && (this.min = c.value), c.toValue > this.max && (this.max = c.toValue), c.value > this.max && (this.max = c.value);
                }
            }
            isNaN(this.minimum) || (this.min = this.minimum);
            isNaN(this.maximum) || (this.max = this.maximum);
            "date" == this.type && this.getDateMinMax();
            this.min > this.max && (a = this.max, this.max = this.min, this.min = a);
            isNaN(this.minTemp) || (this.min = this.minTemp);
            isNaN(this.maxTemp) || (this.max = this.maxTemp);
            this.minReal = this.min;
            this.maxReal = this.max;
            0 === this.min && 0 === this.max && (this.max = 9);
            this.min > this.max && (this.min = this.max - 1);
            a = this.min;
            b = this.max;
            c = this.max - this.min;
            e = 0 === c ? Math.pow(10, Math.floor(Math.log(Math.abs(this.max)) * Math.LOG10E)) / 10 : Math.pow(10, Math.floor(Math.log(Math.abs(c)) * Math.LOG10E)) / 10;
            isNaN(this.maximum) && isNaN(this.maxTemp) && (this.max = Math.ceil(this.max / e) * e + e);
            isNaN(this.minimum) && isNaN(this.minTemp) && (this.min = Math.floor(this.min / e) * e - e);
            0 > this.min && 0 <= a && (this.min = 0);
            0 < this.max && 0 >= b && (this.max = 0);
            "100%" == this.stackType && (this.min = 0 > this.min ? -100 : 0, this.max = 0 > this.max ? 0 : 100);
            c = this.max - this.min;
            e = Math.pow(10, Math.floor(Math.log(Math.abs(c)) * Math.LOG10E)) / 10;
            this.step = Math.ceil(c / this.gridCountR / e) * e;
            c = Math.pow(10, Math.floor(Math.log(Math.abs(this.step)) * Math.LOG10E));
            c = d.fixStepE(c);
            e = Math.ceil(this.step / c);
            5 < e && (e = 10);
            5 >= e && 2 < e && (e = 5);
            this.step = Math.ceil(this.step / (c * e)) * c * e;
            1 > c ? (this.maxDecCount = Math.abs(Math.log(Math.abs(c)) * Math.LOG10E), this.maxDecCount = Math.round(this.maxDecCount), this.step = d.roundTo(this.step, this.maxDecCount + 1)) : this.maxDecCount = 0;
            this.min = this.step * Math.floor(this.min / this.step);
            this.max = this.step * Math.ceil(this.max / this.step);
            0 > this.min && 0 <= a && (this.min = 0);
            0 < this.max && 0 >= b && (this.max = 0);
            1 < this.minReal && 1 < this.max - this.minReal && (this.minReal = Math.floor(this.minReal));
            c = Math.pow(10, Math.floor(Math.log(Math.abs(this.minReal)) * Math.LOG10E));
            0 === this.min && (this.minReal = c);
            0 === this.min && 1 < this.minReal && (this.minReal = 1);
            0 < this.min && 0 < this.minReal - this.step && (this.minReal = this.min + this.step < this.minReal ? this.min + this.step : this.min);
            this.logarithmic && (2 < Math.log(b) * Math.LOG10E - Math.log(a) * Math.LOG10E ? (this.minReal = this.min = Math.pow(10, Math.floor(Math.log(Math.abs(a)) * Math.LOG10E)), this.max = Math.pow(10, Math.ceil(Math.log(Math.abs(b)) * Math.LOG10E))) : (b = Math.pow(10, Math.floor(Math.log(Math.abs(this.min)) * Math.LOG10E)) / 10, a = Math.pow(10, Math.floor(Math.log(Math.abs(a)) * Math.LOG10E)) / 10, b < a && (this.minReal = this.min = 10 * a)))
        },
        getMin: function(a, b) {
            var c, e;
            for (e = a; e <= b; e++) {
                var d = this.data[e].axes[this.id].graphs,
                    f;
                for (f in d) {
                    if (d.hasOwnProperty(f)) {
                        var g = this.chart.getGraphById(f);
                        if (g.includeInMinMax && (!g.hidden || this.includeHidden)) {
                            isNaN(c) && (c = Infinity);
                            this.foundGraphs = !0;
                            g = d[f].values;
                            this.recalculateToPercents && (g = d[f].percents);
                            var k;
                            if (this.minMaxField) {
                                k = g[this.minMaxField], k < c && (c = k);
                            } else {
                                for (var l in g) {
                                    g.hasOwnProperty(l) && "percents" != l && "total" != l && (k = g[l], k < c && (c = k))
                                }
                            }
                        }
                    }
                }
            }
            return c
        },
        getMax: function() {
            var a, b;
            for (b = this.start; b <= this.end; b++) {
                var c = this.data[b].axes[this.id].graphs,
                    e;
                for (e in c) {
                    if (c.hasOwnProperty(e)) {
                        var d = this.chart.getGraphById(e);
                        if (d.includeInMinMax && (!d.hidden || this.includeHidden)) {
                            isNaN(a) && (a = -Infinity);
                            this.foundGraphs = !0;
                            d = c[e].values;
                            this.recalculateToPercents && (d = c[e].percents);
                            var f;
                            if (this.minMaxField) {
                                f = d[this.minMaxField], f > a && (a = f);
                            } else {
                                for (var g in d) {
                                    d.hasOwnProperty(g) && "percents" != g && "total" != g && (f = d[g], f > a && (a = f))
                                }
                            }
                        }
                    }
                }
            }
            return a
        },
        dispatchZoomEvent: function(a, b) {
            var c = {
                type: "axisZoomed",
                startValue: a,
                endValue: b,
                target: this,
                chart: this.chart
            };
            this.fire(c.type, c)
        },
        zoomOut: function() {
            var a = this.chart;
            "xy" != a.type && (this.maxZoom = this.minZoom = void 0, a.updateAfterValueZoom())
        },
        zoomToValues: function(a, b) {
            var c = this.chart;
            "xy" == c.type ? (b < a && (c = b, b = a, a = c), a < this.min && (a = this.min), b > this.max && (b = this.max), c = {
                type: "axisSelfZoomed"
            }, c.chart = this.chart, c.valueAxis = this, c.multiplier = this.axisWidth / Math.abs(this.getCoordinate(b) - this.getCoordinate(a)), c.startValue = a, c.endValue = b, c.position = "V" == this.orientation ? this.reversed ? this.getCoordinate(a) : this.getCoordinate(b) : this.reversed ? this.getCoordinate(b) : this.getCoordinate(a), this.fire(c.type, c)) : (this.minZoom = a, this.maxZoom = b, c.updateAfterValueZoom())
        },
        coordinateToValue: function(a) {
            if (isNaN(a)) {
                return NaN;
            }
            var b = this.axisWidth,
                c = this.stepWidth,
                e = this.reversed,
                d = this.rotate,
                f = this.min,
                g = this.minReal;
            return !0 === this.logarithmic ? Math.pow(10, (d ? !0 === e ? (b - a) / c : a / c : !0 === e ? a / c : (b - a) / c) + Math.log(g) * Math.LOG10E) : !0 === e ? d ? f - (a - b) / c : a / c + f : d ? a / c + f : f - (a - b) / c
        },
        getCoordinate: function(a) {
            if (isNaN(a)) {
                return NaN;
            }
            var b = this.rotate,
                c = this.reversed,
                e = this.axisWidth,
                d = this.stepWidth,
                f = this.min,
                g = this.minReal;
            !0 === this.logarithmic ? (0 === a && (a = this.treatZeroAs), a = Math.log(a) * Math.LOG10E - Math.log(g) * Math.LOG10E, b = b ? !0 === c ? e - d * a : d * a : !0 === c ? d * a : e - d * a) : b = !0 === c ? b ? e - d * (a - f) : d * (a - f) : b ? d * (a - f) : e - d * (a - f);
            b = this.rotate ? b + (this.x - this.viX) : b + (this.y - this.viY);
            1E7 < Math.abs(b) && (b = 1E7 * (b / Math.abs(b)));
            return Math.round(b)
        },
        synchronizeWithAxis: function(a) {
            this.synchronizeWith = a;
            this.listenTo(this.synchronizeWith, "axisChanged", this.handleSynchronization)
        },
        handleSynchronization: function() {
            if (this.synchronizeWith) {
                d.isString(this.synchronizeWith) && (this.synchronizeWith = this.chart.getValueAxisById(this.synchronizeWith));
                var a = this.synchronizeWith,
                    b = a.min,
                    c = a.max,
                    a = a.step,
                    e = this.synchronizationMultiplier;
                e && (this.min = b * e, this.max = c * e, this.step = a * e, b = Math.pow(10, Math.floor(Math.log(Math.abs(this.step)) * Math.LOG10E)), b = Math.abs(Math.log(Math.abs(b)) * Math.LOG10E), this.maxDecCount = b = Math.round(b), this.draw())
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.RecAxis = d.Class({
        construct: function(a) {
            var b = a.chart,
                c = a.axisThickness,
                e = a.axisColor,
                h = a.axisAlpha,
                f = a.offset,
                g = a.dx,
                k = a.dy,
                l = a.viX,
                m = a.viY,
                n = a.viH,
                p = a.viW,
                q = b.container;
            "H" == a.orientation ? (e = d.line(q, [0, p], [0, 0], e, h, c), this.axisWidth = a.width, "bottom" == a.position ? (k = c / 2 + f + n + m - 1, c = l) : (k = -c / 2 - f + m + k, c = g + l)) : (this.axisWidth = a.height, "right" == a.position ? (e = d.line(q, [0, 0, -g], [0, n, n - k], e, h, c), k = m + k, c = c / 2 + f + g + p + l - 1) : (e = d.line(q, [0, 0], [0, n], e, h, c), k = m, c = -c / 2 - f + l));
            e.translate(c, k);
            c = b.container.set();
            c.push(e);
            b.axesSet.push(c);
            d.setCN(b, e, a.bcn + "line");
            this.axisSet = c;
            this.set = e
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.RecItem = d.Class({
        construct: function(a, b, c, e, h, f, g, k, l, m, n, p) {
            b = Math.round(b);
            var q = a.chart;
            this.value = c;
            void 0 == c && (c = "");
            l || (l = 0);
            void 0 == e && (e = !0);
            var r = q.fontFamily,
                u = a.fontSize;
            void 0 == u && (u = q.fontSize);
            var t = a.color;
            void 0 == t && (t = q.color);
            void 0 !== n && (t = n);
            var z = a.chart.container,
                y = z.set();
            this.set = y;
            var v = a.axisThickness,
                w = a.axisColor,
                A = a.axisAlpha,
                B = a.tickLength,
                C = a.gridAlpha,
                D = a.gridThickness,
                J = a.gridColor,
                E = a.dashLength,
                O = a.fillColor,
                I = a.fillAlpha,
                W = a.labelsEnabled;
            n = a.labelRotationR;
            var ea = a.counter,
                P = a.inside,
                oa = a.labelOffset,
                qa = a.dx,
                ka = a.dy,
                Ra = a.orientation,
                ca = a.position,
                aa = a.previousCoord,
                V = a.viH,
                sa = a.viW,
                ba = a.offset,
                da, ta;
            g ? (void 0 !== g.id && (p = q.classNamePrefix + "-guide-" + g.id), W = !0, isNaN(g.tickLength) || (B = g.tickLength), void 0 != g.lineColor && (J = g.lineColor), void 0 != g.color && (t = g.color), isNaN(g.lineAlpha) || (C = g.lineAlpha), isNaN(g.dashLength) || (E = g.dashLength), isNaN(g.lineThickness) || (D = g.lineThickness), !0 === g.inside && (P = !0, 0 < ba && (ba = 0)), isNaN(g.labelRotation) || (n = g.labelRotation), isNaN(g.fontSize) || (u = g.fontSize), g.position && (ca = g.position), void 0 !== g.boldLabel && (k = g.boldLabel), isNaN(g.labelOffset) || (oa = g.labelOffset)) : "" === c && (B = 0);
            m && !isNaN(a.minorTickLength) && (B = a.minorTickLength);
            var fa = "start";
            0 < h && (fa = "middle");
            a.centerLabels && (fa = "middle");
            var R = n * Math.PI / 180,
                X, wa, H = 0,
                x = 0,
                la = 0,
                ga = X = 0,
                Ja = 0;
            "V" == Ra && (n = 0);
            var Z;
            W && "" !== c && (Z = a.autoWrap && 0 === n ? d.wrappedText(z, c, t, r, u, fa, k, Math.abs(h), 0) : d.text(z, c, t, r, u, fa, k), fa = Z.getBBox(), ga = fa.width, Ja = fa.height);
            if ("H" == Ra) {
                if (0 <= b && b <= sa + 1 && (0 < B && 0 < A && b + l <= sa + 1 && (da = d.line(z, [b + l, b + l], [0, B], w, A, D), y.push(da)), 0 < C && (ta = d.line(z, [b, b + qa, b + qa], [V, V + ka, ka], J, C, D, E), y.push(ta))), x = 0, H = b, g && 90 == n && P && (H -= u), !1 === e ? (fa = "start", x = "bottom" == ca ? P ? x + B : x - B : P ? x - B : x + B, H += 3, 0 < h && (H += h / 2 - 3, fa = "middle"), 0 < n && (fa = "middle")) : fa = "middle", 1 == ea && 0 < I && !g && !m && aa < sa && (e = d.fitToBounds(b, 0, sa), aa = d.fitToBounds(aa, 0, sa), X = e - aa, 0 < X && (wa = d.rect(z, X, a.height, O, I), wa.translate(e - X + qa, ka), y.push(wa))), "bottom" == ca ? (x += V + u / 2 + ba, P ? (0 < n ? (x = V - ga / 2 * Math.sin(R) - B - 3, H += ga / 2 * Math.cos(R) - 4 + 2) : 0 > n ? (x = V + ga * Math.sin(R) - B - 3 + 2, H += -ga * Math.cos(R) - Ja * Math.sin(R) - 4) : x -= B + u + 3 + 3, x -= oa) : (0 < n ? (x = V + ga / 2 * Math.sin(R) + B + 3, H -= ga / 2 * Math.cos(R)) : 0 > n ? (x = V + B + 3 - ga / 2 * Math.sin(R) + 2, H += ga / 2 * Math.cos(R)) : x += B + v + 3 + 3, x += oa)) : (x += ka + u / 2 - ba, H += qa, P ? (0 < n ? (x = ga / 2 * Math.sin(R) + B + 3, H -= ga / 2 * Math.cos(R)) : x += B + 3, x += oa) : (0 < n ? (x = -(ga / 2) * Math.sin(R) - B - 6, H += ga / 2 * Math.cos(R)) : x -= B + u + 3 + v + 3, x -= oa)), "bottom" == ca ? X = (P ? V - B - 1 : V + v - 1) + ba : (la = qa, X = (P ? ka : ka - B - v + 1) - ba), f && (H += f), f = H, 0 < n && (f += ga / 2 * Math.cos(R)), Z && (u = 0, P && (u = ga / 2 * Math.cos(R)), f + u > sa + 2 || 0 > f)) {
                    Z.remove(), Z = null
                }
            } else {
                0 <= b && b <= V + 1 && (0 < B && 0 < A && b + l <= V + 1 && (da = d.line(z, [0, B], [b + l, b + l], w, A, D), y.push(da)), 0 < C && (ta = d.line(z, [0, qa, sa + qa], [b, b + ka, b + ka], J, C, D, E), y.push(ta)));
                fa = "end";
                if (!0 === P && "left" == ca || !1 === P && "right" == ca) {
                    fa = "start";
                }
                x = b - Ja / 2 + 2;
                1 == ea && 0 < I && !g && !m && (e = d.fitToBounds(b, 0, V), aa = d.fitToBounds(aa, 0, V), R = e - aa, wa = d.polygon(z, [0, a.width, a.width, 0], [0, 0, R, R], O, I), wa.translate(qa, e - R + ka), y.push(wa));
                x += u / 2;
                "right" == ca ? (H += qa + sa + ba, x += ka, P ? (f || (x -= u / 2 + 3), H = H - (B + 4) - oa) : (H += B + 4 + v, x -= 2, H += oa)) : P ? (H += B + 4 - ba, f || (x -= u / 2 + 3), g && (H += qa, x += ka), H += oa) : (H += -B - v - 4 - 2 - ba, x -= 2, H -= oa);
                da && ("right" == ca ? (la += qa + ba + sa, X += ka, la = P ? la - v : la + v) : (la -= ba, P || (la -= B + v)));
                f && (x += f);
                P = -3;
                "right" == ca && (P += ka);
                Z && (x > V + 1 || x < P) && (Z.remove(), Z = null)
            }
            da && (da.translate(la, X), d.setCN(q, da, a.bcn + "tick"), d.setCN(q, da, p, !0), g && d.setCN(q, da, "guide"));
            !1 === a.visible && (da && da.remove(), Z && (Z.remove(), Z = null));
            Z && (Z.attr({
                "text-anchor": fa
            }), Z.translate(H, x), 0 !== n && Z.rotate(-n, a.chart.backgroundColor), a.allLabels.push(Z), this.label = Z, d.setCN(q, Z, a.bcn + "label"), d.setCN(q, Z, p, !0), g && d.setCN(q, Z, "guide"));
            ta && (d.setCN(q, ta, a.bcn + "grid"), d.setCN(q, ta, p, !0), g && d.setCN(q, ta, "guide"));
            wa && (d.setCN(q, wa, a.bcn + "fill"), d.setCN(q, wa, p, !0));
            m ? ta && d.setCN(q, ta, a.bcn + "grid-minor") : (a.counter = 0 === ea ? 1 : 0, a.previousCoord = b);
            0 === this.set.node.childNodes.length && this.set.remove()
        },
        graphics: function() {
            return this.set
        },
        getLabel: function() {
            return this.label
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.RecFill = d.Class({
        construct: function(a, b, c, e) {
            var h = a.dx,
                f = a.dy,
                g = a.orientation,
                k = 0;
            if (c < b) {
                var l = b;
                b = c;
                c = l
            }
            var m = e.fillAlpha;
            isNaN(m) && (m = 0);
            var l = a.chart.container,
                n = e.fillColor;
            "V" == g ? (b = d.fitToBounds(b, 0, a.viH), c = d.fitToBounds(c, 0, a.viH)) : (b = d.fitToBounds(b, 0, a.viW), c = d.fitToBounds(c, 0, a.viW));
            c -= b;
            isNaN(c) && (c = 4, k = 2, m = 0);
            0 > c && "object" == typeof n && (n = n.join(",").split(",").reverse());
            "V" == g ? (g = d.rect(l, a.viW, c, n, m), g.translate(h, b - k + f)) : (g = d.rect(l, c, a.viH, n, m), g.translate(b - k + h, f));
            d.setCN(a.chart, g, "guide-fill");
            e.id && d.setCN(a.chart, g, "guide-fill-" + e.id);
            this.set = l.set([g])
        },
        graphics: function() {
            return this.set
        },
        getLabel: function() {}
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmChart = d.Class({
        construct: function(a) {
            this.svgIcons = this.tapToActivate = !0;
            this.theme = a;
            this.classNamePrefix = "amcharts";
            this.addClassNames = !1;
            this.version = "3.16.0";
            d.addChart(this);
            this.createEvents("dataUpdated", "init", "rendered", "drawn", "failed", "resized");
            this.height = this.width = "100%";
            this.dataChanged = !0;
            this.chartCreated = !1;
            this.previousWidth = this.previousHeight = 0;
            this.backgroundColor = "#FFFFFF";
            this.borderAlpha = this.backgroundAlpha = 0;
            this.color = this.borderColor = "#000000";
            this.fontFamily = "Verdana";
            this.fontSize = 11;
            this.usePrefixes = !1;
            this.autoResize = !0;
            this.autoDisplay = !1;
            this.addCodeCredits = !0;
            this.precision = -1;
            this.percentPrecision = 2;
            this.decimalSeparator = ".";
            this.thousandsSeparator = ",";
            this.labels = [];
            this.allLabels = [];
            this.titles = [];
            this.marginRight = this.marginLeft = this.autoMarginOffset = 0;
            this.timeOuts = [];
            this.creditsPosition = "top-left";
            var b = document.createElement("div"),
                c = b.style;
            c.overflow = "hidden";
            c.position = "relative";
            c.textAlign = "left";
            this.chartDiv = b;
            b = document.createElement("div");
            c = b.style;
            c.overflow = "hidden";
            c.position = "relative";
            c.textAlign = "left";
            this.legendDiv = b;
            this.titleHeight = 0;
            this.hideBalloonTime = 150;
            this.handDrawScatter = 2;
            this.handDrawThickness = 1;
            this.prefixesOfBigNumbers = [{
                number: 1E3,
                prefix: "k"
            }, {
                number: 1E6,
                prefix: "M"
            }, {
                number: 1E9,
                prefix: "G"
            }, {
                number: 1E12,
                prefix: "T"
            }, {
                number: 1E15,
                prefix: "P"
            }, {
                number: 1E18,
                prefix: "E"
            }, {
                number: 1E21,
                prefix: "Z"
            }, {
                number: 1E24,
                prefix: "Y"
            }];
            this.prefixesOfSmallNumbers = [{
                number: 1E-24,
                prefix: "y"
            }, {
                number: 1E-21,
                prefix: "z"
            }, {
                number: 1E-18,
                prefix: "a"
            }, {
                number: 1E-15,
                prefix: "f"
            }, {
                number: 1E-12,
                prefix: "p"
            }, {
                number: 1E-9,
                prefix: "n"
            }, {
                number: 1E-6,
                prefix: "\u03bc"
            }, {
                number: .001,
                prefix: "m"
            }];
            this.panEventsEnabled = !0;
            this.product = "amcharts";
            this.animations = [];
            this.balloon = new d.AmBalloon(this.theme);
            this.balloon.chart = this;
            d.applyTheme(this, a, "AmChart")
        },
        drawChart: function() {
            0 < this.realWidth && 0 < this.realHeight && (this.drawBackground(), this.redrawLabels(), this.drawTitles(), this.brr(), this.renderFix())
        },
        drawBackground: function() {
            d.remove(this.background);
            var a = this.container,
                b = this.backgroundColor,
                c = this.backgroundAlpha,
                e = this.set;
            d.isModern || 0 !== c || (c = .001);
            var h = this.updateWidth();
            this.realWidth = h;
            var f = this.updateHeight();
            this.realHeight = f;
            b = d.polygon(a, [0, h - 1, h - 1, 0], [0, 0, f - 1, f - 1], b, c, 1, this.borderColor, this.borderAlpha);
            d.setCN(this, b, "bg");
            this.background = b;
            e.push(b);
            if (b = this.backgroundImage) {
                a = a.image(b, 0, 0, h, f), d.setCN(this, b, "bg-image"), this.bgImg = a, e.push(a)
            }
        },
        drawTitles: function(a) {
            var b = this.titles;
            this.titleHeight = 0;
            if (d.ifArray(b)) {
                var c = 20,
                    e;
                for (e = 0; e < b.length; e++) {
                    var h = b[e],
                        h = d.processObject(h, d.Title, this.theme);
                    if (!1 !== h.enabled) {
                        var f = h.color;
                        void 0 === f && (f = this.color);
                        var g = h.size;
                        isNaN(g) && (g = this.fontSize + 2);
                        isNaN(h.alpha);
                        var k = this.marginLeft,
                            f = d.wrappedText(this.container, h.text, f, this.fontFamily, g, "middle", !1, this.divRealWidth - 20);
                        f.translate(k + (this.realWidth - this.marginRight - k) / 2, c);
                        f.node.style.pointerEvents = "none";
                        h.sprite = f;
                        d.setCN(this, f, "title");
                        h.id && d.setCN(this, f, "title-" + h.id);
                        k = !0;
                        void 0 !== h.bold && (k = h.bold);
                        k && f.attr({
                            "font-weight": "bold"
                        });
                        f.attr({
                            opacity: h.alpha
                        });
                        c += f.getBBox().height + 5;
                        a ? f.remove() : this.freeLabelsSet.push(f)
                    }
                }
                this.titleHeight = c - 10
            }
        },
        write: function(a) {
            if (a = "object" != typeof a ? document.getElementById(a) : a) {
                for (; a.firstChild;) {
                    a.removeChild(a.firstChild);
                }
                this.div = a;
                a.style.overflow = "hidden";
                a.style.textAlign = "left";
                var b = this.chartDiv,
                    c = this.legendDiv,
                    e = this.legend,
                    h = c.style,
                    f = b.style;
                this.measure();
                this.previousHeight = this.divRealHeight;
                this.previousWidth = this.divRealWidth;
                var g, k = document.createElement("div");
                g = k.style;
                g.position = "relative";
                this.containerDiv = k;
                k.className = this.classNamePrefix + "-main-div";
                b.className = this.classNamePrefix + "-chart-div";
                a.appendChild(k);
                var l = this.exportConfig;
                l && d.AmExport && !this.AmExport && (this.AmExport = new d.AmExport(this, l));
                this.amExport && d.AmExport && (this.AmExport = d.extend(this.amExport, new d.AmExport(this), !0));
                this.AmExport && this.AmExport.init && this.AmExport.init();
                if (e) {
                    if (e = this.addLegend(e, e.divId), e.enabled) {
                        switch (e.position) {
                            case "bottom":
                                k.appendChild(b);
                                k.appendChild(c);
                                break;
                            case "top":
                                k.appendChild(c);
                                k.appendChild(b);
                                break;
                            case "absolute":
                                g.width = a.style.width;
                                g.height = a.style.height;
                                h.position = "absolute";
                                f.position = "absolute";
                                void 0 !== e.left && (h.left = e.left + "px");
                                void 0 !== e.right && (h.right = e.right + "px");
                                void 0 !== e.top && (h.top = e.top + "px");
                                void 0 !== e.bottom && (h.bottom = e.bottom + "px");
                                e.marginLeft = 0;
                                e.marginRight = 0;
                                k.appendChild(b);
                                k.appendChild(c);
                                break;
                            case "right":
                                g.width = a.style.width;
                                g.height = a.style.height;
                                h.position = "relative";
                                f.position = "absolute";
                                k.appendChild(b);
                                k.appendChild(c);
                                break;
                            case "left":
                                g.width = a.style.width;
                                g.height = a.style.height;
                                h.position = "absolute";
                                f.position = "relative";
                                k.appendChild(b);
                                k.appendChild(c);
                                break;
                            case "outside":
                                k.appendChild(b)
                        }
                    } else {
                        k.appendChild(b);
                    }
                } else {
                    k.appendChild(b);
                }
                this.listenersAdded || (this.addListeners(), this.listenersAdded = !0);
                this.initChart()
            }
        },
        createLabelsSet: function() {
            d.remove(this.labelsSet);
            this.labelsSet = this.container.set();
            this.freeLabelsSet.push(this.labelsSet)
        },
        initChart: function() {
            window.AmCharts_path && (this.path = window.AmCharts_path);
            void 0 === this.path && (this.path = d.getPath());
            void 0 === this.path && (this.path = "amcharts/");
            this.path = d.normalizeUrl(this.path);
            void 0 === this.pathToImages && (this.pathToImages = this.path + "images/");
            this.initHC || (d.callInitHandler(this), this.initHC = !0);
            d.applyLang(this.language, this);
            var a = this.numberFormatter;
            a && (isNaN(a.precision) || (this.precision = a.precision), void 0 !== a.thousandsSeparator && (this.thousandsSeparator = a.thousandsSeparator), void 0 !== a.decimalSeparator && (this.decimalSeparator = a.decimalSeparator));
            (a = this.percentFormatter) && !isNaN(a.precision) && (this.percentPrecision = a.precision);
            this.nf = {
                precision: this.precision,
                thousandsSeparator: this.thousandsSeparator,
                decimalSeparator: this.decimalSeparator
            };
            this.pf = {
                precision: this.percentPrecision,
                thousandsSeparator: this.thousandsSeparator,
                decimalSeparator: this.decimalSeparator
            };
            this.destroy();
            (a = this.container) ? (a.container.innerHTML = "", a.width = this.realWidth, a.height = this.realHeight, a.addDefs(this), this.chartDiv.appendChild(a.container)) : a = new d.AmDraw(this.chartDiv, this.realWidth, this.realHeight, this);
            this.container = a;
            this.extension = ".gif";
            this.svgIcons && d.SVG && (this.extension = ".svg");
            this.checkDisplay();
            a.chart = this;
            d.VML || d.SVG ? (a.handDrawn = this.handDrawn, a.handDrawScatter = this.handDrawScatter, a.handDrawThickness = this.handDrawThickness, this.set && this.set.remove(), this.set = a.set(), this.gridSet && this.gridSet.remove(), this.gridSet = a.set(), this.cursorLineSet && this.cursorLineSet.remove(), this.cursorLineSet = a.set(), this.graphsBehindSet && this.graphsBehindSet.remove(), this.graphsBehindSet = a.set(), this.bulletBehindSet && this.bulletBehindSet.remove(), this.bulletBehindSet = a.set(), this.columnSet && this.columnSet.remove(), this.columnSet = a.set(), this.graphsSet && this.graphsSet.remove(), this.graphsSet = a.set(), this.trendLinesSet && this.trendLinesSet.remove(), this.trendLinesSet = a.set(), this.axesSet && this.axesSet.remove(), this.axesSet = a.set(), this.cursorSet && this.cursorSet.remove(), this.cursorSet = a.set(), this.scrollbarsSet && this.scrollbarsSet.remove(), this.scrollbarsSet = a.set(), this.bulletSet && this.bulletSet.remove(), this.bulletSet = a.set(), this.freeLabelsSet && this.freeLabelsSet.remove(), this.axesLabelsSet && this.axesLabelsSet.remove(), this.axesLabelsSet = a.set(), this.freeLabelsSet = a.set(), this.balloonsSet && this.balloonsSet.remove(), this.balloonsSet = a.set(), this.zoomButtonSet && this.zoomButtonSet.remove(), this.zbSet && (this.zbSet.remove(), this.zbSet = null), this.zoomButtonSet = a.set(), this.linkSet && this.linkSet.remove(), this.linkSet = a.set()) : this.fire("failed", {
                type: "failed",
                chart: this
            })
        },
        premeasure: function() {
            var a = this.div;
            if (a) {
                this.boundingRect = this.chartDiv.getBoundingClientRect();
                var b = a.offsetWidth,
                    c = a.offsetHeight;
                a.clientHeight && (b = a.clientWidth, c = a.clientHeight);
                if (b != this.mw || c != this.mh) {
                    this.mw = b, this.mh = c, this.measure()
                }
            }
        },
        measure: function() {
            var a = this.div;
            if (a) {
                var b = this.chartDiv,
                    c = a.offsetWidth,
                    e = a.offsetHeight,
                    h = this.container;
                a.clientHeight && (c = a.clientWidth, e = a.clientHeight);
                var f = d.removePx(d.getStyle(a, "padding-left")),
                    g = d.removePx(d.getStyle(a, "padding-right")),
                    k = d.removePx(d.getStyle(a, "padding-top")),
                    l = d.removePx(d.getStyle(a, "padding-bottom"));
                isNaN(f) || (c -= f);
                isNaN(g) || (c -= g);
                isNaN(k) || (e -= k);
                isNaN(l) || (e -= l);
                f = a.style;
                a = f.width;
                f = f.height; - 1 != a.indexOf("px") && (c = d.removePx(a)); - 1 != f.indexOf("px") && (e = d.removePx(f));
                e = Math.round(e);
                c = Math.round(c);
                a = Math.round(d.toCoordinate(this.width, c));
                f = Math.round(d.toCoordinate(this.height, e));
                (c != this.previousWidth || e != this.previousHeight) && 0 < a && 0 < f && (b.style.width = a + "px", b.style.height = f + "px", b.style.padding = 0, h && h.setSize(a, f), this.balloon = d.processObject(this.balloon, d.AmBalloon, this.theme), this.balloon.setBounds(2, 2, a - 2, f));
                this.balloon.chart = this;
                this.realWidth = a;
                this.realHeight = f;
                this.divRealWidth = c;
                this.divRealHeight = e
            }
        },
        checkDisplay: function() {
            if (this.autoDisplay && this.container) {
                var a = d.rect(this.container, 10, 10),
                    b = a.getBBox();
                0 === b.width && 0 === b.height && (this.divRealHeight = this.divRealWidth = this.realHeight = this.realWidth = 0, this.previousWidth = this.previousHeight = NaN);
                a.remove()
            }
        },
        destroy: function() {
            this.chartDiv.innerHTML = "";
            this.clearTimeOuts();
            this.legend && this.legend.destroy()
        },
        clearTimeOuts: function() {
            var a = this.timeOuts;
            if (a) {
                var b;
                for (b = 0; b < a.length; b++) {
                    clearTimeout(a[b])
                }
            }
            this.timeOuts = []
        },
        clear: function(a) {
            d.callMethod("clear", [this.chartScrollbar, this.scrollbarV, this.scrollbarH, this.chartCursor]);
            this.chartCursor = this.scrollbarH = this.scrollbarV = this.chartScrollbar = null;
            this.clearTimeOuts();
            this.container && (this.container.remove(this.chartDiv), this.container.remove(this.legendDiv));
            a || d.removeChart(this);
            if (a = this.div) {
                for (; a.firstChild;) {
                    a.removeChild(a.firstChild);
                }
            }
            this.legend && this.legend.destroy()
        },
        setMouseCursor: function(a) {
            "auto" == a && d.isNN && (a = "default");
            this.chartDiv.style.cursor = a;
            this.legendDiv.style.cursor = a
        },
        redrawLabels: function() {
            this.labels = [];
            var a = this.allLabels;
            this.createLabelsSet();
            var b;
            for (b = 0; b < a.length; b++) {
                this.drawLabel(a[b])
            }
        },
        drawLabel: function(a) {
            if (this.container && !1 !== a.enabled) {
                a = d.processObject(a, d.Label, this.theme);
                var b = a.y,
                    c = a.text,
                    e = a.align,
                    h = a.size,
                    f = a.color,
                    g = a.rotation,
                    k = a.alpha,
                    l = a.bold,
                    m = d.toCoordinate(a.x, this.realWidth),
                    b = d.toCoordinate(b, this.realHeight);
                m || (m = 0);
                b || (b = 0);
                void 0 === f && (f = this.color);
                isNaN(h) && (h = this.fontSize);
                e || (e = "start");
                "left" == e && (e = "start");
                "right" == e && (e = "end");
                "center" == e && (e = "middle", g ? b = this.realHeight - b + b / 2 : m = this.realWidth / 2 - m);
                void 0 === k && (k = 1);
                void 0 === g && (g = 0);
                b += h / 2;
                c = d.text(this.container, c, f, this.fontFamily, h, e, l, k);
                c.translate(m, b);
                d.setCN(this, c, "label");
                a.id && d.setCN(this, c, "label-" + a.id);
                0 !== g && c.rotate(g);
                a.url ? (c.setAttr("cursor", "pointer"), c.click(function() {
                    d.getURL(a.url)
                })) : c.node.style.pointerEvents = "none";
                this.labelsSet.push(c);
                this.labels.push(c)
            }
        },
        addLabel: function(a, b, c, e, d, f, g, k, l, m) {
            a = {
                x: a,
                y: b,
                text: c,
                align: e,
                size: d,
                color: f,
                alpha: k,
                rotation: g,
                bold: l,
                url: m,
                enabled: !0
            };
            this.container && this.drawLabel(a);
            this.allLabels.push(a)
        },
        clearLabels: function() {
            var a = this.labels,
                b;
            for (b = a.length - 1; 0 <= b; b--) {
                a[b].remove();
            }
            this.labels = [];
            this.allLabels = []
        },
        updateHeight: function() {
            var a = this.divRealHeight,
                b = this.legend;
            if (b) {
                var c = this.legendDiv.offsetHeight,
                    b = b.position;
                if ("top" == b || "bottom" == b) {
                    a -= c;
                    if (0 > a || isNaN(a)) {
                        a = 0;
                    }
                    this.chartDiv.style.height = a + "px"
                }
            }
            return a
        },
        updateWidth: function() {
            var a = this.divRealWidth,
                b = this.divRealHeight,
                c = this.legend;
            if (c) {
                var e = this.legendDiv,
                    d = e.offsetWidth;
                isNaN(c.width) || (d = c.width);
                c.ieW && (d = c.ieW);
                var f = e.offsetHeight,
                    e = e.style,
                    g = this.chartDiv.style,
                    c = c.position;
                if ("right" == c || "left" == c) {
                    a -= d;
                    if (0 > a || isNaN(a)) {
                        a = 0;
                    }
                    g.width = a + "px";
                    this.balloon.setBounds(2, 2, a - 2, this.realHeight);
                    "left" == c ? (g.left = d + "px", e.left = "0px") : (g.left = "0px", e.left = a + "px");
                    b > f && (e.top = (b - f) / 2 + "px")
                }
            }
            return a
        },
        getTitleHeight: function() {
            this.drawTitles(!0);
            return this.titleHeight
        },
        addTitle: function(a, b, c, e, d) {
            isNaN(b) && (b = this.fontSize + 2);
            a = {
                text: a,
                size: b,
                color: c,
                alpha: e,
                bold: d,
                enabled: !0
            };
            this.titles.push(a);
            return a
        },
        handleWheel: function(a) {
            var b = 0;
            a || (a = window.event);
            a.wheelDelta ? b = a.wheelDelta / 120 : a.detail && (b = -a.detail / 3);
            b && this.handleWheelReal(b, a.shiftKey);
            a.preventDefault && a.preventDefault()
        },
        handleWheelReal: function() {},
        handleDocTouchStart: function() {
            this.hideBalloonReal();
            this.handleMouseMove();
            this.tmx = this.mouseX;
            this.tmy = this.mouseY
        },
        handleDocTouchEnd: function() {
            -.5 < this.tmx && this.tmx < this.divRealWidth + 1 && 0 < this.tmy && this.tmy < this.divRealHeight ? (this.handleMouseMove(), 4 > Math.abs(this.mouseX - this.tmx) && 4 > Math.abs(this.mouseY - this.tmy) && (this.tapped = !0)) : this.tapped = !1
        },
        addListeners: function() {
            var a = this,
                b = a.chartDiv;
            document.addEventListener ? (a.panEventsEnabled && (b.style.msTouchAction = "none"), "ontouchstart" in document.documentElement && (b.addEventListener("touchstart", function(b) {
                a.handleTouchStart.call(a, b)
            }, !0), b.addEventListener("touchmove", function(b) {
                a.handleMouseMove.call(a, b)
            }, !0), b.addEventListener("touchend", function(b) {
                a.handleTouchEnd.call(a, b)
            }, !0), document.addEventListener("touchstart", function(b) {
                a.handleDocTouchStart.call(a, b)
            }), document.addEventListener("touchend", function(b) {
                a.handleDocTouchEnd.call(a, b)
            })), b.addEventListener("mousedown", function(b) {
                a.mouseIsOver = !0;
                a.handleMouseMove.call(a, b);
                a.handleMouseDown.call(a, b)
            }, !0), b.addEventListener("mouseover", function(b) {
                a.handleMouseOver.call(a, b)
            }, !0), b.addEventListener("mouseout", function(b) {
                a.handleMouseOut.call(a, b)
            }, !0)) : (b.attachEvent("onmousedown", function(b) {
                a.handleMouseDown.call(a, b)
            }), b.attachEvent("onmouseover", function(b) {
                a.handleMouseOver.call(a, b)
            }), b.attachEvent("onmouseout", function(b) {
                a.handleMouseOut.call(a, b)
            }))
        },
        dispDUpd: function() {
            if (!this.skipEvents) {
                var a;
                this.dispatchDataUpdated && (this.dispatchDataUpdated = !1, a = "dataUpdated", this.fire(a, {
                    type: a,
                    chart: this
                }));
                this.chartCreated || (this.chartCreated = !0, a = "init", this.fire(a, {
                    type: a,
                    chart: this
                }));
                this.chartRendered || (a = "rendered", this.fire(a, {
                    type: a,
                    chart: this
                }), this.chartRendered = !0);
                a = "drawn";
                this.fire(a, {
                    type: a,
                    chart: this
                })
            }
            this.skipEvents = !1
        },
        validateSize: function() {
            var a = this;
            a.premeasure();
            a.checkDisplay();
            if (a.divRealWidth != a.previousWidth || a.divRealHeight != a.previousHeight) {
                var b = a.legend;
                if (0 < a.realWidth && 0 < a.realHeight) {
                    a.sizeChanged = !0;
                    if (b) {
                        a.legendInitTO && clearTimeout(a.legendInitTO);
                        var c = setTimeout(function() {
                            b.invalidateSize()
                        }, 10);
                        a.timeOuts.push(c);
                        a.legendInitTO = c
                    }
                    "xy" != a.type ? a.marginsUpdated = !1 : (a.marginsUpdated = !0, a.selfZoom = !0);
                    clearTimeout(a.initTO);
                    c = setTimeout(function() {
                        a.initChart()
                    }, 10);
                    a.timeOuts.push(c);
                    a.initTO = c
                }
                a.fire("resized", {
                    type: "resized",
                    chart: a
                });
                a.renderFix();
                b && b.renderFix && b.renderFix();
                a.previousHeight = a.divRealHeight;
                a.previousWidth = a.divRealWidth
            }
        },
        invalidateSize: function() {
            this.previousHeight = this.previousWidth = NaN;
            this.invalidateSizeReal()
        },
        invalidateSizeReal: function() {
            var a = this;
            a.marginsUpdated = !1;
            clearTimeout(a.validateTO);
            var b = setTimeout(function() {
                a.validateSize()
            }, 5);
            a.timeOuts.push(b);
            a.validateTO = b
        },
        validateData: function(a) {
            this.chartCreated && (this.dataChanged = !0, this.marginsUpdated = !1, this.initChart(a))
        },
        validateNow: function(a, b) {
            this.initTO && clearTimeout(this.initTO);
            a && (this.dataChanged = !0);
            this.skipEvents = b;
            this.chartRendered = !1;
            this.write(this.div)
        },
        showItem: function(a) {
            a.hidden = !1;
            this.initChart()
        },
        hideItem: function(a) {
            a.hidden = !0;
            this.initChart()
        },
        hideBalloon: function() {
            var a = this;
            clearTimeout(a.hoverInt);
            clearTimeout(a.balloonTO);
            a.hoverInt = setTimeout(function() {
                a.hideBalloonReal.call(a)
            }, a.hideBalloonTime)
        },
        cleanChart: function() {},
        hideBalloonReal: function() {
            var a = this.balloon;
            a && a.hide()
        },
        showBalloon: function(a, b, c, e, d) {
            var f = this;
            clearTimeout(f.balloonTO);
            clearTimeout(f.hoverInt);
            f.balloonTO = setTimeout(function() {
                f.showBalloonReal.call(f, a, b, c, e, d)
            }, 1)
        },
        showBalloonReal: function(a, b, c, e, d) {
            this.handleMouseMove();
            var f = this.balloon;
            f.enabled && (f.followCursor(!1), f.changeColor(b), !c || f.fixedPosition ? (f.setPosition(e, d), isNaN(e) || isNaN(d) ? f.followCursor(!0) : f.followCursor(!1)) : f.followCursor(!0), a && f.showBalloon(a))
        },
        handleMouseOver: function() {
            this.outTO && clearTimeout(this.outTO);
            d.resetMouseOver();
            this.mouseIsOver = !0
        },
        handleMouseOut: function() {
            var a = this;
            a.outTO && clearTimeout(a.outTO);
            a.outTO = setTimeout(function() {
                a.handleMouseOutReal()
            }, 10)
        },
        handleMouseOutReal: function() {
            d.resetMouseOver();
            this.mouseIsOver = !1
        },
        handleMouseMove: function(a) {
            a || (a = window.event);
            if (a) {
                if (a.touches) {
                    if (a = a.touches.item(0), !a) {
                        return
                    }
                } else {
                    this.wasTouched = !1;
                }
                this.boundingRect && a.clientX && (this.mouseX = a.clientX - this.boundingRect.left, this.mouseY = a.clientY - this.boundingRect.top)
            }
        },
        handleTouchStart: function(a) {
            this.hideBalloonReal();
            a && (a.touches && this.tapToActivate && !this.tapped || !this.panRequired) || (this.handleMouseMove(a), this.handleMouseDown(a))
        },
        handleTouchEnd: function(a) {
            this.wasTouched = !0;
            this.handleMouseMove(a);
            d.resetMouseOver();
            this.handleReleaseOutside(a)
        },
        handleReleaseOutside: function() {},
        handleMouseDown: function(a) {
            d.resetMouseOver();
            this.mouseIsOver = !0;
            a && a.preventDefault && (this.panEventsEnabled ? a.preventDefault() : a.touches || a.preventDefault())
        },
        addLegend: function(a, b) {
            a = d.processObject(a, d.AmLegend, this.theme);
            a.divId = b;
            a.ieW = 0;
            var c;
            c = "object" != typeof b && b ? document.getElementById(b) : b;
            this.legend = a;
            a.chart = this;
            c ? (a.div = c, a.position = "outside", a.autoMargins = !1) : a.div = this.legendDiv;
            return a
        },
        removeLegend: function() {
            this.legend = void 0;
            this.legendDiv.innerHTML = ""
        },
        handleResize: function() {
            (d.isPercents(this.width) || d.isPercents(this.height)) && this.invalidateSizeReal();
            this.renderFix()
        },
        renderFix: function() {
            if (!d.VML) {
                var a = this.container;
                a && a.renderFix()
            }
        },
        getSVG: function() {
            if (d.hasSVG) {
                return this.container
            }
        },
        animate: function(a, b, c, e, h, f, g) {
            a["an_" + b] && d.removeFromArray(this.animations, a["an_" + b]);
            c = {
                obj: a,
                frame: 0,
                attribute: b,
                from: c,
                to: e,
                time: h,
                effect: f,
                suffix: g
            };
            a["an_" + b] = c;
            this.animations.push(c);
            return c
        },
        setLegendData: function(a) {
            var b = this.legend;
            b && b.setData(a)
        },
        stopAnim: function(a) {
            d.removeFromArray(this.animations, a)
        },
        updateAnimations: function() {
            var a;
            this.container && this.container.update();
            if (this.animations) {
                for (a = this.animations.length - 1; 0 <= a; a--) {
                    var b = this.animations[a],
                        c = 1E3 * b.time / d.updateRate,
                        e = b.frame + 1,
                        h = b.obj,
                        f = b.attribute;
                    if (e <= c) {
                        b.frame++;
                        var g = Number(b.from),
                            k = Number(b.to) - g,
                            c = d[b.effect](0, e, g, k, c);
                        0 === k ? (this.animations.splice(a, 1), h.node.style[f] = Number(b.to) + b.suffix) : h.node.style[f] = c + b.suffix
                    } else {
                        h.node.style[f] = Number(b.to) + b.suffix, this.animations.splice(a, 1)
                    }
                }
            }
        },
        update: function() {
            this.updateAnimations()
        },
        inIframe: function() {
            try {
                return window.self !== window.top
            } catch (a) {
                return !0
            }
        },
        brr: function() {}
    });
    d.Slice = d.Class({
        construct: function() {}
    });
    d.SerialDataItem = d.Class({
        construct: function() {}
    });
    d.GraphDataItem = d.Class({
        construct: function() {}
    });
    d.Guide = d.Class({
        construct: function(a) {
            this.cname = "Guide";
            d.applyTheme(this, a, this.cname)
        }
    });
    d.Title = d.Class({
        construct: function(a) {
            this.cname = "Title";
            d.applyTheme(this, a, this.cname)
        }
    });
    d.Label = d.Class({
        construct: function(a) {
            this.cname = "Label";
            d.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmGraph = d.Class({
        construct: function(a) {
            this.cname = "AmGraph";
            this.createEvents("rollOverGraphItem", "rollOutGraphItem", "clickGraphItem", "doubleClickGraphItem", "rightClickGraphItem", "clickGraph", "rollOverGraph", "rollOutGraph");
            this.type = "line";
            this.stackable = !0;
            this.columnCount = 1;
            this.columnIndex = 0;
            this.centerCustomBullets = this.showBalloon = !0;
            this.maxBulletSize = 50;
            this.minBulletSize = 4;
            this.balloonText = "[[value]]";
            this.hidden = this.scrollbar = this.animationPlayed = !1;
            this.pointPosition = "middle";
            this.depthCount = 1;
            this.includeInMinMax = !0;
            this.negativeBase = 0;
            this.visibleInLegend = !0;
            this.showAllValueLabels = !1;
            this.showBulletsAt = this.showBalloonAt = "close";
            this.lineThickness = 1;
            this.dashLength = 0;
            this.connect = !0;
            this.lineAlpha = 1;
            this.bullet = "none";
            this.bulletBorderThickness = 2;
            this.bulletBorderAlpha = 0;
            this.bulletAlpha = 1;
            this.bulletSize = 8;
            this.cornerRadiusTop = this.hideBulletsCount = this.bulletOffset = 0;
            this.cursorBulletAlpha = 1;
            this.gradientOrientation = "vertical";
            this.dy = this.dx = 0;
            this.periodValue = "";
            this.clustered = !0;
            this.periodSpan = 1;
            this.y = this.x = 0;
            this.switchable = !0;
            this.tcc = this.minDistance = 1;
            this.labelRotation = 0;
            this.labelAnchor = "auto";
            this.labelOffset = 3;
            this.bcn = "graph-";
            this.dateFormat = "MMM DD, YYYY";
            d.applyTheme(this, a, this.cname)
        },
        draw: function() {
            var a = this.chart,
                b = a.type;
            isNaN(this.precision) || (this.numberFormatter ? this.numberFormatter.precision = this.precision : this.numberFormatter = {
                precision: this.precision,
                decimalSeparator: a.decimalSeparator,
                thousandsSeparator: a.thousandsSeparator
            });
            var c = a.container;
            this.container = c;
            this.destroy();
            var e = c.set(),
                h = c.set();
            this.behindColumns ? (a.graphsBehindSet.push(e), a.bulletBehindSet.push(h)) : (a.graphsSet.push(e), a.bulletSet.push(h));
            var f = this.bulletAxis;
            d.isString(f) && (this.bulletAxis = a.getValueAxisById(f));
            this.bulletSet = h;
            if (!this.scrollbar) {
                var f = a.marginLeftReal,
                    g = a.marginTopReal;
                e.translate(f, g);
                h.translate(f, g)
            }
            c = c.set();
            d.remove(this.columnsSet);
            e.push(c);
            this.set = e;
            d.setCN(a, e, "graph-" + this.type);
            d.setCN(a, e, "graph-" + this.id);
            d.setCN(a, h, "graph-" + this.type);
            d.setCN(a, h, "graph-" + this.id);
            this.columnsSet = c;
            this.columnsArray = [];
            this.ownColumns = [];
            this.allBullets = [];
            this.animationArray = [];
            e = this.labelPosition;
            e || (h = this.valueAxis.stackType, e = "top", "column" == this.type && (a.rotate && (e = "right"), "100%" == h || "regular" == h) && (e = "middle"), this.labelPosition = e);
            d.ifArray(this.data) && (a = !1, "xy" == b ? this.xAxis.axisCreated && this.yAxis.axisCreated && (a = !0) : this.valueAxis.axisCreated && (a = !0), !this.hidden && a && this.createGraph())
        },
        createGraph: function() {
            var a = this,
                b = a.chart;
            a.startAlpha = b.startAlpha;
            a.seqAn = b.sequencedAnimation;
            a.baseCoord = a.valueAxis.baseCoord;
            void 0 === a.fillAlphas && (a.fillAlphas = 0);
            a.bulletColorR = a.bulletColor;
            void 0 === a.bulletColorR && (a.bulletColorR = a.lineColorR, a.bulletColorNegative = a.negativeLineColor);
            void 0 === a.bulletAlpha && (a.bulletAlpha = a.lineAlpha);
            b = b.type;
            "gantt" == b && (b = "serial");
            clearTimeout(a.playedTO);
            if (!isNaN(a.valueAxis.min) && !isNaN(a.valueAxis.max)) {
                switch (b) {
                    case "serial":
                        a.categoryAxis && (a.createSerialGraph(), "candlestick" == a.type && 1 > a.valueAxis.minMaxMultiplier && a.positiveClip(a.set));
                        break;
                    case "radar":
                        a.createRadarGraph();
                        break;
                    case "xy":
                        a.createXYGraph(), a.positiveClip(a.set)
                }
                a.playedTO = setTimeout(function() {
                    a.setAnimationPlayed.call(a)
                }, 500 * a.chart.startDuration)
            }
        },
        setAnimationPlayed: function() {
            this.animationPlayed = !0
        },
        createXYGraph: function() {
            var a = [],
                b = [],
                c = this.xAxis,
                e = this.yAxis;
            this.pmh = e.viH + 1;
            this.pmw = c.viW + 1;
            this.pmy = this.pmx = 0;
            var d;
            for (d = this.start; d <= this.end; d++) {
                var f = this.data[d].axes[c.id].graphs[this.id],
                    g = f.values,
                    k = g.x,
                    l = g.y,
                    g = c.getCoordinate(k),
                    m = e.getCoordinate(l);
                !isNaN(k) && !isNaN(l) && (a.push(g), b.push(m), f.x = g, f.y = m, k = this.createBullet(f, g, m, d), l = this.labelText) && (f = this.createLabel(f, g, m, l), this.positionLabel(g, m, f, k), this.allBullets.push(f))
            }
            this.drawLineGraph(a, b);
            this.launchAnimation()
        },
        createRadarGraph: function() {
            var a = this.valueAxis.stackType,
                b = [],
                c = [],
                e = [],
                d = [],
                f, g, k, l, m;
            for (m = this.start; m <= this.end; m++) {
                var n = this.data[m].axes[this.valueAxis.id].graphs[this.id],
                    p, q;
                "none" == a || "3d" == a ? p = n.values.value : (p = n.values.close, q = n.values.open);
                if (isNaN(p)) {
                    this.connect || (this.drawLineGraph(b, c, e, d), b = [], c = [], e = [], d = []);
                } else {
                    var r = this.y - (this.valueAxis.getCoordinate(p) - this.height),
                        r = r * this.valueAxis.rMultiplier,
                        u = 180 - 360 / (this.end - this.start + 1) * m;
                    "middle" == this.valueAxis.pointPosition && (u -= 180 / (this.end - this.start + 1));
                    p = r * Math.sin(u / 180 * Math.PI);
                    r *= Math.cos(u / 180 * Math.PI);
                    b.push(p);
                    c.push(r);
                    if (!isNaN(q)) {
                        var t = this.y - (this.valueAxis.getCoordinate(q) - this.height),
                            t = t * this.valueAxis.rMultiplier,
                            z = t * Math.sin(u / 180 * Math.PI),
                            u = t * Math.cos(u / 180 * Math.PI);
                        e.push(z);
                        d.push(u);
                        isNaN(k) && (k = z);
                        isNaN(l) && (l = u)
                    }
                    u = this.createBullet(n, p, r, m);
                    n.x = p;
                    n.y = r;
                    if (z = this.labelText) {
                        n = this.createLabel(n, p, r, z), this.positionLabel(p, r, n, u), this.allBullets.push(n);
                    }
                    isNaN(f) && (f = p);
                    isNaN(g) && (g = r)
                }
            }
            b.push(f);
            c.push(g);
            isNaN(k) || (e.push(k), d.push(l));
            this.drawLineGraph(b, c, e, d);
            this.launchAnimation()
        },
        positionLabel: function(a, b, c, e) {
            var d = "middle",
                f = !1,
                g = this.labelPosition,
                k = c.getBBox();
            if (e) {
                var l = e.graphDataItem,
                    m = this.chart.rotate,
                    n = l.isNegative,
                    p = this.chart,
                    q = this.valueAxis;
                b -= k.height / 4 / 2;
                switch (g) {
                    case "top":
                        g = m ? "top" : n ? "bottom" : "top";
                        break;
                    case "right":
                        g = m ? n ? "left" : "right" : "right";
                        break;
                    case "bottom":
                        g = m ? "bottom" : n ? "top" : "bottom";
                        break;
                    case "left":
                        g = m ? n ? "right" : "left" : "left"
                }
                var r = l.columnGraphics,
                    u = 0,
                    t = 0;
                r && (u = r.x, t = r.y);
                var z = this.labelOffset;
                switch (g) {
                    case "top":
                        b = q.reversed ? b + (e.size / 2 + k.height / 2 + z) : b - (e.size / 2 + k.height / 2 + z);
                        break;
                    case "right":
                        d = "start";
                        a += e.size / 2 + z;
                        break;
                    case "bottom":
                        b = q.reversed ? b - (e.size / 2 + k.height / 2 + z) : b + (e.size / 2 + k.height / 2 + z);
                        break;
                    case "left":
                        d = "end";
                        a -= e.size / 2 + z;
                        break;
                    case "inside":
                        "column" == this.type && (f = !0, m ? n ? (d = "end", a = u - 3 - z) : (d = "start", a = u + 3 + z) : b = n ? t + 7 + z : t - 10 - z);
                        break;
                    case "middle":
                        "column" == this.type && (f = !0, m ? a -= (a - u) / 2 + z - 3 : b -= (b - t) / 2 + z - 3)
                }
                "auto" != this.labelAnchor && (d = this.labelAnchor);
                c.attr({
                    "text-anchor": d
                });
                this.labelRotation && c.rotate(this.labelRotation);
                c.translate(a, b);
                k = c.getBBox();
                !this.showAllValueLabels && r && f && (k.height > l.columnHeight || k.width > l.columnWidth) && (c.remove(), c = !1);
                if (c && ("serial" == p.type || "gantt" == p.type)) {
                    if (m) {
                        if (0 > b || b > this.height) {
                            c.remove(), c = !1
                        }
                    } else if (0 > a || a > this.width) {
                        c.remove(), c = !1;
                    }
                }
                return c
            }
        },
        getGradRotation: function() {
            var a = 270;
            "horizontal" == this.gradientOrientation && (a = 0);
            return this.gradientRotation = a
        },
        createSerialGraph: function() {
            this.dashLengthSwitched = this.fillColorsSwitched = this.lineColorSwitched = void 0;
            var a = this.chart,
                b = this.id,
                c = this.index,
                e = this.data,
                h = this.chart.container,
                f = this.valueAxis,
                g = this.type,
                k = this.columnWidthReal,
                l = this.showBulletsAt;
            isNaN(this.columnWidth) || (k = this.columnWidth);
            isNaN(k) && (k = .8);
            var m = this.useNegativeColorIfDown,
                n = this.width,
                p = this.height,
                q = this.y,
                r = this.rotate,
                u = this.columnCount,
                t = d.toCoordinate(this.cornerRadiusTop, k / 2),
                z = this.connect,
                y = [],
                v = [],
                w, A, B, C, D = this.chart.graphs.length,
                J, E = this.dx / this.tcc,
                O = this.dy / this.tcc,
                I = f.stackType,
                W = this.start,
                ea = this.end,
                P = this.scrollbar,
                oa = "graph-column-";
            P && (oa = "scrollbar-graph-column-");
            var qa = this.categoryAxis,
                ka = this.baseCoord,
                Ra = this.negativeBase,
                ca = this.columnIndex,
                aa = this.lineThickness,
                V = this.lineAlpha,
                sa = this.lineColorR,
                ba = this.dashLength,
                da = this.set,
                ta, fa = this.getGradRotation(),
                R = this.chart.columnSpacing,
                X = qa.cellWidth,
                wa = (X * k - u) / u;
            R > wa && (R = wa);
            var H, x, la, ga = p + 1,
                Ja = n + 1,
                Z = 0,
                qb = 0,
                rb, sb, eb, fb, tb = this.fillColorsR,
                Ka = this.negativeFillColors,
                Da = this.negativeLineColor,
                Wa = this.fillAlphas,
                Xa = this.negativeFillAlphas;
            "object" == typeof Wa && (Wa = Wa[0]);
            "object" == typeof Xa && (Xa = Xa[0]);
            var gb = f.getCoordinate(f.min);
            f.logarithmic && (gb = f.getCoordinate(f.minReal));
            this.minCoord = gb;
            this.resetBullet && (this.bullet = "none");
            if (!(P || "line" != g && "smoothedLine" != g && "step" != g || (1 == e.length && "step" != g && "none" == this.bullet && (this.bullet = "round", this.resetBullet = !0), !Ka && void 0 == Da || m))) {
                var Sa = Ra;
                Sa > f.max && (Sa = f.max);
                Sa < f.min && (Sa = f.min);
                f.logarithmic && (Sa = f.minReal);
                var Ga = f.getCoordinate(Sa),
                    Ib = f.getCoordinate(f.max);
                r ? (ga = p, Ja = Math.abs(Ib - Ga) + 1, rb = p, sb = Math.abs(gb - Ga) + 1, fb = qb = 0, f.reversed ? (Z = 0, eb = Ga) : (Z = Ga, eb = 0)) : (Ja = n, ga = Math.abs(Ib - Ga) + 1, sb = n, rb = Math.abs(gb - Ga) + 1, eb = Z = 0, f.reversed ? (fb = q, qb = Ga) : fb = Ga + 1)
            }
            var Ha = Math.round;
            this.pmx = Ha(Z);
            this.pmy = Ha(qb);
            this.pmh = Ha(ga);
            this.pmw = Ha(Ja);
            this.nmx = Ha(eb);
            this.nmy = Ha(fb);
            this.nmh = Ha(rb);
            this.nmw = Ha(sb);
            d.isModern || (this.nmy = this.nmx = 0, this.nmh = this.height);
            this.clustered || (u = 1);
            k = "column" == g ? (X * k - R * (u - 1)) / u : X * k;
            1 > k && (k = 1);
            var Jb = this.fixedColumnWidth;
            isNaN(Jb) || (k = Jb);
            var K;
            if ("line" == g || "step" == g || "smoothedLine" == g) {
                if (0 < W) {
                    for (K = W - 1; - 1 < K; K--) {
                        if (H = e[K], x = H.axes[f.id].graphs[b], la = x.values.value, !isNaN(la)) {
                            W = K;
                            break
                        }
                    }
                    if (this.lineColorField) {
                        for (K = W; - 1 < K; K--) {
                            if (H = e[K], x = H.axes[f.id].graphs[b], x.lineColor) {
                                this.bulletColorSwitched = this.lineColorSwitched = x.lineColor;
                                break
                            }
                        }
                    }
                    if (this.fillColorsField) {
                        for (K = W; - 1 < K; K--) {
                            if (H = e[K], x = H.axes[f.id].graphs[b], x.fillColors) {
                                this.fillColorsSwitched = x.fillColors;
                                break
                            }
                        }
                    }
                    if (this.dashLengthField) {
                        for (K = W; - 1 < K; K--) {
                            if (H = e[K], x = H.axes[f.id].graphs[b], !isNaN(x.dashLength)) {
                                this.dashLengthSwitched = x.dashLength;
                                break
                            }
                        }
                    }
                }
                if (ea < e.length - 1) {
                    for (K = ea + 1; K < e.length; K++) {
                        if (H = e[K], x = H.axes[f.id].graphs[b], la = x.values.value, !isNaN(la)) {
                            ea = K;
                            break
                        }
                    }
                }
            }
            ea < e.length - 1 && ea++;
            var S = [],
                T = [],
                La = !1;
            if ("line" == g || "step" == g || "smoothedLine" == g) {
                if (this.stackable && "regular" == I || "100%" == I || this.fillToGraph) {
                    La = !0;
                }
            }
            var Kb = this.noStepRisers,
                hb = -1E3,
                ib = -1E3,
                jb = this.minDistance,
                Ma = !0,
                Ya = !1;
            for (K = W; K <= ea; K++) {
                H = e[K];
                x = H.axes[f.id].graphs[b];
                x.index = K;
                var Za, Na = NaN;
                if (m && void 0 == this.openField) {
                    for (var ub = K + 1; ub < e.length && (!e[ub] || !(Za = e[K + 1].axes[f.id].graphs[b]) || !Za.values || (Na = Za.values.value, isNaN(Na))); ub++) {;
                    }
                }
                var U, Q, M, ha, ma = NaN,
                    G = NaN,
                    F = NaN,
                    N = NaN,
                    L = NaN,
                    Oa = NaN,
                    Ea = NaN,
                    Pa = NaN,
                    Fa = NaN,
                    ya = NaN,
                    za = NaN,
                    ia = NaN,
                    ja = NaN,
                    Y = NaN,
                    vb = NaN,
                    wb = NaN,
                    na = NaN,
                    pa = void 0,
                    Ia = tb,
                    Ta = Wa,
                    Ba = sa,
                    ua, xa, xb = this.proCandlesticks,
                    kb = this.topRadius,
                    $a = this.pattern;
                void 0 != x.pattern && ($a = x.pattern);
                isNaN(x.alpha) || (Ta = x.alpha);
                isNaN(x.dashLength) || (ba = x.dashLength);
                var Ca = x.values;
                f.recalculateToPercents && (Ca = x.percents);
                if (Ca) {
                    Y = this.stackable && "none" != I && "3d" != I ? Ca.close : Ca.value;
                    if ("candlestick" == g || "ohlc" == g) {
                        Y = Ca.close, wb = Ca.low, Ea = f.getCoordinate(wb), vb = Ca.high, Fa = f.getCoordinate(vb);
                    }
                    na = Ca.open;
                    F = f.getCoordinate(Y);
                    isNaN(na) || (L = f.getCoordinate(na), m && (Na = na, na = L = NaN));
                    m && (void 0 == this.openField ? Za && (Za.isNegative = Na < Y ? !0 : !1, isNaN(Na) && (x.isNegative = !Ma)) : x.isNegative = Na > Y ? !0 : !1);
                    if (!P) {
                        switch (this.showBalloonAt) {
                            case "close":
                                x.y = F;
                                break;
                            case "open":
                                x.y = L;
                                break;
                            case "high":
                                x.y = Fa;
                                break;
                            case "low":
                                x.y = Ea
                        }
                    }
                    var ma = H.x[qa.id],
                        Ua = this.periodSpan - 1,
                        ra = Math.floor(X / 2) + Math.floor(Ua * X / 2),
                        Aa = ra,
                        lb = 0;
                    "left" == this.stepDirection && (lb = (2 * X + Ua * X) / 2, ma -= lb);
                    "center" == this.stepDirection && (lb = X / 2, ma -= lb);
                    "start" == this.pointPosition && (ma -= X / 2 + Math.floor(Ua * X / 2), ra = 0, Aa = Math.floor(X) + Math.floor(Ua * X));
                    "end" == this.pointPosition && (ma += X / 2 + Math.floor(Ua * X / 2), ra = Math.floor(X) + Math.floor(Ua * X), Aa = 0);
                    if (Kb) {
                        var yb = this.columnWidth;
                        isNaN(yb) || (ra *= yb, Aa *= yb)
                    }
                    P || (x.x = ma); - 1E5 > ma && (ma = -1E5);
                    ma > n + 1E5 && (ma = n + 1E5);
                    r ? (G = F, N = L, L = F = ma, isNaN(na) && !this.fillToGraph && (N = ka), Oa = Ea, Pa = Fa) : (N = G = ma, isNaN(na) && !this.fillToGraph && (L = ka));
                    if (!xb && Y < na || xb && Y < ta) {
                        x.isNegative = !0, Ka && (Ia = Ka), Xa && (Ta = Xa), void 0 != Da && (Ba = Da);
                    }
                    Ya = !1;
                    isNaN(Y) || (m ? Y > Na ? (Ma && (Ya = !0), Ma = !1) : (Ma || (Ya = !0), Ma = !0) : x.isNegative = Y < Ra ? !0 : !1, ta = Y);
                    var Lb = !1;
                    P && a.chartScrollbar.ignoreCustomColors && (Lb = !0);
                    Lb || (void 0 != x.color && (Ia = x.color), x.fillColors && (Ia = x.fillColors));
                    switch (g) {
                        case "line":
                            if (isNaN(Y)) {
                                z || (this.drawLineGraph(y, v, S, T), y = [], v = [], S = [], T = []);
                            } else {
                                if (Math.abs(G - hb) >= jb || Math.abs(F - ib) >= jb) {
                                    y.push(G), v.push(F), hb = G, ib = F;
                                }
                                ya = G;
                                za = F;
                                ia = G;
                                ja = F;
                                !La || isNaN(L) || isNaN(N) || (S.push(N), T.push(L));
                                if (Ya || void 0 != x.lineColor || void 0 != x.fillColors || !isNaN(x.dashLength)) {
                                    this.drawLineGraph(y, v, S, T), y = [G], v = [F], S = [], T = [], !La || isNaN(L) || isNaN(N) || (S.push(N), T.push(L)), m ? Ma ? (this.lineColorSwitched = sa, this.fillColorsSwitched = tb) : (this.lineColorSwitched = Da, this.fillColorsSwitched = Ka) : (this.lineColorSwitched = x.lineColor, this.fillColorsSwitched = x.fillColors), this.dashLengthSwitched = x.dashLength;
                                }
                                x.gap && (this.drawLineGraph(y, v, S, T), y = [], v = [], S = [], T = [])
                            }
                            break;
                        case "smoothedLine":
                            if (isNaN(Y)) {
                                z || (this.drawSmoothedGraph(y, v, S, T), y = [], v = [], S = [], T = []);
                            } else {
                                if (Math.abs(G - hb) >= jb || Math.abs(F - ib) >= jb) {
                                    y.push(G), v.push(F), hb = G, ib = F;
                                }
                                ya = G;
                                za = F;
                                ia = G;
                                ja = F;
                                !La || isNaN(L) || isNaN(N) || (S.push(N), T.push(L));
                                void 0 == x.lineColor && void 0 == x.fillColors && isNaN(x.dashLength) || (this.drawSmoothedGraph(y, v, S, T), y = [G], v = [F], S = [], T = [], !La || isNaN(L) || isNaN(N) || (S.push(N), T.push(L)), this.lineColorSwitched = x.lineColor, this.fillColorsSwitched = x.fillColors, this.dashLengthSwitched = x.dashLength);
                                x.gap && (this.drawSmoothedGraph(y, v, S, T), y = [], v = [], S = [], T = [])
                            }
                            break;
                        case "step":
                            if (!isNaN(Y)) {
                                r ? (isNaN(w) || (y.push(w), v.push(F - ra)), v.push(F - ra), y.push(G), v.push(F + Aa), y.push(G), !La || isNaN(L) || isNaN(N) || (isNaN(B) || (S.push(B), T.push(L - ra)), S.push(N), T.push(L - ra), S.push(N), T.push(L + Aa))) : (isNaN(A) || (v.push(A), y.push(G - ra)), y.push(G - ra), v.push(F), y.push(G + Aa), v.push(F), !La || isNaN(L) || isNaN(N) || (isNaN(C) || (S.push(N - ra), T.push(C)), S.push(N - ra), T.push(L), S.push(N + Aa), T.push(L)));
                                w = G;
                                A = F;
                                B = N;
                                C = L;
                                ya = G;
                                za = F;
                                ia = G;
                                ja = F;
                                if (Ya || void 0 != x.lineColor || void 0 != x.fillColors || !isNaN(x.dashLength)) {
                                    var Zb = y[y.length - 2],
                                        $b = v[v.length - 2];
                                    y.pop();
                                    v.pop();
                                    this.drawLineGraph(y, v, S, T);
                                    y = [Zb];
                                    v = [$b];
                                    r ? (v.push(F + Aa), y.push(G)) : (y.push(G + Aa), v.push(F));
                                    S = [];
                                    T = [];
                                    this.lineColorSwitched = x.lineColor;
                                    this.fillColorsSwitched = x.fillColors;
                                    this.dashLengthSwitched = x.dashLength;
                                    m && (Ma ? (this.lineColorSwitched = sa, this.fillColorsSwitched = tb) : (this.lineColorSwitched = Da, this.fillColorsSwitched = Ka))
                                }
                                if (Kb || x.gap) {
                                    w = A = NaN, this.drawLineGraph(y, v, S, T), y = [], v = [], S = [], T = []
                                }
                            } else if (!z) {
                                if (1 >= this.periodSpan || 1 < this.periodSpan && G - w > ra + Aa) {
                                    w = A = NaN;
                                }
                                this.drawLineGraph(y, v, S, T);
                                y = [];
                                v = [];
                                S = [];
                                T = []
                            }
                            break;
                        case "column":
                            ua = Ba;
                            void 0 != x.lineColor && (ua = x.lineColor);
                            if (!isNaN(Y)) {
                                m || (x.isNegative = Y < Ra ? !0 : !1);
                                x.isNegative && (Ka && (Ia = Ka), void 0 != Da && (ua = Da));
                                var Mb = f.min,
                                    Nb = f.max;
                                if (!(Y < Mb && na < Mb || Y > Nb && na > Nb)) {
                                    var va;
                                    if (r) {
                                        "3d" == I ? (Q = F - (u / 2 - this.depthCount + 1) * (k + R) + R / 2 + O * ca, U = N + E * ca, va = ca) : (Q = Math.floor(F - (u / 2 - ca) * (k + R) + R / 2), U = N, va = 0);
                                        M = k;
                                        ya = G;
                                        za = Q + k / 2;
                                        isNaN(N) || N > G && !x.isNegative && (ya = N);
                                        ia = G;
                                        ja = Q + k / 2;
                                        Q + M > p + va * O && (M = p - Q + va * O);
                                        Q < va * O && (M += Q, Q = va * O);
                                        ha = G - N;
                                        var ac = U;
                                        U = d.fitToBounds(U, 0, n);
                                        ha += ac - U;
                                        ha = d.fitToBounds(ha, -U, n - U + E * ca);
                                        Q < p && 0 < M && (pa = new d.Cuboid(h, ha, M, E - a.d3x, O - a.d3y, Ia, Ta, aa, ua, V, fa, t, r, ba, $a, kb, oa), x.columnWidth = Math.abs(ha), x.columnHeight = Math.abs(M))
                                    } else {
                                        "3d" == I ? (U = G - (u / 2 - this.depthCount + 1) * (k + R) + R / 2 + E * ca, Q = L + O * ca, va = ca) : (U = G - (u / 2 - ca) * (k + R) + R / 2, Q = L, va = 0);
                                        M = k;
                                        ya = U + k / 2;
                                        za = F;
                                        isNaN(L) || L < F && !x.isNegative && !f.reversed && (za = L);
                                        ia = U + k / 2;
                                        ja = F;
                                        U + M > n + va * E && (M = n - U + va * E);
                                        U < va * E && (M += U - va * E, U = va * E);
                                        ha = F - L;
                                        var bc = Q;
                                        Q = d.fitToBounds(Q, this.dy, p);
                                        ha += bc - Q;
                                        ha = d.fitToBounds(ha, -Q + O * ca, p - Q);
                                        U < n + ca * E && 0 < M && (this.showOnAxis && (Q -= O / 2), pa = new d.Cuboid(h, M, ha, E - a.d3x, O - a.d3y, Ia, Ta, aa, ua, this.lineAlpha, fa, t, r, ba, $a, kb, oa), x.columnHeight = Math.abs(ha), x.columnWidth = Math.abs(M))
                                    }
                                }
                                if (pa && (xa = pa.set, d.setCN(a, pa.set, "graph-" + this.type), d.setCN(a, pa.set, "graph-" + this.id), x.className && d.setCN(a, pa.set, x.className, !0), x.columnGraphics = xa, xa.translate(U, Q), this.columnsSet.push(xa), (x.url || this.showHandOnHover) && xa.setAttr("cursor", "pointer"), !P)) {
                                    "none" == I && (J = r ? (this.end + 1 - K) * D - c : D * K + c);
                                    "3d" == I && (r ? (J = (this.end + 1 - K) * D - c - 1E3 * this.depthCount, ya += E * this.columnIndex, ia += E * this.columnIndex, x.y += E * this.columnIndex) : (J = (D - c) * (K + 1) + 1E3 * this.depthCount, za += O * this.columnIndex, ja += O * this.columnIndex, x.y += O * this.columnIndex));
                                    if ("regular" == I || "100%" == I) {
                                        J = r ? 0 < Ca.value ? (this.end + 1 - K) * D + c : (this.end + 1 - K) * D - c : 0 < Ca.value ? D * K + c : D * K - c;
                                    }
                                    this.columnsArray.push({
                                        column: pa,
                                        depth: J
                                    });
                                    x.x = r ? Q + M / 2 : U + M / 2;
                                    this.ownColumns.push(pa);
                                    this.animateColumns(pa, K, G, N, F, L);
                                    this.addListeners(xa, x)
                                }
                            }
                            break;
                        case "candlestick":
                            if (!isNaN(na) && !isNaN(Y)) {
                                var Va, ab;
                                ua = Ba;
                                void 0 != x.lineColor && (ua = x.lineColor);
                                if (r) {
                                    if (Q = F - k / 2, U = N, M = k, Q + M > p && (M = p - Q), 0 > Q && (M += Q, Q = 0), Q < p && 0 < M) {
                                        var zb, Ab;
                                        Y > na ? (zb = [G, Pa], Ab = [N, Oa]) : (zb = [N, Pa], Ab = [G, Oa]);
                                        !isNaN(Pa) && !isNaN(Oa) && F < p && 0 < F && (Va = d.line(h, zb, [F, F], ua, V, aa), ab = d.line(h, Ab, [F, F], ua, V, aa));
                                        ha = G - N;
                                        pa = new d.Cuboid(h, ha, M, E, O, Ia, Wa, aa, ua, V, fa, t, r, ba, $a, kb, oa)
                                    }
                                } else if (U = G - k / 2, Q = L + aa / 2, M = k, U + M > n && (M = n - U), 0 > U && (M += U, U = 0), ha = F - L, U < n && 0 < M) {
                                    xb && Y >= na && (Ta = 0);
                                    var pa = new d.Cuboid(h, M, ha, E, O, Ia, Ta, aa, ua, V, fa, t, r, ba, $a, kb, oa),
                                        Bb, Cb;
                                    Y > na ? (Bb = [F, Fa], Cb = [L, Ea]) : (Bb = [L, Fa], Cb = [F, Ea]);
                                    !isNaN(Fa) && !isNaN(Ea) && G < n && 0 < G && (Va = d.line(h, [G, G], Bb, ua, V, aa), ab = d.line(h, [G, G], Cb, ua, V, aa), d.setCN(a, Va, this.bcn + "line-high"), x.className && d.setCN(a, Va, x.className, !0), d.setCN(a, ab, this.bcn + "line-low"), x.className && d.setCN(a, ab, x.className, !0))
                                }
                                pa && (xa = pa.set, x.columnGraphics = xa, da.push(xa), xa.translate(U, Q - aa / 2), (x.url || this.showHandOnHover) && xa.setAttr("cursor", "pointer"), Va && (da.push(Va), da.push(ab)), ya = G, za = F, r ? (ja = F, ia = G, "open" == l && (ia = N), "high" == l && (ia = Pa), "low" == l && (ia = Oa)) : (ja = F, "open" == l && (ja = L), "high" == l && (ja = Fa), "low" == l && (ja = Ea), ia = G), P || (x.x = r ? Q + M / 2 : U + M / 2, this.animateColumns(pa, K, G, N, F, L), this.addListeners(xa, x)))
                            }
                            break;
                        case "ohlc":
                            if (!(isNaN(na) || isNaN(vb) || isNaN(wb) || isNaN(Y))) {
                                var Ob = h.set();
                                da.push(Ob);
                                Y < na && (x.isNegative = !0, void 0 != Da && (Ba = Da));
                                var mb, nb, ob;
                                if (r) {
                                    var Db = F - k / 2,
                                        Db = d.fitToBounds(Db, 0, p),
                                        Pb = d.fitToBounds(F, 0, p),
                                        Eb = F + k / 2,
                                        Eb = d.fitToBounds(Eb, 0, p);
                                    nb = d.line(h, [N, N], [Db, Pb], Ba, V, aa, ba);
                                    0 < F && F < p && (mb = d.line(h, [Oa, Pa], [F, F], Ba, V, aa, ba));
                                    ob = d.line(h, [G, G], [Pb, Eb], Ba, V, aa, ba);
                                    ja = F;
                                    ia = G;
                                    "open" == l && (ia = N);
                                    "high" == l && (ia = Pa);
                                    "low" == l && (ia = Oa)
                                } else {
                                    var Fb = G - k / 2,
                                        Fb = d.fitToBounds(Fb, 0, n),
                                        Qb = d.fitToBounds(G, 0, n),
                                        Gb = G + k / 2,
                                        Gb = d.fitToBounds(Gb, 0, n);
                                    nb = d.line(h, [Fb, Qb], [L, L], Ba, V, aa, ba);
                                    0 < G && G < n && (mb = d.line(h, [G, G], [Ea, Fa], Ba, V, aa, ba));
                                    ob = d.line(h, [Qb, Gb], [F, F], Ba, V, aa, ba);
                                    ja = F;
                                    "open" == l && (ja = L);
                                    "high" == l && (ja = Fa);
                                    "low" == l && (ja = Ea);
                                    ia = G
                                }
                                da.push(nb);
                                da.push(mb);
                                da.push(ob);
                                d.setCN(a, nb, this.bcn + "stroke-open");
                                d.setCN(a, ob, this.bcn + "stroke-close");
                                d.setCN(a, mb, this.bcn + "stroke");
                                x.className && d.setCN(a, Ob, x.className, !0);
                                ya = G;
                                za = F
                            }
                    }
                    if (!P && !isNaN(Y)) {
                        var Rb = this.hideBulletsCount;
                        if (this.end - this.start <= Rb || 0 === Rb) {
                            var Sb = this.createBullet(x, ia, ja, K),
                                Tb = this.labelText;
                            if (Tb && Sb) {
                                var Hb = this.createLabel(x, ia, ja, Tb);
                                (Hb = this.positionLabel(ya, za, Hb, Sb, M, ha)) && this.allBullets.push(Hb)
                            }
                            if ("regular" == I || "100%" == I) {
                                var Ub = f.totalText;
                                if (Ub) {
                                    var Qa = this.createLabel(x, 0, 0, Ub, f.totalTextColor);
                                    d.setCN(a, Qa, this.bcn + "label-total");
                                    this.allBullets.push(Qa);
                                    var Vb = Qa.getBBox(),
                                        Wb = Vb.width,
                                        Xb = Vb.height,
                                        bb, cb, pb = f.totalTextOffset,
                                        Yb = f.totals[K];
                                    Yb && Yb.remove();
                                    var db = 0;
                                    "column" != g && (db = this.bulletSize);
                                    r ? (cb = F, bb = 0 > Y ? G - Wb / 2 - 2 - db - pb : G + Wb / 2 + 3 + db + pb) : (bb = G, cb = 0 > Y ? F + Xb / 2 + db + pb : F - Xb / 2 - 3 - db - pb);
                                    Qa.translate(bb, cb);
                                    f.totals[K] = Qa;
                                    r ? (0 > cb || cb > p) && Qa.remove() : (0 > bb || bb > n) && Qa.remove()
                                }
                            }
                        }
                    }
                }
            }
            if ("line" == g || "step" == g || "smoothedLine" == g) {
                "smoothedLine" == g ? this.drawSmoothedGraph(y, v, S, T) : this.drawLineGraph(y, v, S, T), P || this.launchAnimation();
            }
            this.bulletsHidden && this.hideBullets();
            this.customBulletsHidden && this.hideCustomBullets()
        },
        animateColumns: function(a, b) {
            var c = this,
                e = c.chart.startDuration;
            0 < e && !c.animationPlayed && (c.seqAn ? (a.set.hide(), c.animationArray.push(a), e = setTimeout(function() {
                c.animate.call(c)
            }, e / (c.end - c.start + 1) * (b - c.start) * 1E3), c.timeOuts.push(e)) : c.animate(a))
        },
        createLabel: function(a, b, c, e, h) {
            var f = this.chart,
                g = a.labelColor;
            g || (g = this.color);
            g || (g = f.color);
            h && (g = h);
            h = this.fontSize;
            void 0 === h && (this.fontSize = h = f.fontSize);
            var k = this.labelFunction;
            e = f.formatString(e, a);
            e = d.cleanFromEmpty(e);
            k && (e = k(a, e));
            a = d.text(this.container, e, g, f.fontFamily, h);
            a.node.style.pointerEvents = "none";
            d.setCN(f, a, this.bcn + "label");
            a.translate(b, c);
            this.bulletSet.push(a);
            return a
        },
        positiveClip: function(a) {
            a.clipRect(this.pmx, this.pmy, this.pmw, this.pmh)
        },
        negativeClip: function(a) {
            a.clipRect(this.nmx, this.nmy, this.nmw, this.nmh)
        },
        drawLineGraph: function(a, b, c, e) {
            var h = this;
            if (1 < a.length) {
                var f = h.set,
                    g = h.chart,
                    k = h.container,
                    l = k.set(),
                    m = k.set();
                f.push(m);
                f.push(l);
                var n = h.lineAlpha,
                    p = h.lineThickness,
                    f = h.fillAlphas,
                    q = h.lineColorR,
                    r = h.negativeLineAlpha;
                isNaN(r) && (r = n);
                var u = h.lineColorSwitched;
                u && (q = u);
                var u = h.fillColorsR,
                    t = h.fillColorsSwitched;
                t && (u = t);
                var z = h.dashLength;
                (t = h.dashLengthSwitched) && (z = t);
                var t = h.negativeLineColor,
                    y = h.negativeFillColors,
                    v = h.negativeFillAlphas,
                    w = h.baseCoord;
                0 !== h.negativeBase && (w = h.valueAxis.getCoordinate(h.negativeBase), w > h.height && (w = h.height), 0 > w && (w = 0));
                n = d.line(k, a, b, q, n, p, z, !1, !0);
                d.setCN(g, n, h.bcn + "stroke");
                l.push(n);
                l.click(function(a) {
                    h.handleGraphEvent(a, "clickGraph")
                }).mouseover(function(a) {
                    h.handleGraphEvent(a, "rollOverGraph")
                }).mouseout(function(a) {
                    h.handleGraphEvent(a, "rollOutGraph")
                });
                void 0 === t || h.useNegativeColorIfDown || (p = d.line(k, a, b, t, r, p, z, !1, !0), d.setCN(g, p, h.bcn + "stroke"), d.setCN(g, p, h.bcn + "stroke-negative"), m.push(p));
                if (0 < f || 0 < v) {
                    if (p = a.join(";").split(";"), r = b.join(";").split(";"), n = g.type, "serial" == n || "radar" == n ? 0 < c.length ? (c.reverse(), e.reverse(), p = a.concat(c), r = b.concat(e)) : "radar" == n ? (r.push(0), p.push(0)) : h.rotate ? (r.push(r[r.length - 1]), p.push(w), r.push(r[0]), p.push(w), r.push(r[0]), p.push(p[0])) : (p.push(p[p.length - 1]), r.push(w), p.push(p[0]), r.push(w), p.push(a[0]), r.push(r[0])) : "xy" == n && (b = h.fillToAxis) && (d.isString(b) && (b = g.getValueAxisById(b)), "H" == b.orientation ? (w = "top" == b.position ? 0 : b.viH, p.push(p[p.length - 1]), r.push(w), p.push(p[0]), r.push(w), p.push(a[0]), r.push(r[0])) : (w = "left" == b.position ? 0 : b.viW, r.push(r[r.length - 1]), p.push(w), r.push(r[0]), p.push(w), r.push(r[0]), p.push(p[0]))), a = h.gradientRotation, 0 < f && (b = d.polygon(k, p, r, u, f, 1, "#000", 0, a), b.pattern(h.pattern, NaN, g.path), d.setCN(g, b, h.bcn + "fill"), l.push(b)), y || void 0 !== t) {
                        isNaN(v) && (v = f), y || (y = t), k = d.polygon(k, p, r, y, v, 1, "#000", 0, a), d.setCN(g, k, h.bcn + "fill"), d.setCN(g, k, h.bcn + "fill-negative"), k.pattern(h.pattern, NaN, g.path), m.push(k), m.click(function(a) {
                            h.handleGraphEvent(a, "clickGraph")
                        }).mouseover(function(a) {
                            h.handleGraphEvent(a, "rollOverGraph")
                        }).mouseout(function(a) {
                            h.handleGraphEvent(a, "rollOutGraph")
                        });
                    }
                }
                h.applyMask(m, l)
            }
        },
        applyMask: function(a, b) {
            var c = a.length();
            "serial" != this.chart.type || this.scrollbar || (this.positiveClip(b), 0 < c && this.negativeClip(a))
        },
        drawSmoothedGraph: function(a, b, c, e) {
            if (1 < a.length) {
                var h = this.set,
                    f = this.chart,
                    g = this.container,
                    k = g.set(),
                    l = g.set();
                h.push(l);
                h.push(k);
                var m = this.lineAlpha,
                    n = this.lineThickness,
                    h = this.dashLength,
                    p = this.fillAlphas,
                    q = this.lineColorR,
                    r = this.fillColorsR,
                    u = this.negativeLineColor,
                    t = this.negativeFillColors,
                    z = this.negativeFillAlphas,
                    y = this.baseCoord,
                    v = this.lineColorSwitched;
                v && (q = v);
                (v = this.fillColorsSwitched) && (r = v);
                v = this.negativeLineAlpha;
                isNaN(v) && (v = m);
                m = new d.Bezier(g, a, b, q, m, n, r, 0, h);
                d.setCN(f, m, this.bcn + "stroke");
                k.push(m.path);
                void 0 !== u && (n = new d.Bezier(g, a, b, u, v, n, r, 0, h), d.setCN(f, n, this.bcn + "stroke"), d.setCN(f, n, this.bcn + "stroke-negative"), l.push(n.path));
                0 < p && (m = a.join(";").split(";"), q = b.join(";").split(";"), n = "", 0 < c.length ? (c.push("M"), e.push("M"), c.reverse(), e.reverse(), m = a.concat(c), q = b.concat(e)) : (this.rotate ? (n += " L" + y + "," + b[b.length - 1], n += " L" + y + "," + b[0]) : (n += " L" + a[a.length - 1] + "," + y, n += " L" + a[0] + "," + y), n += " L" + a[0] + "," + b[0]), c = new d.Bezier(g, m, q, NaN, 0, 0, r, p, h, n), d.setCN(f, c, this.bcn + "fill"), c.path.pattern(this.pattern, NaN, f.path), k.push(c.path), t || void 0 !== u) && (z || (z = p), t || (t = u), a = new d.Bezier(g, a, b, NaN, 0, 0, t, z, h, n), a.path.pattern(this.pattern, NaN, f.path), d.setCN(f, a, this.bcn + "fill"), d.setCN(f, a, this.bcn + "fill-negative"), l.push(a.path));
                this.applyMask(l, k)
            }
        },
        launchAnimation: function() {
            var a = this,
                b = a.chart.startDuration;
            if (0 < b && !a.animationPlayed) {
                var c = a.set,
                    e = a.bulletSet;
                d.VML || (c.attr({
                    opacity: a.startAlpha
                }), e.attr({
                    opacity: a.startAlpha
                }));
                c.hide();
                e.hide();
                a.seqAn ? (b = setTimeout(function() {
                    a.animateGraphs.call(a)
                }, a.index * b * 1E3), a.timeOuts.push(b)) : a.animateGraphs()
            }
        },
        animateGraphs: function() {
            var a = this.chart,
                b = this.set,
                c = this.bulletSet,
                e = this.x,
                d = this.y;
            b.show();
            c.show();
            var f = a.startDuration,
                a = a.startEffect;
            b && (this.rotate ? (b.translate(-1E3, d), c.translate(-1E3, d)) : (b.translate(e, -1E3), c.translate(e, -1E3)), b.animate({
                opacity: 1,
                translate: e + "," + d
            }, f, a), c.animate({
                opacity: 1,
                translate: e + "," + d
            }, f, a))
        },
        animate: function(a) {
            var b = this.chart,
                c = this.animationArray;
            !a && 0 < c.length && (a = c[0], c.shift());
            c = d[d.getEffect(b.startEffect)];
            b = b.startDuration;
            a && (this.rotate ? a.animateWidth(b, c) : a.animateHeight(b, c), a.set.show())
        },
        legendKeyColor: function() {
            var a = this.legendColor,
                b = this.lineAlpha;
            void 0 === a && (a = this.lineColorR, 0 === b && (b = this.fillColorsR) && (a = "object" == typeof b ? b[0] : b));
            return a
        },
        legendKeyAlpha: function() {
            var a = this.legendAlpha;
            void 0 === a && (a = this.lineAlpha, this.fillAlphas > a && (a = this.fillAlphas), 0 === a && (a = this.bulletAlpha), 0 === a && (a = 1));
            return a
        },
        createBullet: function(a, b, c) {
            if (!isNaN(b) && !isNaN(c)) {
                var e = this.chart,
                    h = this.container,
                    f = this.bulletOffset,
                    g = this.bulletSize;
                isNaN(a.bulletSize) || (g = a.bulletSize);
                var k = a.values.value,
                    l = this.maxValue,
                    m = this.minValue,
                    n = this.maxBulletSize,
                    p = this.minBulletSize;
                isNaN(l) || (isNaN(k) || (g = (k - m) / (l - m) * (n - p) + p), m == l && (g = n));
                l = g;
                this.bulletAxis && (g = a.values.error, isNaN(g) || (k = g), g = this.bulletAxis.stepWidth * k);
                g < this.minBulletSize && (g = this.minBulletSize);
                this.rotate ? b = a.isNegative ? b - f : b + f : c = a.isNegative ? c + f : c - f;
                var q, p = this.bulletColorR;
                a.lineColor && (this.bulletColorSwitched = a.lineColor);
                this.bulletColorSwitched && (p = this.bulletColorSwitched);
                a.isNegative && void 0 !== this.bulletColorNegative && (p = this.bulletColorNegative);
                void 0 !== a.color && (p = a.color);
                var r;
                "xy" == e.type && this.valueField && (r = this.pattern, a.pattern && (r = a.pattern));
                f = this.bullet;
                a.bullet && (f = a.bullet);
                var k = this.bulletBorderThickness,
                    m = this.bulletBorderColorR,
                    n = this.bulletBorderAlpha,
                    u = this.bulletAlpha;
                m || (m = p);
                this.useLineColorForBulletBorder && (m = this.lineColorR, this.lineColorSwitched && (m = this.lineColorSwitched));
                var t = a.alpha;
                isNaN(t) || (u = t);
                if ("none" != this.bullet || a.bullet) {
                    q = d.bullet(h, f, g, p, u, k, m, n, l, 0, r, e.path);
                }
                if (this.customBullet || a.customBullet) {
                    r = this.customBullet, a.customBullet && (r = a.customBullet), r && (q && q.remove(), "function" == typeof r ? (r = new r, r.chart = e, a.bulletConfig && (r.availableSpace = c, r.graph = this, r.graphDataItem = a, r.bulletY = c, a.bulletConfig.minCoord = this.minCoord - c, r.bulletConfig = a.bulletConfig), r.write(h), q && r.showBullet && r.set.push(q), a.customBulletGraphics = r.cset, q = r.set) : (q = h.set(), h = h.image(r, 0, 0, g, g), q.push(h), this.centerCustomBullets && h.translate(-g / 2, -g / 2)));
                }
                if (q) {
                    (a.url || this.showHandOnHover) && q.setAttr("cursor", "pointer");
                    if ("serial" == e.type || "gantt" == e.type) {
                        if (-.5 > b - 0 || b - 0 > this.width || c < -g / 2 || c - 0 > this.height) {
                            q.remove(), q = null;
                        }
                    }
                    q && (this.bulletSet.push(q), q.translate(b, c), this.addListeners(q, a), this.allBullets.push(q));
                    a.bx = b;
                    a.by = c;
                    d.setCN(e, q, this.bcn + "bullet");
                    a.className && d.setCN(e, q, a.className, !0)
                }
                q ? (q.size = g || 0, a.bulletGraphics = q) : q = {
                    size: 0
                };
                q.graphDataItem = a;
                return q
            }
        },
        showBullets: function() {
            var a = this.allBullets,
                b;
            this.bulletsHidden = !1;
            for (b = 0; b < a.length; b++) {
                a[b].show()
            }
        },
        hideBullets: function() {
            var a = this.allBullets,
                b;
            this.bulletsHidden = !0;
            for (b = 0; b < a.length; b++) {
                a[b].hide()
            }
        },
        showCustomBullets: function() {
            var a = this.allBullets,
                b;
            this.customBulletsHidden = !1;
            for (b = 0; b < a.length; b++) {
                var c = a[b].graphDataItem;
                c.customBulletGraphics && c.customBulletGraphics.show()
            }
        },
        hideCustomBullets: function() {
            var a = this.allBullets,
                b;
            this.customBulletsHidden = !0;
            for (b = 0; b < a.length; b++) {
                var c = a[b].graphDataItem;
                c.customBulletGraphics && c.customBulletGraphics.hide()
            }
        },
        addListeners: function(a, b) {
            var c = this;
            a.mouseover(function(a) {
                c.handleRollOver(b, a)
            }).mouseout(function(a) {
                c.handleRollOut(b, a)
            }).touchend(function(a) {
                c.handleRollOver(b, a);
                c.chart.panEventsEnabled && c.handleClick(b, a)
            }).touchstart(function(a) {
                c.handleRollOver(b, a)
            }).click(function(a) {
                c.handleClick(b, a)
            }).dblclick(function(a) {
                c.handleDoubleClick(b, a)
            }).contextmenu(function(a) {
                c.handleRightClick(b, a)
            })
        },
        handleRollOver: function(a, b) {
            if (a) {
                var c = this.chart,
                    e = {
                        type: "rollOverGraphItem",
                        item: a,
                        index: a.index,
                        graph: this,
                        target: this,
                        chart: this.chart,
                        event: b
                    };
                this.fire("rollOverGraphItem", e);
                c.fire("rollOverGraphItem", e);
                clearTimeout(c.hoverInt);
                e = this.showBalloon;
                !c.chartCursor || "serial" != c.type && "gantt" != c.type || (e = !1, !c.chartCursor.valueBalloonsEnabled && this.showBalloon && (e = !0));
                if (e) {
                    var e = c.formatString(this.balloonText, a, !0),
                        h = this.balloonFunction;
                    h && (e = h(a, a.graph));
                    e = d.cleanFromEmpty(e);
                    h = c.getBalloonColor(this, a);
                    c.balloon.showBullet = !1;
                    c.balloon.pointerOrientation = "V";
                    var f = a.x,
                        g = a.y;
                    c.rotate && (f = a.y, g = a.x);
                    "" !== e ? c.showBalloon(e, h, !0, f + c.marginLeftReal, g + c.marginTopReal) : this.chart.hideBalloonReal()
                } else {
                    this.chart.hideBalloonReal()
                }
            }
            this.handleGraphEvent(b, "rollOverGraph")
        },
        handleRollOut: function(a, b) {
            this.chart.hideBalloon();
            if (a) {
                var c = {
                    type: "rollOutGraphItem",
                    item: a,
                    index: a.index,
                    graph: this,
                    target: this,
                    chart: this.chart,
                    event: b
                };
                this.fire("rollOutGraphItem", c);
                this.chart.fire("rollOutGraphItem", c)
            }
            this.handleGraphEvent(b, "rollOutGraph")
        },
        handleClick: function(a, b) {
            if (a) {
                var c = {
                    type: "clickGraphItem",
                    item: a,
                    index: a.index,
                    graph: this,
                    target: this,
                    chart: this.chart,
                    event: b
                };
                this.fire("clickGraphItem", c);
                this.chart.fire("clickGraphItem", c);
                d.getURL(a.url, this.urlTarget)
            }
            this.handleGraphEvent(b, "clickGraph")
        },
        handleGraphEvent: function(a, b) {
            var c = {
                type: b,
                graph: this,
                target: this,
                chart: this.chart,
                event: a
            };
            this.fire(b, c);
            this.chart.fire(b, c)
        },
        handleRightClick: function(a, b) {
            if (a) {
                var c = {
                    type: "rightClickGraphItem",
                    item: a,
                    index: a.index,
                    graph: this,
                    target: this,
                    chart: this.chart,
                    event: b
                };
                this.fire("rightClickGraphItem", c);
                this.chart.fire("rightClickGraphItem", c)
            }
        },
        handleDoubleClick: function(a, b) {
            if (a) {
                var c = {
                    type: "doubleClickGraphItem",
                    item: a,
                    index: a.index,
                    graph: this,
                    target: this,
                    chart: this.chart,
                    event: b
                };
                this.fire("doubleClickGraphItem", c);
                this.chart.fire("doubleClickGraphItem", c)
            }
        },
        zoom: function(a, b) {
            this.start = a;
            this.end = b;
            this.draw()
        },
        changeOpacity: function(a) {
            var b = this.set;
            b && b.setAttr("opacity", a);
            if (b = this.ownColumns) {
                var c;
                for (c = 0; c < b.length; c++) {
                    var e = b[c].set;
                    e && e.setAttr("opacity", a)
                }
            }
            (b = this.bulletSet) && b.setAttr("opacity", a)
        },
        destroy: function() {
            d.remove(this.set);
            d.remove(this.bulletSet);
            var a = this.timeOuts;
            if (a) {
                var b;
                for (b = 0; b < a.length; b++) {
                    clearTimeout(a[b])
                }
            }
            this.timeOuts = []
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.ChartCursor = d.Class({
        construct: function(a) {
            this.cname = "ChartCursor";
            this.createEvents("changed", "zoomed", "onHideCursor", "draw", "selected", "moved");
            this.enabled = !0;
            this.cursorAlpha = 1;
            this.selectionAlpha = .2;
            this.cursorColor = "#CC0000";
            this.categoryBalloonAlpha = 1;
            this.color = "#FFFFFF";
            this.type = "cursor";
            this.zoomed = !1;
            this.zoomable = !0;
            this.pan = !1;
            this.categoryBalloonDateFormat = "MMM DD, YYYY";
            this.categoryBalloonText = "[[category]]";
            this.categoryBalloonEnabled = this.valueBalloonsEnabled = !0;
            this.rolledOver = !1;
            this.cursorPosition = "middle";
            this.bulletsEnabled = this.skipZoomDispatch = !1;
            this.bulletSize = 8;
            this.selectWithoutZooming = this.oneBalloonOnly = !1;
            this.graphBulletSize = 1.7;
            this.animationDuration = .3;
            this.zooming = !1;
            this.adjustment = 0;
            this.avoidBalloonOverlapping = !0;
            this.leaveCursor = !1;
            this.leaveAfterTouch = !0;
            d.applyTheme(this, a, this.cname)
        },
        draw: function() {
            this.destroy();
            var a = this.chart;
            a.panRequired = !0;
            var b = a.container;
            this.rotate = a.rotate;
            this.container = b;
            b = b.set();
            b.translate(this.x, this.y);
            this.set = b;
            a.cursorSet.push(b);
            b = new d.AmBalloon;
            b.className = "category";
            b.chart = a;
            this.categoryBalloon = b;
            d.copyProperties(a.balloon, b);
            b.cornerRadius = 0;
            b.shadowAlpha = 0;
            b.borderThickness = 1;
            b.borderAlpha = 1;
            b.showBullet = !1;
            var c = this.categoryBalloonColor;
            void 0 === c && (c = this.cursorColor);
            b.fillColor = c;
            b.balloonColor = c;
            b.fillAlpha = this.categoryBalloonAlpha;
            b.borderColor = c;
            b.color = this.color;
            c = this.valueLineAxis;
            d.isString(c) && (c = a.getValueAxisById(c));
            c || (c = a.valueAxes[0]);
            this.valueLineAxis = c;
            this.valueLineBalloonEnabled && (this.vaBalloon = c = new d.AmBalloon, d.copyProperties(b, c), c.animationDuration = 0, this.rotate || (c.pointerOrientation = "H"));
            this.rotate && (b.pointerOrientation = "H");
            this.extraWidth = 0;
            this.prevX = [];
            this.prevY = [];
            this.prevTX = [];
            this.prevTY = [];
            if (this.valueBalloonsEnabled) {
                for (b = 0; b < a.graphs.length; b++) {
                    c = new d.AmBalloon, c.className = a.graphs[b].id, c.chart = a, d.copyProperties(a.balloon, c), a.graphs[b].valueBalloon = c;
                }
            }
            "cursor" == this.type ? this.createCursor() : this.createCrosshair()
        },
        updateData: function() {
            var a = this.chart;
            this.data = a.chartData;
            this.firstTime = a.firstTime;
            this.lastTime = a.lastTime
        },
        createCursor: function() {
            var a = this.chart,
                b = this.cursorAlpha,
                c = a.categoryAxis,
                e = this.categoryBalloon,
                h, f, g, k;
            g = a.dx;
            k = a.dy;
            var l = this.width,
                m = this.height,
                n = a.rotate;
            e.pointerWidth = c.tickLength;
            n ? (h = [0, l, l + g], f = [0, 0, k], g = [g, 0, 0], k = [k, 0, m]) : (h = [g, 0, 0], f = [k, 0, m], g = [0, l, l + g], k = [0, 0, k]);
            h = d.line(this.container, h, f, this.cursorColor, b, 1);
            d.setCN(a, h, "cursor-line");
            this.line = h;
            h.node.style.pointerEvents = "none";
            (f = this.fullRectSet) ? (f.push(h), f.translate(this.x, this.y)) : this.set.push(h);
            this.valueLineEnabled && (h = this.valueLineAlpha, isNaN(h) || (b = h), b = d.line(this.container, g, k, this.cursorColor, b, 1), b.node.style.pointerEvents = "none", d.setCN(a, b, "cursor-value-line"), this.vLine = b, this.set.push(b));
            this.setBalloonBounds(e, c, n);
            (a = this.vaBalloon) && this.setBalloonBounds(a, this.valueLineAxis, !n);
            this.hideCursor()
        },
        createCrosshair: function() {
            var a = this.cursorAlpha,
                b = this.container,
                c = d.line(b, [0, 0], [0, this.height], this.cursorColor, a, 1),
                a = d.line(b, [0, this.width], [0, 0], this.cursorColor, a, 1);
            d.setCN(this.chart, c, "cursor-line");
            d.setCN(this.chart, a, "cursor-line");
            this.set.push(c);
            this.set.push(a);
            this.vLine = c;
            this.hLine = a;
            this.hideCursor()
        },
        update: function() {
            var a = this.chart;
            if (a) {
                if (a.mouseIsOver) {
                    var b = a.mouseX - this.x,
                        c = a.mouseY - this.y; - .5 < b && b < this.width + 1 && 0 < c && c < this.height ? ((this.valueLineEnabled || this.valueLineBalloonEnabled) && this.updateVLine(b, c), this.setPosition(), this.drawing ? this.rolledOver || a.setMouseCursor("crosshair") : this.pan && (this.rolledOver || a.setMouseCursor("move")), this.rolledOver = !0) : this.rolledOver && (this.handleMouseOut(), this.rolledOver = !1)
                } else {
                    this.rolledOver && (this.handleMouseOut(), this.rolledOver = !1)
                }
            }
        },
        updateVLine: function(a, b) {
            var c = this.vLine,
                e = this.vaBalloon;
            if ((c || e) && !this.panning && !this.drawing) {
                c && c.show();
                var d = this.valueLineAxis,
                    f, g = this.rotate;
                g ? (c && c.translate(a, 0), d && (f = d.coordinateToValue(a)), c = a) : (c && c.translate(0, b), d && (f = d.coordinateToValue(b)), c = b - 1);
                if (e && !isNaN(f) && this.prevLineValue != f) {
                    var k = d.formatValue(f, !0);
                    this.setBalloonPosition(e, d, c, !g);
                    e.showBalloon(k)
                }
                this.prevLineValue = f
            }
        },
        getMousePosition: function() {
            var a, b = this.width,
                c = this.height;
            a = this.chart;
            this.rotate ? (a = a.mouseY - this.y, 0 > a && (a = 0), a > c && (a = c)) : (a = a.mouseX - this.x - 1, 0 > a && (a = 0), a > b && (a = b));
            return a
        },
        updateCrosshair: function() {
            var a = this.chart,
                b = a.mouseX - this.x,
                c = a.mouseY - this.y,
                e = this.vLine,
                h = this.hLine,
                b = d.fitToBounds(b, 0, this.width),
                c = d.fitToBounds(c, 0, this.height);
            e && 0 < this.cursorAlpha && (e.show(), h.show(), e.translate(b, 0), h.translate(0, c));
            this.zooming && (a.hideXScrollbar && (b = NaN), a.hideYScrollbar && (c = NaN), this.updateSelectionSize(b, c));
            this.fireMoved();
            a.mouseIsOver || this.zooming || this.hideCursor()
        },
        fireMoved: function() {
            var a = this.chart,
                b = {
                    type: "moved",
                    target: this
                };
            b.chart = a;
            b.zooming = this.zooming;
            b.x = a.mouseX - this.x;
            b.y = a.mouseY - this.y;
            this.fire("moved", b)
        },
        updateSelectionSize: function(a, b) {
            d.remove(this.selection);
            var c = this.selectionPosX,
                e = this.selectionPosY,
                h = 0,
                f = 0,
                g = this.width,
                k = this.height;
            isNaN(a) || (c > a && (h = a, g = c - a), c < a && (h = c, g = a - c), c == a && (h = a, g = 0), g += this.extraWidth, h -= this.extraWidth / 2);
            isNaN(b) || (e > b && (f = b, k = e - b), e < b && (f = e, k = b - e), e == b && (f = b, k = 0), k += this.extraWidth, f -= this.extraWidth / 2);
            0 < g && 0 < k && (c = d.rect(this.container, g, k, this.cursorColor, this.selectionAlpha), d.setCN(this.chart, c, "cursor-selection"), c.translate(h + this.x, f + this.y), this.selection = c)
        },
        arrangeBalloons: function() {
            var a = this.valueBalloons,
                b = this.x,
                c = this.y,
                e = this.height + c;
            a.sort(this.compareY);
            var d;
            for (d = 0; d < a.length; d++) {
                var f = a[d].balloon;
                f.setBounds(b, c, b + this.width, e);
                f.prevX = this.prevX[d];
                f.prevY = this.prevY[d];
                f.prevTX = this.prevTX[d];
                f.prevTY = this.prevTY[d];
                f.draw();
                e = f.yPos - 3
            }
            this.arrangeBalloons2()
        },
        compareY: function(a, b) {
            return a.yy < b.yy ? 1 : -1
        },
        arrangeBalloons2: function() {
            var a = this.valueBalloons;
            a.reverse();
            var b, c = this.x,
                e, d, f = a.length;
            for (d = 0; d < f; d++) {
                var g = a[d].balloon;
                b = g.bottom;
                var k = g.bottom - g.yPos,
                    l = f - d - 1;
                0 < d && b - k < e + 3 && (g.setBounds(c, e + 3, c + this.width, e + k + 3), g.prevX = this.prevX[l], g.prevY = this.prevY[l], g.prevTX = this.prevTX[l], g.prevTY = this.prevTY[l], g.draw());
                g.set && g.set.show();
                this.prevX[l] = g.prevX;
                this.prevY[l] = g.prevY;
                this.prevTX[l] = g.prevTX;
                this.prevTY[l] = g.prevTY;
                e = g.bottom
            }
        },
        showBullets: function() {
            d.remove(this.allBullets);
            var a = this.container,
                b = a.set();
            this.set.push(b);
            this.set.show();
            this.allBullets = b;
            var b = this.chart.graphs,
                c;
            for (c = 0; c < b.length; c++) {
                var e = b[c];
                if (!e.hidden && e.balloonText) {
                    var h = this.data[this.index].axes[e.valueAxis.id].graphs[e.id],
                        f = h.y;
                    if (!isNaN(f)) {
                        var g, k;
                        g = h.x;
                        this.rotate ? (k = f, f = g) : k = g;
                        e = d.circle(a, this.bulletSize / 2, this.chart.getBalloonColor(e, h, !0), e.cursorBulletAlpha);
                        e.translate(k, f);
                        this.allBullets.push(e)
                    }
                }
            }
        },
        destroy: function() {
            this.clear();
            d.remove(this.selection);
            this.selection = null;
            var a = this.categoryBalloon;
            a && a.destroy();
            (a = this.vaBalloon) && a.destroy();
            this.destroyValueBalloons();
            d.remove(this.set)
        },
        clear: function() {},
        destroyValueBalloons: function() {
            var a = this.valueBalloons;
            if (a) {
                var b;
                for (b = 0; b < a.length; b++) {
                    a[b].balloon.hide()
                }
            }
        },
        zoom: function(a, b, c, e) {
            var h = this.chart;
            this.destroyValueBalloons();
            this.zooming = !1;
            var f;
            this.rotate ? this.selectionPosY = f = h.mouseY : this.selectionPosX = f = h.mouseX;
            this.start = a;
            this.end = b;
            this.startTime = c;
            this.endTime = e;
            this.zoomed = !0;
            e = h.categoryAxis;
            f = this.rotate;
            b = this.width;
            c = this.height;
            a = e.stepWidth;
            if (this.fullWidth) {
                var g = 1;
                e.parseDates && !e.equalSpacing && (g = e.minDuration());
                f ? this.extraWidth = c = a * g : (this.extraWidth = b = a * g, this.categoryBalloon.minWidth = b);
                this.line && this.line.remove();
                this.line = d.rect(this.container, b, c, this.cursorColor, this.cursorAlpha, 0);
                this.line.node.style.pointerEvents = "none";
                d.setCN(h, this.line, "cursor-fill");
                this.fullRectSet && this.fullRectSet.push(this.line)
            }
            this.stepWidth = a;
            this.tempVal = this.valueBalloonsEnabled;
            this.valueBalloonsEnabled = !1;
            this.setPosition();
            this.valueBalloonsEnabled = this.tempVal;
            this.hideCursor()
        },
        hideObj: function(a) {
            a && a.hide()
        },
        hideCursor: function(a) {
            void 0 === a && (a = !0);
            this.leaveCursor || (this.hideObj(this.set), this.hideObj(this.categoryBalloon), this.hideObj(this.line), this.hideObj(this.vLine), this.hideObj(this.hLine), this.hideObj(this.vaBalloon), this.hideObj(this.allBullets), this.destroyValueBalloons(), this.selectWithoutZooming || d.remove(this.selection), this.previousIndex = NaN, a && this.fire("onHideCursor", {
                type: "onHideCursor",
                chart: this.chart,
                target: this
            }), this.drawing || this.chart.setMouseCursor("auto"), this.normalizeBulletSize())
        },
        setPosition: function(a, b, c) {
            void 0 === b && (b = !0);
            if ("cursor" == this.type) {
                if (this.tempPosition = NaN, d.ifArray(this.data)) {
                    isNaN(a) && (a = this.getMousePosition()), (a != this.previousMousePosition || !0 === this.zoomed || this.oneBalloonOnly) && !isNaN(a) && ("mouse" == this.cursorPosition && (this.tempPosition = a), isNaN(c) && (c = this.chart.categoryAxis.xToIndex(a)), c != this.previousIndex || this.zoomed || "mouse" == this.cursorPosition || this.oneBalloonOnly) && (this.updateCursor(c, b), this.zoomed = !1), this.previousMousePosition = a
                }
            } else {
                this.updateCrosshair()
            }
        },
        normalizeBulletSize: function() {
            var a = this.resizedBullets;
            if (a) {
                for (var b = 0; b < a.length; b++) {
                    var c = a[b],
                        e = c.bulletGraphics;
                    e && (e.translate(c.bx, c.by, 1), c = c.graph, isNaN(this.graphBulletAlpha) || (e.setAttr("fill-opacity", c.bulletAlpha), e.setAttr("stroke-opacity", c.bulletBorderAlpha)))
                }
            }
        },
        updateCursor: function(a, b) {
            var c = this.chart,
                e = this.fullWidth,
                h = c.mouseX - this.x,
                f = c.mouseY - this.y;
            this.drawingNow && (d.remove(this.drawingLine), this.drawingLine = d.line(this.container, [this.x + this.drawStartX, this.x + h], [this.y + this.drawStartY, this.y + f], this.cursorColor, 1, 1));
            if (this.enabled) {
                void 0 === b && (b = !0);
                this.index = a += this.adjustment;
                var g = c.categoryAxis,
                    k = c.dx,
                    l = c.dy,
                    m = this.x + 1,
                    n = this.y + 1,
                    p = this.width,
                    q = this.height,
                    r = this.data[a],
                    u;
                this.data[a + 1] && (u = this.data[a + 1]);
                this.fireMoved();
                if (r) {
                    var t = r.x[g.id],
                        z = c.rotate,
                        y = this.stepWidth,
                        v = this.categoryBalloon,
                        w = this.firstTime,
                        A = this.lastTime,
                        B = this.cursorPosition,
                        C = this.zooming,
                        D = this.panning,
                        J = c.graphs;
                    if (c.mouseIsOver || C || D || this.forceShow) {
                        if (this.forceShow = !1, D) {
                            var k = this.panClickPos,
                                c = this.panClickEndTime,
                                C = this.panClickStartTime,
                                E = this.panClickEnd,
                                m = this.panClickStart,
                                h = (z ? k - f : k - h) / y;
                            if (!g.parseDates || g.equalSpacing) {
                                h = Math.round(h);
                            }
                            0 !== h && (k = {
                                type: "zoomed",
                                target: this
                            }, k.chart = this.chart, g.parseDates && !g.equalSpacing ? (c + h > A && (h = A - c), C + h < w && (h = w - C), k.start = Math.round(C + h), k.end = Math.round(c + h), this.fire(k.type, k)) : E + h >= this.data.length || 0 > m + h || (k.start = m + h, k.end = E + h, this.fire(k.type, k)))
                        } else {
                            "start" == B ? t -= g.cellWidth / 2 : "mouse" == B && (c.mouseIsOver ? t = z ? f - 2 : h - 2 : isNaN(this.tempPosition) || (t = this.tempPosition - 2));
                            if (z) {
                                if (0 > t) {
                                    if (C) {
                                        t = 0;
                                    } else {
                                        this.hideCursor();
                                        return
                                    }
                                }
                                if (t > q + 1) {
                                    if (C) {
                                        t = q + 1;
                                    } else {
                                        this.hideCursor();
                                        return
                                    }
                                }
                            } else {
                                if (0 > t) {
                                    if (C) {
                                        t = 0;
                                    } else {
                                        this.hideCursor();
                                        return
                                    }
                                }
                                if (t > p) {
                                    if (C) {
                                        t = p;
                                    } else {
                                        this.hideCursor();
                                        return
                                    }
                                }
                            }
                            w = this.line;
                            0 < this.cursorAlpha && (z ? (A = 0, y = t + l, e && (y -= g.cellWidth / 2)) : (A = t, y = 0, e && (A -= g.cellWidth / 2)), B = this.animationDuration, 0 < B && !this.zooming ? isNaN(this.previousX) ? w.translate(A, y) : (w.translate(this.previousX, this.previousY), w.animate({
                                translate: A + "," + y
                            }, B, "easeOutSine")) : w.translate(A, y), this.previousX = A, this.previousY = y, w.show());
                            this.linePos = z ? t + l : t;
                            C && (e && w.hide(), z ? this.updateSelectionSize(NaN, t) : this.updateSelectionSize(t, NaN));
                            A = !0;
                            C && (A = !1);
                            this.categoryBalloonEnabled && A ? (this.setBalloonPosition(v, g, t, z), (w = this.categoryBalloonFunction) ? v.showBalloon(w(r.category)) : (w = t = "", g.parseDates ? (t = d.formatDate(r.category, this.categoryBalloonDateFormat, c), g = d.changeDate(new Date(r.category), c.categoryAxis.minPeriod, 1), w = d.formatDate(g, this.categoryBalloonDateFormat, c), -1 != t.indexOf("fff") && (t = d.formatMilliseconds(t, r.category), w = d.formatMilliseconds(w, g))) : (t = d.fixNewLines(r.category), u && (w = d.fixNewLines(u.category))), g = this.categoryBalloonText.replace(/\[\[category\]\]/g, String(t)), g = g.replace(/\[\[toCategory\]\]/g, String(w)), v.showBalloon(g))) : v.hide();
                            J && this.bulletsEnabled && this.showBullets();
                            if (this.oneBalloonOnly) {
                                t = Infinity;
                                for (g = 0; g < J.length; g++) {
                                    v = J[g], v.showBalloon && !v.hidden && v.balloonText && (u = r.axes[v.valueAxis.id].graphs[v.id], w = u.y, "top" == v.showBalloonAt && (w = 0), "bottom" == v.showBalloonAt && (w = this.height), isNaN(w) || (z ? Math.abs(h - w) < t && (t = Math.abs(h - w), E = v) : Math.abs(f - w) < t && (t = Math.abs(f - w), E = v)));
                                }
                                this.mostCloseGraph && (E = this.mostCloseGraph)
                            }
                            if (a != this.previousIndex || E != this.previousMostCloseGraph) {
                                if (this.normalizeBulletSize(), this.destroyValueBalloons(), this.resizedBullets = [], J && this.valueBalloonsEnabled && A && c.balloon.enabled) {
                                    this.valueBalloons = A = [];
                                    for (g = 0; g < J.length; g++) {
                                        if (v = J[g], w = NaN, (!this.oneBalloonOnly || v == E) && v.showBalloon && !v.hidden && v.balloonText && ("step" == v.type && "left" == v.stepDirection && (r = this.data[a + 1]), r)) {
                                            if (u = r.axes[v.valueAxis.id].graphs[v.id]) {
                                                w = u.y;
                                            }
                                            "top" == v.showBalloonAt && (w = 0);
                                            "bottom" == v.showBalloonAt && (w = this.height);
                                            if (this.showNextAvailable && isNaN(w) && a + 1 < this.data.length) {
                                                for (t = a + 1; t < this.data.length; t++) {
                                                    if (y = this.data[t]) {
                                                        if (u = y.axes[v.valueAxis.id].graphs[v.id], w = u.y, !isNaN(w)) {
                                                            break;
                                                        }
                                                    }
                                                }
                                            }
                                            if (!isNaN(w)) {
                                                y = u.x;
                                                e = !0;
                                                if (z) {
                                                    if (t = w, 0 > y || y > q) {
                                                        e = !1
                                                    }
                                                } else if (t = y, y = w, 0 > t || t > p + k + 1) {
                                                    e = !1;
                                                }
                                                e && (e = this.graphBulletSize, l = this.graphBulletAlpha, 1 == e && isNaN(l) || !d.isModern || !(B = u.bulletGraphics) || (B.translate(u.bx, u.by, e), this.resizedBullets.push(u), isNaN(l) || (B.setAttr("fill-opacity", l), B.setAttr("stroke-opacity", l))), e = v.valueBalloon, l = c.getBalloonColor(v, u), e.setBounds(m, n, m + p, n + q), e.pointerOrientation = "H", B = this.balloonPointerOrientation, "vertical" == B && (e.pointerOrientation = "V"), "horizontal" == B && (e.pointerOrientation = "H"), e.changeColor(l), void 0 !== v.balloonAlpha && (e.fillAlpha = v.balloonAlpha), void 0 !== v.balloonTextColor && (e.color = v.balloonTextColor), e.setPosition(t + m, y + n), t = c.formatString(v.balloonText, u, !0), (y = v.balloonFunction) && (t = y(u, v).toString()), "" !== t && (z ? e.showBalloon(t) : (e.text = t, e.show = !0), A.push({
                                                    yy: w,
                                                    balloon: e
                                                })), !z && e.set && (e.set.hide(), v = e.textDiv) && (v.style.visibility = "hidden"))
                                            }
                                        }
                                    }
                                    this.avoidBalloonOverlapping && this.arrangeBalloons()
                                }
                            }
                            b ? (k = {
                                type: "changed"
                            }, k.index = a, k.chart = this.chart, k.zooming = C, k.mostCloseGraph = E, k.position = z ? f : h, k.target = this, c.fire("changed", k), this.fire("changed", k), this.skipZoomDispatch = !1) : (this.skipZoomDispatch = !0, c.updateLegendValues(a));
                            this.previousIndex = a;
                            this.previousMostCloseGraph = E
                        }
                    }
                }
            } else this.hideCursor()
        },
        setBalloonPosition: function(a, b, c, e) {
            var d = b.position,
                f = b.inside;
            b = b.axisThickness;
            var g = this.chart,
                k = g.dx,
                g = g.dy,
                l = this.x,
                m = this.y,
                n = this.width,
                p = this.height;
            e ? (f && ("right" == d ? a.setBounds(l, m + g, l + n + k, m + c + g) : a.setBounds(l, m + g, l + n + k, m + c)), "right" == d ? f ? a.setPosition(l + n + k, m + c + g) : a.setPosition(l + n + k + b, m + c + g) : f ? a.setPosition(l, m + c) : a.setPosition(l - b, m + c)) : "top" == d ? f ? a.setPosition(l + c + k, m + g) : a.setPosition(l + c + k, m + g - b + 1) : f ? a.setPosition(l + c, m + p) : a.setPosition(l + c, m + p + b - 1)
        },
        setBalloonBounds: function(a, b, c) {
            var e = b.position,
                d = b.inside,
                f = b.axisThickness,
                g = b.tickLength,
                k = this.chart,
                l = k.dx,
                k = k.dy,
                m = this.x,
                n = this.y,
                p = this.width,
                q = this.height;
            c ? (d && (a.pointerWidth = 0), "right" == e ? d ? a.setBounds(m, n + k, m + p + l, n + q + k) : a.setBounds(m + p + l + f, n + k, m + p + 1E3, n + q + k) : d ? a.setBounds(m, n, p + m, q + n) : a.setBounds(-1E3, -1E3, m - g - f, n + q + 15)) : (a.maxWidth = p, b.parseDates && (g = 0, a.pointerWidth = 0), "top" == e ? d ? a.setBounds(m + l, n + k, p + l + m, q + n) : a.setBounds(m + l, -1E3, p + l + m, n + k - g - f) : d ? a.setBounds(m, n, p + m, q + n - g) : a.setBounds(m, n + q + g + f - 1, m + p, n + q + g + f))
        },
        enableDrawing: function(a) {
            this.enabled = !a;
            this.hideCursor();
            this.rolledOver = !1;
            this.drawing = a
        },
        isZooming: function(a) {
            a && a != this.zooming && this.handleMouseDown("fake");
            a || a == this.zooming || this.handleMouseUp()
        },
        handleMouseOut: function() {
            if (this.enabled)
                if (this.zooming) this.setPosition();
                else {
                    this.index = void 0;
                    var a = {
                        type: "changed",
                        index: void 0,
                        target: this
                    };
                    a.chart = this.chart;
                    this.fire("changed", a);
                    this.chart.wasTouched && this.leaveAfterTouch || this.hideCursor()
                }
        },
        handleReleaseOutside: function() {
            this.handleMouseUp()
        },
        handleMouseUp: function() {
            var a = this.chart,
                b = this.data,
                c;
            if (a) {
                var e = a.mouseX - this.x,
                    h = a.mouseY - this.y;
                if (this.drawingNow) {
                    this.drawingNow = !1;
                    d.remove(this.drawingLine);
                    c = this.drawStartX;
                    var f = this.drawStartY;
                    if (2 < Math.abs(c - e) || 2 < Math.abs(f - h)) c = {
                        type: "draw",
                        target: this,
                        chart: a,
                        initialX: c,
                        initialY: f,
                        finalX: e,
                        finalY: h
                    }, this.fire(c.type, c)
                }
                if (this.enabled && 0 < b.length) {
                    if (this.pan) this.rolledOver = !1;
                    else if (this.zoomable && this.zooming) {
                        c = this.selectWithoutZooming ? {
                            type: "selected"
                        } : {
                            type: "zoomed"
                        };
                        c.target = this;
                        c.chart = a;
                        if ("cursor" == this.type) this.rotate ? this.selectionPosY = h : this.selectionPosX = h = e, 4 > Math.abs(h - this.initialMouse) && this.fromIndex == this.index || (this.index < this.fromIndex ? (c.end = this.fromIndex, c.start = this.index) : (c.end = this.index, c.start = this.fromIndex), h = a.categoryAxis, h.parseDates && !h.equalSpacing && (b[c.start] && (c.start = b[c.start].time), b[c.end] && (c.end = a.getEndTime(b[c.end].time))), this.skipZoomDispatch || this.fire(c.type, c));
                        else {
                            var g = this.initialMouseX,
                                k = this.initialMouseY;
                            3 > Math.abs(e - g) && 3 > Math.abs(h - k) || (b = Math.min(g, e), f = Math.min(k, h), e = Math.abs(g - e), h = Math.abs(k - h), a.hideXScrollbar && (b = 0, e = this.width), a.hideYScrollbar && (f = 0, h = this.height), c.selectionHeight = h, c.selectionWidth = e, c.selectionY = f, c.selectionX = b, this.skipZoomDispatch || this.fire(c.type, c))
                        }
                        this.selectWithoutZooming || d.remove(this.selection)
                    }
                    this.skipZoomDispatch = !1
                }
            }
            this.panning = this.zooming = !1
        },
        showCursorAt: function(a) {
            var b = this.chart.categoryAxis;
            a = b.parseDates ? b.dateToCoordinate(a) : b.categoryToCoordinate(a);
            this.previousMousePosition = NaN;
            this.forceShow = !0;
            this.setPosition(a, !1)
        },
        clearSelection: function() {
            d.remove(this.selection)
        },
        handleMouseDown: function(a) {
            if (this.zoomable || this.pan || this.drawing) {
                var b = this.rotate,
                    c = this.chart,
                    e = c.mouseX - this.x,
                    h = c.mouseY - this.y;
                if (0 < e && e < this.width && 0 < h && h < this.height || "fake" == a) this.setPosition(), this.selectWithoutZooming && d.remove(this.selection), this.drawing ? (this.drawStartY = h, this.drawStartX = e, this.drawingNow = !0) : this.pan ? (this.zoomable = !1, c.setMouseCursor("move"), this.panning = !0, this.panClickPos = b ? h : e, this.panClickStart = this.start, this.panClickEnd = this.end, this.panClickStartTime = this.startTime, this.panClickEndTime = this.endTime) : this.zoomable && ("cursor" == this.type ? (this.fromIndex = this.index, b ? (this.initialMouse = h, this.selectionPosY = this.linePos) : (this.initialMouse = e, this.selectionPosX = this.linePos)) : (this.initialMouseX = e, this.initialMouseY = h, this.selectionPosX = e, this.selectionPosY = h), this.zooming = !0)
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.SimpleChartScrollbar = d.Class({
        construct: function(a) {
            this.createEvents("zoomed");
            this.backgroundColor = "#D4D4D4";
            this.backgroundAlpha = 1;
            this.selectedBackgroundColor = "#EFEFEF";
            this.scrollDuration = this.selectedBackgroundAlpha = 1;
            this.resizeEnabled = !0;
            this.hideResizeGrips = !1;
            this.scrollbarHeight = 20;
            this.updateOnReleaseOnly = !1;
            9 > document.documentMode && (this.updateOnReleaseOnly = !0);
            this.dragIconHeight = this.dragIconWidth = 35;
            this.dragIcon = "dragIcon";
            d.applyTheme(this, a, "SimpleChartScrollbar")
        },
        draw: function() {
            var a = this;
            a.destroy();
            if (a.enabled) {
                var b = a.chart.container,
                    c = a.rotate,
                    e = a.chart;
                e.panRequired = !0;
                var h = b.set();
                a.set = h;
                e.scrollbarsSet.push(h);
                var f, g;
                c ? (f = a.scrollbarHeight, g = e.plotAreaHeight) : (g = a.scrollbarHeight, f = e.plotAreaWidth);
                a.width = f;
                if ((a.height = g) && f) {
                    var k = d.rect(b, f, g, a.backgroundColor, a.backgroundAlpha, 1, a.backgroundColor, a.backgroundAlpha);
                    d.setCN(e, k, "scrollbar-bg");
                    a.bg = k;
                    h.push(k);
                    k = d.rect(b, f, g, "#000", .005);
                    h.push(k);
                    a.invisibleBg = k;
                    k.click(function() {
                        a.handleBgClick()
                    }).mouseover(function() {
                        a.handleMouseOver()
                    }).mouseout(function() {
                        a.handleMouseOut()
                    }).touchend(function() {
                        a.handleBgClick()
                    });
                    k = d.rect(b, f, g, a.selectedBackgroundColor, a.selectedBackgroundAlpha);
                    d.setCN(e, k, "scrollbar-bg-selected");
                    a.selectedBG = k;
                    h.push(k);
                    f = d.rect(b, f, g, "#000", .005);
                    a.dragger = f;
                    h.push(f);
                    f.mousedown(function(b) {
                        a.handleDragStart(b)
                    }).mouseup(function() {
                        a.handleDragStop()
                    }).mouseover(function() {
                        a.handleDraggerOver()
                    }).mouseout(function() {
                        a.handleMouseOut()
                    }).touchstart(function(b) {
                        a.handleDragStart(b)
                    }).touchend(function() {
                        a.handleDragStop()
                    });
                    f = e.pathToImages;
                    g = a.dragIcon.replace(/\.[a-z]*$/i, "");
                    c ? (k = f + g + "H" + e.extension, f = a.dragIconWidth, c = a.dragIconHeight) : (k = f + g + e.extension, c = a.dragIconWidth, f = a.dragIconHeight);
                    g = b.image(k, 0, 0, c, f);
                    d.setCN(e, g, "scrollbar-grip-left");
                    k = k.replace('.gif', '2.gif');
                    k = b.image(k, 0, 0, c, f);
                    d.setCN(e, k, "scrollbar-grip-right");
                    var l = 10,
                        m = 20;
                    e.panEventsEnabled && (l = 25, m = a.scrollbarHeight);
                    var n = d.rect(b, l, m, "#000", .005),
                        p = d.rect(b, l, m, "#000", .005);
                    p.translate(-(l - c) / 2, -(m - f) / 2);
                    n.translate(-(l - c) / 2, -(m - f) / 2);
                    c = b.set([g, p]);
                    b = b.set([k, n]);
                    a.iconLeft = c;
                    h.push(a.iconLeft);
                    a.iconRight = b;
                    h.push(b);
                    c.mousedown(function() {
                        a.leftDragStart()
                    }).mouseup(function() {
                        a.leftDragStop()
                    }).mouseover(function() {
                        a.iconRollOver()
                    }).mouseout(function() {
                        a.iconRollOut()
                    }).touchstart(function() {
                        a.leftDragStart()
                    }).touchend(function() {
                        a.leftDragStop()
                    });
                    b.mousedown(function() {
                        a.rightDragStart()
                    }).mouseup(function() {
                        a.rightDragStop()
                    }).mouseover(function() {
                        a.iconRollOver()
                    }).mouseout(function() {
                        a.iconRollOut()
                    }).touchstart(function() {
                        a.rightDragStart()
                    }).touchend(function() {
                        a.rightDragStop()
                    });
                    d.ifArray(e.chartData) ? h.show() : h.hide();
                    a.hideDragIcons();
                    a.clipDragger(!1)
                }
                h.translate(a.x, a.y);
                h.node.style.msTouchAction = "none"
            }
        },
        updateScrollbarSize: function(a, b) {
            a = Math.round(a);
            b = Math.round(b);
            var c = this.dragger,
                e, d, f, g;
            this.rotate ? (e = 0, d = a, f = this.width + 1, g = b - a, c.setAttr("height", b - a), c.setAttr("y", d)) : (e = a, d = 0, f = b - a, g = this.height + 1, c.setAttr("width", b - a), c.setAttr("x", e));
            this.clipAndUpdate(e, d, f, g)
        },
        update: function() {
            var a, b = !1,
                c, e, d = this.x,
                f = this.y,
                g = this.dragger,
                k = this.getDBox();
            if (k) {
                c = k.x + d;
                e = k.y + f;
                var l = k.width,
                    k = k.height,
                    m = this.rotate,
                    n = this.chart,
                    p = this.width,
                    q = this.height,
                    r = n.mouseX,
                    u = n.mouseY;
                a = this.initialMouse;
                this.forceClip && this.clipDragger(!0);
                n.mouseIsOver && (this.dragging && (n = this.initialCoord, m ? (a = n + (u - a), 0 > a && (a = 0), n = q - k, a > n && (a = n), g.setAttr("y", a)) : (a = n + (r - a), 0 > a && (a = 0), n = p - l, a > n && (a = n), g.setAttr("x", a)), this.clipDragger(!0)), this.resizingRight && (m ? (a = u - e, a + e > q + f && (a = q - e + f), 0 > a ? (this.resizingRight = !1, b = this.resizingLeft = !0) : (0 === a && (a = .1), g.setAttr("height", a))) : (a = r - c, a + c > p + d && (a = p - c + d), 0 > a ? (this.resizingRight = !1, b = this.resizingLeft = !0) : (0 === a && (a = .1), g.setAttr("width", a))), this.clipDragger(!0)), this.resizingLeft && (m ? (c = e, e = u, e < f && (e = f), e > q + f && (e = q + f), a = !0 === b ? c - e : k + c - e, 0 > a ? (this.resizingRight = !0, this.resizingLeft = !1, g.setAttr("y", c + k - f)) : (0 === a && (a = .1), g.setAttr("y", e - f), g.setAttr("height", a))) : (e = r, e < d && (e = d), e > p + d && (e = p + d), a = !0 === b ? c - e : l + c - e, 0 > a ? (this.resizingRight = !0, this.resizingLeft = !1, g.setAttr("x", c + l - d)) : (0 === a && (a = .1), g.setAttr("x", e - d), g.setAttr("width", a))), this.clipDragger(!0)))
            }
        },
        stopForceClip: function() {
            this.forceClip = !1
        },
        clipDragger: function(a) {
            var b = this.getDBox();
            if (b) {
                var c = b.x,
                    e = b.y,
                    d = b.width,
                    b = b.height,
                    f = !1;
                if (this.rotate) {
                    if (c = 0, d = this.width + 1, this.clipY != e || this.clipH != b) f = !0
                } else if (e = 0, b = this.height + 1, this.clipX != c || this.clipW != d) f = !0;
                f && (this.clipAndUpdate(c, e, d, b), a && (this.updateOnReleaseOnly || this.dispatchScrollbarEvent()))
            }
        },
        maskGraphs: function() {},
        clipAndUpdate: function(a, b, c, e) {
            this.clipX = a;
            this.clipY = b;
            this.clipW = c;
            this.clipH = e;
            this.selectedBG.clipRect(a, b, c, e);
            this.updateDragIconPositions();
            this.maskGraphs(a, b, c, e)
        },
        dispatchScrollbarEvent: function() {
            if (this.skipEvent) this.skipEvent = !1;
            else {
                var a = this.chart;
                a.hideBalloon();
                var b = this.getDBox(),
                    c = b.x,
                    e = b.y,
                    d = b.width,
                    b = b.height;
                this.rotate ? (c = e, d = this.height / b) : d = this.width / d;
                a = {
                    type: "zoomed",
                    position: c,
                    chart: a,
                    target: this,
                    multiplier: d
                };
                this.fire(a.type, a)
            }
        },
        updateDragIconPositions: function() {
            var a = this.getDBox(),
                b = a.x,
                c = a.y,
                e = this.iconLeft,
                d = this.iconRight,
                f, g, k = this.scrollbarHeight;
            this.rotate ? (f = this.dragIconWidth, g = this.dragIconHeight, e.translate((k - g) / 2, c - f / 2), d.translate((k - g) / 2, c + a.height - f / 2)) : (f = this.dragIconHeight, g = this.dragIconWidth, e.translate(b - g / 2, (k - f) / 2), d.translate(b - g / 2 + a.width, (k - f) / 2))
        },
        showDragIcons: function() {
            this.resizeEnabled && (this.iconLeft.show(), this.iconRight.show())
        },
        hideDragIcons: function() {
            if (!this.resizingLeft && !this.resizingRight && !this.dragging) {
                if (this.hideResizeGrips || !this.resizeEnabled) this.iconLeft.hide(), this.iconRight.hide();
                this.removeCursors()
            }
        },
        removeCursors: function() {
            this.chart.setMouseCursor("auto")
        },
        relativeZoom: function(a, b) {
            this.enabled && (this.dragger.stop(), this.multiplier = a, this.position = b, this.updateScrollbarSize(b, this.rotate ? b + this.height / a : b + this.width / a), this.clipDragger())
        },
        destroy: function() {
            this.clear();
            d.remove(this.set);
            d.remove(this.iconRight);
            d.remove(this.iconLeft)
        },
        clear: function() {},
        handleDragStart: function() {
            if (this.enabled) {
                var a = this.chart;
                this.dragger.stop();
                this.removeCursors();
                this.dragging = !0;
                var b = this.getDBox();
                this.rotate ? (this.initialCoord = b.y, this.initialMouse = a.mouseY) : (this.initialCoord = b.x, this.initialMouse = a.mouseX)
            }
        },
        handleDragStop: function() {
            this.updateOnReleaseOnly && (this.update(), this.skipEvent = !1, this.dispatchScrollbarEvent());
            this.dragging = !1;
            this.mouseIsOver && this.removeCursors();
            this.update()
        },
        handleDraggerOver: function() {
            this.handleMouseOver()
        },
        leftDragStart: function() {
            this.dragger.stop();
            this.resizingLeft = !0
        },
        leftDragStop: function() {
            this.resizingLeft = !1;
            this.mouseIsOver || this.removeCursors();
            this.updateOnRelease()
        },
        rightDragStart: function() {
            this.dragger.stop();
            this.resizingRight = !0
        },
        rightDragStop: function() {
            this.resizingRight = !1;
            this.mouseIsOver || this.removeCursors();
            this.updateOnRelease()
        },
        iconRollOut: function() {
            this.removeCursors()
        },
        iconRollOver: function() {
            this.rotate ? this.chart.setMouseCursor("n-resize") : this.chart.setMouseCursor("e-resize");
            this.handleMouseOver()
        },
        getDBox: function() {
            if (this.dragger) return this.dragger.getBBox()
        },
        handleBgClick: function() {
            var a = this;
            if (!a.resizingRight && !a.resizingLeft) {
                a.zooming = !0;
                var b, c, e = a.scrollDuration,
                    h = a.dragger;
                b = a.getDBox();
                var f = b.height,
                    g = b.width;
                c = a.chart;
                var k = a.y,
                    l = a.x,
                    m = a.rotate;
                m ? (b = "y", c = c.mouseY - f / 2 - k, c = d.fitToBounds(c, 0, a.height - f)) : (b = "x", c = c.mouseX - g / 2 - l, c = d.fitToBounds(c, 0, a.width - g));
                a.updateOnReleaseOnly ? (a.skipEvent = !1, h.setAttr(b, c), a.dispatchScrollbarEvent(), a.clipDragger()) : (c = Math.round(c), m ? h.animate({
                    y: c
                }, e, ">") : h.animate({
                    x: c
                }, e, ">"), a.forceClip = !0, clearTimeout(a.forceTO), a.forceTO = setTimeout(function() {
                    a.stopForceClip.call(a)
                }, 5E3 * e))
            }
        },
        updateOnRelease: function() {
            this.updateOnReleaseOnly && (this.update(), this.skipEvent = !1, this.dispatchScrollbarEvent())
        },
        handleReleaseOutside: function() {
            if (this.set) {
                if (this.resizingLeft || this.resizingRight || this.dragging) this.updateOnRelease(), this.removeCursors();
                this.mouseIsOver = this.dragging = this.resizingRight = this.resizingLeft = !1;
                this.hideDragIcons();
                this.update()
            }
        },
        handleMouseOver: function() {
            this.mouseIsOver = !0;
            this.showDragIcons()
        },
        handleMouseOut: function() {
            this.mouseIsOver = !1;
            this.hideDragIcons()
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.ChartScrollbar = d.Class({
        inherits: d.SimpleChartScrollbar,
        construct: function(a) {
            this.cname = "ChartScrollbar";
            d.ChartScrollbar.base.construct.call(this, a);
            this.enabled = !0;
            this.graphLineColor = "#BBBBBB";
            this.graphLineAlpha = 0;
            this.graphFillColor = "#BBBBBB";
            this.graphFillAlpha = 1;
            this.selectedGraphLineColor = "#888888";
            this.selectedGraphLineAlpha = 0;
            this.selectedGraphFillColor = "#888888";
            this.selectedGraphFillAlpha = 1;
            this.gridCount = 0;
            this.gridColor = "#FFFFFF";
            this.gridAlpha = .7;
            this.skipEvent = this.autoGridCount = !1;
            this.color = "#FFFFFF";
            this.scrollbarCreated = !1;
            this.offset = 0;
            this.oppositeAxis = !0;
            d.applyTheme(this, a, this.cname)
        },
        init: function() {
            var a = this.categoryAxis,
                b = this.chart;
            a || (this.categoryAxis = a = new d.CategoryAxis);
            a.chart = b;
            a.id = "scrollbar";
            a.dateFormats = b.categoryAxis.dateFormats;
            a.markPeriodChange = b.categoryAxis.markPeriodChange;
            a.boldPeriodBeginning = b.categoryAxis.boldPeriodBeginning;
            a.labelFunction = b.categoryAxis.labelFunction;
            a.axisItemRenderer = d.RecItem;
            a.axisRenderer = d.RecAxis;
            a.guideFillRenderer = d.RecFill;
            a.inside = !0;
            a.fontSize = this.fontSize;
            a.tickLength = 0;
            a.axisAlpha = 0;
            d.isString(this.graph) && (this.graph = d.getObjById(b.graphs, this.graph));
            if (a = this.graph) {
                var c = this.valueAxis;
                c || (this.valueAxis = c = new d.ValueAxis, c.visible = !1, c.scrollbar = !0, c.axisItemRenderer = d.RecItem, c.axisRenderer = d.RecAxis, c.guideFillRenderer = d.RecFill, c.labelsEnabled = !1, c.chart = b);
                b = this.unselectedGraph;
                b || (b = new d.AmGraph, b.scrollbar = !0, this.unselectedGraph = b, b.negativeBase = a.negativeBase, b.noStepRisers = a.noStepRisers);
                b = this.selectedGraph;
                b || (b = new d.AmGraph, b.scrollbar = !0, this.selectedGraph = b, b.negativeBase = a.negativeBase, b.noStepRisers = a.noStepRisers)
            }
            this.scrollbarCreated = !0
        },
        draw: function() {
            var a = this;
            d.ChartScrollbar.base.draw.call(a);
            if (a.enabled) {
                a.scrollbarCreated || a.init();
                var b = a.chart,
                    c = b.chartData,
                    e = a.categoryAxis,
                    h = a.rotate,
                    f = a.x,
                    g = a.y,
                    k = a.width,
                    l = a.height,
                    m = b.categoryAxis,
                    n = a.set;
                e.setOrientation(!h);
                e.parseDates = m.parseDates;
                e.rotate = h;
                e.equalSpacing = m.equalSpacing;
                e.minPeriod = m.minPeriod;
                e.startOnAxis = m.startOnAxis;
                e.viW = k;
                e.viH = l;
                e.width = k;
                e.height = l;
                e.gridCount = a.gridCount;
                e.gridColor = a.gridColor;
                e.gridAlpha = a.gridAlpha;
                e.color = a.color;
                e.tickLength = 0;
                e.axisAlpha = 0;
                e.autoGridCount = a.autoGridCount;
                e.parseDates && !e.equalSpacing && e.timeZoom(b.firstTime, b.lastTime);
                e.zoom(0, c.length - 1);
                if (m = a.graph) {
                    var p = a.valueAxis,
                        q = m.valueAxis;
                    p.id = q.id;
                    p.rotate = h;
                    p.setOrientation(h);
                    p.width = k;
                    p.height = l;
                    p.viW = k;
                    p.viH = l;
                    p.dataProvider = c;
                    p.reversed = q.reversed;
                    p.logarithmic = q.logarithmic;
                    p.gridAlpha = 0;
                    p.axisAlpha = 0;
                    n.push(p.set);
                    h ? (p.y = g, p.x = 0) : (p.x = f, p.y = 0);
                    var f = Infinity,
                        g = -Infinity,
                        r;
                    for (r = 0; r < c.length; r++) {
                        var u = c[r].axes[q.id].graphs[m.id].values,
                            t;
                        for (t in u)
                            if (u.hasOwnProperty(t) && "percents" != t && "total" != t) {
                                var z = u[t];
                                z < f && (f = z);
                                z > g && (g = z)
                            }
                    }
                    Infinity != f && (p.minimum = f); - Infinity != g && (p.maximum = g + .1 * (g - f));
                    f == g && (--p.minimum, p.maximum += 1);
                    void 0 !== a.minimum && (p.minimum = a.minimum);
                    void 0 !== a.maximum && (p.maximum = a.maximum);
                    p.zoom(0, c.length - 1);
                    t = a.unselectedGraph;
                    t.id = m.id;
                    t.bcn = "scrollbar-graph-";
                    t.rotate = h;
                    t.chart = b;
                    t.data = c;
                    t.valueAxis = p;
                    t.chart = m.chart;
                    t.categoryAxis = a.categoryAxis;
                    t.periodSpan = m.periodSpan;
                    t.valueField = m.valueField;
                    t.openField = m.openField;
                    t.closeField = m.closeField;
                    t.highField = m.highField;
                    t.lowField = m.lowField;
                    t.lineAlpha = a.graphLineAlpha;
                    t.lineColorR = a.graphLineColor;
                    t.fillAlphas = a.graphFillAlpha;
                    t.fillColorsR = a.graphFillColor;
                    t.connect = m.connect;
                    t.hidden = m.hidden;
                    t.width = k;
                    t.height = l;
                    t.pointPosition = m.pointPosition;
                    t.stepDirection = m.stepDirection;
                    t.periodSpan = m.periodSpan;
                    q = a.selectedGraph;
                    q.id = m.id;
                    q.bcn = t.bcn + "selected-";
                    q.rotate = h;
                    q.chart = b;
                    q.data = c;
                    q.valueAxis = p;
                    q.chart = m.chart;
                    q.categoryAxis = e;
                    q.periodSpan = m.periodSpan;
                    q.valueField = m.valueField;
                    q.openField = m.openField;
                    q.closeField = m.closeField;
                    q.highField = m.highField;
                    q.lowField = m.lowField;
                    q.lineAlpha = a.selectedGraphLineAlpha;
                    q.lineColorR = a.selectedGraphLineColor;
                    q.fillAlphas = a.selectedGraphFillAlpha;
                    q.fillColorsR = a.selectedGraphFillColor;
                    q.connect = m.connect;
                    q.hidden = m.hidden;
                    q.width = k;
                    q.height = l;
                    q.pointPosition = m.pointPosition;
                    q.stepDirection = m.stepDirection;
                    q.periodSpan = m.periodSpan;
                    b = a.graphType;
                    b || (b = m.type);
                    t.type = b;
                    q.type = b;
                    c = c.length - 1;
                    t.zoom(0, c);
                    q.zoom(0, c);
                    q.set.click(function() {
                        a.handleBackgroundClick()
                    }).mouseover(function() {
                        a.handleMouseOver()
                    }).mouseout(function() {
                        a.handleMouseOut()
                    });
                    t.set.click(function() {
                        a.handleBackgroundClick()
                    }).mouseover(function() {
                        a.handleMouseOver()
                    }).mouseout(function() {
                        a.handleMouseOut()
                    });
                    n.push(t.set);
                    n.push(q.set)
                }
                n.push(e.set);
                n.push(e.labelsSet);
                a.bg.toBack();
                a.invisibleBg.toFront();
                a.dragger.toFront();
                a.iconLeft.toFront();
                a.iconRight.toFront()
            }
        },
        timeZoom: function(a, b, c) {
            this.startTime = a;
            this.endTime = b;
            this.timeDifference = b - a;
            this.skipEvent = !d.toBoolean(c);
            this.zoomScrollbar();
            this.skipEvent || this.dispatchScrollbarEvent()
        },
        zoom: function(a, b) {
            this.start = a;
            this.end = b;
            this.skipEvent = !0;
            this.zoomScrollbar()
        },
        dispatchScrollbarEvent: function() {
            if (this.skipEvent) this.skipEvent = !1;
            else {
                var a = this.chart.chartData,
                    b, c, e = this.dragger.getBBox();
                b = e.x;
                var d = e.y,
                    f = e.width,
                    e = e.height,
                    g = this.chart;
                this.rotate ? (b = d, c = e) : c = f;
                f = {
                    type: "zoomed",
                    target: this
                };
                f.chart = g;
                var k = this.categoryAxis,
                    l = this.stepWidth,
                    d = g.minSelectedTime,
                    e = !1;
                if (k.parseDates && !k.equalSpacing) {
                    if (a = g.lastTime, g = g.firstTime, k = Math.round(b / l) + g, b = this.dragging ? k + this.timeDifference : Math.round((b + c) / l) + g, k > b && (k = b), 0 < d && b - k < d && (b = Math.round(k + (b - k) / 2), e = Math.round(d / 2), k = b - e, b += e, e = !0), b > a && (b = a), b - d < k && (k = b - d), k < g && (k = g), k + d > b && (b = k + d), k != this.startTime || b != this.endTime) this.startTime = k, this.endTime = b, f.start = k, f.end = b, f.startDate = new Date(k), f.endDate = new Date(b), this.fire(f.type, f)
                } else if (k.startOnAxis || (b += l / 2), c -= this.stepWidth / 2, d = k.xToIndex(b), b = k.xToIndex(b + c), d != this.start || this.end != b) k.startOnAxis && (this.resizingRight && d == b && b++, this.resizingLeft && d == b && (0 < d ? d-- : b = 1)), this.start = d, this.end = this.dragging ? this.start + this.difference : b, f.start = this.start, f.end = this.end, k.parseDates && (a[this.start] && (f.startDate = new Date(a[this.start].time)), a[this.end] && (f.endDate = new Date(a[this.end].time))), this.fire(f.type, f);
                e && this.zoomScrollbar()
            }
        },
        zoomScrollbar: function() {
            var a, b;
            a = this.chart;
            var c = a.chartData,
                e = this.categoryAxis;
            e.parseDates && !e.equalSpacing ? (c = e.stepWidth, e = a.firstTime, a = c * (this.startTime - e), b = c * (this.endTime - e)) : (a = c[this.start].x[e.id], b = c[this.end].x[e.id], c = e.stepWidth, e.startOnAxis || (e = c / 2, a -= e, b += e));
            this.stepWidth = c;
            this.updateScrollbarSize(a, b)
        },
        maskGraphs: function(a, b, c, e) {
            var d = this.selectedGraph;
            d && d.set.clipRect(a, b, c, e)
        },
        handleDragStart: function() {
            d.ChartScrollbar.base.handleDragStart.call(this);
            this.difference = this.end - this.start;
            this.timeDifference = this.endTime - this.startTime;
            0 > this.timeDifference && (this.timeDifference = 0)
        },
        handleBackgroundClick: function() {
            d.ChartScrollbar.base.handleBackgroundClick.call(this);
            this.dragging || (this.difference = this.end - this.start, this.timeDifference = this.endTime - this.startTime, 0 > this.timeDifference && (this.timeDifference = 0))
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmBalloon = d.Class({
        construct: function(a) {
            this.cname = "AmBalloon";
            this.enabled = !0;
            this.fillColor = "#FFFFFF";
            this.fillAlpha = .8;
            this.borderThickness = 2;
            this.borderColor = "#FFFFFF";
            this.borderAlpha = 1;
            this.cornerRadius = 0;
            this.maxWidth = 220;
            this.horizontalPadding = 8;
            this.verticalPadding = 4;
            this.pointerWidth = 6;
            this.pointerOrientation = "V";
            this.color = "#000000";
            this.adjustBorderColor = !0;
            this.show = this.follow = this.showBullet = !1;
            this.bulletSize = 3;
            this.shadowAlpha = .4;
            this.shadowColor = "#000000";
            this.fadeOutDuration = this.animationDuration = .3;
            this.fixedPosition = !0;
            this.offsetY = 6;
            this.offsetX = 1;
            this.textAlign = "center";
            this.disableMouseEvents = !0;
            this.deltaSignX = this.deltaSignY = 1;
            d.isModern || (this.offsetY *= 1.5);
            d.applyTheme(this, a, this.cname)
        },
        draw: function() {
            var a = this.pointToX,
                b = this.pointToY,
                c = this.chart;
            d.VML && (this.fadeOutDuration = 0);
            this.xAnim && c.stopAnim(this.xAnim);
            this.yAnim && c.stopAnim(this.yAnim);
            if (!isNaN(a)) {
                var e = this.follow,
                    h = c.container,
                    f = this.set;
                d.remove(f);
                this.removeDiv();
                f = h.set();
                f.node.style.pointerEvents = "none";
                this.set = f;
                c.balloonsSet.push(f);
                if (this.show) {
                    var g = this.l,
                        k = this.t,
                        l = this.r,
                        m = this.b,
                        n = this.balloonColor,
                        p = this.fillColor,
                        q = this.borderColor,
                        r = p;
                    void 0 != n && (this.adjustBorderColor ? r = q = n : p = n);
                    var u = this.horizontalPadding,
                        t = this.verticalPadding,
                        z = this.pointerWidth,
                        y = this.pointerOrientation,
                        v = this.cornerRadius,
                        w = c.fontFamily,
                        A = this.fontSize;
                    void 0 == A && (A = c.fontSize);
                    var n = document.createElement("div"),
                        B = c.classNamePrefix;
                    n.className = B + "-balloon-div";
                    this.className && (n.className = n.className + " " + B + "-balloon-div-" + this.className);
                    B = n.style;
                    this.disableMouseEvents && (B.pointerEvents = "none");
                    B.position = "absolute";
                    var C = this.minWidth,
                        D = "";
                    isNaN(C) || (D = "min-width:" + (C - 2 * u) + "px; ");
                    n.innerHTML = "<div style='text-align:" + this.textAlign + "; " + D + "max-width:" + this.maxWidth + "px; font-size:" + A + "px; color:" + this.color + "; font-family:" + w + "'>" + this.text + "</div>";
                    c.chartDiv.appendChild(n);
                    this.textDiv = n;
                    A = n.offsetWidth;
                    w = n.offsetHeight;
                    n.clientHeight && (A = n.clientWidth, w = n.clientHeight);
                    w += 2 * t;
                    D = A + 2 * u;
                    !isNaN(C) && D < C && (D = C);
                    window.opera && (w += 2);
                    var J = !1,
                        A = this.offsetY;
                    c.handDrawn && (A += c.handDrawScatter + 2);
                    "H" != y ? (C = a - D / 2, b < k + w + 10 && "down" != y ? (J = !0, e && (b += A), A = b + z, this.deltaSignY = -1) : (e && (b -= A), A = b - w - z, this.deltaSignY = 1)) : (2 * z > w && (z = w / 2), A = b - w / 2, a < g + (l - g) / 2 ? (C = a + z, this.deltaSignX = -1) : (C = a - D - z, this.deltaSignX = 1));
                    A + w >= m && (A = m - w);
                    A < k && (A = k);
                    C < g && (C = g);
                    C + D > l && (C = l - D);
                    var k = A + t,
                        m = C + u,
                        t = this.shadowAlpha,
                        E = this.shadowColor,
                        u = this.borderThickness,
                        O = this.bulletSize,
                        I;
                    0 < v || 0 === z ? (0 < t && (a = d.rect(h, D, w, p, 0, u + 1, E, t, this.cornerRadius), d.isModern ? a.translate(1, 1) : a.translate(4, 4), f.push(a)), p = d.rect(h, D, w, p, this.fillAlpha, u, q, this.borderAlpha, this.cornerRadius), this.showBullet && (I = d.circle(h, O, r, this.fillAlpha), f.push(I))) : (r = [], v = [], "H" != y ? (g = a - C, g > D - z && (g = D - z), g < z && (g = z), r = [0, g - z, a - C, g + z, D, D, 0, 0], v = J ? [0, 0, b - A, 0, 0, w, w, 0] : [w, w, b - A, w, w, 0, 0, w]) : (r = b - A, r > w - z && (r = w - z), r < z && (r = z), v = [0, r - z, b - A, r + z, w, w, 0, 0], r = a < g + (l - g) / 2 ? [0, 0, C < a ? 0 : a - C, 0, 0, D, D, 0] : [D, D, C + D > a ? D : a - C, D, D, 0, 0, D]), 0 < t && (a = d.polygon(h, r, v, p, 0, u, E, t), a.translate(1, 1), f.push(a)), p = d.polygon(h, r, v, p, this.fillAlpha, u, q, this.borderAlpha));
                    this.bg = p;
                    f.push(p);
                    p.toFront();
                    d.setCN(c, p, "balloon-bg");
                    this.className && d.setCN(c, p, "balloon-bg-" + this.className);
                    h = 1 * this.deltaSignX;
                    B.left = m + "px";
                    B.top = k + "px";
                    f.translate(C - h, A);
                    p = p.getBBox();
                    this.bottom = A + w + 1;
                    this.yPos = p.y + A;
                    I && I.translate(this.pointToX - C + h, b - A);
                    b = this.animationDuration;
                    0 < this.animationDuration && !e && !isNaN(this.prevX) && (f.translate(this.prevX, this.prevY), f.animate({
                        translate: C - h + "," + A
                    }, b, "easeOutSine"), n && (B.left = this.prevTX + "px", B.top = this.prevTY + "px", this.xAnim = c.animate({
                        node: n
                    }, "left", this.prevTX, m, b, "easeOutSine", "px"), this.yAnim = c.animate({
                        node: n
                    }, "top", this.prevTY, k, b, "easeOutSine", "px")));
                    this.prevX = C - h;
                    this.prevY = A;
                    this.prevTX = m;
                    this.prevTY = k
                }
            }
        },
        followMouse: function() {
            if (this.follow && this.show) {
                var a = this.chart.mouseX - this.offsetX * this.deltaSignX,
                    b = this.chart.mouseY;
                this.pointToX = a;
                this.pointToY = b;
                if (a != this.previousX || b != this.previousY)
                    if (this.previousX = a, this.previousY = b, 0 === this.cornerRadius) this.draw();
                    else {
                        var c = this.set;
                        if (c) {
                            var e = c.getBBox(),
                                a = a - e.width / 2,
                                d = b - e.height - 10;
                            a < this.l && (a = this.l);
                            a > this.r - e.width && (a = this.r - e.width);
                            d < this.t && (d = b + 10);
                            c.translate(a, d);
                            b = this.textDiv.style;
                            b.left = a + this.horizontalPadding + "px";
                            b.top = d + this.verticalPadding + "px"
                        }
                    }
            }
        },
        changeColor: function(a) {
            this.balloonColor = a
        },
        setBounds: function(a, b, c, e) {
            this.l = a;
            this.t = b;
            this.r = c;
            this.b = e;
            this.destroyTO && clearTimeout(this.destroyTO)
        },
        showBalloon: function(a) {
            this.text = a;
            this.show = !0;
            this.destroyTO && clearTimeout(this.destroyTO);
            a = this.chart;
            this.fadeAnim1 && a.stopAnim(this.fadeAnim1);
            this.fadeAnim2 && a.stopAnim(this.fadeAnim2);
            this.draw()
        },
        hide: function(a) {
            var b = this;
            isNaN(a) && (a = b.fadeOutDuration);
            var c = b.chart;
            if (0 < a) {
                b.destroyTO && clearTimeout(b.destroyTO);
                b.destroyTO = setTimeout(function() {
                    b.destroy.call(b)
                }, 1E3 * a);
                b.follow = !1;
                b.show = !1;
                var e = b.set;
                e && (e.setAttr("opacity", b.fillAlpha), b.fadeAnim1 = e.animate({
                    opacity: 0
                }, a, "easeInSine"));
                b.textDiv && (b.fadeAnim2 = c.animate({
                    node: b.textDiv
                }, "opacity", 1, 0, a, "easeInSine", ""))
            } else b.show = !1, b.follow = !1, b.destroy()
        },
        setPosition: function(a, b, c) {
            this.pointToX = a;
            this.pointToY = b;
            c && (a == this.previousX && b == this.previousY || this.draw());
            this.previousX = a;
            this.previousY = b
        },
        followCursor: function(a) {
            var b = this;
            (b.follow = a) ? (b.pShowBullet = b.showBullet, b.showBullet = !1) : void 0 !== b.pShowBullet && (b.showBullet = b.pShowBullet);
            clearInterval(b.interval);
            var c = b.chart.mouseX,
                e = b.chart.mouseY;
            !isNaN(c) && a && (b.pointToX = c - b.offsetX * b.deltaSignX, b.pointToY = e, b.followMouse(), b.interval = setInterval(function() {
                b.followMouse.call(b)
            }, 40))
        },
        removeDiv: function() {
            if (this.textDiv) {
                var a = this.textDiv.parentNode;
                a && a.removeChild(this.textDiv)
            }
        },
        destroy: function() {
            clearInterval(this.interval);
            d.remove(this.set);
            this.removeDiv();
            this.set = null
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmCoordinateChart = d.Class({
        inherits: d.AmChart,
        construct: function(a) {
            d.AmCoordinateChart.base.construct.call(this, a);
            this.theme = a;
            this.createEvents("rollOverGraphItem", "rollOutGraphItem", "clickGraphItem", "doubleClickGraphItem", "rightClickGraphItem", "clickGraph", "rollOverGraph", "rollOutGraph");
            this.startAlpha = 1;
            this.startDuration = 0;
            this.startEffect = "elastic";
            this.sequencedAnimation = !0;
            this.colors = "#FF6600 #FCD202 #B0DE09 #0D8ECF #2A0CD0 #CD0D74 #CC0000 #00CC00 #0000CC #DDDDDD #999999 #333333 #990000".split(" ");
            this.balloonDateFormat = "MMM DD, YYYY";
            this.valueAxes = [];
            this.graphs = [];
            this.guides = [];
            this.gridAboveGraphs = !1;
            d.applyTheme(this, a, "AmCoordinateChart")
        },
        initChart: function() {
            d.AmCoordinateChart.base.initChart.call(this);
            var a = this.categoryAxis;
            a && (this.categoryAxis = d.processObject(a, d.CategoryAxis, this.theme));
            this.processValueAxes();
            this.createValueAxes();
            this.processGraphs();
            this.processGuides();
            d.VML && (this.startAlpha = 1);
            this.setLegendData(this.graphs);
            this.gridAboveGraphs && this.gridSet.toFront()
        },
        createValueAxes: function() {
            if (0 === this.valueAxes.length) {
                var a = new d.ValueAxis;
                this.addValueAxis(a)
            }
        },
        parseData: function() {
            this.processValueAxes();
            this.processGraphs()
        },
        parseSerialData: function(a) {
            var b = this.graphs,
                c, e = {},
                h = this.seriesIdField;
            h || (h = this.categoryField);
            this.chartData = [];
            if (a) {
                var f = !1,
                    g, k = this.categoryAxis,
                    l, m, n;
                k && (f = k.parseDates, l = k.forceShowField, n = k.classNameField, m = k.labelColorField, g = k.categoryFunction);
                var p, q, r = {},
                    u;
                f && (c = d.extractPeriod(k.minPeriod), p = c.period, q = c.count, u = d.getPeriodDuration(p, q));
                var t = {};
                this.lookupTable = t;
                var z, y = this.dataDateFormat,
                    v = {};
                for (z = 0; z < a.length; z++) {
                    var w = {},
                        A = a[z];
                    c = A[this.categoryField];
                    w.dataContext = A;
                    w.category = g ? g(c, A, k) : String(c);
                    l && (w.forceShow = A[l]);
                    n && (w.className = A[n]);
                    m && (w.labelColor = A[m]);
                    t[A[h]] = w;
                    if (f && (k.categoryFunction ? c = k.categoryFunction(c, A, k) : (!y || c instanceof Date || (c = c.toString() + " |"), c = d.getDate(c, y, k.minPeriod)), c = d.resetDateToMin(c, p, q, k.firstDayOfWeek), w.category = c, w.time = c.getTime(), isNaN(w.time))) continue;
                    var B = this.valueAxes;
                    w.axes = {};
                    w.x = {};
                    var C;
                    for (C = 0; C < B.length; C++) {
                        var D = B[C].id;
                        w.axes[D] = {};
                        w.axes[D].graphs = {};
                        var J;
                        for (J = 0; J < b.length; J++) {
                            c = b[J];
                            var E = c.id,
                                O = 1.1;
                            isNaN(c.gapPeriod) || (O = c.gapPeriod);
                            var I = c.periodValue;
                            if (c.valueAxis.id == D) {
                                w.axes[D].graphs[E] = {};
                                var W = {};
                                W.index = z;
                                var ea = A;
                                c.dataProvider && (ea = e);
                                W.values = this.processValues(ea, c, I);
                                !c.connect && v && v[E] && 0 < O && w.time - r[E] >= u * O && (v[E].gap = !0);
                                this.processFields(c, W, ea);
                                W.category = w.category;
                                W.serialDataItem = w;
                                W.graph = c;
                                w.axes[D].graphs[E] = W;
                                r[E] = w.time;
                                v[E] = W
                            }
                        }
                    }
                    this.chartData[z] = w
                }
            }
            for (a = 0; a < b.length; a++) c = b[a], c.dataProvider && this.parseGraphData(c)
        },
        processValues: function(a, b, c) {
            var e = {},
                h, f = !1;
            "candlestick" != b.type && "ohlc" != b.type || "" === c || (f = !0);
            for (var g = "value error open close low high".split(" "), k = 0; k < g.length; k++) {
                var l = g[k];
                "value" != l && "error" != l && f && (c = l.charAt(0).toUpperCase() + l.slice(1));
                var m = a[b[l + "Field"] + c];
                null !== m && (h = Number(m), isNaN(h) || (e[l] = h), "date" == b.valueAxis.type && void 0 !== m && (h = d.getDate(m, b.chart.dataDateFormat), e[l] = h.getTime()))
            }
            return e
        },
        parseGraphData: function(a) {
            var b = a.dataProvider,
                c = a.seriesIdField;
            c || (c = this.seriesIdField);
            c || (c = this.categoryField);
            var e;
            for (e = 0; e < b.length; e++) {
                var d = b[e],
                    f = this.lookupTable[String(d[c])],
                    g = a.valueAxis.id;
                f && (g = f.axes[g].graphs[a.id], g.serialDataItem = f, g.values = this.processValues(d, a, a.periodValue), this.processFields(a, g, d))
            }
        },
        addValueAxis: function(a) {
            a.chart = this;
            this.valueAxes.push(a);
            this.validateData()
        },
        removeValueAxesAndGraphs: function() {
            var a = this.valueAxes,
                b;
            for (b = a.length - 1; - 1 < b; b--) this.removeValueAxis(a[b])
        },
        removeValueAxis: function(a) {
            var b = this.graphs,
                c;
            for (c = b.length - 1; 0 <= c; c--) {
                var e = b[c];
                e && e.valueAxis == a && this.removeGraph(e)
            }
            b = this.valueAxes;
            for (c = b.length - 1; 0 <= c; c--) b[c] == a && b.splice(c, 1);
            this.validateData()
        },
        addGraph: function(a) {
            this.graphs.push(a);
            this.chooseGraphColor(a, this.graphs.length - 1);
            this.validateData()
        },
        removeGraph: function(a) {
            var b = this.graphs,
                c;
            for (c = b.length - 1; 0 <= c; c--) b[c] == a && (b.splice(c, 1), a.destroy());
            this.validateData()
        },
        processValueAxes: function() {
            var a = this.valueAxes,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b],
                    c = d.processObject(c, d.ValueAxis, this.theme);
                a[b] = c;
                c.chart = this;
                c.id || (c.id = "valueAxisAuto" + b + "_" + (new Date).getTime());
                void 0 === c.usePrefixes && (c.usePrefixes = this.usePrefixes)
            }
        },
        processGuides: function() {
            var a = this.guides,
                b = this.categoryAxis;
            if (a)
                for (var c = 0; c < a.length; c++) {
                    var e = a[c];
                    (void 0 !== e.category || void 0 !== e.date) && b && b.addGuide(e);
                    e.id || (e.id = "guideAuto" + c + "_" + (new Date).getTime());
                    var h = e.valueAxis;
                    h ? (d.isString(h) && (h = this.getValueAxisById(h)), h ? h.addGuide(e) : this.valueAxes[0].addGuide(e)) : isNaN(e.value) || this.valueAxes[0].addGuide(e)
                }
        },
        processGraphs: function() {
            var a = this.graphs,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b],
                    c = d.processObject(c, d.AmGraph, this.theme);
                a[b] = c;
                this.chooseGraphColor(c, b);
                c.chart = this;
                d.isString(c.valueAxis) && (c.valueAxis = this.getValueAxisById(c.valueAxis));
                c.valueAxis || (c.valueAxis = this.valueAxes[0]);
                c.id || (c.id = "graphAuto" + b + "_" + (new Date).getTime())
            }
        },
        formatString: function(a, b, c) {
            var e = b.graph,
                h = e.valueAxis;
            h.duration && b.values.value && (h = d.formatDuration(b.values.value, h.duration, "", h.durationUnits, h.maxInterval, h.numberFormatter), a = a.split("[[value]]").join(h));
            a = d.massReplace(a, {
                "[[title]]": e.title,
                "[[description]]": b.description
            });
            a = c ? d.fixNewLines(a) : d.fixBrakes(a);
            return a = d.cleanFromEmpty(a)
        },
        getBalloonColor: function(a, b, c) {
            var e = a.lineColor,
                h = a.balloonColor;
            c && (h = e);
            c = a.fillColorsR;
            "object" == typeof c ? e = c[0] : void 0 !== c && (e = c);
            b.isNegative && (c = a.negativeLineColor, a = a.negativeFillColors, "object" == typeof a ? c = a[0] : void 0 !== a && (c = a), void 0 !== c && (e = c));
            void 0 !== b.color && (e = b.color);
            void 0 !== b.lineColor && (e = b.lineColor);
            b = b.fillColors;
            void 0 !== b && (e = b, d.ifArray(b) && (e = b[0]));
            void 0 === h && (h = e);
            return h
        },
        getGraphById: function(a) {
            return d.getObjById(this.graphs, a)
        },
        getValueAxisById: function(a) {
            return d.getObjById(this.valueAxes, a)
        },
        processFields: function(a, b, c) {
            if (a.itemColors) {
                var e = a.itemColors,
                    h = b.index;
                b.color = h < e.length ? e[h] : d.randomColor()
            }
            e = "lineColor color alpha fillColors description bullet customBullet bulletSize bulletConfig url labelColor dashLength pattern gap className".split(" ");
            for (h = 0; h < e.length; h++) {
                var f = e[h],
                    g = a[f + "Field"];
                g && (g = c[g], d.isDefined(g) && (b[f] = g))
            }
            b.dataContext = c
        },
        chooseGraphColor: function(a, b) {
            if (!a.lineColorR && !a.fillColorsR) {
                if (a.lineColor) a.lineColorR = a.lineColor;
                else {
                    var c;
                    c = this.colors.length > b ? this.colors[b] : d.randomColor();
                    a.lineColorR = c
                }
                a.fillColorsR = a.fillColors ? a.fillColors : a.lineColorR;
                a.bulletBorderColorR = a.bulletBorderColor ? a.bulletBorderColor : a.useLineColorForBulletBorder ? a.lineColorR : a.bulletColor;
                a.bulletColorR = a.bulletColor ? a.bulletColor : a.lineColorR;
                if (c = this.patterns) a.pattern = c[b]
            }
        },
        handleLegendEvent: function(a) {
            var b = a.type;
            a = a.dataItem;
            if (!this.legend.data && a) {
                var c = a.hidden,
                    e = a.showBalloon;
                switch (b) {
                    case "clickMarker":
                        this.textClickEnabled && (e ? this.hideGraphsBalloon(a) : this.showGraphsBalloon(a));
                        break;
                    case "clickLabel":
                        e ? this.hideGraphsBalloon(a) : this.showGraphsBalloon(a);
                        break;
                    case "rollOverItem":
                        c || this.highlightGraph(a);
                        break;
                    case "rollOutItem":
                        c || this.unhighlightGraph();
                        break;
                    case "hideItem":
                        this.hideGraph(a);
                        break;
                    case "showItem":
                        this.showGraph(a)
                }
            }
        },
        highlightGraph: function(a) {
            var b = this.graphs,
                c, e = .2;
            this.legend && (e = this.legend.rollOverGraphAlpha);
            if (1 != e)
                for (c = 0; c < b.length; c++) {
                    var d = b[c];
                    d != a && d.changeOpacity(e)
                }
        },
        unhighlightGraph: function() {
            var a;
            this.legend && (a = this.legend.rollOverGraphAlpha);
            if (1 != a) {
                a = this.graphs;
                var b;
                for (b = 0; b < a.length; b++) a[b].changeOpacity(1)
            }
        },
        showGraph: function(a) {
            a.switchable && (a.hidden = !1, this.dataChanged = !0, "xy" != this.type && (this.marginsUpdated = !1), this.chartCreated && this.initChart())
        },
        hideGraph: function(a) {
            a.switchable && (this.dataChanged = !0, "xy" != this.type && (this.marginsUpdated = !1), a.hidden = !0, this.chartCreated && this.initChart())
        },
        hideGraphsBalloon: function(a) {
            a.showBalloon = !1;
            this.updateLegend()
        },
        showGraphsBalloon: function(a) {
            a.showBalloon = !0;
            this.updateLegend()
        },
        updateLegend: function() {
            this.legend && this.legend.invalidateSize()
        },
        resetAnimation: function() {
            var a = this.graphs;
            if (a) {
                var b;
                for (b = 0; b < a.length; b++) a[b].animationPlayed = !1
            }
        },
        animateAgain: function() {
            this.resetAnimation();
            this.validateNow()
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmSlicedChart = d.Class({
        inherits: d.AmChart,
        construct: function(a) {
            this.createEvents("rollOverSlice", "rollOutSlice", "clickSlice", "pullOutSlice", "pullInSlice", "rightClickSlice");
            d.AmSlicedChart.base.construct.call(this, a);
            this.colors = "#FF0F00 #FF6600 #FF9E01 #FCD202 #F8FF01 #B0DE09 #04D215 #0D8ECF #0D52D1 #2A0CD0 #8A0CCF #CD0D74 #754DEB #DDDDDD #999999 #333333 #000000 #57032A #CA9726 #990000 #4B0C25".split(" ");
            this.alpha = 1;
            this.groupPercent = 0;
            this.groupedTitle = "Other";
            this.groupedPulled = !1;
            this.groupedAlpha = 1;
            this.marginLeft = 0;
            this.marginBottom = this.marginTop = 10;
            this.marginRight = 0;
            this.hoverAlpha = 1;
            this.outlineColor = "#FFFFFF";
            this.outlineAlpha = 0;
            this.outlineThickness = 1;
            this.startAlpha = 0;
            this.startDuration = 1;
            this.startEffect = "bounce";
            this.sequencedAnimation = !0;
            this.pullOutDuration = 1;
            this.pullOutEffect = "bounce";
            this.pullOnHover = this.pullOutOnlyOne = !1;
            this.labelsEnabled = !0;
            this.labelTickColor = "#000000";
            this.labelTickAlpha = .2;
            this.hideLabelsPercent = 0;
            this.urlTarget = "_self";
            this.autoMarginOffset = 10;
            this.gradientRatio = [];
            this.maxLabelWidth = 200;
            d.applyTheme(this, a, "AmSlicedChart")
        },
        initChart: function() {
            d.AmSlicedChart.base.initChart.call(this);
            this.dataChanged && (this.parseData(), this.dispatchDataUpdated = !0, this.dataChanged = !1, this.setLegendData(this.chartData));
            this.drawChart()
        },
        handleLegendEvent: function(a) {
            var b = a.type,
                c = a.dataItem,
                e = this.legend;
            if (!e.data && c) {
                var d = c.hidden;
                a = a.event;
                switch (b) {
                    case "clickMarker":
                        d || e.switchable || this.clickSlice(c, a);
                        break;
                    case "clickLabel":
                        d || this.clickSlice(c, a, !1);
                        break;
                    case "rollOverItem":
                        d || this.rollOverSlice(c, !1, a);
                        break;
                    case "rollOutItem":
                        d || this.rollOutSlice(c, a);
                        break;
                    case "hideItem":
                        this.hideSlice(c, a);
                        break;
                    case "showItem":
                        this.showSlice(c, a)
                }
            }
        },
        invalidateVisibility: function() {
            this.recalculatePercents();
            this.initChart();
            var a = this.legend;
            a && a.invalidateSize()
        },
        addEventListeners: function(a, b) {
            var c = this;
            a.mouseover(function(a) {
                c.rollOverSlice(b, !0, a)
            }).mouseout(function(a) {
                c.rollOutSlice(b, a)
            }).touchend(function(a) {
                c.rollOverSlice(b, a)
            }).touchstart(function(a) {}).mouseup(function(a) {
                c.clickSlice(b, a)
            }).contextmenu(function(a) {
                c.handleRightClick(b, a)
            })
        },
        formatString: function(a, b, c) {
            a = d.formatValue(a, b, ["value"], this.nf, "", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);
            var e = this.pf.precision;
            isNaN(this.tempPrec) || (this.pf.precision = this.tempPrec);
            a = d.formatValue(a, b, ["percents"], this.pf);
            a = d.massReplace(a, {
                "[[title]]": b.title,
                "[[description]]": b.description
            });
            this.pf.precision = e; - 1 != a.indexOf("[[") && (a = d.formatDataContextValue(a, b.dataContext));
            a = c ? d.fixNewLines(a) : d.fixBrakes(a);
            return a = d.cleanFromEmpty(a)
        },
        startSlices: function() {
            var a;
            for (a = 0; a < this.chartData.length; a++) 0 < this.startDuration && this.sequencedAnimation ? this.setStartTO(a) : this.startSlice(this.chartData[a])
        },
        setStartTO: function(a) {
            var b = this;
            a = setTimeout(function() {
                b.startSequenced.call(b)
            }, b.startDuration / b.chartData.length * 500 * a);
            b.timeOuts.push(a)
        },
        pullSlices: function(a) {
            var b = this.chartData,
                c;
            for (c = 0; c < b.length; c++) {
                var e = b[c];
                e.pulled && this.pullSlice(e, 1, a)
            }
        },
        startSequenced: function() {
            var a = this.chartData,
                b;
            for (b = 0; b < a.length; b++)
                if (!a[b].started) {
                    this.startSlice(this.chartData[b]);
                    break
                }
        },
        startSlice: function(a) {
            a.started = !0;
            var b = a.wedge,
                c = this.startDuration,
                e = a.labelSet;
            b && 0 < c && (0 < a.alpha && b.show(), b.translate(a.startX, a.startY), b.animate({
                opacity: 1,
                translate: "0,0"
            }, c, this.startEffect));
            e && 0 < c && (0 < a.alpha && e.show(), e.translate(a.startX, a.startY), e.animate({
                opacity: 1,
                translate: "0,0"
            }, c, this.startEffect))
        },
        showLabels: function() {
            var a = this.chartData,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                if (0 < c.alpha) {
                    var e = c.label;
                    e && e.show();
                    (c = c.tick) && c.show()
                }
            }
        },
        showSlice: function(a) {
            isNaN(a) ? a.hidden = !1 : this.chartData[a].hidden = !1;
            this.invalidateVisibility()
        },
        hideSlice: function(a) {
            isNaN(a) ? a.hidden = !0 : this.chartData[a].hidden = !0;
            this.hideBalloon();
            this.invalidateVisibility()
        },
        rollOverSlice: function(a, b, c) {
            isNaN(a) || (a = this.chartData[a]);
            clearTimeout(this.hoverInt);
            if (!a.hidden) {
                this.pullOnHover && this.pullSlice(a, 1);
                1 > this.hoverAlpha && a.wedge && a.wedge.attr({
                    opacity: this.hoverAlpha
                });
                var e = a.balloonX,
                    h = a.balloonY;
                a.pulled && (e += a.pullX, h += a.pullY);
                var f = this.formatString(this.balloonText, a, !0),
                    g = this.balloonFunction;
                g && (f = g(a, f));
                g = d.adjustLuminosity(a.color, -.15);
                f ? this.showBalloon(f, g, b, e, h) : this.hideBalloon();
                0 === a.value && this.hideBalloon();
                a = {
                    type: "rollOverSlice",
                    dataItem: a,
                    chart: this,
                    event: c
                };
                this.fire(a.type, a)
            }
        },
        rollOutSlice: function(a, b) {
            isNaN(a) || (a = this.chartData[a]);
            a.wedge && a.wedge.attr({
                opacity: 1
            });
            this.hideBalloon();
            var c = {
                type: "rollOutSlice",
                dataItem: a,
                chart: this,
                event: b
            };
            this.fire(c.type, c)
        },
        clickSlice: function(a, b, c) {
            isNaN(a) || (a = this.chartData[a]);
            a.pulled ? this.pullSlice(a, 0) : this.pullSlice(a, 1);
            d.getURL(a.url, this.urlTarget);
            c || (a = {
                type: "clickSlice",
                dataItem: a,
                chart: this,
                event: b
            }, this.fire(a.type, a))
        },
        handleRightClick: function(a, b) {
            isNaN(a) || (a = this.chartData[a]);
            var c = {
                type: "rightClickSlice",
                dataItem: a,
                chart: this,
                event: b
            };
            this.fire(c.type, c)
        },
        drawTicks: function() {
            var a = this.chartData,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                if (c.label && !c.skipTick) {
                    var e = c.ty,
                        e = d.line(this.container, [c.tx0, c.tx, c.tx2], [c.ty0, e, e], this.labelTickColor, this.labelTickAlpha);
                    d.setCN(this, e, this.type + "-tick");
                    d.setCN(this, e, c.className, !0);
                    c.tick = e;
                    c.wedge.push(e)
                }
            }
        },
        initialStart: function() {
            var a = this,
                b = a.startDuration,
                c = setTimeout(function() {
                    a.showLabels.call(a)
                }, 1E3 * b);
            a.timeOuts.push(c);
            a.chartCreated ? a.pullSlices(!0) : (a.startSlices(), 0 < b ? (b = setTimeout(function() {
                a.pullSlices.call(a)
            }, 1200 * b), a.timeOuts.push(b)) : a.pullSlices(!0))
        },
        pullSlice: function(a, b, c) {
            var e = this.pullOutDuration;
            !0 === c && (e = 0);
            if (c = a.wedge) 0 < e ? (c.animate({
                translate: b * a.pullX + "," + b * a.pullY
            }, e, this.pullOutEffect), a.labelSet && a.labelSet.animate({
                translate: b * a.pullX + "," + b * a.pullY
            }, e, this.pullOutEffect)) : (a.labelSet && a.labelSet.translate(b * a.pullX, b * a.pullY), c.translate(b * a.pullX, b * a.pullY));
            1 == b ? (a.pulled = !0, this.pullOutOnlyOne && this.pullInAll(a.index), a = {
                type: "pullOutSlice",
                dataItem: a,
                chart: this
            }) : (a.pulled = !1, a = {
                type: "pullInSlice",
                dataItem: a,
                chart: this
            });
            this.fire(a.type, a)
        },
        pullInAll: function(a) {
            var b = this.chartData,
                c;
            for (c = 0; c < this.chartData.length; c++) c != a && b[c].pulled && this.pullSlice(b[c], 0)
        },
        pullOutAll: function() {
            var a = this.chartData,
                b;
            for (b = 0; b < a.length; b++) a[b].pulled || this.pullSlice(a[b], 1)
        },
        parseData: function() {
            var a = [];
            this.chartData = a;
            var b = this.dataProvider;
            isNaN(this.pieAlpha) || (this.alpha = this.pieAlpha);
            if (void 0 !== b) {
                var c = b.length,
                    e = 0,
                    h, f, g;
                for (h = 0; h < c; h++) {
                    f = {};
                    var k = b[h];
                    f.dataContext = k;
                    null !== k[this.valueField] && (f.value = Number(k[this.valueField]));
                    (g = k[this.titleField]) || (g = "");
                    f.title = g;
                    f.pulled = d.toBoolean(k[this.pulledField], !1);
                    (g = k[this.descriptionField]) || (g = "");
                    f.description = g;
                    f.labelRadius = Number(k[this.labelRadiusField]);
                    f.switchable = !0;
                    f.className = k[this.classNameField];
                    f.url = k[this.urlField];
                    g = k[this.patternField];
                    !g && this.patterns && (g = this.patterns[h]);
                    f.pattern = g;
                    f.visibleInLegend = d.toBoolean(k[this.visibleInLegendField], !0);
                    g = k[this.alphaField];
                    f.alpha = void 0 !== g ? Number(g) : this.alpha;
                    g = k[this.colorField];
                    void 0 !== g && (f.color = g);
                    f.labelColor = d.toColor(k[this.labelColorField]);
                    e += f.value;
                    f.hidden = !1;
                    a[h] = f
                }
                for (h = b = 0; h < c; h++) f = a[h], f.percents = f.value / e * 100, f.percents < this.groupPercent && b++;
                1 < b && (this.groupValue = 0, this.removeSmallSlices(), a.push({
                    title: this.groupedTitle,
                    value: this.groupValue,
                    percents: this.groupValue / e * 100,
                    pulled: this.groupedPulled,
                    color: this.groupedColor,
                    url: this.groupedUrl,
                    description: this.groupedDescription,
                    alpha: this.groupedAlpha,
                    pattern: this.groupedPattern,
                    className: this.groupedClassName,
                    dataContext: {}
                }));
                c = this.baseColor;
                c || (c = this.pieBaseColor);
                e = this.brightnessStep;
                e || (e = this.pieBrightnessStep);
                for (h = 0; h < a.length; h++) c ? g = d.adjustLuminosity(c, h * e / 100) : (g = this.colors[h], void 0 === g && (g = d.randomColor())), void 0 === a[h].color && (a[h].color = g);
                this.recalculatePercents()
            }
        },
        recalculatePercents: function() {
            var a = this.chartData,
                b = 0,
                c, e;
            for (c = 0; c < a.length; c++) e = a[c], !e.hidden && 0 < e.value && (b += e.value);
            for (c = 0; c < a.length; c++) e = this.chartData[c], e.percents = !e.hidden && 0 < e.value ? 100 * e.value / b : 0
        },
        removeSmallSlices: function() {
            var a = this.chartData,
                b;
            for (b = a.length - 1; 0 <= b; b--) a[b].percents < this.groupPercent && (this.groupValue += a[b].value, a.splice(b, 1))
        },
        animateAgain: function() {
            var a = this;
            a.startSlices();
            for (var b = 0; b < a.chartData.length; b++) {
                var c = a.chartData[b];
                c.started = !1;
                var e = c.wedge;
                e && e.translate(c.startX, c.startY);
                (e = c.labelSet) && e.translate(c.startX, c.startY)
            }
            b = a.startDuration;
            0 < b ? (b = setTimeout(function() {
                a.pullSlices.call(a)
            }, 1200 * b), a.timeOuts.push(b)) : a.pullSlices()
        },
        measureMaxLabel: function() {
            var a = this.chartData,
                b = 0,
                c;
            for (c = 0; c < a.length; c++) {
                var e = a[c],
                    h = this.formatString(this.labelText, e),
                    f = this.labelFunction;
                f && (h = f(e, h));
                e = d.text(this.container, h, this.color, this.fontFamily, this.fontSize);
                h = e.getBBox().width;
                h > b && (b = h);
                e.remove()
            }
            return b
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmRectangularChart = d.Class({
        inherits: d.AmCoordinateChart,
        construct: function(a) {
            d.AmRectangularChart.base.construct.call(this, a);
            this.theme = a;
            this.createEvents("zoomed");
            this.marginRight = this.marginBottom = this.marginTop = this.marginLeft = 20;
            this.verticalPosition = this.horizontalPosition = this.depth3D = this.angle = 0;
            this.heightMultiplier = this.widthMultiplier = 1;
            this.plotAreaFillColors = "#FFFFFF";
            this.plotAreaFillAlphas = 0;
            this.plotAreaBorderColor = "#000000";
            this.plotAreaBorderAlpha = 0;
            this.zoomOutButtonImageSize = 19;
            this.zoomOutButtonImage = "lens";
            this.zoomOutText = "Show all";
            this.zoomOutButtonColor = "#e5e5e5";
            this.zoomOutButtonAlpha = 0;
            this.zoomOutButtonRollOverAlpha = 1;
            this.zoomOutButtonPadding = 8;
            this.trendLines = [];
            this.autoMargins = !0;
            this.marginsUpdated = !1;
            this.autoMarginOffset = 10;
            d.applyTheme(this, a, "AmRectangularChart")
        },
        initChart: function() {
            d.AmRectangularChart.base.initChart.call(this);
            this.updateDxy();
            var a = !0;
            !this.marginsUpdated && this.autoMargins && (this.resetMargins(), a = !1);
            this.processScrollbars();
            this.updateMargins();
            this.updatePlotArea();
            this.updateScrollbars();
            this.updateTrendLines();
            this.updateChartCursor();
            this.updateValueAxes();
            a && (this.scrollbarOnly || this.updateGraphs())
        },
        drawChart: function() {
            d.AmRectangularChart.base.drawChart.call(this);
            this.drawPlotArea();
            if (d.ifArray(this.chartData)) {
                var a = this.chartCursor;
                a && a.draw()
            }
        },
        resetMargins: function() {
            var a = {},
                b;
            if ("xy" == this.type) {
                var c = this.xAxes,
                    e = this.yAxes;
                for (b = 0; b < c.length; b++) {
                    var d = c[b];
                    d.ignoreAxisWidth || (d.setOrientation(!0), d.fixAxisPosition(), a[d.position] = !0)
                }
                for (b = 0; b < e.length; b++) c = e[b], c.ignoreAxisWidth || (c.setOrientation(!1), c.fixAxisPosition(), a[c.position] = !0)
            } else {
                e = this.valueAxes;
                for (b = 0; b < e.length; b++) c = e[b], c.ignoreAxisWidth || (c.setOrientation(this.rotate), c.fixAxisPosition(), a[c.position] = !0);
                (b = this.categoryAxis) && !b.ignoreAxisWidth && (b.setOrientation(!this.rotate), b.fixAxisPosition(), b.fixAxisPosition(), a[b.position] = !0)
            }
            a.left && (this.marginLeft = 0);
            a.right && (this.marginRight = 0);
            a.top && (this.marginTop = 0);
            a.bottom && (this.marginBottom = 0);
            this.fixMargins = a
        },
        measureMargins: function() {
            var a = this.valueAxes,
                b, c = this.autoMarginOffset,
                e = this.fixMargins,
                d = this.realWidth,
                f = this.realHeight,
                g = c,
                k = c,
                l = d;
            b = f;
            var m;
            for (m = 0; m < a.length; m++) a[m].handleSynchronization(), b = this.getAxisBounds(a[m], g, l, k, b), g = Math.round(b.l), l = Math.round(b.r), k = Math.round(b.t), b = Math.round(b.b);
            if (a = this.categoryAxis) b = this.getAxisBounds(a, g, l, k, b), g = Math.round(b.l), l = Math.round(b.r), k = Math.round(b.t), b = Math.round(b.b);
            e.left && g < c && (this.marginLeft = Math.round(-g + c));
            e.right && l >= d - c && (this.marginRight = Math.round(l - d + c));
            e.top && k < c + this.titleHeight && (this.marginTop = Math.round(this.marginTop - k + c + this.titleHeight));
            e.bottom && b > f - c && (this.marginBottom = Math.round(this.marginBottom + b - f + c));
            this.initChart()
        },
        getAxisBounds: function(a, b, c, e, d) {
            if (!a.ignoreAxisWidth) {
                var f = a.labelsSet,
                    g = a.tickLength;
                a.inside && (g = 0);
                if (f) switch (f = a.getBBox(), a.position) {
                    case "top":
                        a = f.y;
                        e > a && (e = a);
                        break;
                    case "bottom":
                        a = f.y + f.height;
                        d < a && (d = a);
                        break;
                    case "right":
                        a = f.x + f.width + g + 3;
                        c < a && (c = a);
                        break;
                    case "left":
                        a = f.x - g, b > a && (b = a)
                }
            }
            return {
                l: b,
                t: e,
                r: c,
                b: d
            }
        },
        drawZoomOutButton: function() {
            var a = this;
            if (!a.zbSet) {
                var b = a.container.set();
                a.zoomButtonSet.push(b);
                var c = a.color,
                    e = a.fontSize,
                    h = a.zoomOutButtonImageSize,
                    f = a.zoomOutButtonImage.replace(/\.[a-z]*$/i, ""),
                    g = d.lang.zoomOutText || a.zoomOutText,
                    k = a.zoomOutButtonColor,
                    l = a.zoomOutButtonAlpha,
                    m = a.zoomOutButtonFontSize,
                    n = a.zoomOutButtonPadding;
                isNaN(m) || (e = m);
                (m = a.zoomOutButtonFontColor) && (c = m);
                var m = a.zoomOutButton,
                    p;
                m && (m.fontSize && (e = m.fontSize), m.color && (c = m.color), m.backgroundColor && (k = m.backgroundColor), isNaN(m.backgroundAlpha) || (a.zoomOutButtonRollOverAlpha = m.backgroundAlpha));
                var q = m = 0;
                void 0 !== a.pathToImages && f && (p = a.container.image(a.pathToImages + f + a.extension, 0, 0, h, h), d.setCN(a, p, "zoom-out-image"), b.push(p), p = p.getBBox(), m = p.width + 5);
                void 0 !== g && (c = d.text(a.container, g, c, a.fontFamily, e, "start"), d.setCN(a, c, "zoom-out-label"), e = c.getBBox(), q = p ? p.height / 2 - 3 : e.height / 2, c.translate(m, q), b.push(c));
                p = b.getBBox();
                c = 1;
                d.isModern || (c = 0);
                k = d.rect(a.container, p.width + 2 * n + 5, p.height + 2 * n - 2, k, 1, 1, k, c);
                k.setAttr("opacity", l);
                k.translate(-n, -n);
                d.setCN(a, k, "zoom-out-bg");
                b.push(k);
                k.toBack();
                a.zbBG = k;
                p = k.getBBox();
                b.translate(a.marginLeftReal + a.plotAreaWidth - p.width + n, a.marginTopReal + n);
                b.hide();
                b.mouseover(function() {
                    a.rollOverZB()
                }).mouseout(function() {
                    a.rollOutZB()
                }).click(function() {
                    a.clickZB()
                }).touchstart(function() {
                    a.rollOverZB()
                }).touchend(function() {
                    a.rollOutZB();
                    a.clickZB()
                });
                for (l = 0; l < b.length; l++) b[l].attr({
                    cursor: "pointer"
                });
                a.zbSet = b
            }
        },
        rollOverZB: function() {
            this.zbBG.setAttr("opacity", this.zoomOutButtonRollOverAlpha)
        },
        rollOutZB: function() {
            this.zbBG.setAttr("opacity", this.zoomOutButtonAlpha)
        },
        clickZB: function() {
            this.zoomOut()
        },
        zoomOut: function() {
            this.updateScrollbar = !0;
            this.zoom()
        },
        drawPlotArea: function() {
            var a = this.dx,
                b = this.dy,
                c = this.marginLeftReal,
                e = this.marginTopReal,
                h = this.plotAreaWidth - 1,
                f = this.plotAreaHeight - 1,
                g = this.plotAreaFillColors,
                k = this.plotAreaFillAlphas,
                l = this.plotAreaBorderColor,
                m = this.plotAreaBorderAlpha;
            "object" == typeof k && (k = k[0]);
            g = d.polygon(this.container, [0, h, h, 0, 0], [0, 0, f, f, 0], g, k, 1, l, m, this.plotAreaGradientAngle);
            d.setCN(this, g, "plot-area");
            g.translate(c + a, e + b);
            this.set.push(g);
            0 !== a && 0 !== b && (g = this.plotAreaFillColors, "object" == typeof g && (g = g[0]), g = d.adjustLuminosity(g, -.15), h = d.polygon(this.container, [0, a, h + a, h, 0], [0, b, b, 0, 0], g, k, 1, l, m), d.setCN(this, h, "plot-area-bottom"), h.translate(c, e + f), this.set.push(h), a = d.polygon(this.container, [0, 0, a, a, 0], [0, f, f + b, b, 0], g, k, 1, l, m), d.setCN(this, a, "plot-area-left"), a.translate(c, e), this.set.push(a));
            (c = this.bbset) && this.scrollbarOnly && c.remove()
        },
        updatePlotArea: function() {
            var a = this.updateWidth(),
                b = this.updateHeight(),
                c = this.container;
            this.realWidth = a;
            this.realWidth = b;
            c && this.container.setSize(a, b);
            a = a - this.marginLeftReal - this.marginRightReal - this.dx;
            b = b - this.marginTopReal - this.marginBottomReal;
            1 > a && (a = 1);
            1 > b && (b = 1);
            this.plotAreaWidth = Math.round(a);
            this.plotAreaHeight = Math.round(b)
        },
        updateDxy: function() {
            this.dx = Math.round(this.depth3D * Math.cos(this.angle * Math.PI / 180));
            this.dy = Math.round(-this.depth3D * Math.sin(this.angle * Math.PI / 180));
            this.d3x = Math.round(this.columnSpacing3D * Math.cos(this.angle * Math.PI / 180));
            this.d3y = Math.round(-this.columnSpacing3D * Math.sin(this.angle * Math.PI / 180))
        },
        updateMargins: function() {
            var a = this.getTitleHeight();
            this.titleHeight = a;
            this.marginTopReal = this.marginTop - this.dy;
            this.fixMargins && !this.fixMargins.top && (this.marginTopReal += a);
            this.marginBottomReal = this.marginBottom;
            this.marginLeftReal = this.marginLeft;
            this.marginRightReal = this.marginRight
        },
        updateValueAxes: function() {
            var a = this.valueAxes,
                b = this.marginLeftReal,
                c = this.marginTopReal,
                e = this.plotAreaHeight,
                h = this.plotAreaWidth,
                f;
            for (f = 0; f < a.length; f++) {
                var g = a[f];
                g.axisRenderer = d.RecAxis;
                g.guideFillRenderer = d.RecFill;
                g.axisItemRenderer = d.RecItem;
                g.dx = this.dx;
                g.dy = this.dy;
                g.viW = h - 1;
                g.viH = e - 1;
                g.marginsChanged = !0;
                g.viX = b;
                g.viY = c;
                this.updateObjectSize(g)
            }
        },
        updateObjectSize: function(a) {
            a.width = (this.plotAreaWidth - 1) * this.widthMultiplier;
            a.height = (this.plotAreaHeight - 1) * this.heightMultiplier;
            a.x = this.marginLeftReal + this.horizontalPosition;
            a.y = this.marginTopReal + this.verticalPosition
        },
        updateGraphs: function() {
            var a = this.graphs,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                c.x = this.marginLeftReal + this.horizontalPosition;
                c.y = this.marginTopReal + this.verticalPosition;
                c.width = this.plotAreaWidth * this.widthMultiplier;
                c.height = this.plotAreaHeight * this.heightMultiplier;
                c.index = b;
                c.dx = this.dx;
                c.dy = this.dy;
                c.rotate = this.rotate
            }
        },
        updateChartCursor: function() {
            var a = this.chartCursor;
            a && (a = d.processObject(a, d.ChartCursor, this.theme), this.addChartCursor(a), a.x = this.marginLeftReal, a.y = this.marginTopReal, a.width = this.plotAreaWidth - 1, a.height = this.plotAreaHeight - 1, a.chart = this)
        },
        processScrollbars: function() {
            var a = this.chartScrollbar;
            a && (a = d.processObject(a, d.ChartScrollbar, this.theme), this.addChartScrollbar(a))
        },
        updateScrollbars: function() {},
        addChartCursor: function(a) {
            d.callMethod("destroy", [this.chartCursor]);
            a && (this.listenTo(a, "changed", this.handleCursorChange), this.listenTo(a, "zoomed", this.handleCursorZoom));
            this.chartCursor = a
        },
        removeChartCursor: function() {
            d.callMethod("destroy", [this.chartCursor]);
            this.chartCursor = null
        },
        zoomTrendLines: function() {
            var a = this.trendLines,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                c.valueAxis.recalculateToPercents ? c.set && c.set.hide() : (c.x = this.marginLeftReal + this.horizontalPosition, c.y = this.marginTopReal + this.verticalPosition, c.draw())
            }
        },
        addTrendLine: function(a) {
            this.trendLines.push(a)
        },
        removeTrendLine: function(a) {
            var b = this.trendLines,
                c;
            for (c = b.length - 1; 0 <= c; c--) b[c] == a && b.splice(c, 1)
        },
        adjustMargins: function(a, b) {
            var c = a.position,
                e = a.scrollbarHeight + a.offset;
            a.enabled && ("top" == c ? b ? this.marginLeftReal += e : this.marginTopReal += e : b ? this.marginRightReal += e : this.marginBottomReal += e)
        },
        getScrollbarPosition: function(a, b, c) {
            var e = "bottom",
                d = "top";
            a.oppositeAxis || (d = e, e = "top");
            a.position = b ? "bottom" == c || "left" == c ? e : d : "top" == c || "right" == c ? e : d
        },
        updateChartScrollbar: function(a, b) {
            if (a) {
                a.rotate = b;
                var c = this.marginTopReal,
                    e = this.marginLeftReal,
                    d = a.scrollbarHeight,
                    f = this.dx,
                    g = this.dy,
                    k = a.offset;
                "top" == a.position ? b ? (a.y = c, a.x = e - d - k) : (a.y = c - d + g - k, a.x = e + f) : b ? (a.y = c + g, a.x = e + this.plotAreaWidth + f + k) : (a.y = c + this.plotAreaHeight + k, a.x = this.marginLeftReal)
            }
        },
        showZB: function(a) {
            var b = this.zbSet;
            a && (b = this.zoomOutText, "" !== b && b && this.drawZoomOutButton());
            if (b = this.zbSet) this.zoomButtonSet.push(b), a ? b.show() : b.hide(), this.rollOutZB()
        },
        handleReleaseOutside: function(a) {
            d.AmRectangularChart.base.handleReleaseOutside.call(this, a);
            (a = this.chartCursor) && a.handleReleaseOutside && a.handleReleaseOutside()
        },
        handleMouseDown: function(a) {
            d.AmRectangularChart.base.handleMouseDown.call(this, a);
            var b = this.chartCursor;
            b && b.handleMouseDown && b.handleMouseDown(a)
        },
        handleCursorChange: function() {},
        update: function() {
            d.AmRectangularChart.base.update.call(this);
            this.chartCursor && this.chartCursor.update && this.chartCursor.update()
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.TrendLine = d.Class({
        construct: function(a) {
            this.cname = "TrendLine";
            this.createEvents("click");
            this.isProtected = !1;
            this.dashLength = 0;
            this.lineColor = "#00CC00";
            this.lineThickness = this.lineAlpha = 1;
            d.applyTheme(this, a, this.cname)
        },
        draw: function() {
            var a = this;
            a.destroy();
            var b = a.chart,
                c = b.container,
                e, h, f, g, k = a.categoryAxis,
                l = a.initialDate,
                m = a.initialCategory,
                n = a.finalDate,
                p = a.finalCategory,
                q = a.valueAxis,
                r = a.valueAxisX,
                u = a.initialXValue,
                t = a.finalXValue,
                z = a.initialValue,
                y = a.finalValue,
                v = q.recalculateToPercents,
                w = b.dataDateFormat;
            k && (l && (l = d.getDate(l, w, "fff"), a.initialDate = l, e = k.dateToCoordinate(l)), m && (e = k.categoryToCoordinate(m)), n && (n = d.getDate(n, w, "fff"), a.finalDate = n, h = k.dateToCoordinate(n)), p && (h = k.categoryToCoordinate(p)));
            r && !v && (isNaN(u) || (e = r.getCoordinate(u)), isNaN(t) || (h = r.getCoordinate(t)));
            q && !v && (isNaN(z) || (f = q.getCoordinate(z)), isNaN(y) || (g = q.getCoordinate(y)));
            if (!(isNaN(e) || isNaN(h) || isNaN(f) || isNaN(f))) {
                b.rotate ? (k = [f, g], g = [e, h]) : (k = [e, h], g = [f, g]);
                l = a.lineColor;
                f = d.line(c, k, g, l, a.lineAlpha, a.lineThickness, a.dashLength);
                e = k;
                h = g;
                p = k[1] - k[0];
                q = g[1] - g[0];
                0 === p && (p = .01);
                0 === q && (q = .01);
                m = p / Math.abs(p);
                n = q / Math.abs(q);
                q = p * q / Math.abs(p * q) * Math.sqrt(Math.pow(p, 2) + Math.pow(q, 2));
                p = Math.asin(p / q);
                q = 90 * Math.PI / 180 - p;
                p = Math.abs(5 * Math.cos(q));
                q = Math.abs(5 * Math.sin(q));
                e.push(k[1] - m * q, k[0] - m * q);
                h.push(g[1] + n * p, g[0] + n * p);
                k = d.polygon(c, e, h, l, .005, 0);
                c = c.set([k, f]);
                c.translate(b.marginLeftReal, b.marginTopReal);
                b.trendLinesSet.push(c);
                d.setCN(b, f, "trend-line");
                d.setCN(b, f, "trend-line-" + a.id);
                a.line = f;
                a.set = c;
                if (f = a.initialImage) f = d.processObject(f, d.Image, a.theme), f.chart = b, f.draw(), f.translate(e[0] + f.offsetX, h[0] + f.offsetY), c.push(f.set);
                if (f = a.finalImage) f = d.processObject(f, d.Image, a.theme), f.chart = b, f.draw(), f.translate(e[1] + f.offsetX, h[1] + f.offsetY), c.push(f.set);
                k.mouseup(function() {
                    a.handleLineClick()
                }).mouseover(function() {
                    a.handleLineOver()
                }).mouseout(function() {
                    a.handleLineOut()
                });
                k.touchend && k.touchend(function() {
                    a.handleLineClick()
                });
                c.clipRect(0, 0, b.plotAreaWidth, b.plotAreaHeight)
            }
        },
        handleLineClick: function() {
            var a = {
                type: "click",
                trendLine: this,
                chart: this.chart
            };
            this.fire(a.type, a)
        },
        handleLineOver: function() {
            var a = this.rollOverColor;
            void 0 !== a && this.line.attr({
                stroke: a
            })
        },
        handleLineOut: function() {
            this.line.attr({
                stroke: this.lineColor
            })
        },
        destroy: function() {
            d.remove(this.set)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.Image = d.Class({
        construct: function(a) {
            this.cname = "Image";
            this.height = this.width = 20;
            this.rotation = this.offsetY = this.offsetX = 0;
            this.balloonColor = this.color = "#000000";
            this.opacity = 1;
            d.applyTheme(this, a, this.cname)
        },
        draw: function() {
            var a = this;
            a.set && a.set.remove();
            var b = a.chart.container;
            a.set = b.set();
            var c, e;
            a.url ? (c = b.image(a.url, 0, 0, a.width, a.height), e = 1) : a.svgPath && (c = b.path(a.svgPath), c.setAttr("fill", a.color), c.setAttr("stroke", a.outlineColor), b = c.getBBox(), e = Math.min(a.width / b.width, a.height / b.height));
            c && (c.setAttr("opacity", a.opacity), a.set.rotate(a.rotation), c.translate(-a.width / 2, -a.height / 2, e), a.balloonText && c.mouseover(function(b) {
                a.chart.showBalloon(a.balloonText, a.balloonColor, !0)
            }).mouseout(function(b) {
                a.chart.hideBalloon()
            }).touchend(function(b) {
                a.chart.hideBalloon()
            }).touchstart(function(b) {
                a.chart.showBalloon(a.balloonText, a.balloonColor, !0)
            }), a.set.push(c))
        },
        translate: function(a, b) {
            this.set && this.set.translate(a, b)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.circle = function(a, b, c, e, h, f, g, k, l) {
        0 >= b && (b = .001);
        if (void 0 == h || 0 === h) h = .01;
        void 0 === f && (f = "#000000");
        void 0 === g && (g = 0);
        e = {
            fill: c,
            stroke: f,
            "fill-opacity": e,
            "stroke-width": h,
            "stroke-opacity": g
        };
        a = isNaN(l) ? a.circle(0, 0, b).attr(e) : a.ellipse(0, 0, b, l).attr(e);
        k && a.gradient("radialGradient", [c, d.adjustLuminosity(c, -.6)]);
        return a
    };
    d.text = function(a, b, c, e, h, f, g, k) {
        f || (f = "middle");
        "right" == f && (f = "end");
        "left" == f && (f = "start");
        isNaN(k) && (k = 1);
        void 0 !== b && (b = String(b), d.isIE && !d.isModern && (b = b.replace("&amp;", "&"), b = b.replace("&", "&amp;")));
        c = {
            fill: c,
            "font-family": e,
            "font-size": h + "px",
            opacity: k
        };
        !0 === g && (c["font-weight"] = "bold");
        c["text-anchor"] = f;
        return a.text(b, c)
    };
    d.polygon = function(a, b, c, e, h, f, g, k, l, m, n) {
        isNaN(f) && (f = .01);
        isNaN(k) && (k = h);
        var p = e,
            q = !1;
        "object" == typeof p && 1 < p.length && (q = !0, p = p[0]);
        void 0 === g && (g = p);
        h = {
            fill: p,
            stroke: g,
            "fill-opacity": h,
            "stroke-width": f,
            "stroke-opacity": k
        };
        void 0 !== n && 0 < n && (h["stroke-dasharray"] = n);
        n = d.dx;
        f = d.dy;
        a.handDrawn && (c = d.makeHD(b, c, a.handDrawScatter), b = c[0], c = c[1]);
        g = Math.round;
        m && (g = d.doNothing);
        m = "M" + (g(b[0]) + n) + "," + (g(c[0]) + f);
        for (k = 1; k < b.length; k++) m += " L" + (g(b[k]) + n) + "," + (g(c[k]) + f);
        a = a.path(m + " Z").attr(h);
        q && a.gradient("linearGradient", e, l);
        return a
    };
    d.rect = function(a, b, c, e, h, f, g, k, l, m, n) {
        if (isNaN(b) || isNaN(c)) return a.set();
        isNaN(f) && (f = 0);
        void 0 === l && (l = 0);
        void 0 === m && (m = 270);
        isNaN(h) && (h = 0);
        var p = e,
            q = !1;
        "object" == typeof p && (p = p[0], q = !0);
        void 0 === g && (g = p);
        void 0 === k && (k = h);
        b = Math.round(b);
        c = Math.round(c);
        var r = 0,
            u = 0;
        0 > b && (b = Math.abs(b), r = -b);
        0 > c && (c = Math.abs(c), u = -c);
        r += d.dx;
        u += d.dy;
        h = {
            fill: p,
            stroke: g,
            "fill-opacity": h,
            "stroke-opacity": k
        };
        void 0 !== n && 0 < n && (h["stroke-dasharray"] = n);
        a = a.rect(r, u, b, c, l, f).attr(h);
        q && a.gradient("linearGradient", e, m);
        return a
    };
    d.bullet = function(a, b, c, e, h, f, g, k, l, m, n, p) {
        var q;
        "circle" == b && (b = "round");
        switch (b) {
            case "round":
                q = d.circle(a, c / 2, e, h, f, g, k);
                break;
            case "square":
                q = d.polygon(a, [-c / 2, c / 2, c / 2, -c / 2], [c / 2, c / 2, -c / 2, -c / 2], e, h, f, g, k, m - 180);
                break;
            case "rectangle":
                q = d.polygon(a, [-c, c, c, -c], [c / 2, c / 2, -c / 2, -c / 2], e, h, f, g, k, m - 180);
                break;
            case "diamond":
                q = d.polygon(a, [-c / 2, 0, c / 2, 0], [0, -c / 2, 0, c / 2], e, h, f, g, k);
                break;
            case "triangleUp":
                q = d.triangle(a, c, 0, e, h, f, g, k);
                break;
            case "triangleDown":
                q = d.triangle(a, c, 180, e, h, f, g, k);
                break;
            case "triangleLeft":
                q = d.triangle(a, c, 270, e, h, f, g, k);
                break;
            case "triangleRight":
                q = d.triangle(a, c, 90, e, h, f, g, k);
                break;
            case "bubble":
                q = d.circle(a, c / 2, e, h, f, g, k, !0);
                break;
            case "line":
                q = d.line(a, [-c / 2, c / 2], [0, 0], e, h, f, g, k);
                break;
            case "yError":
                q = a.set();
                q.push(d.line(a, [0, 0], [-c / 2, c / 2], e, h, f));
                q.push(d.line(a, [-l, l], [-c / 2, -c / 2], e, h, f));
                q.push(d.line(a, [-l, l], [c / 2, c / 2], e, h, f));
                break;
            case "xError":
                q = a.set(), q.push(d.line(a, [-c / 2, c / 2], [0, 0], e, h, f)), q.push(d.line(a, [-c / 2, -c / 2], [-l, l], e, h, f)), q.push(d.line(a, [c / 2, c / 2], [-l, l], e, h, f))
        }
        q && q.pattern(n, NaN, p);
        return q
    };
    d.triangle = function(a, b, c, e, d, f, g, k) {
        if (void 0 === f || 0 === f) f = 1;
        void 0 === g && (g = "#000");
        void 0 === k && (k = 0);
        e = {
            fill: e,
            stroke: g,
            "fill-opacity": d,
            "stroke-width": f,
            "stroke-opacity": k
        };
        b /= 2;
        var l;
        0 === c && (l = " M" + -b + "," + b + " L0," + -b + " L" + b + "," + b + " Z");
        180 == c && (l = " M" + -b + "," + -b + " L0," + b + " L" + b + "," + -b + " Z");
        90 == c && (l = " M" + -b + "," + -b + " L" + b + ",0 L" + -b + "," + b + " Z");
        270 == c && (l = " M" + -b + ",0 L" + b + "," + b + " L" + b + "," + -b + " Z");
        return a.path(l).attr(e)
    };
    d.line = function(a, b, c, e, h, f, g, k, l, m, n) {
        if (a.handDrawn && !n) return d.handDrawnLine(a, b, c, e, h, f, g, k, l, m, n);
        f = {
            fill: "none",
            "stroke-width": f
        };
        void 0 !== g && 0 < g && (f["stroke-dasharray"] = g);
        isNaN(h) || (f["stroke-opacity"] = h);
        e && (f.stroke = e);
        e = Math.round;
        m && (e = d.doNothing);
        m = d.dx;
        h = d.dy;
        g = "M" + (e(b[0]) + m) + "," + (e(c[0]) + h);
        for (k = 1; k < b.length; k++) g += " L" + (e(b[k]) + m) + "," + (e(c[k]) + h);
        if (d.VML) return a.path(g, void 0, !0).attr(f);
        l && (g += " M0,0 L0,0");
        return a.path(g).attr(f)
    };
    d.makeHD = function(a, b, c) {
        for (var e = [], d = [], f = 1; f < a.length; f++)
            for (var g = Number(a[f - 1]), k = Number(b[f - 1]), l = Number(a[f]), m = Number(b[f]), n = Math.sqrt(Math.pow(l - g, 2) + Math.pow(m - k, 2)), n = Math.round(n / 50) + 1, l = (l - g) / n, m = (m - k) / n, p = 0; p <= n; p++) {
                var q = g + p * l + Math.random() * c,
                    r = k + p * m + Math.random() * c;
                e.push(q);
                d.push(r)
            }
        return [e, d]
    };
    d.handDrawnLine = function(a, b, c, e, h, f, g, k, l, m) {
        var n, p = a.set();
        for (n = 1; n < b.length; n++)
            for (var q = [b[n - 1], b[n]], r = [c[n - 1], c[n]], r = d.makeHD(q, r, a.handDrawScatter), q = r[0], r = r[1], u = 1; u < q.length; u++) p.push(d.line(a, [q[u - 1], q[u]], [r[u - 1], r[u]], e, h, f + Math.random() * a.handDrawThickness - a.handDrawThickness / 2, g, k, l, m, !0));
        return p
    };
    d.doNothing = function(a) {
        return a
    };
    d.wedge = function(a, b, c, e, h, f, g, k, l, m, n, p, q) {
        var r = Math.round;
        f = r(f);
        g = r(g);
        k = r(k);
        var u = r(g / f * k),
            t = d.VML,
            z = 359.5 + f / 100;
        359.94 < z && (z = 359.94);
        h >= z && (h = z);
        var y = 1 / 180 * Math.PI,
            z = b + Math.sin(e * y) * k,
            v = c - Math.cos(e * y) * u,
            w = b + Math.sin(e * y) * f,
            A = c - Math.cos(e * y) * g,
            B = b + Math.sin((e + h) * y) * f,
            C = c - Math.cos((e + h) * y) * g,
            D = b + Math.sin((e + h) * y) * k,
            y = c - Math.cos((e + h) * y) * u,
            J = {
                fill: d.adjustLuminosity(m.fill, -.2),
                "stroke-opacity": 0,
                "fill-opacity": m["fill-opacity"]
            },
            E = 0;
        180 < Math.abs(h) && (E = 1);
        e = a.set();
        var O;
        t && (z = r(10 * z), w = r(10 * w), B = r(10 * B), D = r(10 * D), v = r(10 * v), A = r(10 * A), C = r(10 * C), y = r(10 * y), b = r(10 * b), l = r(10 * l), c = r(10 * c), f *= 10, g *= 10, k *= 10, u *= 10, 1 > Math.abs(h) && 1 >= Math.abs(B - w) && 1 >= Math.abs(C - A) && (O = !0));
        h = "";
        var I;
        p && (J["fill-opacity"] = 0, J["stroke-opacity"] = m["stroke-opacity"] / 2, J.stroke = m.stroke);
        if (0 < l) {
            I = " M" + z + "," + (v + l) + " L" + w + "," + (A + l);
            t ? (O || (I += " A" + (b - f) + "," + (l + c - g) + "," + (b + f) + "," + (l + c + g) + "," + w + "," + (A + l) + "," + B + "," + (C + l)), I += " L" + D + "," + (y + l), 0 < k && (O || (I += " B" + (b - k) + "," + (l + c - u) + "," + (b + k) + "," + (l + c + u) + "," + D + "," + (l + y) + "," + z + "," + (l + v)))) : (I += " A" + f + "," + g + ",0," + E + ",1," + B + "," + (C + l) + " L" + D + "," + (y + l), 0 < k && (I += " A" + k + "," + u + ",0," + E + ",0," + z + "," + (v + l)));
            I += " Z";
            var W = l;
            t && (W /= 10);
            for (var ea = 0; ea < W; ea += 10) {
                var P = a.path(I, void 0, void 0, "1000,1000").attr(J);
                e.push(P);
                P.translate(0, -ea)
            }
            I = a.path(" M" + z + "," + v + " L" + z + "," + (v + l) + " L" + w + "," + (A + l) + " L" + w + "," + A + " L" + z + "," + v + " Z", void 0, void 0, "1000,1000").attr(J);
            l = a.path(" M" + B + "," + C + " L" + B + "," + (C + l) + " L" + D + "," + (y + l) + " L" + D + "," + y + " L" + B + "," + C + " Z", void 0, void 0, "1000,1000").attr(J);
            e.push(I);
            e.push(l)
        }
        t ? (O || (h = " A" + r(b - f) + "," + r(c - g) + "," + r(b + f) + "," + r(c + g) + "," + r(w) + "," + r(A) + "," + r(B) + "," + r(C)), f = " M" + r(z) + "," + r(v) + " L" + r(w) + "," + r(A) + h + " L" + r(D) + "," + r(y)) : f = " M" + z + "," + v + " L" + w + "," + A + (" A" + f + "," + g + ",0," + E + ",1," + B + "," + C) + " L" + D + "," + y;
        0 < k && (t ? O || (f += " B" + (b - k) + "," + (c - u) + "," + (b + k) + "," + (c + u) + "," + D + "," + y + "," + z + "," + v) : f += " A" + k + "," + u + ",0," + E + ",0," + z + "," + v);
        a.handDrawn && (b = d.line(a, [z, w], [v, A], m.stroke, m.thickness * Math.random() * a.handDrawThickness, m["stroke-opacity"]), e.push(b));
        a = a.path(f + " Z", void 0, void 0, "1000,1000").attr(m);
        if (n) {
            b = [];
            for (c = 0; c < n.length; c++) b.push(d.adjustLuminosity(m.fill, n[c]));
            0 < b.length && a.gradient("linearGradient", b)
        }
        a.pattern(p, NaN, q);
        e.wedge = a;
        e.push(a);
        return e
    };
    d.rgb2hex = function(a) {
        return (a = a.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === a.length ? "#" + ("0" + parseInt(a[1], 10).toString(16)).slice(-2) + ("0" + parseInt(a[2], 10).toString(16)).slice(-2) + ("0" + parseInt(a[3], 10).toString(16)).slice(-2) : ""
    };
    d.adjustLuminosity = function(a, b) {
        a && -1 != a.indexOf("rgb") && (a = d.rgb2hex(a));
        a = String(a).replace(/[^0-9a-f]/gi, "");
        6 > a.length && (a = String(a[0]) + String(a[0]) + String(a[1]) + String(a[1]) + String(a[2]) + String(a[2]));
        b = b || 0;
        var c = "#",
            e, h;
        for (h = 0; 3 > h; h++) e = parseInt(a.substr(2 * h, 2), 16), e = Math.round(Math.min(Math.max(0, e + e * b), 255)).toString(16), c += ("00" + e).substr(e.length);
        return c
    }
})();
(function() {
    var d = window.AmCharts;
    d.Bezier = d.Class({
        construct: function(a, b, c, e, h, f, g, k, l, m) {
            "object" == typeof g && (g = g[0]);
            "object" == typeof k && (k = k[0]);
            0 === k && (g = "none");
            f = {
                fill: g,
                "fill-opacity": k,
                "stroke-width": f
            };
            void 0 !== l && 0 < l && (f["stroke-dasharray"] = l);
            isNaN(h) || (f["stroke-opacity"] = h);
            e && (f.stroke = e);
            e = "M" + Math.round(b[0]) + "," + Math.round(c[0]);
            h = [];
            for (l = 0; l < b.length; l++) h.push({
                x: Number(b[l]),
                y: Number(c[l])
            });
            1 < h.length && (b = this.interpolate(h), e += this.drawBeziers(b));
            m ? e += m : d.VML || (e += "M0,0 L0,0");
            this.path = a.path(e).attr(f);
            this.node = this.path.node
        },
        interpolate: function(a) {
            var b = [];
            b.push({
                x: a[0].x,
                y: a[0].y
            });
            var c = a[1].x - a[0].x,
                e = a[1].y - a[0].y,
                h = d.bezierX,
                f = d.bezierY;
            b.push({
                x: a[0].x + c / h,
                y: a[0].y + e / f
            });
            var g;
            for (g = 1; g < a.length - 1; g++) {
                var k = a[g - 1],
                    l = a[g],
                    e = a[g + 1];
                isNaN(e.x) && (e = l);
                isNaN(l.x) && (l = k);
                isNaN(k.x) && (k = l);
                c = e.x - l.x;
                e = e.y - k.y;
                k = l.x - k.x;
                k > c && (k = c);
                b.push({
                    x: l.x - k / h,
                    y: l.y - e / f
                });
                b.push({
                    x: l.x,
                    y: l.y
                });
                b.push({
                    x: l.x + k / h,
                    y: l.y + e / f
                })
            }
            e = a[a.length - 1].y - a[a.length - 2].y;
            c = a[a.length - 1].x - a[a.length - 2].x;
            b.push({
                x: a[a.length - 1].x - c / h,
                y: a[a.length - 1].y - e / f
            });
            b.push({
                x: a[a.length - 1].x,
                y: a[a.length - 1].y
            });
            return b
        },
        drawBeziers: function(a) {
            var b = "",
                c;
            for (c = 0; c < (a.length - 1) / 3; c++) b += this.drawBezierMidpoint(a[3 * c], a[3 * c + 1], a[3 * c + 2], a[3 * c + 3]);
            return b
        },
        drawBezierMidpoint: function(a, b, c, e) {
            var d = Math.round,
                f = this.getPointOnSegment(a, b, .75),
                g = this.getPointOnSegment(e, c, .75),
                k = (e.x - a.x) / 16,
                l = (e.y - a.y) / 16,
                m = this.getPointOnSegment(a, b, .375);
            a = this.getPointOnSegment(f, g, .375);
            a.x -= k;
            a.y -= l;
            b = this.getPointOnSegment(g, f, .375);
            b.x += k;
            b.y += l;
            c = this.getPointOnSegment(e, c, .375);
            k = this.getMiddle(m, a);
            f = this.getMiddle(f, g);
            g = this.getMiddle(b, c);
            m = " Q" + d(m.x) + "," + d(m.y) + "," + d(k.x) + "," + d(k.y);
            m += " Q" + d(a.x) + "," + d(a.y) + "," + d(f.x) + "," + d(f.y);
            m += " Q" + d(b.x) + "," + d(b.y) + "," + d(g.x) + "," + d(g.y);
            return m += " Q" + d(c.x) + "," + d(c.y) + "," + d(e.x) + "," + d(e.y)
        },
        getMiddle: function(a, b) {
            return {
                x: (a.x + b.x) / 2,
                y: (a.y + b.y) / 2
            }
        },
        getPointOnSegment: function(a, b, c) {
            return {
                x: a.x + (b.x - a.x) * c,
                y: a.y + (b.y - a.y) * c
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmDraw = d.Class({
        construct: function(a, b, c, e) {
            d.SVG_NS = "http://www.w3.org/2000/svg";
            d.SVG_XLINK = "http://www.w3.org/1999/xlink";
            d.hasSVG = !!document.createElementNS && !!document.createElementNS(d.SVG_NS, "svg").createSVGRect;
            1 > b && (b = 10);
            1 > c && (c = 10);
            this.div = a;
            this.width = b;
            this.height = c;
            this.rBin = document.createElement("div");
            d.hasSVG ? (d.SVG = !0, b = this.createSvgElement("svg"), a.appendChild(b), this.container = b, this.addDefs(e), this.R = new d.SVGRenderer(this)) : d.isIE && d.VMLRenderer && (d.VML = !0, d.vmlStyleSheet || (document.namespaces.add("amvml", "urn:schemas-microsoft-com:vml"), 31 > document.styleSheets.length ? (b = document.createStyleSheet(), b.addRule(".amvml", "behavior:url(#default#VML); display:inline-block; antialias:true"), d.vmlStyleSheet = b) : document.styleSheets[0].addRule(".amvml", "behavior:url(#default#VML); display:inline-block; antialias:true")), this.container = a, this.R = new d.VMLRenderer(this, e), this.R.disableSelection(a))
        },
        createSvgElement: function(a) {
            return document.createElementNS(d.SVG_NS, a)
        },
        circle: function(a, b, c, e) {
            var h = new d.AmDObject("circle", this);
            h.attr({
                r: c,
                cx: a,
                cy: b
            });
            this.addToContainer(h.node, e);
            return h
        },
        ellipse: function(a, b, c, e, h) {
            var f = new d.AmDObject("ellipse", this);
            f.attr({
                rx: c,
                ry: e,
                cx: a,
                cy: b
            });
            this.addToContainer(f.node, h);
            return f
        },
        setSize: function(a, b) {
            0 < a && 0 < b && (this.container.style.width = a + "px", this.container.style.height = b + "px")
        },
        rect: function(a, b, c, e, h, f, g) {
            var k = new d.AmDObject("rect", this);
            d.VML && (h = Math.round(100 * h / Math.min(c, e)), c += 2 * f, e += 2 * f, k.bw = f, k.node.style.marginLeft = -f, k.node.style.marginTop = -f);
            1 > c && (c = 1);
            1 > e && (e = 1);
            k.attr({
                x: a,
                y: b,
                width: c,
                height: e,
                rx: h,
                ry: h,
                "stroke-width": f
            });
            this.addToContainer(k.node, g);
            return k
        },
        image: function(a, b, c, e, h, f) {
            var g = new d.AmDObject("image", this);
            g.attr({
                x: b,
                y: c,
                width: e,
                height: h
            });
            this.R.path(g, a);
            this.addToContainer(g.node, f);
            return g
        },
        addToContainer: function(a, b) {
            b || (b = this.container);
            b.appendChild(a)
        },
        text: function(a, b, c) {
            return this.R.text(a, b, c)
        },
        path: function(a, b, c, e) {
            var h = new d.AmDObject("path", this);
            e || (e = "100,100");
            h.attr({
                cs: e
            });
            c ? h.attr({
                dd: a
            }) : h.attr({
                d: a
            });
            this.addToContainer(h.node, b);
            return h
        },
        set: function(a) {
            return this.R.set(a)
        },
        remove: function(a) {
            if (a) {
                var b = this.rBin;
                b.appendChild(a);
                b.innerHTML = ""
            }
        },
        renderFix: function() {
            var a = this.container,
                b = a.style;
            b.top = "0px";
            b.left = "0px";
            var c = a.getBoundingClientRect(),
                a = c.left - Math.round(c.left),
                c = c.top - Math.round(c.top);
            a && (b.left = a + "px");
            c && (b.top = c + "px")
        },
        update: function() {
            this.R.update()
        },
        addDefs: function(a) {
            if (d.hasSVG) {
                var b = this.createSvgElement("desc"),
                    c = this.container;
                c.setAttribute("version", "1.1");
                c.style.position = "absolute";
                this.setSize(this.width, this.height);
                d.rtl && (c.setAttribute("direction", "rtl"), c.style.left = "auto", c.style.right = "0px");
                a.addCodeCredits && b.appendChild(document.createTextNode("JavaScript chart by amCharts " + a.version));
                c.appendChild(b);
                a.defs && (b = this.createSvgElement("defs"), c.appendChild(b), d.parseDefs(a.defs, b), this.defs = b)
            }
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.AmDObject = d.Class({
        construct: function(a, b) {
            this.D = b;
            this.R = b.R;
            this.node = this.R.create(this, a);
            this.y = this.x = 0;
            this.scale = 1
        },
        attr: function(a) {
            this.R.attr(this, a);
            return this
        },
        getAttr: function(a) {
            return this.node.getAttribute(a)
        },
        setAttr: function(a, b) {
            this.R.setAttr(this, a, b);
            return this
        },
        clipRect: function(a, b, c, e) {
            this.R.clipRect(this, a, b, c, e)
        },
        translate: function(a, b, c, e) {
            e || (a = Math.round(a), b = Math.round(b));
            this.R.move(this, a, b, c);
            this.x = a;
            this.y = b;
            this.scale = c;
            this.angle && this.rotate(this.angle)
        },
        rotate: function(a, b) {
            this.R.rotate(this, a, b);
            this.angle = a
        },
        animate: function(a, b, c) {
            for (var e in a)
                if (a.hasOwnProperty(e)) {
                    var h = e,
                        f = a[e];
                    c = d.getEffect(c);
                    this.R.animate(this, h, f, b, c)
                }
        },
        push: function(a) {
            if (a) {
                var b = this.node;
                b.appendChild(a.node);
                var c = a.clipPath;
                c && b.appendChild(c);
                (a = a.grad) && b.appendChild(a)
            }
        },
        text: function(a) {
            this.R.setText(this, a)
        },
        remove: function() {
            this.R.remove(this)
        },
        clear: function() {
            var a = this.node;
            if (a.hasChildNodes())
                for (; 1 <= a.childNodes.length;) a.removeChild(a.firstChild)
        },
        hide: function() {
            this.setAttr("visibility", "hidden")
        },
        show: function() {
            this.setAttr("visibility", "visible")
        },
        getBBox: function() {
            return this.R.getBBox(this)
        },
        toFront: function() {
            var a = this.node;
            if (a) {
                this.prevNextNode = a.nextSibling;
                var b = a.parentNode;
                b && b.appendChild(a)
            }
        },
        toPrevious: function() {
            var a = this.node;
            a && this.prevNextNode && (a = a.parentNode) && a.insertBefore(this.prevNextNode, null)
        },
        toBack: function() {
            var a = this.node;
            if (a) {
                this.prevNextNode = a.nextSibling;
                var b = a.parentNode;
                if (b) {
                    var c = b.firstChild;
                    c && b.insertBefore(a, c)
                }
            }
        },
        mouseover: function(a) {
            this.R.addListener(this, "mouseover", a);
            return this
        },
        mouseout: function(a) {
            this.R.addListener(this, "mouseout", a);
            return this
        },
        click: function(a) {
            this.R.addListener(this, "click", a);
            return this
        },
        dblclick: function(a) {
            this.R.addListener(this, "dblclick", a);
            return this
        },
        mousedown: function(a) {
            this.R.addListener(this, "mousedown", a);
            return this
        },
        mouseup: function(a) {
            this.R.addListener(this, "mouseup", a);
            return this
        },
        touchstart: function(a) {
            this.R.addListener(this, "touchstart", a);
            return this
        },
        touchend: function(a) {
            this.R.addListener(this, "touchend", a);
            return this
        },
        contextmenu: function(a) {
            this.node.addEventListener ? this.node.addEventListener("contextmenu", a, !0) : this.R.addListener(this, "contextmenu", a);
            return this
        },
        stop: function() {
            d.removeFromArray(this.R.animations, this.an_x);
            d.removeFromArray(this.R.animations, this.an_y)
        },
        length: function() {
            return this.node.childNodes.length
        },
        gradient: function(a, b, c) {
            this.R.gradient(this, a, b, c)
        },
        pattern: function(a, b, c) {
            a && this.R.pattern(this, a, b, c)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.VMLRenderer = d.Class({
        construct: function(a, b) {
            this.chart = b;
            this.D = a;
            this.cNames = {
                circle: "oval",
                ellipse: "oval",
                rect: "roundrect",
                path: "shape"
            };
            this.styleMap = {
                x: "left",
                y: "top",
                width: "width",
                height: "height",
                "font-family": "fontFamily",
                "font-size": "fontSize",
                visibility: "visibility"
            }
        },
        create: function(a, b) {
            var c;
            if ("group" == b) c = document.createElement("div"), a.type = "div";
            else if ("text" == b) c = document.createElement("div"), a.type = "text";
            else if ("image" == b) c = document.createElement("img"), a.type = "image";
            else {
                a.type = "shape";
                a.shapeType = this.cNames[b];
                c = document.createElement("amvml:" + this.cNames[b]);
                var e = document.createElement("amvml:stroke");
                c.appendChild(e);
                a.stroke = e;
                var d = document.createElement("amvml:fill");
                c.appendChild(d);
                a.fill = d;
                d.className = "amvml";
                e.className = "amvml";
                c.className = "amvml"
            }
            c.style.position = "absolute";
            c.style.top = 0;
            c.style.left = 0;
            return c
        },
        path: function(a, b) {
            a.node.setAttribute("src", b)
        },
        setAttr: function(a, b, c) {
            if (void 0 !== c) {
                var e;
                8 === document.documentMode && (e = !0);
                var h = a.node,
                    f = a.type,
                    g = h.style;
                "r" == b && (g.width = 2 * c, g.height = 2 * c);
                "oval" == a.shapeType && ("rx" == b && (g.width = 2 * c), "ry" == b && (g.height = 2 * c));
                "roundrect" == a.shapeType && ("width" != b && "height" != b || --c);
                "cursor" == b && (g.cursor = c);
                "cx" == b && (g.left = c - d.removePx(g.width) / 2);
                "cy" == b && (g.top = c - d.removePx(g.height) / 2);
                var k = this.styleMap[b];
                void 0 !== k && (g[k] = c);
                "text" == f && ("text-anchor" == b && (a.anchor = c, k = h.clientWidth, "end" == c && (g.marginLeft = -k + "px"), "middle" == c && (g.marginLeft = -(k / 2) + "px", g.textAlign = "center"), "start" == c && (g.marginLeft = "0px")), "fill" == b && (g.color = c), "font-weight" == b && (g.fontWeight = c));
                if (g = a.children)
                    for (k = 0; k < g.length; k++) g[k].setAttr(b, c);
                if ("shape" == f) {
                    "cs" == b && (h.style.width = "100px", h.style.height = "100px", h.setAttribute("coordsize", c));
                    "d" == b && h.setAttribute("path", this.svgPathToVml(c));
                    "dd" == b && h.setAttribute("path", c);
                    f = a.stroke;
                    a = a.fill;
                    "stroke" == b && (e ? f.color = c : f.setAttribute("color", c));
                    "stroke-width" == b && (e ? f.weight = c : f.setAttribute("weight", c));
                    "stroke-opacity" == b && (e ? f.opacity = c : f.setAttribute("opacity", c));
                    "stroke-dasharray" == b && (g = "solid", 0 < c && 3 > c && (g = "dot"), 3 <= c && 6 >= c && (g = "dash"), 6 < c && (g = "longdash"), e ? f.dashstyle = g : f.setAttribute("dashstyle", g));
                    if ("fill-opacity" == b || "opacity" == b) 0 === c ? e ? a.on = !1 : a.setAttribute("on", !1) : e ? a.opacity = c : a.setAttribute("opacity", c);
                    "fill" == b && (e ? a.color = c : a.setAttribute("color", c));
                    "rx" == b && (e ? h.arcSize = c + "%" : h.setAttribute("arcsize", c + "%"))
                }
            }
        },
        attr: function(a, b) {
            for (var c in b) b.hasOwnProperty(c) && this.setAttr(a, c, b[c])
        },
        text: function(a, b, c) {
            var e = new d.AmDObject("text", this.D),
                h = e.node;
            h.style.whiteSpace = "pre";
            h.innerHTML = a;
            this.D.addToContainer(h, c);
            this.attr(e, b);
            return e
        },
        getBBox: function(a) {
            return this.getBox(a.node)
        },
        getBox: function(a) {
            var b = a.offsetLeft,
                c = a.offsetTop,
                d = a.offsetWidth,
                h = a.offsetHeight,
                f;
            if (a.hasChildNodes()) {
                var g, k, l;
                for (l = 0; l < a.childNodes.length; l++) {
                    f = this.getBox(a.childNodes[l]);
                    var m = f.x;
                    isNaN(m) || (isNaN(g) ? g = m : m < g && (g = m));
                    var n = f.y;
                    isNaN(n) || (isNaN(k) ? k = n : n < k && (k = n));
                    m = f.width + m;
                    isNaN(m) || (d = Math.max(d, m));
                    f = f.height + n;
                    isNaN(f) || (h = Math.max(h, f))
                }
                0 > g && (b += g);
                0 > k && (c += k)
            }
            return {
                x: b,
                y: c,
                width: d,
                height: h
            }
        },
        setText: function(a, b) {
            var c = a.node;
            c && (c.innerHTML = b);
            this.setAttr(a, "text-anchor", a.anchor)
        },
        addListener: function(a, b, c) {
            a.node["on" + b] = c
        },
        move: function(a, b, c) {
            var e = a.node,
                h = e.style;
            "text" == a.type && (c -= d.removePx(h.fontSize) / 2 - 1);
            "oval" == a.shapeType && (b -= d.removePx(h.width) / 2, c -= d.removePx(h.height) / 2);
            a = a.bw;
            isNaN(a) || (b -= a, c -= a);
            isNaN(b) || isNaN(c) || (e.style.left = b + "px", e.style.top = c + "px")
        },
        svgPathToVml: function(a) {
            var b = a.split(" ");
            a = "";
            var c, d = Math.round,
                h;
            for (h = 0; h < b.length; h++) {
                var f = b[h],
                    g = f.substring(0, 1),
                    f = f.substring(1),
                    k = f.split(","),
                    l = d(k[0]) + "," + d(k[1]);
                "M" == g && (a += " m " + l);
                "L" == g && (a += " l " + l);
                "Z" == g && (a += " x e");
                if ("Q" == g) {
                    var m = c.length,
                        n = c[m - 1],
                        p = k[0],
                        q = k[1],
                        l = k[2],
                        r = k[3];
                    c = d(c[m - 2] / 3 + 2 / 3 * p);
                    n = d(n / 3 + 2 / 3 * q);
                    p = d(2 / 3 * p + l / 3);
                    q = d(2 / 3 * q + r / 3);
                    a += " c " + c + "," + n + "," + p + "," + q + "," + l + "," + r
                }
                "A" == g && (a += " wa " + f);
                "B" == g && (a += " at " + f);
                c = k
            }
            return a
        },
        animate: function(a, b, c, d, h) {
            var f = a.node,
                g = this.chart;
            if ("translate" == b) {
                b = c.split(",");
                c = b[1];
                var k = f.offsetTop;
                g.animate(a, "left", f.offsetLeft, b[0], d, h, "px");
                g.animate(a, "top", k, c, d, h, "px")
            }
        },
        clipRect: function(a, b, c, d, h) {
            a = a.node;
            0 === b && 0 === c ? (a.style.width = d + "px", a.style.height = h + "px", a.style.overflow = "hidden") : a.style.clip = "rect(" + c + "px " + (b + d) + "px " + (c + h) + "px " + b + "px)"
        },
        rotate: function(a, b, c) {
            if (0 !== Number(b)) {
                var e = a.node;
                a = e.style;
                c || (c = this.getBGColor(e.parentNode));
                a.backgroundColor = c;
                a.paddingLeft = 1;
                c = b * Math.PI / 180;
                var h = Math.cos(c),
                    f = Math.sin(c),
                    g = d.removePx(a.left),
                    k = d.removePx(a.top),
                    l = e.offsetWidth,
                    e = e.offsetHeight;
                b /= Math.abs(b);
                a.left = g + l / 2 - l / 2 * Math.cos(c) - b * e / 2 * Math.sin(c) + 3;
                a.top = k - b * l / 2 * Math.sin(c) + b * e / 2 * Math.sin(c);
                a.cssText = a.cssText + "; filter:progid:DXImageTransform.Microsoft.Matrix(M11='" + h + "', M12='" + -f + "', M21='" + f + "', M22='" + h + "', sizingmethod='auto expand');"
            }
        },
        getBGColor: function(a) {
            var b = "#FFFFFF";
            if (a.style) {
                var c = a.style.backgroundColor;
                "" !== c ? b = c : a.parentNode && (b = this.getBGColor(a.parentNode))
            }
            return b
        },
        set: function(a) {
            var b = new d.AmDObject("group", this.D);
            this.D.container.appendChild(b.node);
            if (a) {
                var c;
                for (c = 0; c < a.length; c++) b.push(a[c])
            }
            return b
        },
        gradient: function(a, b, c, d) {
            var h = "";
            "radialGradient" == b && (b = "gradientradial", c.reverse());
            "linearGradient" == b && (b = "gradient");
            var f;
            for (f = 0; f < c.length; f++) {
                var g = Math.round(100 * f / (c.length - 1)),
                    h = h + (g + "% " + c[f]);
                f < c.length - 1 && (h += ",")
            }
            a = a.fill;
            90 == d ? d = 0 : 270 == d ? d = 180 : 180 == d ? d = 90 : 0 === d && (d = 270);
            8 === document.documentMode ? (a.type = b, a.angle = d) : (a.setAttribute("type", b), a.setAttribute("angle", d));
            h && (a.colors.value = h)
        },
        remove: function(a) {
            a.clipPath && this.D.remove(a.clipPath);
            this.D.remove(a.node)
        },
        disableSelection: function(a) {
            void 0 !== typeof a.onselectstart && (a.onselectstart = function() {
                return !1
            });
            a.style.cursor = "default"
        },
        pattern: function(a, b, c, e) {
            c = a.node;
            a = a.fill;
            var h = "none";
            b.color && (h = b.color);
            c.fillColor = h;
            b = b.url;
            d.isAbsolute(b) || (b = e + b);
            8 === document.documentMode ? (a.type = "tile", a.src = b) : (a.setAttribute("type", "tile"), a.setAttribute("src", b))
        },
        update: function() {}
    })
})();
(function() {
    var d = window.AmCharts;
    d.SVGRenderer = d.Class({
        construct: function(a) {
            this.D = a;
            this.animations = []
        },
        create: function(a, b) {
            return document.createElementNS(d.SVG_NS, b)
        },
        attr: function(a, b) {
            for (var c in b) b.hasOwnProperty(c) && this.setAttr(a, c, b[c])
        },
        setAttr: function(a, b, c) {
            void 0 !== c && a.node.setAttribute(b, c)
        },
        animate: function(a, b, c, e, h) {
            var f = a.node;
            a["an_" + b] && d.removeFromArray(this.animations, a["an_" + b]);
            "translate" == b ? (f = (f = f.getAttribute("transform")) ? String(f).substring(10, f.length - 1) : "0,0", f = f.split(", ").join(" "), f = f.split(" ").join(","), 0 === f && (f = "0,0")) : f = Number(f.getAttribute(b));
            c = {
                obj: a,
                frame: 0,
                attribute: b,
                from: f,
                to: c,
                time: e,
                effect: h
            };
            this.animations.push(c);
            a["an_" + b] = c
        },
        update: function() {
            var a, b = this.animations;
            for (a = b.length - 1; 0 <= a; a--) {
                var c = b[a],
                    e = 1E3 * c.time / d.updateRate,
                    h = c.frame + 1,
                    f = c.obj,
                    g = c.attribute,
                    k, l, m;
                h <= e ? (c.frame++, "translate" == g ? (k = c.from.split(","), g = Number(k[0]), k = Number(k[1]), isNaN(k) && (k = 0), l = c.to.split(","), m = Number(l[0]), l = Number(l[1]), m = 0 === m - g ? m : Math.round(d[c.effect](0, h, g, m - g, e)), c = 0 === l - k ? l : Math.round(d[c.effect](0, h, k, l - k, e)), g = "transform", c = "translate(" + m + "," + c + ")") : (l = Number(c.from), k = Number(c.to), m = k - l, c = d[c.effect](0, h, l, m, e), isNaN(c) && (c = k), 0 === m && this.animations.splice(a, 1)), this.setAttr(f, g, c)) : ("translate" == g ? (l = c.to.split(","), m = Number(l[0]), l = Number(l[1]), f.translate(m, l)) : (k = Number(c.to), this.setAttr(f, g, k)), this.animations.splice(a, 1))
            }
        },
        getBBox: function(a) {
            if (a = a.node) try {
                return a.getBBox()
            } catch (b) {}
            return {
                width: 0,
                height: 0,
                x: 0,
                y: 0
            }
        },
        path: function(a, b) {
            a.node.setAttributeNS(d.SVG_XLINK, "xlink:href", b)
        },
        clipRect: function(a, b, c, e, h) {
            var f = a.node,
                g = a.clipPath;
            g && this.D.remove(g);
            var k = f.parentNode;
            k && (f = document.createElementNS(d.SVG_NS, "clipPath"), g = d.getUniqueId(), f.setAttribute("id", g), this.D.rect(b, c, e, h, 0, 0, f), k.appendChild(f), b = "#", d.baseHref && !d.isIE && (b = this.removeTarget(window.location.href) + b), this.setAttr(a, "clip-path", "url(" + b + g + ")"), this.clipPathC++, a.clipPath = f)
        },
        text: function(a, b, c) {
            var e = new d.AmDObject("text", this.D);
            a = String(a).split("\n");
            var h = d.removePx(b["font-size"]),
                f;
            for (f = 0; f < a.length; f++) {
                var g = this.create(null, "tspan");
                g.appendChild(document.createTextNode(a[f]));
                g.setAttribute("y", (h + 2) * f + Math.round(h / 2));
                g.setAttribute("x", 0);
                e.node.appendChild(g)
            }
            e.node.setAttribute("y", Math.round(h / 2));
            this.attr(e, b);
            this.D.addToContainer(e.node, c);
            return e
        },
        setText: function(a, b) {
            var c = a.node;
            c && (c.removeChild(c.firstChild), c.appendChild(document.createTextNode(b)))
        },
        move: function(a, b, c, d) {
            isNaN(b) && (b = 0);
            isNaN(c) && (c = 0);
            b = "translate(" + b + "," + c + ")";
            d && (b = b + " scale(" + d + ")");
            this.setAttr(a, "transform", b)
        },
        rotate: function(a, b) {
            var c = a.node.getAttribute("transform"),
                d = "rotate(" + b + ")";
            c && (d = c + " " + d);
            this.setAttr(a, "transform", d)
        },
        set: function(a) {
            var b = new d.AmDObject("g", this.D);
            this.D.container.appendChild(b.node);
            if (a) {
                var c;
                for (c = 0; c < a.length; c++) b.push(a[c])
            }
            return b
        },
        addListener: function(a, b, c) {
            a.node["on" + b] = c
        },
        gradient: function(a, b, c, e) {
            var h = a.node,
                f = a.grad;
            f && this.D.remove(f);
            b = document.createElementNS(d.SVG_NS, b);
            f = d.getUniqueId();
            b.setAttribute("id", f);
            if (!isNaN(e)) {
                var g = 0,
                    k = 0,
                    l = 0,
                    m = 0;
                90 == e ? l = 100 : 270 == e ? m = 100 : 180 == e ? g = 100 : 0 === e && (k = 100);
                b.setAttribute("x1", g + "%");
                b.setAttribute("x2", k + "%");
                b.setAttribute("y1", l + "%");
                b.setAttribute("y2", m + "%")
            }
            for (e = 0; e < c.length; e++) g = document.createElementNS(d.SVG_NS, "stop"), k = 100 * e / (c.length - 1), 0 === e && (k = 0), g.setAttribute("offset", k + "%"), g.setAttribute("stop-color", c[e]), b.appendChild(g);
            h.parentNode.appendChild(b);
            c = "#";
            d.baseHref && !d.isIE && (c = this.removeTarget(window.location.href) + c);
            h.setAttribute("fill", "url(" + c + f + ")");
            a.grad = b
        },
        removeTarget: function(a) {
            return a.split("#")[0]
        },
        pattern: function(a, b, c, e) {
            var h = a.node;
            isNaN(c) && (c = 1);
            var f = a.patternNode;
            f && this.D.remove(f);
            var f = document.createElementNS(d.SVG_NS, "pattern"),
                g = d.getUniqueId(),
                k = b;
            b.url && (k = b.url);
            d.isAbsolute(k) || (k = e + k);
            e = Number(b.width);
            isNaN(e) && (e = 4);
            var l = Number(b.height);
            isNaN(l) && (l = 4);
            e /= c;
            l /= c;
            c = b.x;
            isNaN(c) && (c = 0);
            var m = -Math.random() * Number(b.randomX);
            isNaN(m) || (c = m);
            m = b.y;
            isNaN(m) && (m = 0);
            var n = -Math.random() * Number(b.randomY);
            isNaN(n) || (m = n);
            f.setAttribute("id", g);
            f.setAttribute("width", e);
            f.setAttribute("height", l);
            f.setAttribute("patternUnits", "userSpaceOnUse");
            f.setAttribute("xlink:href", k);
            b.color && (n = document.createElementNS(d.SVG_NS, "rect"), n.setAttributeNS(null, "height", e), n.setAttributeNS(null, "width", l), n.setAttributeNS(null, "fill", b.color), f.appendChild(n));
            this.D.image(k, 0, 0, e, l, f).translate(c, m);
            k = "#";
            d.baseHref && !d.isIE && (k = this.removeTarget(window.location.href) + k);
            h.setAttribute("fill", "url(" + k + g + ")");
            a.patternNode = f;
            h.parentNode.appendChild(f)
        },
        remove: function(a) {
            a.clipPath && this.D.remove(a.clipPath);
            a.grad && this.D.remove(a.grad);
            a.patternNode && this.D.remove(a.patternNode);
            this.D.remove(a.node)
        }
    })
})();
AmCharts.AmDSet = AmCharts.Class({
    construct: function(d) {
        this.create("g")
    },
    attr: function(d) {
        this.R.attr(this.node, d)
    },
    move: function(d, a) {
        this.R.move(this.node, d, a)
    }
});
(function() {
    var d = window.AmCharts;
    d.AmLegend = d.Class({
        construct: function(a) {
            this.enabled = !0;
            this.cname = "AmLegend";
            this.createEvents("rollOverMarker", "rollOverItem", "rollOutMarker", "rollOutItem", "showItem", "hideItem", "clickMarker", "rollOverItem", "rollOutItem", "clickLabel");
            this.position = "bottom";
            this.borderColor = this.color = "#000000";
            this.borderAlpha = 0;
            this.markerLabelGap = 5;
            this.verticalGap = 10;
            this.align = "left";
            this.horizontalGap = 0;
            this.spacing = 10;
            this.markerDisabledColor = "#AAB3B3";
            this.markerType = "square";
            this.markerSize = 16;
            this.markerBorderThickness = this.markerBorderAlpha = 1;
            this.marginBottom = this.marginTop = 0;
            this.marginLeft = this.marginRight = 20;
            this.autoMargins = !0;
            this.valueWidth = 50;
            this.switchable = !0;
            this.switchType = "x";
            this.switchColor = "#FFFFFF";
            this.rollOverColor = "#CC0000";
            this.reversedOrder = !1;
            this.labelText = "[[title]]";
            this.valueText = "[[value]]";
            this.useMarkerColorForLabels = !1;
            this.rollOverGraphAlpha = 1;
            this.textClickEnabled = !1;
            this.equalWidths = !0;
            this.backgroundColor = "#FFFFFF";
            this.backgroundAlpha = 0;
            this.useGraphSettings = !1;
            this.showEntries = !0;
            d.applyTheme(this, a, this.cname)
        },
        setData: function(a) {
            this.legendData = a;
            this.invalidateSize()
        },
        invalidateSize: function() {
            this.destroy();
            this.entries = [];
            this.valueLabels = [];
            var a = this.legendData;
            this.enabled && (d.ifArray(a) || d.ifArray(this.data)) && this.drawLegend()
        },
        drawLegend: function() {
            var a = this.chart,
                b = this.position,
                c = this.width,
                e = a.divRealWidth,
                h = a.divRealHeight,
                f = this.div,
                g = this.legendData;
            this.data && (g = this.data);
            isNaN(this.fontSize) && (this.fontSize = a.fontSize);
            if ("right" == b || "left" == b) this.maxColumns = 1, this.autoMargins && (this.marginLeft = this.marginRight = 10);
            else if (this.autoMargins) {
                this.marginRight = a.marginRight;
                this.marginLeft = a.marginLeft;
                var k = a.autoMarginOffset;
                "bottom" == b ? (this.marginBottom = k, this.marginTop = 0) : (this.marginTop = k, this.marginBottom = 0)
            }
            c = void 0 !== c ? d.toCoordinate(c, e) : "right" != b && "left" != b ? a.realWidth : 0 < this.ieW ? this.ieW : a.realWidth;
            "outside" == b ? (c = f.offsetWidth, h = f.offsetHeight, f.clientHeight && (c = f.clientWidth, h = f.clientHeight)) : (isNaN(c) || (f.style.width = c + "px"), f.className = "amChartsLegend " + a.classNamePrefix + "-legend-div");
            this.divWidth = c;
            (b = this.container) ? (b.container.innerHTML = "", f.appendChild(b.container), b.width = c, b.height = h, b.setSize(c, h), b.addDefs(a)) : b = new d.AmDraw(f, c, h, a);
            this.container = b;
            this.lx = 0;
            this.ly = 8;
            h = this.markerSize;
            h > this.fontSize && (this.ly = h / 2 - 1);
            0 < h && (this.lx += h + this.markerLabelGap);
            this.titleWidth = 0;
            if (h = this.title) h = d.text(this.container, h, this.color, a.fontFamily, this.fontSize, "start", !0), d.setCN(a, h, "legend-title"), h.translate(this.marginLeft, this.marginTop + this.verticalGap + this.ly + 1), a = h.getBBox(), this.titleWidth = a.width + 15, this.titleHeight = a.height + 6;
            this.index = this.maxLabelWidth = 0;
            if (this.showEntries) {
                for (a = 0; a < g.length; a++) this.createEntry(g[a]);
                for (a = this.index = 0; a < g.length; a++) this.createValue(g[a])
            }
            this.arrangeEntries();
            this.updateValues()
        },
        arrangeEntries: function() {
            var a = this.position,
                b = this.marginLeft + this.titleWidth,
                c = this.marginRight,
                e = this.marginTop,
                h = this.marginBottom,
                f = this.horizontalGap,
                g = this.div,
                k = this.divWidth,
                l = this.maxColumns,
                m = this.verticalGap,
                n = this.spacing,
                p = k - c - b,
                q = 0,
                r = 0,
                u = this.container;
            this.set && this.set.remove();
            var t = u.set();
            this.set = t;
            var z = u.set();
            t.push(z);
            var y = this.entries,
                v, w;
            for (w = 0; w < y.length; w++) {
                v = y[w].getBBox();
                var A = v.width;
                A > q && (q = A);
                v = v.height;
                v > r && (r = v)
            }
            var A = r = 0,
                B = f,
                C = 0,
                D = 0;
            for (w = 0; w < y.length; w++) {
                var J = y[w];
                this.reversedOrder && (J = y[y.length - w - 1]);
                v = J.getBBox();
                var E;
                this.equalWidths ? E = A * (q + n + this.markerLabelGap) : (E = B, B = B + v.width + f + n);
                v.height > D && (D = v.height);
                E + v.width > p && 0 < w && 0 !== A && (r++, E = A = 0, B = E + v.width + f + n, C = C + D + m, D = 0);
                J.translate(E, C);
                A++;
                !isNaN(l) && A >= l && (A = 0, r++, C = C + D + m, B = f, D = 0);
                z.push(J)
            }
            v = z.getBBox();
            l = v.height + 2 * m - 1;
            "left" == a || "right" == a ? (n = v.width + 2 * f, k = n + b + c, g.style.width = k + "px", this.ieW = k) : n = k - b - c - 1;
            c = d.polygon(this.container, [0, n, n, 0], [0, 0, l, l], this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);
            d.setCN(this.chart, c, "legend-bg");
            t.push(c);
            t.translate(b, e);
            c.toBack();
            b = f;
            if ("top" == a || "bottom" == a || "absolute" == a || "outside" == a) "center" == this.align ? b = f + (n - v.width) / 2 : "right" == this.align && (b = f + n - v.width);
            z.translate(b, m + 1);
            this.titleHeight > l && (l = this.titleHeight);
            a = l + e + h + 1;
            0 > a && (a = 0);
            a > this.chart.divRealHeight && (g.style.top = "0px");
            g.style.height = Math.round(a) + "px";
            u.setSize(this.divWidth, a)
        },
        createEntry: function(a) {
            if (!1 !== a.visibleInLegend) {
                var b = this.chart,
                    c = a.markerType;
                a.legendEntryWidth = this.markerSize;
                c || (c = this.markerType);
                var e = a.color,
                    h = a.alpha;
                a.legendKeyColor && (e = a.legendKeyColor());
                a.legendKeyAlpha && (h = a.legendKeyAlpha());
                var f;
                !0 === a.hidden && (f = e = this.markerDisabledColor);
                var g = a.pattern,
                    k = a.customMarker;
                k || (k = this.customMarker);
                var l = this.container,
                    m = this.markerSize,
                    n = 0,
                    p = 0,
                    q = m / 2;
                if (this.useGraphSettings) {
                    c = a.type;
                    this.switchType = void 0;
                    if ("line" == c || "step" == c || "smoothedLine" == c || "ohlc" == c) g = l.set(), a.hidden || (e = a.lineColorR, f = a.bulletBorderColorR), n = d.line(l, [0, 2 * m], [m / 2, m / 2], e, a.lineAlpha, a.lineThickness, a.dashLength), d.setCN(b, n, "graph-stroke"), g.push(n), a.bullet && (a.hidden || (e = a.bulletColorR), n = d.bullet(l, a.bullet, a.bulletSize, e, a.bulletAlpha, a.bulletBorderThickness, f, a.bulletBorderAlpha)) && (d.setCN(b, n, "graph-bullet"), n.translate(m + 1, m / 2), g.push(n)), q = 0, n = m, p = m / 3;
                    else {
                        var r;
                        a.getGradRotation && (r = a.getGradRotation());
                        n = a.fillColorsR;
                        !0 === a.hidden && (n = e);
                        if (g = this.createMarker("rectangle", n, a.fillAlphas, a.lineThickness, e, a.lineAlpha, r, g)) q = m, g.translate(q, m / 2);
                        n = m
                    }
                    d.setCN(b, g, "graph-" + c);
                    d.setCN(b, g, "graph-" + a.id)
                } else k ? g = l.image(k, 0, 0, m, m) : (g = this.createMarker(c, e, h, void 0, void 0, void 0, void 0, g)) && g.translate(m / 2, m / 2);
                d.setCN(b, g, "legend-marker");
                this.addListeners(g, a);
                l = l.set([g]);
                this.switchable && a.switchable && l.setAttr("cursor", "pointer");
                void 0 !== a.id && d.setCN(b, l, "legend-item-" + a.id);
                d.setCN(b, l, a.className, !0);
                (f = this.switchType) && "none" != f && 0 < m && ("x" == f ? (c = this.createX(), c.translate(m / 2, m / 2)) : c = this.createV(), c.dItem = a, !0 !== a.hidden ? "x" == f ? c.hide() : c.show() : "x" != f && c.hide(), this.switchable || c.hide(), this.addListeners(c, a), a.legendSwitch = c, l.push(c), d.setCN(b, c, "legend-switch"));
                f = this.color;
                a.showBalloon && this.textClickEnabled && void 0 !== this.selectedColor && (f = this.selectedColor);
                this.useMarkerColorForLabels && (f = e);
                !0 === a.hidden && (f = this.markerDisabledColor);
                e = d.massReplace(this.labelText, {
                    "[[title]]": a.title
                });
                c = this.fontSize;
                g && (m <= c && g.translate(q, m / 2 + this.ly - c / 2 + (c + 2 - m) / 2 - p), a.legendEntryWidth = g.getBBox().width);
                var u;
                e && (e = d.fixBrakes(e), a.legendTextReal = e, u = this.labelWidth, u = isNaN(u) ? d.text(this.container, e, f, b.fontFamily, c, "start") : d.wrappedText(this.container, e, f, b.fontFamily, c, "start", !1, u, 0), d.setCN(b, u, "legend-label"), u.translate(this.lx + n, this.ly), l.push(u), b = u.getBBox().width, this.maxLabelWidth < b && (this.maxLabelWidth = b));
                this.entries[this.index] = l;
                a.legendEntry = this.entries[this.index];
                a.legendLabel = u;
                this.index++
            }
        },
        addListeners: function(a, b) {
            var c = this;
            a && a.mouseover(function(a) {
                c.rollOverMarker(b, a)
            }).mouseout(function(a) {
                c.rollOutMarker(b, a)
            }).click(function(a) {
                c.clickMarker(b, a)
            })
        },
        rollOverMarker: function(a, b) {
            this.switchable && this.dispatch("rollOverMarker", a, b);
            this.dispatch("rollOverItem", a, b)
        },
        rollOutMarker: function(a, b) {
            this.switchable && this.dispatch("rollOutMarker", a, b);
            this.dispatch("rollOutItem", a, b)
        },
        clickMarker: function(a, b) {
            this.switchable && (!0 === a.hidden ? this.dispatch("showItem", a, b) : this.dispatch("hideItem", a, b));
            this.dispatch("clickMarker", a, b)
        },
        rollOverLabel: function(a, b) {
            a.hidden || (this.textClickEnabled && a.legendLabel && a.legendLabel.attr({
                fill: this.rollOverColor
            }), this.dispatch("rollOverItem", a, b))
        },
        rollOutLabel: function(a, b) {
            if (!a.hidden) {
                if (this.textClickEnabled && a.legendLabel) {
                    var c = this.color;
                    void 0 !== this.selectedColor && a.showBalloon && (c = this.selectedColor);
                    this.useMarkerColorForLabels && (c = a.lineColor, void 0 === c && (c = a.color));
                    a.legendLabel.attr({
                        fill: c
                    })
                }
                this.dispatch("rollOutItem", a, b)
            }
        },
        clickLabel: function(a, b) {
            this.textClickEnabled ? a.hidden || this.dispatch("clickLabel", a, b) : this.switchable && (!0 === a.hidden ? this.dispatch("showItem", a, b) : this.dispatch("hideItem", a, b))
        },
        dispatch: function(a, b, c) {
            b = {
                type: a,
                dataItem: b,
                target: this,
                event: c,
                chart: this.chart
            };
            this.chart && this.chart.handleLegendEvent(b);
            this.fire(a, b)
        },
        createValue: function(a) {
            var b = this,
                c = b.fontSize,
                e = b.chart;
            if (!1 !== a.visibleInLegend) {
                var h = b.maxLabelWidth;
                b.forceWidth && (h = b.labelWidth);
                b.equalWidths || (b.valueAlign = "left");
                "left" == b.valueAlign && (h = a.legendEntry.getBBox().width);
                var f = h;
                if (b.valueText && 0 < b.valueWidth) {
                    var g = b.color;
                    b.useMarkerColorForValues && (g = a.color, a.legendKeyColor && (g = a.legendKeyColor()));
                    !0 === a.hidden && (g = b.markerDisabledColor);
                    var k = b.valueText,
                        h = h + b.lx + b.markerLabelGap + b.valueWidth,
                        l = "end";
                    "left" == b.valueAlign && (h -= b.valueWidth, l = "start");
                    g = d.text(b.container, k, g, b.chart.fontFamily, c, l);
                    d.setCN(e, g, "legend-value");
                    g.translate(h, b.ly);
                    b.entries[b.index].push(g);
                    f += b.valueWidth + 2 * b.markerLabelGap;
                    g.dItem = a;
                    b.valueLabels.push(g)
                }
                b.index++;
                e = b.markerSize;
                e < c + 7 && (e = c + 7, d.VML && (e += 3));
                c = b.container.rect(a.legendEntryWidth, 0, f, e, 0, 0).attr({
                    stroke: "none",
                    fill: "#fff",
                    "fill-opacity": .005
                });
                c.dItem = a;
                b.entries[b.index - 1].push(c);
                c.mouseover(function(c) {
                    b.rollOverLabel(a, c)
                }).mouseout(function(c) {
                    b.rollOutLabel(a, c)
                }).click(function(c) {
                    b.clickLabel(a, c)
                })
            }
        },
        createV: function() {
            var a = this.markerSize;
            return d.polygon(this.container, [a / 5, a / 2, a - a / 5, a / 2], [a / 3, a - a / 5, a / 5, a / 1.7], this.switchColor)
        },
        createX: function() {
            var a = (this.markerSize - 4) / 2,
                b = {
                    stroke: this.switchColor,
                    "stroke-width": 3
                },
                c = this.container,
                e = d.line(c, [-a, a], [-a, a]).attr(b),
                a = d.line(c, [-a, a], [a, -a]).attr(b);
            return this.container.set([e, a])
        },
        createMarker: function(a, b, c, e, h, f, g, k) {
            var l = this.markerSize,
                m = this.container;
            h || (h = this.markerBorderColor);
            h || (h = b);
            isNaN(e) && (e = this.markerBorderThickness);
            isNaN(f) && (f = this.markerBorderAlpha);
            return d.bullet(m, a, l, b, c, e, h, f, l, g, k, this.chart.path)
        },
        validateNow: function() {
            this.invalidateSize()
        },
        updateValues: function() {
            var a = this.valueLabels,
                b = this.chart,
                c, e = this.data;
            for (c = 0; c < a.length; c++) {
                var h = a[c],
                    f = h.dItem,
                    g = " ";
                if (e) f.value ? h.text(f.value) : h.text("");
                else {
                    var k;
                    if (void 0 !== f.type) {
                        k = f.currentDataItem;
                        var l = this.periodValueText;
                        f.legendPeriodValueText && (l = f.legendPeriodValueText);
                        k ? (g = this.valueText, f.legendValueText && (g = f.legendValueText), g = b.formatString(g, k)) : l && b.formatPeriodString && (l = d.massReplace(l, {
                            "[[title]]": f.title
                        }), g = b.formatPeriodString(l, f))
                    } else g = b.formatString(this.valueText, f);
                    if (l = this.valueFunction) k && (f = k), g = l(f, g);
                    h.text(g)
                }
            }
        },
        renderFix: function() {
            if (!d.VML) {
                var a = this.container;
                a && a.renderFix()
            }
        },
        destroy: function() {
            this.div.innerHTML = "";
            d.remove(this.set)
        }
    })
})();
(function() {
    var d = window.AmCharts;
    d.formatMilliseconds = function(a, b) {
        if (-1 != a.indexOf("fff")) {
            var c = b.getMilliseconds(),
                d = String(c);
            10 > c && (d = "00" + c);
            10 <= c && 100 > c && (d = "0" + c);
            a = a.replace(/fff/g, d)
        }
        return a
    };
    d.extractPeriod = function(a) {
        var b = d.stripNumbers(a),
            c = 1;
        b != a && (c = Number(a.slice(0, a.indexOf(b))));
        return {
            period: b,
            count: c
        }
    };
    d.getDate = function(a, b, c) {
        return a instanceof Date ? d.newDate(a, c) : b && isNaN(a) ? d.stringToDate(a, b) : new Date(a)
    };
    d.newDate = function(a, b) {
        return b && -1 == b.indexOf("fff") ? new Date(a) : d.useUTC ? new Date(a.getUTCFullYear(), a.getUTCMonth(), a.getUTCDate(), a.getUTCHours(), a.getUTCMinutes(), a.getUTCSeconds(), a.getUTCMilliseconds()) : new Date(a.getFullYear(), a.getMonth(), a.getDate(), a.getHours(), a.getMinutes(), a.getSeconds(), a.getMilliseconds())
    };
    d.resetDateToMin = function(a, b, c, e) {
        void 0 === e && (e = 1);
        var h, f, g, k, l, m, n;
        d.useUTC ? (h = a.getUTCFullYear(), f = a.getUTCMonth(), g = a.getUTCDate(), k = a.getUTCHours(), l = a.getUTCMinutes(), m = a.getUTCSeconds(), n = a.getUTCMilliseconds(), a = a.getUTCDay()) : (h = a.getFullYear(), f = a.getMonth(), g = a.getDate(), k = a.getHours(), l = a.getMinutes(), m = a.getSeconds(), n = a.getMilliseconds(), a = a.getDay());
        switch (b) {
            case "YYYY":
                h = Math.floor(h / c) * c;
                f = 0;
                g = 1;
                n = m = l = k = 0;
                break;
            case "MM":
                f = Math.floor(f / c) * c;
                g = 1;
                n = m = l = k = 0;
                break;
            case "WW":
                g = a >= e ? g - a + e : g - (7 + a) + e;
                n = m = l = k = 0;
                break;
            case "DD":
                n = m = l = k = 0;
                break;
            case "hh":
                k = Math.floor(k / c) * c;
                n = m = l = 0;
                break;
            case "mm":
                l = Math.floor(l / c) * c;
                n = m = 0;
                break;
            case "ss":
                m = Math.floor(m / c) * c;
                n = 0;
                break;
            case "fff":
                n = Math.floor(n / c) * c
        }
        d.useUTC ? (a = new Date, a.setUTCFullYear(h, f, g), a.setUTCHours(k, l, m, n)) : a = new Date(h, f, g, k, l, m, n);
        return a
    };
    d.getPeriodDuration = function(a, b) {
        void 0 === b && (b = 1);
        var c;
        switch (a) {
            case "YYYY":
                c = 316224E5;
                break;
            case "MM":
                c = 26784E5;
                break;
            case "WW":
                c = 6048E5;
                break;
            case "DD":
                c = 864E5;
                break;
            case "hh":
                c = 36E5;
                break;
            case "mm":
                c = 6E4;
                break;
            case "ss":
                c = 1E3;
                break;
            case "fff":
                c = 1
        }
        return c * b
    };
    d.intervals = {
        s: {
            nextInterval: "ss",
            contains: 1E3
        },
        ss: {
            nextInterval: "mm",
            contains: 60,
            count: 0
        },
        mm: {
            nextInterval: "hh",
            contains: 60,
            count: 1
        },
        hh: {
            nextInterval: "DD",
            contains: 24,
            count: 2
        },
        DD: {
            nextInterval: "",
            contains: Infinity,
            count: 3
        }
    };
    d.getMaxInterval = function(a, b) {
        var c = d.intervals;
        return a >= c[b].contains ? (a = Math.round(a / c[b].contains), b = c[b].nextInterval, d.getMaxInterval(a, b)) : "ss" == b ? c[b].nextInterval : b
    };
    d.dayNames = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ");
    d.shortDayNames = "Sun Mon Tue Wed Thu Fri Sat".split(" ");
    d.monthNames = "January February March April May June July August September October November December".split(" ");
    d.shortMonthNames = "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ");
    d.getWeekNumber = function(a) {
        a = new Date(a);
        a.setHours(0, 0, 0);
        a.setDate(a.getDate() + 4 - (a.getDay() || 7));
        var b = new Date(a.getFullYear(), 0, 1);
        return Math.ceil(((a - b) / 864E5 + 1) / 7)
    };
    d.stringToDate = function(a, b) {
        var c = {},
            e = [{
                pattern: "YYYY",
                period: "year"
            }, {
                pattern: "YY",
                period: "year"
            }, {
                pattern: "MM",
                period: "month"
            }, {
                pattern: "M",
                period: "month"
            }, {
                pattern: "DD",
                period: "date"
            }, {
                pattern: "D",
                period: "date"
            }, {
                pattern: "JJ",
                period: "hours"
            }, {
                pattern: "J",
                period: "hours"
            }, {
                pattern: "HH",
                period: "hours"
            }, {
                pattern: "H",
                period: "hours"
            }, {
                pattern: "KK",
                period: "hours"
            }, {
                pattern: "K",
                period: "hours"
            }, {
                pattern: "LL",
                period: "hours"
            }, {
                pattern: "L",
                period: "hours"
            }, {
                pattern: "NN",
                period: "minutes"
            }, {
                pattern: "N",
                period: "minutes"
            }, {
                pattern: "SS",
                period: "seconds"
            }, {
                pattern: "S",
                period: "seconds"
            }, {
                pattern: "QQQ",
                period: "milliseconds"
            }, {
                pattern: "QQ",
                period: "milliseconds"
            }, {
                pattern: "Q",
                period: "milliseconds"
            }],
            h = !0,
            f = b.indexOf("AA"); - 1 != f && (a.substr(f, 2), "pm" == a.toLowerCase && (h = !1));
        var f = b,
            g, k, l;
        for (l = 0; l < e.length; l++) k = e[l].period, c[k] = 0, "date" == k && (c[k] = 1);
        for (l = 0; l < e.length; l++)
            if (g = e[l].pattern, k = e[l].period, -1 != b.indexOf(g)) {
                var m = d.getFromDateString(g, a, f);
                b = b.replace(g, "");
                if ("KK" == g || "K" == g || "LL" == g || "L" == g) h || (m += 12);
                c[k] = m
            }
        d.useUTC ? (e = new Date, e.setUTCFullYear(c.year, c.month, c.date), e.setUTCHours(c.hours, c.minutes, c.seconds, c.milliseconds)) : e = new Date(c.year, c.month, c.date, c.hours, c.minutes, c.seconds, c.milliseconds);
        return e
    };
    d.getFromDateString = function(a, b, c) {
        if (void 0 !== b) return c = c.indexOf(a), b = String(b), b = b.substr(c, a.length), "0" == b.charAt(0) && (b = b.substr(1, b.length - 1)), b = Number(b), isNaN(b) && (b = 0), -1 != a.indexOf("M") && b--, b
    };
    d.formatDate = function(a, b, c) {
        c || (c = d);
        var e, h, f, g, k, l, m, n = d.getWeekNumber(a);
        d.useUTC ? (e = a.getUTCFullYear(), h = a.getUTCMonth(), f = a.getUTCDate(), g = a.getUTCDay(), k = a.getUTCHours(), l = a.getUTCMinutes(), m = a.getUTCSeconds(), a = a.getUTCMilliseconds()) : (e = a.getFullYear(), h = a.getMonth(), f = a.getDate(), g = a.getDay(), k = a.getHours(), l = a.getMinutes(), m = a.getSeconds(), a = a.getMilliseconds());
        var p = String(e).substr(2, 2),
            q = h + 1;
        9 > h && (q = "0" + q);
        var r = "0" + g;
        b = b.replace(/W/g, n);
        n = k;
        24 == n && (n = 0);
        var u = n;
        10 > u && (u = "0" + u);
        b = b.replace(/JJ/g, u);
        b = b.replace(/J/g, n);
        u = k;
        0 === u && (u = 24, -1 != b.indexOf("H") && f--);
        n = f;
        10 > f && (n = "0" + f);
        var t = u;
        10 > t && (t = "0" + t);
        b = b.replace(/HH/g, t);
        b = b.replace(/H/g, u);
        u = k;
        11 < u && (u -= 12);
        t = u;
        10 > t && (t = "0" + t);
        b = b.replace(/KK/g, t);
        b = b.replace(/K/g, u);
        u = k;
        0 === u && (u = 12);
        12 < u && (u -= 12);
        t = u;
        10 > t && (t = "0" + t);
        b = b.replace(/LL/g, t);
        b = b.replace(/L/g, u);
        u = l;
        10 > u && (u = "0" + u);
        b = b.replace(/NN/g, u);
        b = b.replace(/N/g, l);
        l = m;
        10 > l && (l = "0" + l);
        b = b.replace(/SS/g, l);
        b = b.replace(/S/g, m);
        m = a;
        10 > m && (m = "00" + m);
        100 > m && (m = "0" + m);
        l = a;
        10 > l && (l = "00" + l);
        b = b.replace(/QQQ/g, m);
        b = b.replace(/QQ/g, l);
        b = b.replace(/Q/g, a);
        b = 12 > k ? b.replace(/A/g, "am") : b.replace(/A/g, "pm");
        b = b.replace(/YYYY/g, "@IIII@");
        b = b.replace(/YY/g, "@II@");
        b = b.replace(/MMMM/g, "@XXXX@");
        b = b.replace(/MMM/g, "@XXX@");
        b = b.replace(/MM/g, "@XX@");
        b = b.replace(/M/g, "@X@");
        b = b.replace(/DD/g, "@RR@");
        b = b.replace(/D/g, "@R@");
        b = b.replace(/EEEE/g, "@PPPP@");
        b = b.replace(/EEE/g, "@PPP@");
        b = b.replace(/EE/g, "@PP@");
        b = b.replace(/E/g, "@P@");
        b = b.replace(/@IIII@/g, e);
        b = b.replace(/@II@/g, p);
        b = b.replace(/@XXXX@/g, c.monthNames[h]);
        b = b.replace(/@XXX@/g, c.shortMonthNames[h]);
        b = b.replace(/@XX@/g, q);
        b = b.replace(/@X@/g, h + 1);
        b = b.replace(/@RR@/g, n);
        b = b.replace(/@R@/g, f);
        b = b.replace(/@PPPP@/g, c.dayNames[g]);
        b = b.replace(/@PPP@/g, c.shortDayNames[g]);
        b = b.replace(/@PP@/g, r);
        return b = b.replace(/@P@/g, g)
    };
    d.changeDate = function(a, b, c, e, h) {
        if (d.useUTC) return d.changeUTCDate(a, b, c, e, h);
        var f = -1;
        void 0 === e && (e = !0);
        void 0 === h && (h = !1);
        !0 === e && (f = 1);
        switch (b) {
            case "YYYY":
                a.setFullYear(a.getFullYear() + c * f);
                e || h || a.setDate(a.getDate() + 1);
                break;
            case "MM":
                b = a.getMonth();
                a.setMonth(a.getMonth() + c * f);
                a.getMonth() > b + c * f && a.setDate(a.getDate() - 1);
                e || h || a.setDate(a.getDate() + 1);
                break;
            case "DD":
                a.setDate(a.getDate() + c * f);
                break;
            case "WW":
                a.setDate(a.getDate() + c * f * 7);
                break;
            case "hh":
                a.setHours(a.getHours() + c * f);
                break;
            case "mm":
                a.setMinutes(a.getMinutes() + c * f);
                break;
            case "ss":
                a.setSeconds(a.getSeconds() + c * f);
                break;
            case "fff":
                a.setMilliseconds(a.getMilliseconds() + c * f)
        }
        return a
    };
    d.changeUTCDate = function(a, b, c, d, h) {
        var f = -1;
        void 0 === d && (d = !0);
        void 0 === h && (h = !1);
        !0 === d && (f = 1);
        switch (b) {
            case "YYYY":
                a.setUTCFullYear(a.getUTCFullYear() + c * f);
                d || h || a.setUTCDate(a.getUTCDate() + 1);
                break;
            case "MM":
                b = a.getUTCMonth();
                a.setUTCMonth(a.getUTCMonth() + c * f);
                a.getUTCMonth() > b + c * f && a.setUTCDate(a.getUTCDate() - 1);
                d || h || a.setUTCDate(a.getUTCDate() + 1);
                break;
            case "DD":
                a.setUTCDate(a.getUTCDate() + c * f);
                break;
            case "WW":
                a.setUTCDate(a.getUTCDate() + c * f * 7);
                break;
            case "hh":
                a.setUTCHours(a.getUTCHours() + c * f);
                break;
            case "mm":
                a.setUTCMinutes(a.getUTCMinutes() + c * f);
                break;
            case "ss":
                a.setUTCSeconds(a.getUTCSeconds() + c * f);
                break;
            case "fff":
                a.setUTCMilliseconds(a.getUTCMilliseconds() + c * f)
        }
        return a
    }
})();;
(function() {
    var e = window.AmCharts;
    e.AmSerialChart = e.Class({
        inherits: e.AmRectangularChart,
        construct: function(a) {
            this.type = "serial";
            e.AmSerialChart.base.construct.call(this, a);
            this.cname = "AmSerialChart";
            this.theme = a;
            this.createEvents("changed");
            this.columnSpacing = 5;
            this.columnSpacing3D = 0;
            this.columnWidth = .8;
            this.updateScrollbar = !0;
            var b = new e.CategoryAxis(a);
            b.chart = this;
            this.categoryAxis = b;
            this.zoomOutOnDataUpdate = !0;
            this.mouseWheelZoomEnabled = this.mouseWheelScrollEnabled = this.rotate = this.skipZoom = !1;
            this.minSelectedTime = 0;
            e.applyTheme(this, a, this.cname)
        },
        initChart: function() {
            e.AmSerialChart.base.initChart.call(this);
            this.updateCategoryAxis(this.categoryAxis, this.rotate, "categoryAxis");
            this.dataChanged && (this.updateData(), this.dataChanged = !1, this.dispatchDataUpdated = !0);
            var a = this.chartCursor;
            a && a.updateData && (a.updateData(), a.fullWidth && (a.fullRectSet = this.cursorLineSet));
            var a = this.countColumns(),
                b = this.graphs,
                c;
            for (c = 0; c < b.length; c++) b[c].columnCount = a;
            this.updateScrollbar = !0;
            this.drawChart();
            this.autoMargins && !this.marginsUpdated && (this.marginsUpdated = !0, this.measureMargins())
        },
        handleWheelReal: function(a, b) {
            if (!this.wheelBusy) {
                var c = this.categoryAxis,
                    d = c.parseDates,
                    g = c.minDuration(),
                    e = c = 1;
                this.mouseWheelZoomEnabled ? b || (c = -1) : b && (c = -1);
                var f = this.chartData.length,
                    k = this.lastTime,
                    m = this.firstTime;
                0 > a ? d ? (f = this.endTime - this.startTime, d = this.startTime + c * g, g = this.endTime + e * g, 0 < e && 0 < c && g >= k && (g = k, d = k - f), this.zoomToDates(new Date(d), new Date(g))) : (0 < e && 0 < c && this.end >= f - 1 && (c = e = 0), d = this.start +
                    c, g = this.end + e, this.zoomToIndexes(d, g)) : d ? (f = this.endTime - this.startTime, d = this.startTime - c * g, g = this.endTime - e * g, 0 < e && 0 < c && d <= m && (d = m, g = m + f), this.zoomToDates(new Date(d), new Date(g))) : (0 < e && 0 < c && 1 > this.start && (c = e = 0), d = this.start - c, g = this.end - e, this.zoomToIndexes(d, g))
            }
        },
        validateData: function(a) {
            this.marginsUpdated = !1;
            this.zoomOutOnDataUpdate && !a && (this.endTime = this.end = this.startTime = this.start = NaN);
            e.AmSerialChart.base.validateData.call(this)
        },
        drawChart: function() {
            if (0 < this.realWidth && 0 < this.realHeight) {
                e.AmSerialChart.base.drawChart.call(this);
                var a = this.chartData;
                if (e.ifArray(a)) {
                    var b = this.chartScrollbar;
                    b && b.draw();
                    var a = a.length - 1,
                        c, b = this.categoryAxis;
                    if (b.parseDates && !b.equalSpacing) {
                        if (b = this.startTime, c = this.endTime, isNaN(b) || isNaN(c)) b = this.firstTime, c = this.lastTime
                    } else if (b = this.start, c = this.end, isNaN(b) || isNaN(c)) b = 0, c = a;
                    this.endTime = this.startTime = this.end = this.start = void 0;
                    this.zoom(b, c)
                }
            } else this.cleanChart();
            this.dispDUpd()
        },
        cleanChart: function() {
            e.callMethod("destroy", [this.valueAxes, this.graphs, this.categoryAxis, this.chartScrollbar, this.chartCursor])
        },
        updateCategoryAxis: function(a, b, c) {
            a.chart = this;
            a.id = c;
            a.rotate = b;
            a.axisRenderer = e.RecAxis;
            a.guideFillRenderer = e.RecFill;
            a.axisItemRenderer = e.RecItem;
            a.setOrientation(!this.rotate);
            a.x = this.marginLeftReal;
            a.y = this.marginTopReal;
            a.dx = this.dx;
            a.dy = this.dy;
            a.width = this.plotAreaWidth - 1;
            a.height = this.plotAreaHeight - 1;
            a.viW = this.plotAreaWidth - 1;
            a.viH = this.plotAreaHeight - 1;
            a.viX = this.marginLeftReal;
            a.viY = this.marginTopReal;
            a.marginsChanged = !0
        },
        updateValueAxes: function() {
            e.AmSerialChart.base.updateValueAxes.call(this);
            var a = this.valueAxes,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b],
                    d = this.rotate;
                c.rotate = d;
                c.setOrientation(d);
                d = this.categoryAxis;
                if (!d.startOnAxis || d.parseDates) c.expandMinMax = !0
            }
        },
        updateData: function() {
            this.parseData();
            var a = this.graphs,
                b, c = this.chartData;
            for (b = 0; b < a.length; b++) a[b].data = c;
            0 < c.length && (this.firstTime = this.getStartTime(c[0].time), this.lastTime = this.getEndTime(c[c.length - 1].time))
        },
        getStartTime: function(a) {
            var b = this.categoryAxis;
            return e.resetDateToMin(new Date(a), b.minPeriod, 1, b.firstDayOfWeek).getTime()
        },
        getEndTime: function(a) {
            var b = e.extractPeriod(this.categoryAxis.minPeriod);
            return e.changeDate(new Date(a), b.period, b.count, !0).getTime() - 1
        },
        updateMargins: function() {
            e.AmSerialChart.base.updateMargins.call(this);
            var a = this.chartScrollbar;
            a && (this.getScrollbarPosition(a, this.rotate, this.categoryAxis.position), this.adjustMargins(a, this.rotate))
        },
        updateScrollbars: function() {
            e.AmSerialChart.base.updateScrollbars.call(this);
            this.updateChartScrollbar(this.chartScrollbar, this.rotate)
        },
        zoom: function(a, b) {
            var c = this.categoryAxis;
            c.parseDates && !c.equalSpacing ? this.timeZoom(a, b) : this.indexZoom(a, b);
            this.updateLegendValues()
        },
        timeZoom: function(a, b) {
            var c = this.maxSelectedTime;
            isNaN(c) || (b != this.endTime && b - a > c && (a = b - c, this.updateScrollbar = !0), a != this.startTime && b - a > c && (b = a + c, this.updateScrollbar = !0));
            var d = this.minSelectedTime;
            if (0 < d && b - a < d) {
                var g = Math.round(a + (b - a) / 2),
                    d = Math.round(d / 2);
                a = g - d;
                b = g + d
            }
            var h = this.chartData,
                g = this.categoryAxis;
            if (e.ifArray(h) && (a != this.startTime || b != this.endTime)) {
                var f = g.minDuration(),
                    d = this.firstTime,
                    k = this.lastTime;
                a || (a = d, isNaN(c) || (a = k - c));
                b || (b = k);
                a > k && (a = k);
                b < d && (b = d);
                a < d && (a = d);
                b > k && (b = k);
                b < a && (b = a + f);
                b - a < f / 5 && (b < k ? b = a + f / 5 : a = b - f / 5);
                this.startTime = a;
                this.endTime = b;
                c = h.length - 1;
                f = this.getClosestIndex(h, "time", a, !0, 0, c);
                h = this.getClosestIndex(h, "time", b, !1, f, c);
                g.timeZoom(a, b);
                g.zoom(f, h);
                this.start = e.fitToBounds(f, 0, c);
                this.end = e.fitToBounds(h, 0, c);
                this.zoomAxesAndGraphs();
                this.zoomScrollbar();
                a != d || b != k ? this.showZB(!0) : this.showZB(!1);
                this.updateColumnsDepth();
                this.dispatchTimeZoomEvent()
            }
        },
        updateAfterValueZoom: function() {
            this.zoomAxesAndGraphs();
            this.zoomScrollbar();
            this.updateColumnsDepth()
        },
        indexZoom: function(a, b) {
            var c = this.maxSelectedSeries;
            isNaN(c) || (b != this.end && b - a > c && (a = b - c, this.updateScrollbar = !0), a != this.start && b - a > c && (b = a + c, this.updateScrollbar = !0));
            if (a != this.start || b != this.end) {
                var d = this.chartData.length - 1;
                isNaN(a) && (a = 0, isNaN(c) || (a = d - c));
                isNaN(b) && (b = d);
                b < a && (b = a);
                b > d && (b = d);
                a > d && (a = d - 1);
                0 > a && (a = 0);
                this.start = a;
                this.end = b;
                this.categoryAxis.zoom(a, b);
                this.zoomAxesAndGraphs();
                this.zoomScrollbar();
                0 !== a || b != this.chartData.length - 1 ? this.showZB(!0) : this.showZB(!1);
                this.updateColumnsDepth();
                this.dispatchIndexZoomEvent()
            }
        },
        updateGraphs: function() {
            e.AmSerialChart.base.updateGraphs.call(this);
            var a = this.graphs,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b];
                c.columnWidthReal = this.columnWidth;
                c.categoryAxis = this.categoryAxis;
                e.isString(c.fillToGraph) && (c.fillToGraph = this.getGraphById(c.fillToGraph))
            }
        },
        updateColumnsDepth: function() {
            var a, b = this.graphs,
                c;
            e.remove(this.columnsSet);
            this.columnsArray = [];
            for (a = 0; a < b.length; a++) {
                c = b[a];
                var d = c.columnsArray;
                if (d) {
                    var g;
                    for (g = 0; g < d.length; g++) this.columnsArray.push(d[g])
                }
            }
            this.columnsArray.sort(this.compareDepth);
            if (0 < this.columnsArray.length) {
                b = this.container.set();
                this.columnSet.push(b);
                for (a = 0; a < this.columnsArray.length; a++) b.push(this.columnsArray[a].column.set);
                c && b.translate(c.x, c.y);
                this.columnsSet = b
            }
        },
        compareDepth: function(a, b) {
            return a.depth > b.depth ? 1 : -1
        },
        zoomScrollbar: function() {
            var a = this.chartScrollbar,
                b = this.categoryAxis;
            a && this.updateScrollbar && a.enabled && a.dragger && (a.dragger.stop(), b.parseDates && !b.equalSpacing ? a.timeZoom(this.startTime, this.endTime) : a.zoom(this.start, this.end), this.updateScrollbar = !0)
        },
        updateTrendLines: function() {
            var a = this.trendLines,
                b;
            for (b = 0; b < a.length; b++) {
                var c = a[b],
                    c = e.processObject(c, e.TrendLine, this.theme);
                a[b] = c;
                c.chart = this;
                c.id || (c.id = "trendLineAuto" + b + "_" + (new Date).getTime());
                e.isString(c.valueAxis) && (c.valueAxis = this.getValueAxisById(c.valueAxis));
                c.valueAxis || (c.valueAxis = this.valueAxes[0]);
                c.categoryAxis = this.categoryAxis
            }
        },
        zoomAxesAndGraphs: function() {
            if (!this.scrollbarOnly) {
                var a = this.valueAxes,
                    b;
                for (b = 0; b < a.length; b++) a[b].zoom(this.start, this.end);
                a = this.graphs;
                for (b = 0; b < a.length; b++) a[b].zoom(this.start, this.end);
                this.zoomTrendLines();
                (b = this.chartCursor) && b.zoom && b.zoom(this.start, this.end, this.startTime, this.endTime)
            }
        },
        countColumns: function() {
            var a = 0,
                b = this.valueAxes.length,
                c = this.graphs.length,
                d, e, h = !1,
                f, k;
            for (k = 0; k < b; k++) {
                e = this.valueAxes[k];
                var m = e.stackType;
                if ("100%" == m || "regular" == m)
                    for (h = !1, f = 0; f < c; f++) d = this.graphs[f], d.tcc = 1, d.valueAxis == e && "column" == d.type && (!h && d.stackable && (a++, h = !0), (!d.stackable && d.clustered || d.newStack) && a++, d.columnIndex = a - 1, d.clustered || (d.columnIndex = 0));
                if ("none" == m || "3d" == m) {
                    h = !1;
                    for (f = 0; f < c; f++) d = this.graphs[f], d.valueAxis == e && "column" == d.type && (d.clustered ? (d.tcc = 1, d.newStack && (a = 0), d.hidden || (d.columnIndex = a, a++)) : d.hidden || (h = !0, d.tcc = 1, d.columnIndex = 0));
                    h && 0 === a && (a = 1)
                }
                if ("3d" == m) {
                    e = 1;
                    for (k = 0; k < c; k++) d = this.graphs[k], d.newStack && e++, d.depthCount = e, d.tcc = a;
                    a = e
                }
            }
            return a
        },
        parseData: function() {
            e.AmSerialChart.base.parseData.call(this);
            this.parseSerialData(this.dataProvider)
        },
        getCategoryIndexByValue: function(a) {
            var b = this.chartData,
                c, d;
            for (d = 0; d < b.length; d++) b[d].category == a && (c = d);
            return c
        },
        handleCursorChange: function(a) {
            this.updateLegendValues(a.index)
        },
        handleCursorZoom: function(a) {
            this.updateScrollbar = !0;
            this.zoom(a.start, a.end)
        },
        handleScrollbarZoom: function(a) {
            this.updateScrollbar = !1;
            this.zoom(a.start, a.end)
        },
        dispatchTimeZoomEvent: function() {
            if (this.prevStartTime != this.startTime || this.prevEndTime != this.endTime) {
                var a = {
                    type: "zoomed"
                };
                a.startDate = new Date(this.startTime);
                a.endDate = new Date(this.endTime);
                a.startIndex = this.start;
                a.endIndex = this.end;
                this.startIndex = this.start;
                this.endIndex = this.end;
                this.startDate = a.startDate;
                this.endDate = a.endDate;
                this.prevStartTime = this.startTime;
                this.prevEndTime = this.endTime;
                var b = this.categoryAxis,
                    c = e.extractPeriod(b.minPeriod).period,
                    b = b.dateFormatsObject[c];
                a.startValue = e.formatDate(a.startDate, b, this);
                a.endValue = e.formatDate(a.endDate, b, this);
                a.chart = this;
                a.target = this;
                this.fire(a.type, a)
            }
        },
        dispatchIndexZoomEvent: function() {
            if (this.prevStartIndex != this.start || this.prevEndIndex != this.end) {
                this.startIndex = this.start;
                this.endIndex = this.end;
                var a = this.chartData;
                if (e.ifArray(a) && !isNaN(this.start) && !isNaN(this.end)) {
                    var b = {
                        chart: this,
                        target: this,
                        type: "zoomed"
                    };
                    b.startIndex = this.start;
                    b.endIndex = this.end;
                    b.startValue = a[this.start].category;
                    b.endValue = a[this.end].category;
                    this.categoryAxis.parseDates && (this.startTime = a[this.start].time, this.endTime = a[this.end].time, b.startDate = new Date(this.startTime), b.endDate = new Date(this.endTime));
                    this.prevStartIndex = this.start;
                    this.prevEndIndex = this.end;
                    this.fire(b.type, b)
                }
            }
        },
        updateLegendValues: function(a) {
            var b = this.graphs,
                c;
            for (c = 0; c < b.length; c++) {
                var d = b[c];
                isNaN(a) ? d.currentDataItem = void 0 : d.currentDataItem = this.chartData[a].axes[d.valueAxis.id].graphs[d.id]
            }
            this.legend && this.legend.updateValues()
        },
        getClosestIndex: function(a, b, c, d, e, h) {
            0 > e && (e = 0);
            h > a.length - 1 && (h = a.length - 1);
            var f = e + Math.round((h -
                    e) / 2),
                k = a[f][b];
            if (c == k) return f;
            if (1 >= h - e) {
                if (d) return e;
                d = a[h][b];
                return Math.abs(a[e][b] - c) < Math.abs(d - c) ? e : h
            }
            return c == k ? f : c < k ? this.getClosestIndex(a, b, c, d, e, f) : this.getClosestIndex(a, b, c, d, f, h)
        },
        zoomToIndexes: function(a, b) {
            this.updateScrollbar = !0;
            var c = this.chartData;
            if (c) {
                var d = c.length;
                0 < d && (0 > a && (a = 0), b > d - 1 && (b = d - 1), d = this.categoryAxis, d.parseDates && !d.equalSpacing ? this.zoom(c[a].time, this.getEndTime(c[b].time)) : this.zoom(a, b))
            }
        },
        zoomToDates: function(a, b) {
            this.updateScrollbar = !0;
            var c = this.chartData;
            if (this.categoryAxis.equalSpacing) {
                var d = this.getClosestIndex(c, "time", a.getTime(), !0, 0, c.length);
                b = e.resetDateToMin(b, this.categoryAxis.minPeriod, 1);
                c = this.getClosestIndex(c, "time", b.getTime(), !1, 0, c.length);
                this.zoom(d, c)
            } else this.zoom(a.getTime(), b.getTime())
        },
        zoomToCategoryValues: function(a, b) {
            this.updateScrollbar = !0;
            this.zoom(this.getCategoryIndexByValue(a), this.getCategoryIndexByValue(b))
        },
        formatPeriodString: function(a, b) {
            if (b) {
                var c = ["value", "open", "low", "high", "close"],
                    d = "value open low high close average sum count".split(" "),
                    g = b.valueAxis,
                    h = this.chartData,
                    f = b.numberFormatter;
                f || (f = this.nf);
                for (var k = 0; k < c.length; k++) {
                    for (var m = c[k], l = 0, p = 0, q, t, x, u, r, n = 0, A = 0, y, z, v, E, H, I = this.start; I <= this.end; I++) {
                        var w = h[I];
                        if (w && (w = w.axes[g.id].graphs[b.id])) {
                            if (w.values) {
                                var B = w.values[m];
                                if (this.rotate) {
                                    if (0 > w.x || w.x > w.graph.height) B = NaN
                                } else if (0 > w.x || w.x > w.graph.width) B = NaN;
                                if (!isNaN(B)) {
                                    isNaN(q) && (q = B);
                                    t = B;
                                    if (isNaN(x) || x > B) x = B;
                                    if (isNaN(u) || u < B) u = B;
                                    r = e.getDecimals(l);
                                    var D = e.getDecimals(B),
                                        l = l + B,
                                        l = e.roundTo(l, Math.max(r, D));
                                    p++;
                                    r = l / p
                                }
                            }
                            if (w.percents && (w = w.percents[m], !isNaN(w))) {
                                isNaN(y) && (y = w);
                                z = w;
                                if (isNaN(v) || v > w) v = w;
                                if (isNaN(E) || E < w) E = w;
                                H = e.getDecimals(n);
                                B = e.getDecimals(w);
                                n += w;
                                n = e.roundTo(n, Math.max(H, B));
                                A++;
                                H = n / A
                            }
                        }
                    }
                    n = {
                        open: y,
                        close: z,
                        high: E,
                        low: v,
                        average: H,
                        sum: n,
                        count: A
                    };
                    a = e.formatValue(a, {
                        open: q,
                        close: t,
                        high: u,
                        low: x,
                        average: r,
                        sum: l,
                        count: p
                    }, d, f, m + "\\.", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);
                    a = e.formatValue(a, n, d, this.pf, "percents\\." + m + "\\.")
                }
            }
            return a = e.cleanFromEmpty(a)
        },
        formatString: function(a, b, c) {
            var d = b.graph;
            if (-1 != a.indexOf("[[category]]")) {
                var g = b.serialDataItem.category;
                if (this.categoryAxis.parseDates) {
                    var h = this.balloonDateFormat,
                        f = this.chartCursor;
                    f && (h = f.categoryBalloonDateFormat); - 1 != a.indexOf("[[category]]") && (h = e.formatDate(g, h, this), -1 != h.indexOf("fff") && (h = e.formatMilliseconds(h, g)), g = h)
                }
                a = a.replace(/\[\[category\]\]/g, String(g))
            }
            g = d.numberFormatter;
            g || (g = this.nf);
            h = b.graph.valueAxis;
            (f = h.duration) && !isNaN(b.values.value) && (f = e.formatDuration(b.values.value, f, "", h.durationUnits, h.maxInterval, g), a = a.replace(RegExp("\\[\\[value\\]\\]", "g"), f));
            "date" == h.type && (h = e.formatDate(new Date(b.values.value), d.dateFormat, this), f = RegExp("\\[\\[value\\]\\]", "g"), a = a.replace(f, h), h = e.formatDate(new Date(b.values.open), d.dateFormat, this), f = RegExp("\\[\\[open\\]\\]", "g"), a = a.replace(f, h));
            d = "value open low high close total".split(" ");
            h = this.pf;
            a = e.formatValue(a, b.percents, d, h, "percents\\.");
            a = e.formatValue(a, b.values, d, g, "", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);
            a = e.formatValue(a, b.values, ["percents"], h); - 1 != a.indexOf("[[") && (a = e.formatDataContextValue(a, b.dataContext)); - 1 != a.indexOf("[[") && b.graph.customData && (a = e.formatDataContextValue(a, b.graph.customData));
            return a = e.AmSerialChart.base.formatString.call(this, a, b, c)
        },
        addChartScrollbar: function(a) {
            e.callMethod("destroy", [this.chartScrollbar]);
            a && (a.chart = this, this.listenTo(a, "zoomed", this.handleScrollbarZoom));
            this.rotate ? void 0 === a.width && (a.width = a.scrollbarHeight) : void 0 === a.height && (a.height = a.scrollbarHeight);
            this.chartScrollbar = a
        },
        removeChartScrollbar: function() {
            e.callMethod("destroy", [this.chartScrollbar]);
            this.chartScrollbar = null
        },
        handleReleaseOutside: function(a) {
            e.AmSerialChart.base.handleReleaseOutside.call(this, a);
            e.callMethod("handleReleaseOutside", [this.chartScrollbar])
        },
        update: function() {
            e.AmSerialChart.base.update.call(this);
            this.chartScrollbar && this.chartScrollbar.update && this.chartScrollbar.update()
        }
    })
})();
(function() {
    var e = window.AmCharts;
    e.Cuboid = e.Class({
        construct: function(a, b, c, d, e, h, f, k, m, l, p, q, t, x, u, r, n) {
            this.set = a.set();
            this.container = a;
            this.h = Math.round(c);
            this.w = Math.round(b);
            this.dx = d;
            this.dy = e;
            this.colors = h;
            this.alpha = f;
            this.bwidth = k;
            this.bcolor = m;
            this.balpha = l;
            this.dashLength = x;
            this.topRadius = r;
            this.pattern = u;
            this.rotate = t;
            this.bcn = n;
            t ? 0 > b && 0 === p && (p = 180) : 0 > c && 270 == p && (p = 90);
            this.gradientRotation = p;
            0 === d && 0 === e && (this.cornerRadius = q);
            this.draw()
        },
        draw: function() {
            var a = this.set;
            a.clear();
            var b = this.container,
                c = b.chart,
                d = this.w,
                g = this.h,
                h = this.dx,
                f = this.dy,
                k = this.colors,
                m = this.alpha,
                l = this.bwidth,
                p = this.bcolor,
                q = this.balpha,
                t = this.gradientRotation,
                x = this.cornerRadius,
                u = this.dashLength,
                r = this.pattern,
                n = this.topRadius,
                A = this.bcn,
                y = k,
                z = k;
            "object" == typeof k && (y = k[0], z = k[k.length - 1]);
            var v, E, H, I, w, B, D, L, M, Q = m;
            r && (m = 0);
            var C, F, G, J, K = this.rotate;
            if (0 < Math.abs(h) || 0 < Math.abs(f))
                if (isNaN(n)) D = z, z = e.adjustLuminosity(y, -.2), z = e.adjustLuminosity(y, -.2), v = e.polygon(b, [0, h, d + h, d, 0], [0, f, f, 0, 0], z, m, 1, p, 0, t), 0 < q && (M = e.line(b, [0, h, d + h], [0, f, f], p, q, l, u)), E = e.polygon(b, [0, 0, d, d, 0], [0, g, g, 0, 0], z, m, 1, p, 0, t), E.translate(h, f), 0 < q && (H = e.line(b, [h, h], [f, f + g], p, q, l, u)), I = e.polygon(b, [0, 0, h, h, 0], [0, g, g + f, f, 0], z, m, 1, p, 0, t), w = e.polygon(b, [d, d, d + h, d + h, d], [0, g, g + f, f, 0], z, m, 1, p, 0, t), 0 < q && (B = e.line(b, [d, d + h, d + h, d], [0, f, g + f, g], p, q, l, u)), z = e.adjustLuminosity(D, .2), D = e.polygon(b, [0, h, d + h, d, 0], [g, g + f, g + f, g, g], z, m, 1, p, 0, t), 0 < q && (L = e.line(b, [0, h, d + h], [g, g + f, g + f], p, q, l, u));
                else {
                    var N, O, P;
                    K ? (N = g / 2, z = h / 2, P = g / 2, O = d + h / 2, F = Math.abs(g / 2), C = Math.abs(h / 2)) : (z = d / 2, N = f / 2, O = d / 2, P = g + f / 2 + 1, C = Math.abs(d / 2), F = Math.abs(f / 2));
                    G = C * n;
                    J = F * n;
                    .1 < C && .1 < C && (v = e.circle(b, C, y, m, l, p, q, !1, F), v.translate(z, N));
                    .1 < G && .1 < G && (D = e.circle(b, G, e.adjustLuminosity(y, .5), m, l, p, q, !1, J), D.translate(O, P))
                }
            m = Q;
            1 > Math.abs(g) && (g = 0);
            1 > Math.abs(d) && (d = 0);
            !isNaN(n) && (0 < Math.abs(h) || 0 < Math.abs(f)) ? (k = [y], k = {
                fill: k,
                stroke: p,
                "stroke-width": l,
                "stroke-opacity": q,
                "fill-opacity": m
            }, K ? (m = "M0,0 L" + d + "," + (g / 2 - g / 2 * n), l = " B", 0 < d && (l = " A"), e.VML ? (m += l + Math.round(d -
                G) + "," + Math.round(g / 2 - J) + "," + Math.round(d + G) + "," + Math.round(g / 2 + J) + "," + d + ",0," + d + "," + g, m = m + (" L0," + g) + (l + Math.round(-C) + "," + Math.round(g / 2 - F) + "," + Math.round(C) + "," + Math.round(g / 2 + F) + ",0," + g + ",0,0")) : (m += "A" + G + "," + J + ",0,0,0," + d + "," + (g - g / 2 * (1 - n)) + "L0," + g, m += "A" + C + "," + F + ",0,0,1,0,0"), C = 90) : (l = d / 2 - d / 2 * n, m = "M0,0 L" + l + "," + g, e.VML ? (m = "M0,0 L" + l + "," + g, l = " B", 0 > g && (l = " A"), m += l + Math.round(d / 2 - G) + "," + Math.round(g - J) + "," + Math.round(d / 2 + G) + "," + Math.round(g + J) + ",0," + g + "," + d + "," + g, m += " L" + d + ",0", m += l + Math.round(d / 2 + C) + "," + Math.round(F) + "," + Math.round(d / 2 - C) + "," + Math.round(-F) + "," + d + ",0,0,0") : (m += "A" + G + "," + J + ",0,0,0," + (d - d / 2 * (1 - n)) + "," + g + "L" + d + ",0", m += "A" + C + "," + F + ",0,0,1,0,0"), C = 180), b = b.path(m).attr(k), b.gradient("linearGradient", [y, e.adjustLuminosity(y, -.3), e.adjustLuminosity(y, -.3), y], C), K ? b.translate(h / 2, 0) : b.translate(0, f / 2)) : b = 0 === g ? e.line(b, [0, d], [0, 0], p, q, l, u) : 0 === d ? e.line(b, [0, 0], [0, g], p, q, l, u) : 0 < x ? e.rect(b, d, g, k, m, l, p, q, x, t, u) : e.polygon(b, [0, 0, d, d, 0], [0, g, g, 0, 0], k, m, l, p, q, t, !1, u);
            d = isNaN(n) ? 0 > g ? [v, M, E, H, I, w, B, D, L, b] : [D, L, E, H, I, w, v, M, B, b] : K ? 0 < d ? [v, b, D] : [D, b, v] : 0 > g ? [v, b, D] : [D, b, v];
            e.setCN(c, b, A + "front");
            e.setCN(c, E, A + "back");
            e.setCN(c, D, A + "top");
            e.setCN(c, v, A + "bottom");
            e.setCN(c, I, A + "left");
            e.setCN(c, w, A + "right");
            for (v = 0; v < d.length; v++)
                if (E = d[v]) a.push(E), e.setCN(c, E, A + "element");
            r && b.pattern(r, NaN, c.path)
        },
        width: function(a) {
            isNaN(a) && (a = 0);
            this.w = Math.round(a);
            this.draw()
        },
        height: function(a) {
            isNaN(a) && (a = 0);
            this.h = Math.round(a);
            this.draw()
        },
        animateHeight: function(a, b) {
            var c = this;
            c.easing = b;
            c.totalFrames = Math.round(1E3 * a / e.updateRate);
            c.rh = c.h;
            c.frame = 0;
            c.height(1);
            setTimeout(function() {
                c.updateHeight.call(c)
            }, e.updateRate)
        },
        updateHeight: function() {
            var a = this;
            a.frame++;
            var b = a.totalFrames;
            a.frame <= b && (b = a.easing(0, a.frame, 1, a.rh - 1, b), a.height(b), setTimeout(function() {
                a.updateHeight.call(a)
            }, e.updateRate))
        },
        animateWidth: function(a, b) {
            var c = this;
            c.easing = b;
            c.totalFrames = Math.round(1E3 * a / e.updateRate);
            c.rw = c.w;
            c.frame = 0;
            c.width(1);
            setTimeout(function() {
                c.updateWidth.call(c)
            }, e.updateRate)
        },
        updateWidth: function() {
            var a = this;
            a.frame++;
            var b = a.totalFrames;
            a.frame <= b && (b = a.easing(0, a.frame, 1, a.rw - 1, b), a.width(b), setTimeout(function() {
                a.updateWidth.call(a)
            }, e.updateRate))
        }
    })
})();
(function() {
    var e = window.AmCharts;
    e.CategoryAxis = e.Class({
        inherits: e.AxisBase,
        construct: function(a) {
            this.cname = "CategoryAxis";
            e.CategoryAxis.base.construct.call(this, a);
            this.minPeriod = "DD";
            this.equalSpacing = this.parseDates = !1;
            this.position = "bottom";
            this.startOnAxis = !1;
            this.firstDayOfWeek = 1;
            this.gridPosition = "middle";
            this.markPeriodChange = this.boldPeriodBeginning = !0;
            this.safeDistance = 30;
            this.centerLabelOnFullPeriod = !0;
            e.applyTheme(this, a, this.cname)
        },
        draw: function() {
            e.CategoryAxis.base.draw.call(this);
            this.generateDFObject();
            var a = this.chart.chartData;
            this.data = a;
            this.labelRotationR = this.labelRotation;
            if (e.ifArray(a)) {
                var b, c = this.chart;
                "scrollbar" != this.id ? (e.setCN(c, this.set, "category-axis"), e.setCN(c, this.labelsSet, "category-axis"), e.setCN(c, this.axisLine.axisSet, "category-axis")) : this.bcn = this.id + "-";
                var d = this.start,
                    g = this.labelFrequency,
                    h = 0,
                    f = this.end - d + 1,
                    k = this.gridCountR,
                    m = this.showFirstLabel,
                    l = this.showLastLabel,
                    p, q = "",
                    q = e.extractPeriod(this.minPeriod),
                    t = e.getPeriodDuration(q.period, q.count),
                    x, u, r, n;
                x = this.rotate;
                b = this.firstDayOfWeek;
                p = this.boldPeriodBeginning;
                n = e.resetDateToMin(new Date(a[a.length - 1].time + 1.05 * t), this.minPeriod, 1, b).getTime();
                this.firstTime = c.firstTime;
                this.endTime > n && (this.endTime = n);
                n = this.minorGridEnabled;
                var A = this.gridAlpha;
                if (this.parseDates && !this.equalSpacing) this.lastTime = a[a.length - 1].time, this.maxTime = e.resetDateToMin(new Date(this.lastTime + 1.05 * t), this.minPeriod, 1, b).getTime(), this.timeDifference = this.endTime - this.startTime, this.parseDatesDraw();
                else if (!this.parseDates) {
                    if (this.cellWidth = this.getStepWidth(f), f < k && (k = f), h += this.start, this.stepWidth = this.getStepWidth(f), 0 < k) {
                        k = Math.floor(f / k);
                        t = this.chooseMinorFrequency(k);
                        f = h;
                        f / 2 == Math.round(f / 2) && f--;
                        0 > f && (f = 0);
                        var y = 0;
                        this.end - f + 1 >= this.autoRotateCount && (this.labelRotationR = this.autoRotateAngle);
                        for (b = f; b <= this.end + 2; b++) {
                            p = !1;
                            0 <= b && b < this.data.length ? (u = this.data[b], q = u.category, p = u.forceShow) : q = "";
                            if (n && !isNaN(t))
                                if (b / t == Math.round(b / t) || p) b / k == Math.round(b / k) || p || (this.gridAlpha = this.minorGridAlpha, q = void 0);
                                else continue;
                            else if (b / k != Math.round(b / k) && !p) continue;
                            f = this.getCoordinate(b - h);
                            r = 0;
                            "start" == this.gridPosition && (f -= this.cellWidth / 2, r = this.cellWidth / 2);
                            p = !0;
                            var z = r;
                            "start" == this.tickPosition && (z = 0, p = !1, r = 0);
                            if (b == d && !m || b == this.end && !l) q = void 0;
                            Math.round(y / g) != y / g && (q = void 0);
                            y++;
                            var v = this.cellWidth;
                            x && (v = NaN, this.ignoreAxisWidth || !c.autoMargins) && (v = "right" == this.position ? c.marginRight : c.marginLeft, v -= this.tickLength + 10);
                            this.labelFunction && u && (q = this.labelFunction(q, u, this));
                            q = e.fixBrakes(q);
                            a = !1;
                            this.boldLabels && (a = !0);
                            b > this.end && "start" == this.tickPosition && (q = " ");
                            this.rotate && this.inside && (r = -2);
                            r = new this.axisItemRenderer(this, f, q, p, v, r, void 0, a, z, !1, u.labelColor, u.className);
                            r.serialDataItem = u;
                            this.pushAxisItem(r);
                            this.gridAlpha = A
                        }
                    }
                } else if (this.parseDates && this.equalSpacing) {
                    h = this.start;
                    this.startTime = this.data[this.start].time;
                    this.endTime = this.data[this.end].time;
                    this.timeDifference = this.endTime - this.startTime;
                    d = this.choosePeriod(0);
                    g = d.period;
                    x = d.count;
                    a = e.getPeriodDuration(g, x);
                    a < t && (g = q.period, x = q.count, a = t);
                    u = g;
                    "WW" == u && (u = "DD");
                    this.stepWidth = this.getStepWidth(f);
                    k = Math.ceil(this.timeDifference / a) + 1;
                    q = e.resetDateToMin(new Date(this.startTime - a), g, x, b).getTime();
                    this.cellWidth = this.getStepWidth(f);
                    f = Math.round(q / a);
                    d = -1;
                    f / 2 == Math.round(f / 2) && (d = -2, q -= a);
                    f = this.start;
                    f / 2 == Math.round(f / 2) && f--;
                    0 > f && (f = 0);
                    A = this.end + 2;
                    A >= this.data.length && (A = this.data.length);
                    y = !1;
                    y = !m;
                    this.previousPos = -1E3;
                    20 < this.labelRotationR && (this.safeDistance = 5);
                    z = f;
                    if (this.data[f].time != e.resetDateToMin(new Date(this.data[f].time), g, x, b).getTime())
                        for (a = 0, v = q, b = f; b < A; b++) t = this.data[b].time, this.checkPeriodChange(g, x, t, v) && (a++, 2 <= a && (z = b, b = A), v = t);
                    n && 1 < x && (t = this.chooseMinorFrequency(x), e.getPeriodDuration(g, t));
                    if (0 < this.gridCountR)
                        for (b = f; b < A; b++)
                            if (t = this.data[b].time, this.checkPeriodChange(g, x, t, q) && b >= z) {
                                f = this.getCoordinate(b - this.start);
                                n = !1;
                                this.nextPeriod[u] && (n = this.checkPeriodChange(this.nextPeriod[u], 1, t, q, u));
                                a = !1;
                                n && this.markPeriodChange ? (n = this.dateFormatsObject[this.nextPeriod[u]], a = !0) : n = this.dateFormatsObject[u];
                                q = e.formatDate(new Date(t), n, c);
                                if (b == d && !m || b == k && !l) q = " ";
                                y ? y = !1 : (p || (a = !1), f - this.previousPos > this.safeDistance * Math.cos(this.labelRotationR * Math.PI / 180) && (this.labelFunction && (q = this.labelFunction(q, new Date(t), this, g, x, r)), this.boldLabels && (a = !0), r = new this.axisItemRenderer(this, f, q, void 0, void 0, void 0, void 0, a), n = r.graphics(), this.pushAxisItem(r), n = n.getBBox().width, e.isModern || (n -= f), this.previousPos = f + n));
                                r = q = t
                            }
                }
                for (b = 0; b < this.data.length; b++)
                    if (m = this.data[b]) l = this.parseDates && !this.equalSpacing ? Math.round((m.time - this.startTime) * this.stepWidth + this.cellWidth / 2) : this.getCoordinate(b - h), m.x[this.id] = l;
                m = this.guides.length;
                for (b = 0; b < m; b++) l = this.guides[b], p = r = r = k = n = NaN, d = l.above, l.toCategory && (r = c.getCategoryIndexByValue(l.toCategory), isNaN(r) || (n = this.getCoordinate(r - h), l.expand && (n += this.cellWidth / 2), r = new this.axisItemRenderer(this, n, "", !0, NaN, NaN, l), this.pushAxisItem(r, d))), l.category && (p = c.getCategoryIndexByValue(l.category), isNaN(p) || (k = this.getCoordinate(p - h), l.expand && (k -= this.cellWidth / 2), r = (n - k) / 2, r = new this.axisItemRenderer(this, k, l.label, !0, NaN, r, l), this.pushAxisItem(r, d))), p = c.dataDateFormat, l.toDate && (l.toDate = e.getDate(l.toDate, p, this.minPeriod), this.equalSpacing ? (r = c.getClosestIndex(this.data, "time", l.toDate.getTime(), !1, 0, this.data.length - 1), isNaN(r) || (n = this.getCoordinate(r - h))) : n = (l.toDate.getTime() - this.startTime) * this.stepWidth, r = new this.axisItemRenderer(this, n, "", !0, NaN, NaN, l), this.pushAxisItem(r, d)), l.date && (l.date = e.getDate(l.date, p, this.minPeriod), this.equalSpacing ? (p = c.getClosestIndex(this.data, "time", l.date.getTime(), !1, 0, this.data.length - 1), isNaN(p) || (k = this.getCoordinate(p - h))) : k = (l.date.getTime() - this.startTime) * this.stepWidth, r = (n - k) / 2, p = !0, l.toDate && (p = !1), r = "H" == this.orientation ? new this.axisItemRenderer(this, k, l.label, p, 2 * r, NaN, l) : new this.axisItemRenderer(this, k, l.label, !1, NaN, r, l), this.pushAxisItem(r, d)), (0 < n || 0 < k) && (n < this.width || k < this.width) && (n = new this.guideFillRenderer(this, k, n, l), p = n.graphics(), this.pushAxisItem(n, d), l.graphics = p, p.index = b, l.balloonText && this.addEventListeners(p, l))
            }
            this.axisCreated = !0;
            c = this.x;
            h = this.y;
            this.set.translate(c, h);
            this.labelsSet.translate(c, h);
            this.labelsSet.show();
            this.positionTitle();
            (c = this.axisLine.set) && c.toFront();
            c = this.getBBox().height;
            2 < c - this.previousHeight && this.autoWrap && !this.parseDates && (this.axisCreated = this.chart.marginsUpdated = !1);
            this.previousHeight = c
        },
        xToIndex: function(a) {
            var b = this.data,
                c = this.chart,
                d = c.rotate,
                g = this.stepWidth;
            this.parseDates && !this.equalSpacing ? (a = this.startTime + Math.round(a / g) - this.minDuration() / 2, c = c.getClosestIndex(b, "time", a, !1, this.start, this.end + 1)) : (this.startOnAxis || (a -= g / 2), c = this.start + Math.round(a / g));
            var c = e.fitToBounds(c, 0, b.length - 1),
                h;
            b[c] && (h = b[c].x[this.id]);
            d ? h > this.height + 1 && c-- : h > this.width + 1 && c--;
            0 > h && c++;
            return c = e.fitToBounds(c, 0, b.length - 1)
        },
        dateToCoordinate: function(a) {
            return this.parseDates && !this.equalSpacing ? (a.getTime() - this.startTime) * this.stepWidth : this.parseDates && this.equalSpacing ? (a = this.chart.getClosestIndex(this.data, "time", a.getTime(), !1, 0, this.data.length - 1), this.getCoordinate(a - this.start)) : NaN
        },
        categoryToCoordinate: function(a) {
            return this.chart ? (a = this.chart.getCategoryIndexByValue(a), this.getCoordinate(a - this.start)) : NaN
        },
        coordinateToDate: function(a) {
            return this.equalSpacing ? (a = this.xToIndex(a), new Date(this.data[a].time)) : new Date(this.startTime + a / this.stepWidth)
        },
        getCoordinate: function(a) {
            a *= this.stepWidth;
            this.startOnAxis || (a += this.stepWidth / 2);
            return Math.round(a)
        }
    })
})();;
(function() {
    var e = window.AmCharts;
    e.AmXYChart = e.Class({
        inherits: e.AmRectangularChart,
        construct: function(a) {
            this.type = "xy";
            e.AmXYChart.base.construct.call(this, a);
            this.cname = "AmXYChart";
            this.theme = a;
            this.createEvents("zoomed");
            this.maxZoomFactor = 20;
            e.applyTheme(this, a, this.cname)
        },
        initChart: function() {
            e.AmXYChart.base.initChart.call(this);
            this.dataChanged && (this.updateData(), this.dataChanged = !1, this.dispatchDataUpdated = !0);
            this.updateScrollbar = !0;
            this.drawChart();
            this.autoMargins && !this.marginsUpdated && (this.marginsUpdated = !0, this.measureMargins());
            var a = this.marginLeftReal,
                c = this.marginTopReal,
                b = this.plotAreaWidth,
                d = this.plotAreaHeight;
            this.graphsSet.clipRect(a, c, b, d);
            this.bulletSet.clipRect(a, c, b, d);
            this.trendLinesSet.clipRect(a, c, b, d)
        },
        prepareForExport: function() {
            var a = this.bulletSet;
            a.clipPath && this.container.remove(a.clipPath)
        },
        createValueAxes: function() {
            var a = [],
                c = [];
            this.xAxes = a;
            this.yAxes = c;
            var b = this.valueAxes,
                d, f;
            for (f = 0; f < b.length; f++) {
                d = b[f];
                var k = d.position;
                if ("top" == k || "bottom" == k) d.rotate = !0;
                d.setOrientation(d.rotate);
                k = d.orientation;
                "V" == k && c.push(d);
                "H" == k && a.push(d)
            }
            0 === c.length && (d = new e.ValueAxis(this.theme), d.rotate = !1, d.setOrientation(!1), b.push(d), c.push(d));
            0 === a.length && (d = new e.ValueAxis(this.theme), d.rotate = !0, d.setOrientation(!0), b.push(d), a.push(d));
            for (f = 0; f < b.length; f++) this.processValueAxis(b[f], f);
            a = this.graphs;
            for (f = 0; f < a.length; f++) this.processGraph(a[f], f)
        },
        drawChart: function() {
            e.AmXYChart.base.drawChart.call(this);
            e.ifArray(this.chartData) ? (this.chartScrollbar && this.updateScrollbars(), this.selfZoom && (this.horizontalPosition = this.horizontalPosition * this.plotAreaWidth / this.prevPlotAreaWidth, this.verticalPosition = this.verticalPosition * this.plotAreaHeight / this.prevPlotAreaHeight, this.selfZoom = !1), this.zoomChart()) : this.cleanChart();
            if (this.hideXScrollbar) {
                var a = this.scrollbarH;
                a && (this.removeListener(a, "zoomed", this.handleHSBZoom), a.destroy());
                this.scrollbarH = null
            }
            if (this.hideYScrollbar) {
                if (a = this.scrollbarV) this.removeListener(a, "zoomed", this.handleVSBZoom), a.destroy();
                this.scrollbarV = null
            }
            if (!this.autoMargins || this.marginsUpdated) this.dispDUpd(), this.chartCreated = !0, this.zoomScrollbars()
        },
        cleanChart: function() {
            e.callMethod("destroy", [this.valueAxes, this.graphs, this.scrollbarV, this.scrollbarH, this.chartCursor])
        },
        zoomChart: function() {
            this.toggleZoomOutButton();
            this.zoomObjects(this.valueAxes);
            this.zoomObjects(this.graphs);
            this.zoomTrendLines();
            this.dispatchAxisZoom();
            this.prevPlotAreaWidth = this.plotAreaWidth;
            this.prevPlotAreaHeight = this.plotAreaHeight
        },
        toggleZoomOutButton: function() {
            1 == this.heightMultiplier && 1 == this.widthMultiplier ? this.showZB(!1) : this.showZB(!0)
        },
        dispatchAxisZoom: function() {
            var a = this.valueAxes,
                c;
            for (c = 0; c < a.length; c++) {
                var b = a[c];
                if (!isNaN(b.min) && !isNaN(b.max)) {
                    var d, f;
                    "V" == b.orientation ? (d = b.coordinateToValue(-this.verticalPosition), f = b.coordinateToValue(-this.verticalPosition + this.plotAreaHeight)) : (d = b.coordinateToValue(-this.horizontalPosition), f = b.coordinateToValue(-this.horizontalPosition + this.plotAreaWidth));
                    if (!isNaN(d) && !isNaN(f)) {
                        if (d > f) {
                            var e = f;
                            f = d;
                            d = e
                        }
                        b.dispatchZoomEvent(d, f)
                    }
                }
            }
        },
        zoomObjects: function(a) {
            var c = a.length,
                b, d;
            for (b = 0; b < c; b++) d = a[b], d.minTemp = d.min, d.maxTemp = d.max, this.updateObjectSize(d), d.zoom(0, this.chartData.length - 1), d.minTemp = NaN, d.maxTemp = NaN
        },
        updateData: function() {
            this.parseData();
            var a = this.chartData,
                c = a.length - 1,
                b = this.graphs,
                d = this.dataProvider,
                e = -Infinity,
                k = Infinity,
                h, l;
            for (h = 0; h < b.length; h++)
                if (l = b[h], l.data = a, l.zoom(0, c), l = l.valueField) {
                    var n;
                    for (n = 0; n < d.length; n++)
                        if (null !== p) {
                            var p = Number(d[n][l]);
                            p > e && (e = p);
                            p < k && (k = p)
                        }
                }
            for (h = 0; h < b.length; h++) l = b[h], l.maxValue = e, l.minValue = k;
            if (a = this.chartCursor) a.updateData(), a.type = "crosshair", a.valueBalloonsEnabled = !1
        },
        zoomOut: function() {
            this.verticalPosition = this.horizontalPosition = 0;
            this.heightMultiplier = this.widthMultiplier = 1;
            this.zoomChart();
            this.zoomScrollbars()
        },
        processValueAxis: function(a) {
            a.chart = this;
            a.minMaxField = "H" == a.orientation ? "x" : "y";
            a.min = NaN;
            a.max = NaN;
            this.listenTo(a, "axisSelfZoomed", this.handleAxisSelfZoom)
        },
        processGraph: function(a) {
            e.isString(a.xAxis) && (a.xAxis = this.getValueAxisById(a.xAxis));
            e.isString(a.yAxis) && (a.yAxis = this.getValueAxisById(a.yAxis));
            a.xAxis || (a.xAxis = this.xAxes[0]);
            a.yAxis || (a.yAxis = this.yAxes[0]);
            a.valueAxis = a.yAxis
        },
        parseData: function() {
            e.AmXYChart.base.parseData.call(this);
            this.chartData = [];
            var a = this.dataProvider,
                c = this.valueAxes,
                b = this.graphs,
                d;
            if (a)
                for (d = 0; d < a.length; d++) {
                    var f = {
                            axes: {},
                            x: {},
                            y: {}
                        },
                        k = this.dataDateFormat,
                        h = a[d],
                        l;
                    for (l = 0; l < c.length; l++) {
                        var n = c[l].id;
                        f.axes[n] = {};
                        f.axes[n].graphs = {};
                        var p;
                        for (p = 0; p < b.length; p++) {
                            var m = b[p],
                                t = m.id;
                            if (m.xAxis.id == n || m.yAxis.id == n) {
                                var q = {};
                                q.serialDataItem = f;
                                q.index = d;
                                var r = {},
                                    g = h[m.valueField];
                                null !== g && (g = Number(g), isNaN(g) || (r.value = g));
                                g = h[m.xField];
                                null !== g && ("date" == m.xAxis.type && (g = e.getDate(h[m.xField], k).getTime()), g = Number(g), isNaN(g) || (r.x = g));
                                g = h[m.yField];
                                null !== g && ("date" == m.yAxis.type && (g = e.getDate(h[m.yField], k).getTime()), g = Number(g), isNaN(g) || (r.y = g));
                                g = h[m.errorField];
                                null !== g && (g = Number(g), isNaN(g) || (r.error = g));
                                q.values = r;
                                this.processFields(m, q, h);
                                q.serialDataItem = f;
                                q.graph = m;
                                f.axes[n].graphs[t] = q
                            }
                        }
                    }
                    this.chartData[d] = f
                }
        },
        formatString: function(a, c, b) {
            var d = c.graph,
                f = d.numberFormatter;
            f || (f = this.nf);
            var k, h;
            "date" == c.graph.xAxis.type && (k = e.formatDate(new Date(c.values.x), d.dateFormat, this), h = RegExp("\\[\\[x\\]\\]", "g"), a = a.replace(h, k));
            "date" == c.graph.yAxis.type && (k = e.formatDate(new Date(c.values.y), d.dateFormat, this), h = RegExp("\\[\\[y\\]\\]", "g"), a = a.replace(h, k));
            a = e.formatValue(a, c.values, ["value", "x", "y"], f); - 1 != a.indexOf("[[") && (a = e.formatDataContextValue(a, c.dataContext));
            return a = e.AmXYChart.base.formatString.call(this, a, c, b)
        },
        addChartScrollbar: function(a) {
            e.callMethod("destroy", [this.chartScrollbar, this.scrollbarH, this.scrollbarV]);
            if (a) {
                this.chartScrollbar = a;
                this.scrollbarHeight = a.scrollbarHeight;
                var c = "backgroundColor backgroundAlpha selectedBackgroundColor selectedBackgroundAlpha scrollDuration resizeEnabled hideResizeGrips scrollbarHeight updateOnReleaseOnly".split(" ");
                if (!this.hideYScrollbar) {
                    var b = new e.SimpleChartScrollbar(this.theme);
                    b.skipEvent = !0;
                    b.chart = this;
                    this.listenTo(b, "zoomed", this.handleVSBZoom);
                    e.copyProperties(a, b, c);
                    b.rotate = !0;
                    this.scrollbarV = b
                }
                this.hideXScrollbar || (b = new e.SimpleChartScrollbar(this.theme), b.skipEvent = !0, b.chart = this, this.listenTo(b, "zoomed", this.handleHSBZoom), e.copyProperties(a, b, c), b.rotate = !1, this.scrollbarH = b)
            }
        },
        updateTrendLines: function() {
            var a = this.trendLines,
                c;
            for (c = 0; c < a.length; c++) {
                var b = a[c],
                    b = e.processObject(b, e.TrendLine, this.theme);
                a[c] = b;
                b.chart = this;
                var d = b.valueAxis;
                e.isString(d) && (b.valueAxis = this.getValueAxisById(d));
                d = b.valueAxisX;
                e.isString(d) && (b.valueAxisX = this.getValueAxisById(d));
                b.id || (b.id = "trendLineAuto" + c + "_" + (new Date).getTime());
                b.valueAxis || (b.valueAxis = this.yAxes[0]);
                b.valueAxisX || (b.valueAxisX = this.xAxes[0])
            }
        },
        updateMargins: function() {
            e.AmXYChart.base.updateMargins.call(this);
            var a = this.scrollbarV;
            a && (this.getScrollbarPosition(a, !0, this.yAxes[0].position), this.adjustMargins(a, !0));
            if (a = this.scrollbarH) this.getScrollbarPosition(a, !1, this.xAxes[0].position), this.adjustMargins(a, !1)
        },
        updateScrollbars: function() {
            e.AmXYChart.base.updateScrollbars.call(this);
            var a = this.scrollbarV;
            a && (this.updateChartScrollbar(a, !0), a.draw());
            if (a = this.scrollbarH) this.updateChartScrollbar(a, !1), a.draw()
        },
        zoomScrollbars: function() {
            var a = this.scrollbarH;
            a && a.relativeZoom(this.widthMultiplier, -this.horizontalPosition / this.widthMultiplier);
            (a = this.scrollbarV) && a.relativeZoom(this.heightMultiplier, -this.verticalPosition / this.heightMultiplier)
        },
        fitMultiplier: function(a) {
            a > this.maxZoomFactor && (a = this.maxZoomFactor);
            return a
        },
        fitH: function(a, c) {
            var b = -(this.plotAreaWidth * c - this.plotAreaWidth);
            a < b && (a = b);
            this.horizontalPosition = a
        },
        fitV: function(a, c) {
            var b = -(this.plotAreaHeight * c - this.plotAreaHeight);
            a < b && (a = b);
            this.verticalPosition = a
        },
        handleHSBZoom: function(a) {
            var c = this.fitMultiplier(a.multiplier);
            this.fitH(-a.position * c, c);
            this.widthMultiplier = c;
            this.zoomChart()
        },
        handleVSBZoom: function(a) {
            var c = this.fitMultiplier(a.multiplier);
            this.fitV(-a.position * c, c);
            this.heightMultiplier = c;
            this.zoomChart()
        },
        handleAxisSelfZoom: function(a) {
            if ("H" == a.valueAxis.orientation) {
                var c = this.fitMultiplier(a.multiplier);
                this.fitH(-a.position * c, c);
                this.widthMultiplier = c
            } else c = this.fitMultiplier(a.multiplier), this.fitV(-a.position * c, c), this.heightMultiplier = c;
            this.zoomChart();
            a = this.graphs;
            for (c = 0; c < a.length; c++) a[c].setAnimationPlayed();
            this.zoomScrollbars()
        },
        handleCursorZoom: function(a) {
            var c = this.widthMultiplier * this.plotAreaWidth / a.selectionWidth,
                b = this.heightMultiplier * this.plotAreaHeight / a.selectionHeight,
                c = this.fitMultiplier(c),
                b = this.fitMultiplier(b),
                d = (this.verticalPosition - a.selectionY) * b / this.heightMultiplier;
            this.fitH((this.horizontalPosition - a.selectionX) * c / this.widthMultiplier, c);
            this.fitV(d, b);
            this.widthMultiplier = c;
            this.heightMultiplier = b;
            this.zoomChart();
            this.zoomScrollbars()
        },
        removeChartScrollbar: function() {
            e.callMethod("destroy", [this.scrollbarH, this.scrollbarV]);
            this.scrollbarV = this.scrollbarH = null
        },
        handleReleaseOutside: function(a) {
            e.AmXYChart.base.handleReleaseOutside.call(this, a);
            e.callMethod("handleReleaseOutside", [this.scrollbarH, this.scrollbarV])
        },
        update: function() {
            e.AmXYChart.base.update.call(this);
            this.scrollbarH && this.scrollbarH.update && this.scrollbarH.update();
            this.scrollbarV && this.scrollbarV.update && this.scrollbarV.update()
        }
    })
})();;
(function() {
    var f = window.AmCharts;
    f.AmMap = f.Class({
        inherits: f.AmChart,
        construct: function(a) {
            this.cname = "AmMap";
            this.type = "map";
            this.theme = a;
            this.svgNotSupported = "This browser doesn't support SVG. Use Chrome, Firefox, Internet Explorer 9 or later.";
            this.createEvents("rollOverMapObject", "rollOutMapObject", "clickMapObject", "selectedObjectChanged", "homeButtonClicked", "zoomCompleted", "dragCompleted", "positionChanged", "writeDevInfo", "click");
            this.zoomDuration = 1;
            this.zoomControl = new f.ZoomControl(a);
            this.fitMapToContainer = !0;
            this.mouseWheelZoomEnabled = this.backgroundZoomsToTop = !1;
            this.allowClickOnSelectedObject = this.useHandCursorOnClickableOjects = this.showBalloonOnSelectedObject = !0;
            this.showObjectsAfterZoom = this.wheelBusy = !1;
            this.zoomOnDoubleClick = this.useObjectColorForBalloon = !0;
            this.allowMultipleDescriptionWindows = !1;
            this.dragMap = this.centerMap = this.linesAboveImages = !0;
            this.colorSteps = 5;
            this.showAreasInList = !0;
            this.showLinesInList = this.showImagesInList = !1;
            this.areasProcessor = new f.AreasProcessor(this);
            this.areasSettings = new f.AreasSettings(a);
            this.imagesProcessor = new f.ImagesProcessor(this);
            this.imagesSettings = new f.ImagesSettings(a);
            this.linesProcessor = new f.LinesProcessor(this);
            this.linesSettings = new f.LinesSettings(a);
            this.initialTouchZoom = 1;
            this.showDescriptionOnHover = !1;
            f.AmMap.base.construct.call(this, a);
            this.creditsPosition = "bottom-left";
            this.product = "ammap";
            this.areasClasses = {};
            f.applyTheme(this, a, this.cname)
        },
        initChart: function() {
            this.zoomInstantly = !0;
            var a = this.container;
            this.panRequired = !0;
            if (this.sizeChanged && f.hasSVG && this.chartCreated) {
                this.freeLabelsSet && this.freeLabelsSet.remove();
                this.freeLabelsSet = a.set();
                this.container.setSize(this.realWidth, this.realHeight);
                this.resizeMap();
                this.drawBackground();
                this.redrawLabels();
                this.drawTitles();
                this.processObjects();
                this.rescaleObjects();
                this.zoomControl.init(this, a);
                this.drawBg();
                var b = this.smallMap;
                b && b.init(this, a);
                (b = this.valueLegend) && b.init(this, a);
                this.sizeChanged = !1;
                this.zoomToLongLat(this.zLevelTemp, this.zLongTemp, this.zLatTemp, !0);
                this.previousWidth = this.realWidth;
                this.previousHeight = this.realHeight;
                this.updateSmallMap();
                this.linkSet.toFront();
                this.zoomControl.update && this.zoomControl.update()
            } else(f.AmMap.base.initChart.call(this), f.hasSVG) ? (this.dataChanged && (this.parseData(), this.dispatchDataUpdated = !0, this.dataChanged = !1, a = this.legend) && (a.position = "absolute", a.invalidateSize()), this.createDescriptionsDiv(), this.svgAreas = [], this.svgAreasById = {}, this.drawChart()) : (this.chartDiv.style.textAlign = "", this.chartDiv.setAttribute("class", "ammapAlert"), this.chartDiv.innerHTML = this.svgNotSupported, this.fire("failed", {
                type: "failed",
                chart: this
            }))
        },
        storeTemp: function() {
            var a = this.zoomLongitude();
            isNaN(a) || (this.zLongTemp = a);
            a = this.zoomLatitude();
            isNaN(a) || (this.zLatTemp = a);
            a = this.zoomLevel();
            isNaN(a) || (this.zLevelTemp = a)
        },
        invalidateSize: function() {
            this.storeTemp();
            f.AmMap.base.invalidateSize.call(this)
        },
        validateSize: function() {
            f.hasSVG && 0 < this.realWidth && 0 < this.realHeight && this.storeTemp();
            f.AmMap.base.validateSize.call(this)
        },
        handleWheelReal: function(a) {
            if (!this.wheelBusy) {
                this.stopAnimation();
                var b = this.zoomLevel(),
                    c = this.zoomControl,
                    d = c.zoomFactor;
                this.wheelBusy = !0;
                a = f.fitToBounds(0 < a ? b * d : b / d, c.minZoomLevel, c.maxZoomLevel);
                d = this.mouseX / this.mapWidth;
                c = this.mouseY / this.mapHeight;
                d = (this.zoomX() - d) * (a / b) + d;
                b = (this.zoomY() - c) * (a / b) + c;
                this.zoomTo(a, d, b)
            }
        },
        addLegend: function(a, b) {
            a.position = "absolute";
            a.autoMargins = !1;
            a.valueWidth = 0;
            a.switchable = !1;
            f.AmMap.base.addLegend.call(this, a, b);
            void 0 === a.enabled && (a.enabled = !0);
            return a
        },
        handleLegendEvent: function() {},
        createDescriptionsDiv: function() {
            if (!this.descriptionsDiv) {
                var a = document.createElement("div"),
                    b = a.style;
                b.position = "absolute";
                b.left = "0px";
                b.top = "0px";
                this.descriptionsDiv = a
            }
            this.containerDiv.appendChild(this.descriptionsDiv)
        },
        drawChart: function() {
            f.AmMap.base.drawChart.call(this);
            var a = this.dataProvider;
            this.dataProvider = a = f.extend(a, new f.MapData, !0);
            this.areasSettings = f.processObject(this.areasSettings, f.AreasSettings, this.theme);
            this.imagesSettings = f.processObject(this.imagesSettings, f.ImagesSettings, this.theme);
            this.linesSettings = f.processObject(this.linesSettings, f.LinesSettings, this.theme);
            var b = this.container;
            this.mapContainer && this.mapContainer.remove();
            this.mapContainer = b.set();
            this.graphsSet.push(this.mapContainer);
            var c;
            a.map && (c = f.maps[a.map]);
            a.mapVar && (c = a.mapVar);
            c ? (this.svgData = c.svg, this.getBounds(), this.buildEverything()) : (a = a.mapURL) && this.loadXml(a);
            this.balloonsSet.toFront()
        },
        drawBg: function() {
            var a = this;
            a.background.click(function() {
                a.handleBackgroundClick()
            })
        },
        buildEverything: function() {
            if (0 < this.realWidth && 0 < this.realHeight) {
                var a = this.container;
                this.zoomControl = f.processObject(this.zoomControl, f.ZoomControl, this.theme);
                this.zoomControl.init(this, a);
                this.drawBg();
                this.buildSVGMap();
                var b = this.smallMap;
                b && (b = this.smallMap = f.processObject(this.smallMap, f.SmallMap, this.theme), b.init(this, a));
                b = this.dataProvider;
                isNaN(b.zoomX) && isNaN(b.zoomY) && isNaN(b.zoomLatitude) && isNaN(b.zoomLongitude) && (this.centerMap ? (b.zoomLatitude = this.coordinateToLatitude(this.mapHeight / 2), b.zoomLongitude = this.coordinateToLongitude(this.mapWidth / 2)) : (b.zoomX = 0, b.zoomY = 0), this.zoomInstantly = !0);
                this.selectObject(this.dataProvider);
                this.processAreas();
                if (b = this.valueLegend) this.valueLegend = b = f.processObject(b, f.ValueLegend, this.theme), b.init(this, a);
                this.objectList && (a = this.objectList = f.processObject(this.objectList, f.ObjectList)) && (this.clearObjectList(), a.init(this));
                this.dispDUpd();
                this.linkSet.toFront()
            } else this.cleanChart()
        },
        hideGroup: function(a) {
            this.showHideGroup(a, !1)
        },
        showGroup: function(a) {
            this.showHideGroup(a, !0)
        },
        showHideGroup: function(a, b) {
            this.showHideReal(this.imagesProcessor.allObjects, a, b);
            this.showHideReal(this.areasProcessor.allObjects, a, b);
            this.showHideReal(this.linesProcessor.allObjects, a, b)
        },
        showHideReal: function(a, b, c) {
            var d;
            for (d = 0; d < a.length; d++) {
                var e = a[d];
                if (e.groupId == b) {
                    var g = e.displayObject;
                    g && (c ? (e.hidden = !1, g.show()) : (e.hidden = !0, g.hide()))
                }
            }
        },
        update: function() {
            f.hasSVG && (f.AmMap.base.update.call(this), this.zoomControl && this.zoomControl.update && this.zoomControl.update())
        },
        animateMap: function() {
            var a = this;
            a.totalFrames = 1E3 * a.zoomDuration / f.updateRate;
            a.totalFrames += 1;
            a.frame = 0;
            a.tweenPercent = 0;
            a.balloon.hide(0);
            setTimeout(function() {
                a.updateSize.call(a)
            }, f.updateRate)
        },
        updateSize: function() {
            var a = this,
                b = a.totalFrames;
            a.preventHover = !0;
            a.frame <= b ? (a.frame++, b = f.easeOutSine(0, a.frame, 0, 1, b), 1 <= b ? (b = 1, a.preventHover = !1, a.wheelBusy = !1) : setTimeout(function() {
                a.updateSize.call(a)
            }, f.updateRate), .8 < b && (a.preventHover = !1)) : (b = 1, a.preventHover = !1, a.wheelBusy = !1);
            a.tweenPercent = b;
            a.rescaleMapAndObjects()
        },
        rescaleMapAndObjects: function() {
            var a = this.initialScale,
                b = this.initialX,
                c = this.initialY,
                d = this.tweenPercent,
                a = a + (this.finalScale - a) * d;
            this.mapContainer.translate(b + (this.finalX - b) * d, c + (this.finalY - c) * d, a, !0);
            if (this.areasSettings.adjustOutlineThickness) {
                for (var b = this.svgAreas, e = 0; e < b.length; e++)(c = b[e]) && c.setAttr("stroke-width", this.areasSettings.outlineThickness / a);
                for (e = 0; e < b.length; e++) {
                    var c = b[e],
                        g = c.displayObject;
                    g && g.setAttr("stroke-width", c.outlineThicknessReal / a)
                }
            }
            this.rescaleObjects();
            this.positionChanged();
            this.updateSmallMap();
            1 == d && (d = {
                type: "zoomCompleted",
                chart: this
            }, this.fire(d.type, d))
        },
        updateSmallMap: function() {
            this.smallMap && this.smallMap.update()
        },
        rescaleObjects: function() {
            var a = this.mapContainer.scale,
                b = this.imagesProcessor.objectsToResize,
                c;
            for (c = 0; c < b.length; c++) {
                var d = b[c].image;
                d.translate(d.x, d.y, b[c].scale / a, !0)
            }
            b = this.imagesProcessor.labelsToReposition;
            for (c = 0; c < b.length; c++) d = b[c], d.imageLabel && this.imagesProcessor.positionLabel(d.imageLabel, d, d.labelPositionReal);
            b = this.linesProcessor;
            if (d = b.linesToResize)
                for (c = 0; c < d.length; c++) {
                    var e = d[c];
                    e.line.setAttr("stroke-width", e.thickness / a)
                }
            b = b.objectsToResize;
            for (c = 0; c < b.length; c++) d = b[c], d.translate(d.x, d.y, 1 / a, !0)
        },
        handleTouchEnd: function(a) {
            this.initialDistance = NaN;
            this.mouseIsDown = this.isDragging = !1;
            f.AmMap.base.handleTouchEnd.call(this, a)
        },
        handleMouseDown: function(a) {
            f.resetMouseOver();
            this.mouseIsDown = this.mouseIsOver = !0;
            this.balloon.hide(0);
            a && this.mouseIsOver && a.preventDefault && this.panEventsEnabled && a.preventDefault();
            if (this.chartCreated && !this.preventHover && (this.initialTouchZoom = this.zoomLevel(), this.dragMap && (this.stopAnimation(), this.mapContainerClickX = this.mapContainer.x, this.mapContainerClickY = this.mapContainer.y), a || (a = window.event), a.shiftKey && !0 === this.developerMode && this.getDevInfo(), a && a.touches)) {
                var b = this.mouseX,
                    c = this.mouseY,
                    d = a.touches.item(1);
                d && this.panEventsEnabled && this.boundingRect && (a = d.clientX - this.boundingRect.left, d = d.clientY - this.boundingRect.top, this.middleXP = (b + (a - b) / 2) / this.realWidth, this.middleYP = (c + (d - c) / 2) / this.realHeight, this.initialDistance = Math.sqrt(Math.pow(a - b, 2) + Math.pow(d - c, 2)))
            }
        },
        stopDrag: function() {
            this.isDragging = !1
        },
        handleReleaseOutside: function() {
            if (f.isModern) {
                var a = this;
                a.mouseIsDown = !1;
                setTimeout(function() {
                    a.resetPinch.call(a)
                }, 100);
                if (!a.preventHover) {
                    a.stopDrag();
                    var b = a.zoomControl;
                    b && b.draggerUp && b.draggerUp();
                    a.mapWasDragged = !1;
                    var b = a.mapContainer,
                        c = a.mapContainerClickX,
                        d = a.mapContainerClickY;
                    isNaN(c) || isNaN(d) || !(2 < Math.abs(b.x - c) || Math.abs(b.y - d)) || (a.mapWasDragged = !0, b = {
                        type: "dragCompleted",
                        zoomX: a.zoomX(),
                        zoomY: a.zoomY(),
                        zoomLevel: a.zoomLevel(),
                        chart: a
                    }, a.fire(b.type, b));
                    !a.mouseIsOver || a.mapWasDragged || a.skipClick || (b = {
                        type: "click",
                        x: a.mouseX,
                        y: a.mouseY,
                        chart: a
                    }, a.fire(b.type, b));
                    a.mapContainerClickX = NaN;
                    a.mapContainerClickY = NaN;
                    a.objectWasClicked = !1;
                    a.zoomOnDoubleClick && a.mouseIsOver && (b = (new Date).getTime(), 200 > b - a.previousClickTime && 40 < b - a.previousClickTime && a.doDoubleClickZoom(), a.previousClickTime = b)
                }
            }
        },
        resetPinch: function() {
            this.mapWasPinched = !1
        },
        handleMouseMove: function(a) {
            var b = this;
            f.AmMap.base.handleMouseMove.call(b, a);
            if (!a || !a.touches || !b.tapToActivate || b.tapped) {
                b.panEventsEnabled && b.mouseIsOver && a && a.preventDefault && a.preventDefault();
                var c = b.previuosMouseX,
                    d = b.previuosMouseY,
                    e = b.mouseX,
                    g = b.mouseY,
                    l = b.zoomControl;
                isNaN(c) && (c = e);
                isNaN(d) && (d = g);
                b.mouse2X = NaN;
                b.mouse2Y = NaN;
                a && a.touches && (a = a.touches.item(1)) && b.panEventsEnabled && b.boundingRect && (b.mouse2X = a.clientX - b.boundingRect.left, b.mouse2Y = a.clientY - b.boundingRect.top);
                if (a = b.mapContainer) {
                    var h = b.mouse2X,
                        k = b.mouse2Y;
                    b.pinchTO && clearTimeout(b.pinchTO);
                    b.pinchTO = setTimeout(function() {
                        b.resetPinch.call(b)
                    }, 1E3);
                    var n = b.realHeight,
                        p = b.realWidth,
                        x = b.mapWidth,
                        v = b.mapHeight;
                    b.mouseIsDown && b.dragMap && (5 < Math.abs(b.previuosMouseX - b.mouseX) || 5 < Math.abs(b.previuosMouseY - b.mouseY)) && (b.isDragging = !0);
                    if (!isNaN(h)) {
                        b.stopDrag();
                        var y = Math.sqrt(Math.pow(h - e, 2) + Math.pow(k - g, 2)),
                            r = b.initialDistance;
                        isNaN(r) && (r = Math.sqrt(Math.pow(h - e, 2) + Math.pow(k - g, 2)));
                        if (!isNaN(r)) {
                            var h = b.initialTouchZoom * y / r,
                                h = f.fitToBounds(h, l.minZoomLevel, l.maxZoomLevel),
                                l = b.zoomLevel(),
                                r = b.middleXP,
                                k = b.middleYP,
                                y = n / v,
                                w = p / x,
                                r = (b.zoomX() - r * w) * (h / l) + r * w,
                                k = (b.zoomY() - k * y) * (h / l) + k * y;
                            .1 < Math.abs(h - l) && (b.zoomTo(h, r, k, !0), b.mapWasPinched = !0, clearTimeout(b.pinchTO))
                        }
                    }
                    h = a.scale;
                    b.isDragging && (b.balloon.hide(0), b.positionChanged(), c = a.x + (e - c), d = a.y + (g - d), b.preventDragOut && (v = -v * h + n / 2, n /= 2, c = f.fitToBounds(c, -x * h + p / 2, p / 2), d = f.fitToBounds(d, v, n)), a.translate(c, d, h, !0), b.updateSmallMap());
                    b.previuosMouseX = e;
                    b.previuosMouseY = g
                }
            }
        },
        selectObject: function(a) {
            var b = this;
            a || (a = b.dataProvider);
            a.isOver = !1;
            var c = a.linkToObject;
            "string" == typeof c && (c = b.getObjectById(c));
            a.useTargetsZoomValues && c && (a.zoomX = c.zoomX, a.zoomY = c.zoomY, a.zoomLatitude = c.zoomLatitude, a.zoomLongitude = c.zoomLongitude, a.zoomLevel = c.zoomLevel);
            var d = b.selectedObject;
            d && b.returnInitialColor(d);
            b.selectedObject = a;
            var e = !1,
                g, l;
            "MapArea" == a.objectType && (a.autoZoomReal && (e = !0), g = b.areasSettings.selectedOutlineColor, l = b.areasSettings.selectedOutlineThickness);
            if (c && !e && ("string" == typeof c && (c = b.getObjectById(c)), isNaN(a.zoomLevel) && isNaN(a.zoomX) && isNaN(a.zoomY))) {
                if (b.extendMapData(c)) return;
                b.selectObject(c);
                return
            }
            b.allowMultipleDescriptionWindows || b.closeAllDescriptions();
            clearTimeout(b.selectedObjectTimeOut);
            clearTimeout(b.processObjectsTimeOut);
            c = b.zoomDuration;
            !e && isNaN(a.zoomLevel) && isNaN(a.zoomX) && isNaN(a.zoomY) ? (b.showDescriptionAndGetUrl(), b.processObjects()) : (b.selectedObjectTimeOut = setTimeout(function() {
                b.showDescriptionAndGetUrl.call(b)
            }, 1E3 * c + 200), b.showObjectsAfterZoom ? b.processObjectsTimeOut = setTimeout(function() {
                b.processObjects.call(b)
            }, 1E3 * c + 200) : b.processObjects());
            c = a.displayObject;
            e = a.selectedColorReal;
            "MapImage" == a.objectType && (g = b.imagesSettings.selectedOutlineColor, l = b.imagesSettings.selectedOutlineThickness, c = a.image);
            if (c) {
                if (f.setCN(b, c, "selected-object"), a.bringForwardOnHover && c.toFront(), !a.preserveOriginalAttributes) {
                    c.setAttr("stroke", a.outlineColorReal);
                    void 0 !== e && c.setAttr("fill", e);
                    void 0 !== g && c.setAttr("stroke", g);
                    void 0 !== l && c.setAttr("stroke-width", l);
                    if ("MapLine" == a.objectType) {
                        var h = a.lineSvg;
                        h && h.setAttr("stroke", e);
                        if (h = a.arrowSvg) h.setAttr("fill", e), h.setAttr("stroke", e)
                    }
                    if (h = a.imageLabel) {
                        var k = a.selectedLabelColorReal;
                        void 0 !== k && h.setAttr("fill", k)
                    }
                    a.selectable || (c.setAttr("cursor", "default"), h && h.setAttr("cursor", "default"))
                }
            } else b.returnInitialColorReal(a);
            if (c = a.groupId)
                for (h = b.getGroupById(c), k = 0; k < h.length; k++) {
                    var n = h[k];
                    n.isOver = !1;
                    c = n.displayObject;
                    "MapImage" == n.objectType && (c = n.image);
                    if (c) {
                        var p = n.selectedColorReal;
                        void 0 !== p && c.setAttr("fill", p);
                        void 0 !== g && c.setAttr("stroke", g);
                        void 0 !== l && c.setAttr("stroke-width", l);
                        "MapLine" == n.objectType && ((c = n.lineSvg) && c.setAttr("stroke", e), c = n.arrowSvg) && (c.setAttr("fill", e), c.setAttr("stroke", e))
                    }
                }
            b.zoomToSelectedObject();
            d != a && (a = {
                type: "selectedObjectChanged",
                chart: b
            }, b.fire(a.type, a))
        },
        returnInitialColor: function(a, b) {
            this.returnInitialColorReal(a);
            b && (a.isFirst = !1);
            if (this.selectedObject.bringForwardOnHover) {
                var c = this.selectedObject.displayObject;
                c && c.toFront()
            }
            if (c = a.groupId) {
                var c = this.getGroupById(c),
                    d;
                for (d = 0; d < c.length; d++) this.returnInitialColorReal(c[d]), b && (c[d].isFirst = !1)
            }
        },
        closeAllDescriptions: function() {
            this.descriptionsDiv.innerHTML = ""
        },
        returnInitialColorReal: function(a) {
            a.isOver = !1;
            var b = a.displayObject;
            if (b) {
                b.toPrevious();
                if ("MapImage" == a.objectType) {
                    var c = a.tempScale;
                    isNaN(c) || b.translate(b.x, b.y, c, !0);
                    a.tempScale = NaN;
                    b = a.image
                }
                c = a.colorReal;
                if ("MapLine" == a.objectType) {
                    var d = a.lineSvg;
                    d && d.setAttr("stroke", c);
                    if (d = a.arrowSvg) d.setAttr("fill", c), d.setAttr("stroke", c)
                }
                var d = a.alphaReal,
                    e = a.outlineAlphaReal,
                    g = a.outlineThicknessReal,
                    f = a.outlineColorReal;
                if (a.showAsSelected) {
                    var c = a.selectedColorReal,
                        h, k;
                    "MapImage" == a.objectType && (h = this.imagesSettings.selectedOutlineColor, k = this.imagesSettings.selectedOutlineThickness);
                    "MapArea" == a.objectType && (h = this.areasSettings.selectedOutlineColor, k = this.areasSettings.selectedOutlineThickness);
                    void 0 !== h && (f = h);
                    void 0 !== k && (g = k)
                }
                "bubble" == a.type && (c = void 0);
                void 0 !== c && b.setAttr("fill", c);
                if (h = a.image) h.setAttr("fill", c), h.setAttr("stroke", f), h.setAttr("stroke-width", g), h.setAttr("fill-opacity", d), h.setAttr("stroke-opacity", e);
                "MapArea" == a.objectType && (c = 1, this.areasSettings.adjustOutlineThickness && (c = this.zoomLevel()), b.setAttr("stroke", f), b.setAttr("stroke-width", g / c), b.setAttr("fill-opacity", d), b.setAttr("stroke-opacity", e));
                (c = a.pattern) && b.pattern(c, this.mapScale, this.path);
                (b = a.imageLabel) && !a.labelInactive && (a.showAsSelected && void 0 !== a.selectedLabelColor ? b.setAttr("fill", a.selectedLabelColor) : b.setAttr("fill", a.labelColorReal))
            }
        },
        zoomToRectangle: function(a, b, c, d) {
            var e = this.realWidth,
                g = this.realHeight,
                l = this.mapSet.scale,
                h = this.zoomControl,
                e = f.fitToBounds(c / e > d / g ? .8 * e / (c * l) : .8 * g / (d * l), h.minZoomLevel, h.maxZoomLevel);
            this.zoomToMapXY(e, (a + c / 2) * l, (b + d / 2) * l)
        },
        zoomToLatLongRectangle: function(a, b, c, d) {
            var e = this.dataProvider,
                g = this.zoomControl,
                l = Math.abs(c - a),
                h = Math.abs(b - d),
                k = Math.abs(e.rightLongitude - e.leftLongitude),
                e = Math.abs(e.topLatitude - e.bottomLatitude),
                g = f.fitToBounds(l / k > h / e ? .8 * k / l : .8 * e / h, g.minZoomLevel, g.maxZoomLevel);
            this.zoomToLongLat(g, a + (c - a) / 2, d + (b - d) / 2)
        },
        getGroupById: function(a) {
            var b = [];
            this.getGroup(this.imagesProcessor.allObjects, a, b);
            this.getGroup(this.linesProcessor.allObjects, a, b);
            this.getGroup(this.areasProcessor.allObjects, a, b);
            return b
        },
        zoomToGroup: function(a) {
            a = "object" == typeof a ? a : this.getGroupById(a);
            var b, c, d, e, g;
            for (g = 0; g < a.length; g++) {
                var f = a[g].displayObject;
                if (f) {
                    var h = f.getBBox(),
                        f = h.y,
                        k = h.y + h.height,
                        n = h.x,
                        h = h.x + h.width;
                    if (f < b || isNaN(b)) b = f;
                    if (k > e || isNaN(e)) e = k;
                    if (n < c || isNaN(c)) c = n;
                    if (h > d || isNaN(d)) d = h
                }
            }
            a = this.mapSet.getBBox();
            c -= a.x;
            d -= a.x;
            e -= a.y;
            b -= a.y;
            this.zoomToRectangle(c, b, d - c, e - b)
        },
        getGroup: function(a, b, c) {
            if (a) {
                var d;
                for (d = 0; d < a.length; d++) {
                    var e = a[d];
                    e.groupId == b && c.push(e)
                }
            }
        },
        zoomToStageXY: function(a, b, c, d) {
            if (!this.objectWasClicked) {
                var e = this.zoomControl;
                a = f.fitToBounds(a, e.minZoomLevel, e.maxZoomLevel);
                e = this.zoomLevel();
                c = this.coordinateToLatitude((c - this.mapContainer.y) / e);
                b = this.coordinateToLongitude((b - this.mapContainer.x) / e);
                this.zoomToLongLat(a, b, c, d)
            }
        },
        zoomToLongLat: function(a, b, c, d) {
            b = this.longitudeToCoordinate(b);
            c = this.latitudeToCoordinate(c);
            this.zoomToMapXY(a, b, c, d)
        },
        zoomToMapXY: function(a, b, c, d) {
            var e = this.mapWidth,
                g = this.mapHeight;
            this.zoomTo(a, -(b / e) * a + this.realWidth / e / 2, -(c / g) * a + this.realHeight / g / 2, d)
        },
        zoomToObject: function(a) {
            if (a) {
                var b = a.zoomLatitude,
                    c = a.zoomLongitude,
                    d = a.zoomLevel,
                    e = this.zoomInstantly,
                    g = a.zoomX,
                    l = a.zoomY,
                    h = this.realWidth,
                    k = this.realHeight;
                isNaN(d) || (isNaN(b) || isNaN(c) ? this.zoomTo(d, g, l, e) : this.zoomToLongLat(d, c, b, e));
                this.zoomInstantly = !1;
                "MapImage" == a.objectType && isNaN(a.zoomX) && isNaN(a.zoomY) && isNaN(a.zoomLatitude) && isNaN(a.zoomLongitude) && !isNaN(a.latitude) && !isNaN(a.longitude) && this.zoomToLongLat(a.zoomLevel, a.longitude, a.latitude);
                "MapArea" == a.objectType && (g = a.displayObject.getBBox(), b = this.mapScale, c = g.x * b, d = g.y * b, e = g.width * b, g = g.height * b, h = a.autoZoomReal && isNaN(a.zoomLevel) ? e / h > g / k ? .8 * h / e : .8 * k / g : a.zoomLevel, k = this.zoomControl, h = f.fitToBounds(h, k.minZoomLevel, k.maxZoomLevel), isNaN(a.zoomX) && isNaN(a.zoomY) && isNaN(a.zoomLatitude) && isNaN(a.zoomLongitude) && (a = this.mapSet.getBBox(), this.zoomToMapXY(h, -a.x * b + c + e / 2, -a.y * b + d + g / 2)));
                this.zoomControl.update()
            }
        },
        zoomToSelectedObject: function() {
            this.zoomToObject(this.selectedObject)
        },
        zoomTo: function(a, b, c, d) {
            var e = this.zoomControl;
            a = f.fitToBounds(a, e.minZoomLevel, e.maxZoomLevel);
            e = this.zoomLevel();
            isNaN(b) && (b = this.realWidth / this.mapWidth, b = (this.zoomX() - .5 * b) * (a / e) + .5 * b);
            isNaN(c) && (c = this.realHeight / this.mapHeight, c = (this.zoomY() - .5 * c) * (a / e) + .5 * c);
            this.stopAnimation();
            isNaN(a) || (e = this.mapContainer, this.initialX = e.x, this.initialY = e.y, this.initialScale = e.scale, this.finalX = this.mapWidth * b, this.finalY = this.mapHeight * c, this.finalScale = a, this.finalX != this.initialX || this.finalY != this.initialY || this.finalScale != this.initialScale ? d ? (this.tweenPercent = 1, this.rescaleMapAndObjects(), this.wheelBusy = !1) : this.animateMap() : this.wheelBusy = !1)
        },
        loadXml: function(a) {
            var b;
            window.XMLHttpRequest && (b = new XMLHttpRequest);
            b.overrideMimeType && b.overrideMimeType("text/xml");
            b.open("GET", a, !1);
            b.send();
            this.parseXMLObject(b.responseXML);
            this.svgData && this.buildEverything()
        },
        stopAnimation: function() {
            this.frame = this.totalFrames
        },
        processObjects: function() {
            var a = this.container,
                b = this.stageImagesContainer;
            b && b.remove();
            this.stageImagesContainer = b = a.set();
            this.trendLinesSet.push(b);
            var c = this.stageLinesContainer;
            c && c.remove();
            this.stageLinesContainer = c = a.set();
            this.trendLinesSet.push(c);
            var d = this.mapImagesContainer;
            d && d.remove();
            this.mapImagesContainer = d = a.set();
            this.mapContainer.push(d);
            var e = this.mapLinesContainer;
            e && e.remove();
            this.mapLinesContainer = e = a.set();
            this.mapContainer.push(e);
            this.linesAboveImages ? (d.toFront(), b.toFront(), e.toFront(), c.toFront()) : (e.toFront(), c.toFront(), d.toFront(), b.toFront());
            if (a = this.selectedObject) this.imagesProcessor.reset(), this.linesProcessor.reset(), this.linesAboveImages ? (this.imagesProcessor.process(a), this.linesProcessor.process(a)) : (this.linesProcessor.process(a), this.imagesProcessor.process(a));
            this.rescaleObjects()
        },
        processAreas: function() {
            this.areasProcessor.process(this.dataProvider)
        },
        buildSVGMap: function() {
            var a = this.svgData.g.path,
                b = this.container,
                c = b.set();
            void 0 === a.length && (a = [a]);
            var d;
            for (d = 0; d < a.length; d++) {
                var e = a[d],
                    g = e.d,
                    f = e.title;
                e.titleTr && (f = e.titleTr);
                g = b.path(g);
                g.id = e.id;
                if (this.areasSettings.preserveOriginalAttributes) {
                    g.customAttr = {};
                    for (var h in e) "d" != h && "id" != h && "title" != h && (g.customAttr[h] = e[h])
                }
                this.svgAreasById[e.id] = {
                    area: g,
                    title: f,
                    className: e["class"]
                };
                this.svgAreas.push(g);
                c.push(g)
            }
            this.mapSet = c;
            this.mapContainer.push(c);
            this.resizeMap()
        },
        addObjectEventListeners: function(a, b) {
            var c = this;
            a.mouseup(function(a) {
                c.clickMapObject(b, a)
            }).mouseover(function(a) {
                c.balloonX = NaN;
                c.rollOverMapObject(b, !0, a)
            }).mouseout(function(a) {
                c.balloonX = NaN;
                c.rollOutMapObject(b, a)
            }).touchend(function(a) {
                c.tapToActivate && !c.tapped || c.mapWasDragged || c.mapWasPinched || (c.balloonX = NaN, c.rollOverMapObject(b, !0, a), c.clickMapObject(b, a))
            }).touchstart(function(a) {})
        },
        checkIfSelected: function(a) {
            var b = this.selectedObject;
            if (b == a) return !0;
            if (b = b.groupId) {
                var b = this.getGroupById(b),
                    c;
                for (c = 0; c < b.length; c++)
                    if (b[c] == a) return !0
            }
            return !1
        },
        clearMap: function() {
            this.chartDiv.innerHTML = "";
            this.clearObjectList()
        },
        clearObjectList: function() {
            var a = this.objectList;
            a && a.div && (a.div.innerHTML = "")
        },
        checkIfLast: function(a) {
            if (a) {
                var b = a.parentNode;
                if (b && b.lastChild == a) return !0
            }
            return !1
        },
        showAsRolledOver: function(a) {
            var b = a.displayObject;
            if (!a.showAsSelected && b && !a.isOver) {
                b.node.onmouseout = function() {};
                b.node.onmouseover = function() {};
                b.node.onclick = function() {};
                !a.isFirst && a.bringForwardOnHover && (b.toFront(), a.isFirst = !0);
                var c = a.rollOverColorReal,
                    d;
                a.preserveOriginalAttributes && (c = void 0);
                void 0 == c && (isNaN(a.rollOverBrightnessReal) || (c = f.adjustLuminosity(a.colorReal, a.rollOverBrightnessReal / 100)));
                if (void 0 != c)
                    if ("MapImage" == a.objectType)(d = a.image) && d.setAttr("fill", c);
                    else if ("MapLine" == a.objectType) {
                    if ((d = a.lineSvg) && d.setAttr("stroke", c), d = a.arrowSvg) d.setAttr("fill", c), d.setAttr("stroke", c)
                } else b.setAttr("fill", c);
                (c = a.imageLabel) && !a.labelInactive && (d = a.labelRollOverColorReal, void 0 != d && c.setAttr("fill", d));
                c = a.rollOverOutlineColorReal;
                void 0 != c && ("MapImage" == a.objectType ? (d = a.image) && d.setAttr("stroke", c) : b.setAttr("stroke", c));
                "MapImage" == a.objectType ? (c = this.imagesSettings.rollOverOutlineThickness, (d = a.image) && (isNaN(c) || d.setAttr("stroke-width", c))) : (c = this.areasSettings.rollOverOutlineThickness, isNaN(c) || b.setAttr("stroke-width", c));
                if ("MapArea" == a.objectType) {
                    c = this.areasSettings;
                    d = a.rollOverAlphaReal;
                    isNaN(d) || b.setAttr("fill-opacity", d);
                    d = c.rollOverOutlineAlpha;
                    isNaN(d) || b.setAttr("stroke-opacity", d);
                    d = 1;
                    this.areasSettings.adjustOutlineThickness && (d = this.zoomLevel());
                    var e = c.rollOverOutlineThickness;
                    isNaN(e) || b.setAttr("stroke-width", e / d);
                    (c = c.rollOverPattern) && b.pattern(c, this.mapScale, this.path)
                }
                "MapImage" == a.objectType && (c = a.rollOverScaleReal, isNaN(c) || 1 == c || (d = b.scale, isNaN(d) && (d = 1), a.tempScale = d, b.translate(b.x, b.y, d * c, !0)));
                this.useHandCursorOnClickableOjects && this.checkIfClickable(a) && b.setAttr("cursor", "pointer");
                this.addObjectEventListeners(b, a);
                a.isOver = !0
            }
        },
        rollOverMapObject: function(a, b, c) {
            if (this.chartCreated) {
                this.handleMouseMove();
                var d = this.previouslyHovered;
                d && d != a ? (!1 === this.checkIfSelected(d) && (this.returnInitialColor(d, !0), this.previouslyHovered = null), this.balloon.hide(0)) : clearTimeout(this.hoverInt);
                if (!this.preventHover) {
                    if (!1 === this.checkIfSelected(a)) {
                        if (d = a.groupId) {
                            var d = this.getGroupById(d),
                                e;
                            for (e = 0; e < d.length; e++) d[e] != a && this.showAsRolledOver(d[e])
                        }
                        this.showAsRolledOver(a)
                    } else(d = a.displayObject) && (this.allowClickOnSelectedObject ? d.setAttr("cursor", "pointer") : d.setAttr("cursor", "default"));
                    this.showDescriptionOnHover ? this.showDescription(a) : !this.showBalloonOnSelectedObject && this.checkIfSelected(a) || !1 === b || (e = this.balloon, this.balloon.fixedPosition = !1, b = a.colorReal, d = "", void 0 !== b && this.useObjectColorForBalloon || (b = e.fillColor), (e = a.balloonTextReal) && (d = this.formatString(e, a)), this.balloonLabelFunction && (d = this.balloonLabelFunction(a, this)), "MapArea" != a.objectType && (this.balloonX = NaN), d && "" !== d && this.showBalloon(d, b, !1, this.balloonX, this.balloonY));
                    c = {
                        type: "rollOverMapObject",
                        mapObject: a,
                        chart: this,
                        event: c
                    };
                    this.fire(c.type, c);
                    this.previouslyHovered = a
                }
            }
        },
        longitudeToX: function(a) {
            return this.longitudeToCoordinate(a) * this.zoomLevel() + this.mapContainer.x
        },
        latitudeToY: function(a) {
            return this.latitudeToCoordinate(a) * this.zoomLevel() + this.mapContainer.y
        },
        rollOutMapObject: function(a, b) {
            this.hideBalloon();
            if (this.chartCreated && a.isOver) {
                this.checkIfSelected(a) || this.returnInitialColor(a);
                var c = {
                    type: "rollOutMapObject",
                    mapObject: a,
                    chart: this,
                    event: b
                };
                this.fire(c.type, c)
            }
        },
        formatString: function(a, b) {
            var c = this.nf,
                d = this.pf,
                e = b.title;
            b.titleTr && (e = b.titleTr);
            void 0 == e && (e = "");
            var g = b.value,
                g = isNaN(g) ? "" : f.formatNumber(g, c),
                c = b.percents,
                c = isNaN(c) ? "" : f.formatNumber(c, d),
                d = b.description;
            void 0 == d && (d = "");
            var l = b.customData;
            void 0 == l && (l = "");
            return a = f.massReplace(a, {
                "[[title]]": e,
                "[[value]]": g,
                "[[percent]]": c,
                "[[description]]": d,
                "[[customData]]": l
            })
        },
        clickMapObject: function(a, b) {
            var c = this;
            b && (b.touches || c.hideBalloon());
            if (c.chartCreated && !c.preventHover && !c.mapWasDragged && c.checkIfClickable(a) && !c.mapWasPinched) {
                c.selectObject(a);
                var d = c.zoomLevel();
                c.clickLatitude = c.coordinateToLatitude((c.mouseY - c.mapContainer.y) / d);
                c.clickLongitude = c.coordinateToLongitude((c.mouseX - c.mapContainer.x) / d);
                b && b.touches && setTimeout(function() {
                    c.showBalloonAfterZoom.call(c)
                }, 1E3 * c.zoomDuration);
                d = {
                    type: "clickMapObject",
                    mapObject: a,
                    chart: c,
                    event: b
                };
                c.fire(d.type, d);
                c.objectWasClicked = !0
            }
        },
        showBalloonAfterZoom: function() {
            this.balloonX = this.longitudeToX(this.clickLongitude);
            this.balloonY = this.latitudeToY(this.clickLatitude);
            this.rollOverMapObject(this.selectedObject, !0)
        },
        checkIfClickable: function(a) {
            var b = this.allowClickOnSelectedObject;
            return this.selectedObject == a && b ? !0 : this.selectedObject != a || b ? !0 === a.selectable || "MapArea" == a.objectType && a.autoZoomReal || a.url || a.linkToObject || 0 < a.images.length || 0 < a.lines.length || !isNaN(a.zoomLevel) || !isNaN(a.zoomX) || !isNaN(a.zoomY) || a.description ? !0 : !1 : !1
        },
        resizeMap: function() {
            var a = this.mapSet;
            if (a) {
                var b = 1,
                    c = a.getBBox(),
                    d = this.realWidth,
                    e = this.realHeight,
                    g = c.width,
                    f = c.height;
                this.fitMapToContainer && (b = g / d > f / e ? d / g : e / f);
                a.translate(-c.x * b, -c.y * b, b, !0);
                this.mapScale = b;
                this.mapHeight = f * b;
                this.mapWidth = g * b
            }
        },
        zoomIn: function() {
            var a = this.zoomLevel() * this.zoomControl.zoomFactor;
            this.zoomTo(a)
        },
        zoomOut: function() {
            var a = this.zoomLevel() / this.zoomControl.zoomFactor;
            this.zoomTo(a)
        },
        moveLeft: function() {
            var a = this.zoomX() + this.zoomControl.panStepSize;
            this.zoomTo(this.zoomLevel(), a, this.zoomY())
        },
        moveRight: function() {
            var a = this.zoomX() - this.zoomControl.panStepSize;
            this.zoomTo(this.zoomLevel(), a, this.zoomY())
        },
        moveUp: function() {
            var a = this.zoomY() + this.zoomControl.panStepSize;
            this.zoomTo(this.zoomLevel(), this.zoomX(), a)
        },
        moveDown: function() {
            var a = this.zoomY() - this.zoomControl.panStepSize;
            this.zoomTo(this.zoomLevel(), this.zoomX(), a)
        },
        zoomX: function() {
            return this.mapSet ? Math.round(1E4 * this.mapContainer.x / this.mapWidth) / 1E4 : NaN
        },
        zoomY: function() {
            return this.mapSet ? Math.round(1E4 * this.mapContainer.y / this.mapHeight) / 1E4 : NaN
        },
        goHome: function() {
            this.selectObject(this.dataProvider);
            var a = {
                type: "homeButtonClicked",
                chart: this
            };
            this.fire(a.type, a)
        },
        zoomLevel: function() {
            return Math.round(1E5 * this.mapContainer.scale) / 1E5
        },
        showDescriptionAndGetUrl: function() {
            var a = this.selectedObject;
            if (a) {
                this.showDescription();
                var b = a.url;
                if (b) f.getURL(b, a.urlTarget);
                else if (b = a.linkToObject) {
                    if ("string" == typeof b) {
                        var c = this.getObjectById(b);
                        if (c) {
                            this.selectObject(c);
                            return
                        }
                    }
                    b && a.passZoomValuesToTarget && (b.zoomLatitude = this.zoomLatitude(), b.zoomLongitude = this.zoomLongitude(), b.zoomLevel = this.zoomLevel());
                    this.extendMapData(b) || this.selectObject(b)
                }
            }
        },
        extendMapData: function(a) {
            var b = a.objectType;
            if ("MapImage" != b && "MapArea" != b && "MapLine" != b) return f.extend(a, new f.MapData, !0), this.dataProvider = a, this.zoomInstantly = !0, this.validateData(), !0
        },
        showDescription: function(a) {
            a || (a = this.selectedObject);
            this.allowMultipleDescriptionWindows || this.closeAllDescriptions();
            if (a.description) {
                var b = a.descriptionWindow;
                b && b.close();
                b = new f.DescriptionWindow;
                a.descriptionWindow = b;
                var c = a.descriptionWindowWidth,
                    d = a.descriptionWindowHeight,
                    e = a.descriptionWindowLeft,
                    g = a.descriptionWindowTop,
                    l = a.descriptionWindowRight,
                    h = a.descriptionWindowBottom;
                isNaN(l) || (e = this.realWidth - l);
                isNaN(h) || (g = this.realHeight - h);
                var k = a.descriptionWindowX;
                isNaN(k) || (e = k);
                k = a.descriptionWindowY;
                isNaN(k) || (g = k);
                isNaN(e) && (e = this.mouseX, e = e > this.realWidth / 2 ? e - c - 20 : e + 20);
                isNaN(g) && (g = this.mouseY);
                b.maxHeight = d;
                k = a.title;
                a.titleTr && (k = a.titleTr);
                b.show(this, this.descriptionsDiv, a.description, k);
                a = b.div.style;
                a.position = "absolute";
                a.width = c + "px";
                a.maxHeight = d + "px";
                isNaN(h) || (g -= b.div.offsetHeight);
                isNaN(l) || (e -= b.div.offsetWidth);
                a.left = e + "px";
                a.top = g + "px"
            }
        },
        parseXMLObject: function(a) {
            var b = {
                root: {}
            };
            this.parseXMLNode(b, "root", a);
            this.svgData = b.root.svg;
            this.getBounds()
        },
        getBounds: function() {
            var a = this.dataProvider;
            try {
                var b = this.svgData.defs["amcharts:ammap"];
                a.leftLongitude = Number(b.leftLongitude);
                a.rightLongitude = Number(b.rightLongitude);
                a.topLatitude = Number(b.topLatitude);
                a.bottomLatitude = Number(b.bottomLatitude);
                a.projection = b.projection;
                var c = b.wrappedLongitudes;
                c && (a.rightLongitude += 360);
                a.wrappedLongitudes = c
            } catch (d) {}
        },
        recalcLongitude: function(a) {
            var b = this.dataProvider.leftLongitude,
                c = this.dataProvider.wrappedLongitudes;
            return isNaN(a) && c ? a < b ? Number(a) + 360 : a : a
        },
        latitudeToCoordinate: function(a) {
            var b, c = this.dataProvider;
            if (this.mapSet) {
                b = c.topLatitude;
                var d = c.bottomLatitude;
                "mercator" == c.projection && (a = this.mercatorLatitudeToCoordinate(a), b = this.mercatorLatitudeToCoordinate(b), d = this.mercatorLatitudeToCoordinate(d));
                b = (a - b) / (d - b) * this.mapHeight
            }
            return b
        },
        longitudeToCoordinate: function(a) {
            a = this.recalcLongitude(a);
            var b, c = this.dataProvider;
            this.mapSet && (b = c.leftLongitude, b = (a -
                b) / (c.rightLongitude - b) * this.mapWidth);
            return b
        },
        mercatorLatitudeToCoordinate: function(a) {
            89.5 < a && (a = 89.5); - 89.5 > a && (a = -89.5);
            a = f.degreesToRadians(a);
            a = .5 * Math.log((1 + Math.sin(a)) / (1 - Math.sin(a)));
            return f.radiansToDegrees(a / 2)
        },
        zoomLatitude: function() {
            if (this.mapContainer) return this.coordinateToLatitude((-this.mapContainer.y + this.previousHeight / 2) / this.zoomLevel())
        },
        zoomLongitude: function() {
            if (this.mapContainer) return this.coordinateToLongitude((-this.mapContainer.x + this.previousWidth / 2) / this.zoomLevel())
        },
        getAreaCenterLatitude: function(a) {
            a = a.displayObject.getBBox();
            var b = this.mapScale;
            a = -this.mapSet.getBBox().y * b + (a.y + a.height / 2) * b;
            return this.coordinateToLatitude(a)
        },
        getAreaCenterLongitude: function(a) {
            a = a.displayObject.getBBox();
            var b = this.mapScale;
            a = -this.mapSet.getBBox().x * b + (a.x + a.width / 2) * b;
            return this.coordinateToLongitude(a)
        },
        coordinateToLatitude: function(a) {
            var b;
            if (this.mapSet) {
                var c = this.dataProvider,
                    d = c.bottomLatitude,
                    e = c.topLatitude;
                b = this.mapHeight;
                "mercator" == c.projection ? (c = this.mercatorLatitudeToCoordinate(d), e = this.mercatorLatitudeToCoordinate(e), a = 2 * Math.atan(Math.exp(2 * (a * (c - e) / b + e) * Math.PI / 180)) - .5 * Math.PI, b = f.radiansToDegrees(a)) : b = a / b * (d - e) + e
            }
            return Math.round(1E6 * b) / 1E6
        },
        coordinateToLongitude: function(a) {
            var b, c = this.dataProvider;
            this.mapSet && (b = a / this.mapWidth * (c.rightLongitude - c.leftLongitude) + c.leftLongitude);
            return Math.round(1E6 * b) / 1E6
        },
        milesToPixels: function(a) {
            var b = this.dataProvider;
            return this.mapWidth / (b.rightLongitude - b.leftLongitude) * a / 69.172
        },
        kilometersToPixels: function(a) {
            var b = this.dataProvider;
            return this.mapWidth / (b.rightLongitude - b.leftLongitude) * a / 111.325
        },
        handleBackgroundClick: function() {
            if (this.backgroundZoomsToTop && !this.mapWasDragged) {
                var a = this.dataProvider;
                if (this.checkIfClickable(a)) this.clickMapObject(a);
                else {
                    var b = a.zoomX,
                        c = a.zoomY,
                        d = a.zoomLongitude,
                        e = a.zoomLatitude,
                        a = a.zoomLevel;
                    isNaN(b) || isNaN(c) || this.zoomTo(a, b, c);
                    isNaN(d) || isNaN(e) || this.zoomToLongLat(a, d, e, !0)
                }
            }
        },
        parseXMLNode: function(a, b, c, d) {
            void 0 === d && (d = "");
            var e, g, f;
            if (c) {
                var h = c.childNodes.length;
                for (e = 0; e < h; e++) {
                    g = c.childNodes[e];
                    var k = g.nodeName,
                        n = g.nodeValue ? this.trim(g.nodeValue) : "",
                        p = !1;
                    g.attributes && 0 < g.attributes.length && (p = !0);
                    if (0 !== g.childNodes.length || "" !== n || !1 !== p)
                        if (3 == g.nodeType || 4 == g.nodeType) {
                            if ("" !== n) {
                                g = 0;
                                for (f in a[b]) a[b].hasOwnProperty(f) && g++;
                                g ? a[b]["#text"] = n : a[b] = n
                            }
                        } else if (1 == g.nodeType) {
                        var x;
                        void 0 !== a[b][k] ? void 0 === a[b][k].length ? (x = a[b][k], a[b][k] = [], a[b][k].push(x), a[b][k].push({}), x = a[b][k][1]) : "object" == typeof a[b][k] && (a[b][k].push({}), x = a[b][k][a[b][k].length - 1]) : (a[b][k] = {}, x = a[b][k]);
                        if (g.attributes && g.attributes.length)
                            for (n = 0; n < g.attributes.length; n++) x[g.attributes[n].name] = g.attributes[n].value;
                        void 0 !== a[b][k].length ? this.parseXMLNode(a[b][k], a[b][k].length - 1, g, d + "  ") : this.parseXMLNode(a[b], k, g, d + "  ")
                    }
                }
                g = 0;
                c = "";
                for (f in a[b]) "#text" == f ? c = a[b][f] : g++;
                0 === g && void 0 === a[b].length && (a[b] = c)
            }
        },
        doDoubleClickZoom: function() {
            if (!this.mapWasDragged) {
                var a = this.zoomLevel() * this.zoomControl.zoomFactor;
                this.zoomToStageXY(a, this.mouseX, this.mouseY)
            }
        },
        getDevInfo: function() {
            var a = this.zoomLevel(),
                a = {
                    chart: this,
                    type: "writeDevInfo",
                    zoomLevel: a,
                    zoomX: this.zoomX(),
                    zoomY: this.zoomY(),
                    zoomLatitude: this.zoomLatitude(),
                    zoomLongitude: this.zoomLongitude(),
                    latitude: this.coordinateToLatitude((this.mouseY - this.mapContainer.y) / a),
                    longitude: this.coordinateToLongitude((this.mouseX - this.mapContainer.x) / a),
                    left: this.mouseX,
                    top: this.mouseY,
                    right: this.realWidth - this.mouseX,
                    bottom: this.realHeight - this.mouseY,
                    percentLeft: Math.round(this.mouseX / this.realWidth * 100) + "%",
                    percentTop: Math.round(this.mouseY / this.realHeight * 100) + "%",
                    percentRight: Math.round((this.realWidth - this.mouseX) / this.realWidth * 100) + "%",
                    percentBottom: Math.round((this.realHeight - this.mouseY) / this.realHeight * 100) + "%"
                },
                b = "zoomLevel:" + a.zoomLevel + ", zoomLongitude:" + a.zoomLongitude + ", zoomLatitude:" + a.zoomLatitude + "\n",
                b = b + ("zoomX:" + a.zoomX + ", zoomY:" + a.zoomY + "\n"),
                b = b + ("latitude:" + a.latitude + ", longitude:" + a.longitude + "\n"),
                b = b + ("left:" + a.left + ", top:" + a.top + "\n"),
                b = b + ("right:" + a.right + ", bottom:" + a.bottom + "\n"),
                b = b + ("left:" + a.percentLeft + ", top:" + a.percentTop + "\n"),
                b = b + ("right:" + a.percentRight + ", bottom:" + a.percentBottom + "\n");
            a.str = b;
            this.fire(a.type, a);
            return a
        },
        getXY: function(a, b, c) {
            void 0 !== a && (-1 != String(a).indexOf("%") ? (a = Number(a.split("%").join("")), c && (a = 100 - a), a = Number(a) * b / 100) : c && (a = b - a));
            return a
        },
        getObjectById: function(a) {
            var b = this.dataProvider;
            if (b.areas) {
                var c = this.getObject(a, b.areas);
                if (c) return c
            }
            if (c = this.getObject(a, b.images)) return c;
            if (a = this.getObject(a, b.lines)) return a
        },
        getObject: function(a, b) {
            if (b) {
                var c;
                for (c = 0; c < b.length; c++) {
                    var d = b[c];
                    if (d.id == a) return d;
                    if (d.areas) {
                        var e = this.getObject(a, d.areas);
                        if (e) return e
                    }
                    if (e = this.getObject(a, d.images)) return e;
                    if (d = this.getObject(a, d.lines)) return d
                }
            }
        },
        parseData: function() {
            var a = this.dataProvider;
            this.processObject(a.areas, a, "area");
            this.processObject(a.images, a, "image");
            this.processObject(a.lines, a, "line")
        },
        processObject: function(a, b, c) {
            if (a) {
                var d;
                for (d = 0; d < a.length; d++) {
                    var e = a[d];
                    e.parentObject = b;
                    "area" == c && f.extend(e, new f.MapArea(this.theme), !0);
                    "image" == c && (e = f.extend(e, new f.MapImage(this.theme), !0));
                    "line" == c && (e = f.extend(e, new f.MapLine(this.theme), !0));
                    a[d] = e;
                    e.areas && this.processObject(e.areas, e, "area");
                    e.images && this.processObject(e.images, e, "image");
                    e.lines && this.processObject(e.lines, e, "line")
                }
            }
        },
        positionChanged: function() {
            var a = {
                type: "positionChanged",
                zoomX: this.zoomX(),
                zoomY: this.zoomY(),
                zoomLevel: this.zoomLevel(),
                chart: this
            };
            this.fire(a.type, a)
        },
        getX: function(a, b) {
            return this.getXY(a, this.realWidth, b)
        },
        getY: function(a, b) {
            return this.getXY(a, this.realHeight, b)
        },
        trim: function(a) {
            if (a) {
                var b;
                for (b = 0; b < a.length; b++)
                    if (-1 === " \n\r\t\f\x0B\u00a0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u3000".indexOf(a.charAt(b))) {
                        a = a.substring(b);
                        break
                    }
                for (b = a.length - 1; 0 <= b; b--)
                    if (-1 === " \n\r\t\f\x0B\u00a0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u3000".indexOf(a.charAt(b))) {
                        a = a.substring(0, b + 1);
                        break
                    }
                return -1 === " \n\r\t\f\x0B\u00a0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u3000".indexOf(a.charAt(0)) ? a : ""
            }
        },
        destroy: function() {
            f.AmMap.base.destroy.call(this)
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.ZoomControl = f.Class({
        construct: function(a) {
            this.cname = "ZoomControl";
            this.panStepSize = .1;
            this.zoomFactor = 2;
            this.maxZoomLevel = 64;
            this.minZoomLevel = 1;
            this.panControlEnabled = !1;
            this.zoomControlEnabled = !0;
            this.buttonRollOverColor = "#DADADA";
            this.buttonFillColor = "#FFFFFF";
            this.buttonFillAlpha = 1;
            this.buttonBorderColor = "#000000";
            this.buttonBorderAlpha = .1;
            this.buttonIconAlpha = this.buttonBorderThickness = 1;
            this.gridColor = this.buttonIconColor = "#000000";
            this.homeIconFile = "homeIcon.gif";
            this.gridBackgroundColor = "#000000";
            this.draggerAlpha = this.gridAlpha = this.gridBackgroundAlpha = 0;
            this.draggerSize = this.buttonSize = 31;
            this.iconSize = 11;
            this.homeButtonEnabled = !0;
            this.buttonCornerRadius = 2;
            this.gridHeight = 5;
            this.roundButtons = !0;
            this.top = this.left = 10;
            f.applyTheme(this, a, this.cname)
        },
        init: function(a, b) {
            var c = this;
            c.chart = a;
            f.remove(c.set);
            var d = b.set();
            f.setCN(a, d, "zoom-control");
            var e = c.buttonSize,
                g = c.zoomControlEnabled,
                l = c.panControlEnabled,
                h = c.buttonFillColor,
                k = c.buttonFillAlpha,
                n = c.buttonBorderThickness,
                p = c.buttonBorderColor,
                x = c.buttonBorderAlpha,
                v = c.buttonCornerRadius,
                y = c.buttonRollOverColor,
                r = c.gridHeight,
                w = c.zoomFactor,
                J = c.minZoomLevel,
                A = c.maxZoomLevel,
                D = c.buttonIconAlpha,
                B = c.buttonIconColor,
                E = c.roundButtons,
                P = a.svgIcons,
                q = a.getX(c.left),
                u = a.getY(c.top);
            isNaN(c.right) || (q = a.getX(c.right, !0), q = l ? q - 3 * e : q - e);
            isNaN(c.bottom) || (u = a.getY(c.bottom, !0), g && (u -= r + 3 * e), u = l ? u - 3 * e : c.homeButtonEnabled ? u - .5 * e : u + e);
            d.translate(q, u);
            c.previousDY = NaN;
            var m, q = e / 4 - 1;
            if (g) {
                m = b.set();
                f.setCN(a, m, "zoom-control-zoom");
                d.push(m);
                c.set = d;
                c.zoomSet = m;
                g = f.rect(b, e + 6, r + 2 * e + 6, c.gridBackgroundColor, c.gridBackgroundAlpha, 0, 0, 0, 4);
                f.setCN(a, g, "zoom-bg");
                g.translate(-3, -3);
                g.mouseup(function() {
                    c.handleBgUp()
                }).touchend(function() {
                    c.handleBgUp()
                });
                m.push(g);
                var z = e;
                E && (z = e / 1.5);
                c.draggerSize = z;
                var F = Math.log(A / J) / Math.log(w) + 1,
                    g = r / F,
                    t, N = b.set();
                N.translate((e - z) / 2 + 1, 1, NaN, !0);
                m.push(N);
                for (t = 1; t < F; t++) u = e + t * g, u = f.line(b, [1, z - 2], [u, u], c.gridColor, c.gridAlpha, 1), f.setCN(a, u, "zoom-grid"), N.push(u);
                u = new f.SimpleButton;
                u.setDownHandler(c.draggerDown, c);
                u.setClickHandler(c.draggerUp, c);
                u.init(b, z, g, h, k, n, p, x, v, y);
                f.setCN(a, u.set, "zoom-dragger");
                m.push(u.set);
                u.set.setAttr("opacity", c.draggerAlpha);
                c.dragger = u.set;
                c.previousY = NaN;
                u = new f.SimpleButton;
                P ? (z = b.set(), F = f.line(b, [-q, q], [0, 0], B, D, 1), t = f.line(b, [0, 0], [-q, q], B, D, 1), z.push(F), z.push(t), u.svgIcon = z) : u.setIcon(a.pathToImages + "plus.gif", c.iconSize);
                u.setClickHandler(a.zoomIn, a);
                u.init(b, e, e, h, k, n, p, x, v, y, D, B, E);
                f.setCN(a, u.set, "zoom-in");
                m.push(u.set);
                u = new f.SimpleButton;
                P ? u.svgIcon = f.line(b, [-q, q], [0, 0], B, D, 1) : u.setIcon(a.pathToImages + "minus.gif", c.iconSize);
                u.setClickHandler(a.zoomOut, a);
                u.init(b, e, e, h, k, n, p, x, v, y, D, B, E);
                u.set.translate(0, r + e);
                f.setCN(a, u.set, "zoom-out");
                m.push(u.set);
                r -= g;
                J = Math.log(J / 100) / Math.log(w);
                w = Math.log(A / 100) / Math.log(w);
                c.realStepSize = r / (w - J);
                c.realGridHeight = r;
                c.stepMax = w
            }
            l && (l = b.set(), f.setCN(a, l, "zoom-control-pan"), d.push(l), m && m.translate(e, 4 * e), w = new f.SimpleButton, P ? w.svgIcon = f.line(b, [q / 5, -q + q / 5, q / 5], [-q, 0, q], B, D, 1) : w.setIcon(a.pathToImages + "panLeft.gif", c.iconSize), w.setClickHandler(a.moveLeft, a), w.init(b, e, e, h, k, n, p, x, v, y, D, B, E), w.set.translate(0, e), f.setCN(a, w.set, "pan-left"), l.push(w.set), w = new f.SimpleButton, P ? w.svgIcon = f.line(b, [-q / 5, q - q / 5, -q / 5], [-q, 0, q], B, D, 1) : w.setIcon(a.pathToImages + "panRight.gif", c.iconSize), w.setClickHandler(a.moveRight, a), w.init(b, e, e, h, k, n, p, x, v, y, D, B, E), w.set.translate(2 * e, e), f.setCN(a, w.set, "pan-right"), l.push(w.set), w = new f.SimpleButton, P ? w.svgIcon = f.line(b, [-q, 0, q], [q / 5, -q + q / 5, q / 5], B, D, 1) : w.setIcon(a.pathToImages + "panUp.gif", c.iconSize), w.setClickHandler(a.moveUp, a), w.init(b, e, e, h, k, n, p, x, v, y, D, B, E), w.set.translate(e, 0), f.setCN(a, w.set, "pan-up"), l.push(w.set), w = new f.SimpleButton, P ? w.svgIcon = f.line(b, [-q, 0, q], [-q / 5, q - q / 5, -q / 5], B, D, 1) : w.setIcon(a.pathToImages + "panDown.gif", c.iconSize), w.setClickHandler(a.moveDown, a), w.init(b, e, e, h, k, n, p, x, v, y, D, B, E), w.set.translate(e, 2 * e), f.setCN(a, w.set, "pan-down"), l.push(w.set), d.push(l));
            c.homeButtonEnabled && (l = new f.SimpleButton, P ? l.svgIcon = f.polygon(b, [-q, 0, q, q - 1, q - 1, 2, 2, -2, -2, -q + 1, -q + 1], [0, -q, 0, 0, q - 1, q - 1, 2, 2, q - 1, q - 1, 0], B, D, 1, B, D) : l.setIcon(a.pathToImages + c.homeIconFile, c.iconSize), l.setClickHandler(a.goHome, a), c.panControlEnabled && (x = k = 0), l.init(b, e, e, h, k, n, p, x, v, y, D, B, E), c.panControlEnabled ? l.set.translate(e, e) : m && m.translate(0, 1.5 * e), f.setCN(a, l.set, "pan-home"), d.push(l.set));
            c.update()
        },
        draggerDown: function() {
            this.chart.stopDrag();
            this.isDragging = !0
        },
        draggerUp: function() {
            this.isDragging = !1
        },
        handleBgUp: function() {
            var a = this.chart,
                b = 100 * Math.pow(this.zoomFactor, this.stepMax - (a.mouseY - this.zoomSet.y - this.set.y - this.buttonSize - this.realStepSize / 2) / this.realStepSize);
            a.zoomTo(b)
        },
        update: function() {
            var a, b = this.zoomFactor,
                c = this.realStepSize,
                d = this.stepMax,
                e = this.dragger,
                g = this.buttonSize,
                l = this.chart;
            l && (this.isDragging ? (l.stopDrag(), a = e.y + (l.mouseY - this.previousY), a = f.fitToBounds(a, g, this.realGridHeight + g), c = 100 * Math.pow(b, d - (a - g) / c), l.zoomTo(c, NaN, NaN, !0)) : (a = Math.log(l.zoomLevel() / 100) / Math.log(b), a = (d - a) * c + g), this.previousY = l.mouseY, this.previousDY != a && e && (e.translate((this.buttonSize - this.draggerSize) / 2, a), this.previousDY = a))
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.SimpleButton = f.Class({
        construct: function() {},
        init: function(a, b, c, d, e, g, l, h, k, n, p, x, v) {
            var y = this;
            y.rollOverColor = n;
            y.color = d;
            y.container = a;
            n = a.set();
            y.set = n;
            v ? (b /= 2, d = f.circle(a, b, d, e, g, l, h), d.translate(b, b)) : d = f.rect(a, b, c, d, e, g, l, h, k);
            n.push(d);
            e = y.iconPath;
            var r;
            e && (r = y.iconSize, g = (b - r) / 2, v && (g = (2 * b - r) / 2), r = a.image(e, g, (c - r) / 2, r, r));
            y.svgIcon && (r = y.svgIcon, v ? r.translate(b, b) : r.translate(b / 2, b / 2));
            n.setAttr("cursor", "pointer");
            r && (n.push(r), r.setAttr("opacity", p), r.node.style.pointerEvents = "none");
            d.mousedown(function() {
                y.handleDown()
            }).touchstart(function() {
                y.handleDown()
            }).mouseup(function() {
                y.handleUp()
            }).touchend(function() {
                y.handleUp()
            }).mouseover(function() {
                y.handleOver()
            }).mouseout(function() {
                y.handleOut()
            });
            y.bg = d
        },
        setIcon: function(a, b) {
            this.iconPath = a;
            this.iconSize = b
        },
        setClickHandler: function(a, b) {
            this.clickHandler = a;
            this.scope = b
        },
        setDownHandler: function(a, b) {
            this.downHandler = a;
            this.scope = b
        },
        handleUp: function() {
            var a = this.clickHandler;
            a && a.call(this.scope)
        },
        handleDown: function() {
            var a = this.downHandler;
            a && a.call(this.scope)
        },
        handleOver: function() {
            this.container.chart.skipClick = !0;
            this.bg.setAttr("fill", this.rollOverColor)
        },
        handleOut: function() {
            this.container.chart.skipClick = !1;
            this.bg.setAttr("fill", this.color)
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.SmallMap = f.Class({
        construct: function(a) {
            this.cname = "SmallMap";
            this.mapColor = "#e6e6e6";
            this.rectangleColor = "#FFFFFF";
            this.top = this.right = 10;
            this.minimizeButtonWidth = 23;
            this.backgroundColor = "#9A9A9A";
            this.backgroundAlpha = 1;
            this.borderColor = "#FFFFFF";
            this.iconColor = "#000000";
            this.borderThickness = 3;
            this.borderAlpha = 1;
            this.size = .2;
            this.enabled = !0;
            f.applyTheme(this, a, this.cname)
        },
        init: function(a, b) {
            var c = this;
            if (c.enabled) {
                c.chart = a;
                c.container = b;
                c.width = a.realWidth * c.size;
                c.height = a.realHeight * c.size;
                f.remove(c.set);
                var d = b.set();
                c.set = d;
                f.setCN(a, d, "small-map");
                var e = b.set();
                c.allSet = e;
                d.push(e);
                c.buildSVGMap();
                var g = c.borderThickness,
                    l = c.borderColor,
                    h = f.rect(b, c.width + g, c.height + g, c.backgroundColor, c.backgroundAlpha, g, l, c.borderAlpha);
                f.setCN(a, h, "small-map-bg");
                h.translate(-g / 2, -g / 2);
                e.push(h);
                h.toBack();
                var k, n, h = c.minimizeButtonWidth,
                    p = new f.SimpleButton,
                    x = h / 2;
                a.svgIcons ? p.svgIcon = f.line(b, [-x / 2, 0, x / 2], [-x / 4, x / 4, -x / 4], c.iconColor, 1, 1) : p.setIcon(a.pathToImages + "arrowDown.gif", h);
                p.setClickHandler(c.minimize, c);
                p.init(b, h, h, l, 1, 1, l, 1);
                f.setCN(a, p.set, "small-map-down");
                p = p.set;
                c.downButtonSet = p;
                d.push(p);
                var v = new f.SimpleButton;
                a.svgIcons ? v.svgIcon = f.line(b, [-x / 2, 0, x / 2], [x / 4, -x / 4, x / 4], c.iconColor, 1, 1) : v.setIcon(a.pathToImages + "arrowUp.gif", h);
                v.setClickHandler(c.maximize, c);
                v.init(b, h, h, l, 1, 1, l, 1);
                f.setCN(a, v.set, "small-map-up");
                l = v.set;
                c.upButtonSet = l;
                l.hide();
                d.push(l);
                var y, r;
                isNaN(c.top) || (k = a.getY(c.top) + g, r = 0);
                isNaN(c.bottom) || (k = a.getY(c.bottom, !0) -
                    c.height - g, r = c.height - h + g / 2);
                isNaN(c.left) || (n = a.getX(c.left) + g, y = -g / 2);
                isNaN(c.right) || (n = a.getX(c.right, !0) - c.width - g, y = c.width - h + g / 2);
                g = b.set();
                g.clipRect(1, 1, c.width, c.height);
                e.push(g);
                c.rectangleC = g;
                d.translate(n, k);
                p.translate(y, r);
                l.translate(y, r);
                e.mouseup(function() {
                    c.handleMouseUp()
                });
                c.drawRectangle()
            } else f.remove(c.allSet), f.remove(c.downButtonSet), f.remove(c.upButtonSet)
        },
        minimize: function() {
            this.downButtonSet.hide();
            this.upButtonSet.show();
            this.allSet.hide()
        },
        maximize: function() {
            this.downButtonSet.show();
            this.upButtonSet.hide();
            this.allSet.show()
        },
        buildSVGMap: function() {
            var a = this.chart,
                b = {
                    fill: this.mapColor,
                    stroke: this.mapColor,
                    "stroke-opacity": 1
                },
                c = a.svgData.g.path,
                d = this.container,
                e = d.set();
            f.setCN(a, e, "small-map-image");
            var g;
            for (g = 0; g < c.length; g++) {
                var l = d.path(c[g].d).attr(b);
                e.push(l)
            }
            this.allSet.push(e);
            b = e.getBBox();
            c = this.size * a.mapScale;
            d = -b.x * c;
            g = -b.y * c;
            var h = l = 0;
            a.centerMap && (l = (this.width - b.width * c) / 2, h = (this.height - b.height * c) / 2);
            this.mapWidth = b.width * c;
            this.mapHeight = b.height * c;
            this.dx = l;
            this.dy = h;
            e.translate(d + l, g + h, c)
        },
        update: function() {
            var a = this.chart,
                b = a.zoomLevel(),
                c = this.width,
                d = a.mapContainer,
                a = c / (a.realWidth * b),
                c = c / b,
                b = this.height / b,
                e = this.rectangle;
            e.translate(-d.x * a + this.dx, -d.y * a + this.dy);
            0 < c && 0 < b && (e.setAttr("width", Math.ceil(c + 1)), e.setAttr("height", Math.ceil(b + 1)));
            this.rWidth = c;
            this.rHeight = b
        },
        drawRectangle: function() {
            var a = this.rectangle;
            f.remove(a);
            a = f.rect(this.container, 10, 10, "#000", 0, 1, this.rectangleColor, 1);
            f.setCN(this.chart, a, "small-map-rectangle");
            this.rectangleC.push(a);
            this.rectangle = a
        },
        handleMouseUp: function() {
            var a = this.chart,
                b = a.zoomLevel();
            a.zoomTo(b, -((a.mouseX - this.set.x - this.dx - this.rWidth / 2) / this.mapWidth) * b, -((a.mouseY - this.set.y - this.dy - this.rHeight / 2) / this.mapHeight) * b)
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.AreasProcessor = f.Class({
        construct: function(a) {
            this.chart = a
        },
        process: function(a) {
            this.updateAllAreas();
            this.allObjects = [];
            a = a.areas;
            var b = this.chart,
                c, d = a.length,
                e, g;
            c = 0;
            var l = b.svgAreasById,
                h = !1,
                k = !1,
                n = 0;
            for (e = 0; e < d; e++)
                if (g = a[e], g = g.value, !isNaN(g)) {
                    if (!1 === h || h < g) h = g;
                    if (!1 === k || k > g) k = g;
                    c += Math.abs(g);
                    n++
                }
            isNaN(b.minValue) || (k = b.minValue);
            isNaN(b.maxValue) || (h = b.maxValue);
            b.maxValueReal = h;
            b.minValueReal = k;
            for (e = 0; e < d; e++) g = a[e], isNaN(g.value) ? g.percents = void 0 : (g.percents = (g.value - k) / c * 100, k == h && (g.percents = 100));
            for (e = 0; e < d; e++) {
                g = a[e];
                var p = l[g.id];
                c = b.areasSettings;
                p && p.className && (n = b.areasClasses[p.className]) && (c = n, c = f.processObject(c, f.AreasSettings, b.theme));
                var x = c.color,
                    v = c.alpha,
                    y = c.outlineThickness,
                    r = c.rollOverColor,
                    w = c.selectedColor,
                    J = c.rollOverAlpha,
                    A = c.rollOverBrightness,
                    D = c.outlineColor,
                    B = c.outlineAlpha,
                    E = c.balloonText,
                    P = c.selectable,
                    q = c.pattern,
                    u = c.rollOverOutlineColor,
                    m = c.bringForwardOnHover,
                    z = c.preserveOriginalAttributes;
                this.allObjects.push(g);
                g.chart = b;
                g.baseSettings = c;
                g.autoZoomReal = void 0 == g.autoZoom ? c.autoZoom : g.autoZoom;
                n = g.color;
                void 0 == n && (n = x);
                var F = g.alpha;
                isNaN(F) && (F = v);
                v = g.rollOverAlpha;
                isNaN(v) && (v = J);
                isNaN(v) && (v = F);
                J = g.rollOverColor;
                void 0 == J && (J = r);
                r = g.pattern;
                void 0 == r && (r = q);
                q = g.selectedColor;
                void 0 == q && (q = w);
                (w = g.balloonText) || (w = E);
                void 0 == c.colorSolid || isNaN(g.value) || (E = Math.floor((g.value - k) / ((h - k) / b.colorSteps)), E == b.colorSteps && E--, E *= 1 / (b.colorSteps - 1), h == k && (E = 1), g.colorReal = f.getColorFade(n, c.colorSolid, E));
                void 0 != g.color && (g.colorReal = g.color);
                void 0 == g.selectable && (g.selectable = P);
                void 0 == g.colorReal && (g.colorReal = x);
                x = g.outlineColor;
                void 0 == x && (x = D);
                D = g.outlineAlpha;
                isNaN(D) && (D = B);
                B = g.outlineThickness;
                isNaN(B) && (B = y);
                y = g.rollOverOutlineColor;
                void 0 == y && (y = u);
                u = g.rollOverBrightness;
                void 0 == u && (u = A);
                void 0 == g.bringForwardOnHover && (g.bringForwardOnHover = m);
                void 0 == g.preserveOriginalAttributes && (g.preserveOriginalAttributes = z);
                isNaN(c.selectedBrightness) || (q = f.adjustLuminosity(g.colorReal, c.selectedBrightness / 100));
                g.alphaReal = F;
                g.rollOverColorReal = J;
                g.rollOverAlphaReal = v;
                g.balloonTextReal = w;
                g.selectedColorReal = q;
                g.outlineColorReal = x;
                g.outlineAlphaReal = D;
                g.rollOverOutlineColorReal = y;
                g.outlineThicknessReal = B;
                g.patternReal = r;
                g.rollOverBrightnessReal = u;
                f.processDescriptionWindow(c, g);
                if (p && (A = p.area, m = p.title, g.enTitle = p.title, m && !g.title && (g.title = m), (p = b.language) ? (m = f.mapTranslations) && (p = m[p]) && p[g.enTitle] && (g.titleTr = p[g.enTitle]) : g.titleTr = void 0, A)) {
                    g.displayObject = A;
                    g.mouseEnabled && b.addObjectEventListeners(A, g);
                    var t;
                    void 0 != n && (t = n);
                    void 0 != g.colorReal && (t = g.showAsSelected || b.selectedObject == g ? g.selectedColorReal : g.colorReal);
                    A.node.setAttribute("class", "");
                    f.setCN(b, A, "map-area");
                    f.setCN(b, A, "map-area-" + A.id);
                    c.adjustOutlineThickness && (B /= b.zoomLevel());
                    g.preserveOriginalAttributes || (A.setAttr("fill", t), A.setAttr("stroke", x), A.setAttr("stroke-opacity", D), A.setAttr("stroke-width", B), A.setAttr("fill-opacity", F));
                    r && A.pattern(r, b.mapScale, b.path);
                    g.hidden && A.hide()
                }
            }
        },
        updateAllAreas: function() {
            var a = this.chart,
                b = a.areasSettings,
                c = b.unlistedAreasColor,
                d = b.unlistedAreasAlpha,
                e = b.unlistedAreasOutlineColor,
                g = b.unlistedAreasOutlineAlpha,
                l = a.svgAreas,
                h = a.dataProvider,
                k = h.areas,
                n = {},
                p;
            for (p = 0; p < k.length; p++) n[k[p].id] = k[p];
            for (p = 0; p < l.length; p++) {
                k = l[p];
                if (b.preserveOriginalAttributes) {
                    if (k.customAttr)
                        for (var x in k.customAttr) k.setAttr(x, k.customAttr[x])
                } else {
                    void 0 != c && k.setAttr("fill", c);
                    isNaN(d) || k.setAttr("fill-opacity", d);
                    void 0 != e && k.setAttr("stroke", e);
                    isNaN(g) || k.setAttr("stroke-opacity", g);
                    var v = b.outlineThickness;
                    b.adjustOutlineThickness && (v /= a.zoomLevel());
                    k.setAttr("stroke-width", v)
                }
                f.setCN(a, k, "map-area-unlisted");
                h.getAreasFromMap && !n[k.id] && (v = new f.MapArea(a.theme), v.parentObject = h, v.id = k.id, h.areas.push(v))
            }
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.AreasSettings = f.Class({
        construct: function(a) {
            this.cname = "AreasSettings";
            this.alpha = 1;
            this.autoZoom = !1;
            this.balloonText = "[[title]]";
            this.color = "#FFCC00";
            this.colorSolid = "#990000";
            this.unlistedAreasAlpha = 1;
            this.unlistedAreasColor = "#DDDDDD";
            this.outlineColor = "#FFFFFF";
            this.outlineThickness = this.outlineAlpha = 1;
            this.selectedColor = this.rollOverOutlineColor = "#CC0000";
            this.unlistedAreasOutlineColor = "#FFFFFF";
            this.unlistedAreasOutlineAlpha = 1;
            this.descriptionWindowWidth = 250;
            this.bringForwardOnHover = this.adjustOutlineThickness = !0;
            f.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.ImagesProcessor = f.Class({
        construct: function(a) {
            this.chart = a;
            this.reset()
        },
        process: function(a) {
            var b = a.images,
                c;
            for (c = 0; c < b.length; c++) this.createImage(b[c], c);
            a.parentObject && a.remainVisible && this.process(a.parentObject)
        },
        createImage: function(a, b) {
            var c = this.chart,
                d = c.container,
                e = c.mapImagesContainer,
                g = c.stageImagesContainer,
                l = c.imagesSettings;
            a.remove && a.remove();
            var h = l.color,
                k = l.alpha,
                n = l.rollOverColor,
                p = l.rollOverOutlineColor,
                x = l.selectedColor,
                v = l.balloonText,
                y = l.outlineColor,
                r = l.outlineAlpha,
                w = l.outlineThickness,
                J = l.selectedScale,
                A = l.rollOverScale,
                D = l.labelPosition,
                B = l.labelColor,
                E = l.labelFontSize,
                P = l.bringForwardOnHover,
                q = l.labelRollOverColor,
                u = l.rollOverBrightness,
                m = l.selectedLabelColor;
            a.index = b;
            a.chart = c;
            a.baseSettings = c.imagesSettings;
            var z = d.set();
            a.displayObject = z;
            var F = a.color;
            void 0 == F && (F = h);
            h = a.alpha;
            isNaN(h) && (h = k);
            void 0 == a.bringForwardOnHover && (a.bringForwardOnHover = P);
            k = a.outlineAlpha;
            isNaN(k) && (k = r);
            r = a.rollOverColor;
            void 0 == r && (r = n);
            n = a.selectedColor;
            void 0 == n && (n = x);
            (x = a.balloonText) || (x = v);
            v = a.outlineColor;
            void 0 == v && (v = y);
            a.outlineColorReal = v;
            y = a.outlineThickness;
            isNaN(y) && (y = w);
            (w = a.labelPosition) || (w = D);
            D = a.labelColor;
            void 0 == D && (D = B);
            B = a.labelRollOverColor;
            void 0 == B && (B = q);
            q = a.selectedLabelColor;
            void 0 == q && (q = m);
            m = a.labelFontSize;
            isNaN(m) && (m = E);
            E = a.selectedScale;
            isNaN(E) && (E = J);
            J = a.rollOverScale;
            isNaN(J) && (J = A);
            A = a.rollOverBrightness;
            void 0 == A && (A = u);
            isNaN(l.selectedBrightness) || (n = f.adjustLuminosity(a.colorReal, l.selectedBrightness / 100));
            a.colorReal = F;
            a.alphaReal = h;
            a.rollOverColorReal = r;
            a.balloonTextReal = x;
            a.selectedColorReal = n;
            a.labelColorReal = D;
            a.labelRollOverColorReal = B;
            a.selectedLabelColorReal = q;
            a.labelFontSizeReal = m;
            a.labelPositionReal = w;
            a.selectedScaleReal = E;
            a.rollOverScaleReal = J;
            a.rollOverOutlineColorReal = p;
            a.rollOverBrightnessReal = A;
            f.processDescriptionWindow(l, a);
            a.centeredReal = void 0 == a.centered ? l.centered : a.centered;
            A = a.type;
            J = a.imageURL;
            E = a.svgPath;
            m = a.width;
            r = a.height;
            p = a.scale;
            isNaN(a.percentWidth) || (m = a.percentWidth / 100 * c.realWidth);
            isNaN(a.percentHeight) || (r = a.percentHeight / 100 * c.realHeight);
            var t;
            J || A || E || (A = "circle", m = 1, k = h = 0);
            q = u = 0;
            l = a.selectedColorReal;
            if (A) {
                isNaN(m) && (m = 10);
                isNaN(r) && (r = 10);
                "kilometers" == a.widthAndHeightUnits && (m = c.kilometersToPixels(a.width), r = c.kilometersToPixels(a.height));
                "miles" == a.widthAndHeightUnits && (m = c.milesToPixels(a.width), r = c.milesToPixels(a.height));
                if ("circle" == A || "bubble" == A) r = m;
                t = this.createPredefinedImage(F, v, y, A, m, r);
                q = u = 0;
                a.centeredReal ? (isNaN(a.right) || (u = m * p), isNaN(a.bottom) || (q = r * p)) : (u = m * p / 2, q = r * p / 2);
                t.translate(u, q, p, !0)
            } else J ? (isNaN(m) && (m = 10), isNaN(r) && (r = 10), t = d.image(J, 0, 0, m, r), t.node.setAttribute("preserveAspectRatio", "none"), t.setAttr("opacity", h), a.centeredReal && (u = isNaN(a.right) ? -m / 2 : m / 2, q = isNaN(a.bottom) ? -r / 2 : r / 2, t.translate(u, q, NaN, !0))) : E && (t = d.path(E), v = t.getBBox(), a.centeredReal ? (u = -v.x * p - v.width * p / 2, isNaN(a.right) || (u = -u), q = -v.y * p - v.height * p / 2, isNaN(a.bottom) || (q = -q)) : u = q = 0, t.translate(u, q, p, !0), t.x = u, t.y = q);
            t && (z.push(t), a.image = t, t.setAttr("stroke-opacity", k), t.setAttr("fill-opacity", h), t.setAttr("fill", F), f.setCN(c, t, "map-image"), void 0 != a.id && f.setCN(c, t, "map-image-" + a.id));
            F = a.labelColorReal;
            !a.showAsSelected && c.selectedObject != a || void 0 == l || (t.setAttr("fill", l), F = a.selectedLabelColorReal);
            t = null;
            void 0 !== a.label && (t = f.text(d, a.label, F, c.fontFamily, a.labelFontSizeReal, a.labelAlign), f.setCN(c, t, "map-image-label"), void 0 !== a.id && f.setCN(c, t, "map-image-label-" + a.id), F = a.labelBackgroundAlpha, (h = a.labelBackgroundColor) && 0 < F && (k = t.getBBox(), d = f.rect(d, k.width + 16, k.height + 10, h, F), f.setCN(c, d, "map-image-label-background"), void 0 != a.id && f.setCN(c, d, "map-image-label-background-" + a.id), z.push(d), a.labelBG = d), a.imageLabel = t, z.push(t), f.setCN(c, z, "map-image-container"), void 0 != a.id && f.setCN(c, z, "map-image-container-" + a.id));
            isNaN(a.latitude) || isNaN(a.longitude) ? g.push(z) : e.push(z);
            z && (z.rotation = a.rotation, isNaN(a.rotation) || z.rotate(a.rotation));
            this.updateSizeAndPosition(a);
            a.mouseEnabled && c.addObjectEventListeners(z, a);
            a.hidden && z.hide()
        },
        updateSizeAndPosition: function(a) {
            var b = this.chart,
                c = a.displayObject,
                d = b.getX(a.left),
                e = b.getY(a.top),
                g = a.image.getBBox();
            isNaN(a.right) || (d = b.getX(a.right, !0) - g.width * a.scale);
            isNaN(a.bottom) || (e = b.getY(a.bottom, !0) - g.height * a.scale);
            var f = a.longitude,
                h = a.latitude,
                g = this.objectsToResize;
            this.allSvgObjects.push(c);
            this.allObjects.push(a);
            var k = a.imageLabel;
            if (!isNaN(d) && !isNaN(e)) c.translate(d, e, NaN, !0);
            else if (!isNaN(h) && !isNaN(f))
                if (d = b.longitudeToCoordinate(f), e = b.latitudeToCoordinate(h), c.translate(d, e, NaN, !0), a.fixedSize) {
                    d = 1;
                    if (a.showAsSelected || b.selectedObject == a) d = a.selectedScaleReal;
                    g.push({
                        image: c,
                        scale: d
                    })
                } else k && this.labelsToReposition.push(a);
            this.positionLabel(k, a, a.labelPositionReal)
        },
        positionLabel: function(a, b, c) {
            if (a) {
                var d = b.image,
                    e = 0,
                    g = 0,
                    f = 0,
                    h = 0;
                d && (h = d.getBBox(), g = d.y, e = d.x, f = h.width, h = h.height, b.svgPath && (f *= b.scale, h *= b.scale));
                var d = a.getBBox(),
                    k = d.width,
                    n = d.height;
                "right" == c && (e += f + k / 2 + 5, g += h / 2 - 2);
                "left" == c && (e += -k / 2 - 5, g += h / 2 - 2);
                "top" == c && (g -= n / 2 + 3, e += f / 2);
                "bottom" == c && (g += h + n / 2, e += f / 2);
                "middle" == c && (e += f / 2, g += h / 2);
                a.translate(e +
                    b.labelShiftX, g + b.labelShiftY, NaN, !0);
                b.labelBG && b.labelBG.translate(e - d.width / 2 + b.labelShiftX - 9, g + b.labelShiftY - d.height / 2 - 3, NaN, !0)
            }
        },
        createPredefinedImage: function(a, b, c, d, e, g) {
            var l = this.chart.container,
                h;
            switch (d) {
                case "circle":
                    h = f.circle(l, e / 2, a, 1, c, b, 1);
                    break;
                case "rectangle":
                    h = f.polygon(l, [-e / 2, e / 2, e / 2, -e / 2], [g / 2, g / 2, -g / 2, -g / 2], a, 1, c, b, 1);
                    break;
                case "bubble":
                    h = f.circle(l, e / 2, a, 1, c, b, 1, !0);
                    break;
                case "hexagon":
                    e /= Math.sqrt(3), h = f.polygon(l, [.866 * e, 0 * e, -.866 * e, -.866 * e, 0 * e, .866 * e], [.5 * e, 1 * e, .5 * e, -.5 * e, -1 * e, -.5 * e], a, 1, c, b, 1)
            }
            return h
        },
        reset: function() {
            this.objectsToResize = [];
            this.allSvgObjects = [];
            this.allObjects = [];
            this.allLabels = [];
            this.labelsToReposition = []
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.ImagesSettings = f.Class({
        construct: function(a) {
            this.cname = "ImagesSettings";
            this.balloonText = "[[title]]";
            this.alpha = 1;
            this.borderAlpha = 0;
            this.borderThickness = 1;
            this.labelPosition = "right";
            this.labelColor = "#000000";
            this.labelFontSize = 11;
            this.color = "#000000";
            this.labelRollOverColor = "#00CC00";
            this.centered = !0;
            this.rollOverScale = this.selectedScale = 1;
            this.descriptionWindowWidth = 250;
            this.bringForwardOnHover = !0;
            this.outlineColor = "transparent";
            f.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.LinesProcessor = f.Class({
        construct: function(a) {
            this.chart = a;
            this.reset()
        },
        process: function(a) {
            var b = a.lines,
                c = this.chart,
                d = c.linesSettings,
                e = this.objectsToResize,
                g = c.mapLinesContainer,
                l = c.stageLinesContainer,
                h = d.thickness,
                k = d.dashLength,
                n = d.arrow,
                p = d.arrowSize,
                x = d.arrowColor,
                v = d.arrowAlpha,
                y = d.color,
                r = d.alpha,
                w = d.rollOverColor,
                J = d.selectedColor,
                A = d.rollOverAlpha,
                D = d.balloonText,
                B = d.bringForwardOnHover,
                E = d.arc,
                P = d.rollOverBrightness,
                q = c.container,
                u;
            for (u = 0; u < b.length; u++) {
                var m = b[u];
                m.chart = c;
                m.baseSettings = d;
                var z = q.set();
                m.displayObject = z;
                this.allSvgObjects.push(z);
                this.allObjects.push(m);
                m.mouseEnabled && c.addObjectEventListeners(z, m);
                if (m.remainVisible || c.selectedObject == m.parentObject) {
                    var F = m.thickness;
                    isNaN(F) && (F = h);
                    var t = m.dashLength;
                    isNaN(t) && (t = k);
                    var N = m.color;
                    void 0 == N && (N = y);
                    var C = m.alpha;
                    isNaN(C) && (C = r);
                    var U = m.rollOverAlpha;
                    isNaN(U) && (U = A);
                    isNaN(U) && (U = C);
                    var H = m.rollOverColor;
                    void 0 == H && (H = w);
                    var Z = m.selectedColor;
                    void 0 == Z && (Z = J);
                    var K = m.balloonText;
                    K || (K = D);
                    var R = m.arc;
                    isNaN(R) && (R = E);
                    var M = m.arrow;
                    if (!M || "none" == M && "none" != n) M = n;
                    var W = m.arrowColor;
                    void 0 == W && (W = x);
                    void 0 == W && (W = N);
                    var X = m.arrowAlpha;
                    isNaN(X) && (X = v);
                    isNaN(X) && (X = C);
                    var S = m.arrowSize;
                    isNaN(S) && (S = p);
                    var I = m.rollOverBrightness;
                    void 0 == I && (I = P);
                    isNaN(d.selectedBrightness) || (Z = f.adjustLuminosity(m.colorReal, d.selectedBrightness / 100));
                    m.alphaReal = C;
                    m.colorReal = N;
                    m.rollOverColorReal = H;
                    m.rollOverAlphaReal = U;
                    m.balloonTextReal = K;
                    m.selectedColorReal = Z;
                    m.thicknessReal = F;
                    m.rollOverBrightnessReal = I;
                    void 0 == m.bringForwardOnHover && (m.bringForwardOnHover = B);
                    f.processDescriptionWindow(d, m);
                    var H = this.processCoordinates(m.x, c.realWidth),
                        K = this.processCoordinates(m.y, c.realHeight),
                        I = m.longitudes,
                        U = m.latitudes,
                        O = I.length,
                        L;
                    if (0 < O)
                        for (H = [], L = 0; L < O; L++) H.push(c.longitudeToCoordinate(I[L]));
                    O = U.length;
                    if (0 < O)
                        for (K = [], L = 0; L < O; L++) K.push(c.latitudeToCoordinate(U[L]));
                    if (0 < H.length) {
                        f.dx = 0;
                        f.dy = 0;
                        var Q, ba, Y;
                        L = 10 * (1 - Math.abs(R));
                        10 <= L && (L = NaN);
                        1 > L && (L = 1);
                        if (isNaN(L)) I = f.line(q, H, K, N, 1, F, t, !1, !1, !0), N = f.line(q, H, K, N, .001, 3, t, !1, !1, !0);
                        else {
                            O = 1;
                            0 > R && (O = 0);
                            I = {
                                stroke: N,
                                "stroke-opacity": 1,
                                "stroke-width": F,
                                "fill-opacity": 0
                            };
                            void 0 !== t && 0 < t && (I["stroke-dasharray"] = t);
                            var t = H[0],
                                aa = H[1],
                                ca = K[0],
                                da = K[1];
                            ba = Math.sqrt(Math.pow(aa - t, 2) + Math.pow(da - ca, 2));
                            Y = ba / 2 * L;
                            Q = 270 + 180 * Math.acos(ba / 2 / Y) / Math.PI;
                            isNaN(Q) && (Q = 270);
                            t < aa && (L = t, t = aa, aa = L, L = ca, ca = da, da = L, Q = -Q);
                            0 < R && (Q = -Q);
                            t = "M" + t + "," + ca + "A" + Y + "," + Y + ",0,0," + O + "," + aa + "," + da;
                            I = q.path(t).attr(I);
                            N = q.path(t).attr({
                                stroke: N,
                                "stroke-width": 3,
                                "stroke-opacity": .001,
                                fill: "none"
                            })
                        }
                        f.setCN(c, I, "map-line");
                        void 0 != m.id && f.setCN(c, I, "map-line-" + m.id);
                        f.dx = .5;
                        f.dy = .5;
                        z.push(I);
                        z.push(N);
                        I.setAttr("opacity", C);
                        if ("none" != M) {
                            var G, T, V;
                            if ("end" == M || "both" == M) C = H[H.length - 1], O = K[K.length - 1], 1 < H.length ? (t = H[H.length - 2], G = K[K.length - 2]) : (t = C, G = O), G = 180 * Math.atan((O - G) / (C - t)) / Math.PI, isNaN(Q) || (G += Q), T = C, V = O, G = 0 > C - t ? G - 90 : G + 90;
                            "both" == M && (C = f.polygon(q, [-S / 2, 0, S / 2], [1.5 * S, 0, 1.5 * S], W, X, 1, W, X), z.push(C), C.translate(T, V, 1, !0), C.rotate(G), f.setCN(c, I, "map-line-arrow"), void 0 != m.id && f.setCN(c, I, "map-line-arrow-" +
                                m.id), m.fixedSize && e.push(C));
                            if ("start" == M || "both" == M) C = H[0], V = K[0], 1 < H.length ? (t = H[1], T = K[1]) : (t = C, T = V), G = 180 * Math.atan((V - T) / (C - t)) / Math.PI, isNaN(Q) || (G -= Q), T = C, G = 0 > C - t ? G - 90 : G + 90;
                            "middle" == M && (C = H[H.length - 1], O = K[K.length - 1], 1 < H.length ? (t = H[H.length - 2], G = K[K.length - 2]) : (t = C, G = O), T = t + (C - t) / 2, V = G + (O - G) / 2, G = 180 * Math.atan((O - G) / (C - t)) / Math.PI, isNaN(Q) || (M = ba / 2, M = Y - Math.sqrt(Y * Y - M * M), 0 > R && (M = -M), R = Math.sin(G / 180 * Math.PI), -1 == R && (R = 1), T -= R * M, V += Math.cos(G / 180 * Math.PI) * M), G = 0 > C - t ? G - 90 : G + 90);
                            C = f.polygon(q, [-S / 2, 0, S / 2], [1.5 * S, 0, 1.5 * S], W, X, 1, W, X);
                            f.setCN(c, I, "map-line-arrow");
                            void 0 != m.id && f.setCN(c, I, "map-line-arrow-" + m.id);
                            z.push(C);
                            C.translate(T, V, 1, !0);
                            C.rotate(G);
                            m.fixedSize && e.push(C);
                            m.arrowSvg = C
                        }
                        m.fixedSize && I && (this.linesToResize.push({
                            line: I,
                            thickness: F
                        }), this.linesToResize.push({
                            line: N,
                            thickness: 3
                        }));
                        m.lineSvg = I;
                        m.showAsSelected && !isNaN(Z) && I.setAttr("stroke", Z);
                        0 < U.length ? g.push(z) : l.push(z);
                        m.hidden && z.hide()
                    }
                }
            }
            a.parentObject && a.remainVisible && this.process(a.parentObject)
        },
        processCoordinates: function(a, b) {
            var c = [],
                d;
            for (d = 0; d < a.length; d++) {
                var e = a[d],
                    g = Number(e);
                isNaN(g) && (g = Number(e.replace("%", "")) * b / 100);
                isNaN(g) || c.push(g)
            }
            return c
        },
        reset: function() {
            this.objectsToResize = [];
            this.allSvgObjects = [];
            this.allObjects = [];
            this.linesToResize = []
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.LinesSettings = f.Class({
        construct: function(a) {
            this.cname = "LinesSettings";
            this.balloonText = "[[title]]";
            this.thickness = 1;
            this.dashLength = 0;
            this.arrowSize = 10;
            this.arrowAlpha = 1;
            this.arrow = "none";
            this.color = "#990000";
            this.descriptionWindowWidth = 250;
            this.bringForwardOnHover = !0;
            f.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.MapObject = f.Class({
        construct: function(a) {
            this.fixedSize = this.mouseEnabled = !0;
            this.images = [];
            this.lines = [];
            this.areas = [];
            this.remainVisible = !0;
            this.passZoomValuesToTarget = !1;
            this.objectType = this.cname;
            f.applyTheme(this, a, "MapObject")
        }
    })
})();
(function(f) {
    f = window.AmCharts;
    f.MapArea = f.Class({
        inherits: f.MapObject,
        construct: function(a) {
            this.cname = "MapArea";
            f.MapArea.base.construct.call(this, a);
            f.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.MapLine = f.Class({
        inherits: f.MapObject,
        construct: function(a) {
            this.cname = "MapLine";
            this.longitudes = [];
            this.latitudes = [];
            this.x = [];
            this.y = [];
            this.arrow = "none";
            f.MapLine.base.construct.call(this, a);
            f.applyTheme(this, a, this.cname)
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.MapImage = f.Class({
        inherits: f.MapObject,
        construct: function(a) {
            this.cname = "MapImage";
            this.scale = 1;
            this.widthAndHeightUnits = "pixels";
            this.labelShiftY = this.labelShiftX = 0;
            f.MapImage.base.construct.call(this, a);
            f.applyTheme(this, a, this.cname)
        },
        remove: function() {
            var a = this.displayObject;
            a && a.remove();
            (a = this.imageLabel) && a.remove()
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.degreesToRadians = function(a) {
        return a / 180 * Math.PI
    };
    f.radiansToDegrees = function(a) {
        return a / Math.PI * 180
    };
    f.getColorFade = function(a, b, c) {
        var d = f.hex2RGB(b);
        b = d[0];
        var e = d[1],
            d = d[2],
            g = f.hex2RGB(a);
        a = g[0];
        var l = g[1],
            g = g[2];
        a += Math.round((b - a) * c);
        l += Math.round((e - l) * c);
        g += Math.round((d - g) * c);
        return "rgb(" + a + "," + l + "," + g + ")"
    };
    f.hex2RGB = function(a) {
        return [parseInt(a.substring(1, 3), 16), parseInt(a.substring(3, 5), 16), parseInt(a.substring(5, 7), 16)]
    };
    f.processDescriptionWindow = function(a, b) {
        isNaN(b.descriptionWindowX) && (b.descriptionWindowX = a.descriptionWindowX);
        isNaN(b.descriptionWindowY) && (b.descriptionWindowY = a.descriptionWindowY);
        isNaN(b.descriptionWindowLeft) && (b.descriptionWindowLeft = a.descriptionWindowLeft);
        isNaN(b.descriptionWindowRight) && (b.descriptionWindowRight = a.descriptionWindowRight);
        isNaN(b.descriptionWindowTop) && (b.descriptionWindowTop = a.descriptionWindowTop);
        isNaN(b.descriptionWindowBottom) && (b.descriptionWindowBottom = a.descriptionWindowBottom);
        isNaN(b.descriptionWindowWidth) && (b.descriptionWindowWidth = a.descriptionWindowWidth);
        isNaN(b.descriptionWindowHeight) && (b.descriptionWindowHeight = a.descriptionWindowHeight)
    }
})();
(function() {
    var f = window.AmCharts;
    f.MapData = f.Class({
        inherits: f.MapObject,
        construct: function() {
            this.cname = "MapData";
            f.MapData.base.construct.call(this);
            this.projection = "mercator";
            this.topLatitude = 90;
            this.bottomLatitude = -90;
            this.leftLongitude = -180;
            this.rightLongitude = 180;
            this.zoomLevel = 1;
            this.getAreasFromMap = !1
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.DescriptionWindow = f.Class({
        construct: function() {},
        show: function(a, b, c, d) {
            var e = this,
                g = document.createElement("div");
            g.style.position = "absolute";
            var f = a.classNamePrefix + "-description-";
            g.className = "ammapDescriptionWindow " + f + "div";
            e.div = g;
            b.appendChild(g);
            var h = ".gif";
            a.svgIcons && (h = ".svg");
            var k = document.createElement("img");
            k.className = "ammapDescriptionWindowCloseButton " + f + "close-img";
            k.src = a.pathToImages + "xIcon" + h;
            k.style.cssFloat = "right";
            k.style.cursor = "pointer";
            k.onclick = function() {
                e.close()
            };
            k.onmouseover = function() {
                k.src = a.pathToImages + "xIconH" + h
            };
            k.onmouseout = function() {
                k.src = a.pathToImages + "xIcon" + h
            };
            g.appendChild(k);
            b = document.createElement("div");
            b.className = "ammapDescriptionTitle " + f + "title-div";
            b.onmousedown = function() {
                e.div.style.zIndex = 1E3
            };
            g.appendChild(b);
            d = document.createTextNode(d);
            b.appendChild(d);
            d = b.offsetHeight;
            b = document.createElement("div");
            b.className = "ammapDescriptionText " + f + "text-div";
            b.style.maxHeight = e.maxHeight - d - 20 + "px";
            g.appendChild(b);
            b.innerHTML = c
        },
        close: function() {
            try {
                this.div.parentNode.removeChild(this.div)
            } catch (a) {}
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.ValueLegend = f.Class({
        construct: function(a) {
            this.cname = "ValueLegend";
            this.enabled = !0;
            this.showAsGradient = !1;
            this.minValue = 0;
            this.height = 12;
            this.width = 200;
            this.bottom = this.left = 10;
            this.borderColor = "#FFFFFF";
            this.borderAlpha = this.borderThickness = 1;
            this.color = "#000000";
            this.fontSize = 11;
            f.applyTheme(this, a, this.cname)
        },
        init: function(a, b) {
            if (this.enabled) {
                var c = a.areasSettings.color,
                    d = a.areasSettings.colorSolid,
                    e = a.colorSteps;
                f.remove(this.set);
                var g = b.set();
                this.set = g;
                f.setCN(a, g, "value-legend");
                var l = 0,
                    h = this.minValue,
                    k = this.fontSize,
                    n = a.fontFamily,
                    p = this.color;
                void 0 == h && (h = a.minValueReal);
                void 0 !== h && (l = f.text(b, h, p, n, k, "left"), l.translate(0, k / 2 - 1), f.setCN(a, l, "value-legend-min-label"), g.push(l), l = l.getBBox().height);
                h = this.maxValue;
                void 0 === h && (h = a.maxValueReal);
                void 0 !== h && (l = f.text(b, h, p, n, k, "right"), l.translate(this.width, k / 2 - 1), f.setCN(a, l, "value-legend-max-label"), g.push(l), l = l.getBBox().height);
                if (this.showAsGradient) c = f.rect(b, this.width, this.height, [c, d], 1, this.borderThickness, this.borderColor, 1, 0, 0), f.setCN(a, c, "value-legend-gradient"), c.translate(0, l), g.push(c);
                else
                    for (k = this.width / e, n = 0; n < e; n++) p = f.getColorFade(c, d, 1 * n / (e - 1)), p = f.rect(b, k, this.height, p, 1, this.borderThickness, this.borderColor, 1), f.setCN(a, p, "value-legend-color"), f.setCN(a, p, "value-legend-color-" + n), p.translate(k * n, l), g.push(p);
                d = c = 0;
                e = g.getBBox();
                l = a.getY(this.bottom, !0);
                k = a.getY(this.top);
                n = a.getX(this.right, !0);
                p = a.getX(this.left);
                isNaN(k) || (c = k);
                isNaN(l) || (c = l - e.height);
                isNaN(p) || (d = p);
                isNaN(n) || (d = n - e.width);
                g.translate(d, c)
            } else f.remove(this.set)
        }
    })
})();
(function() {
    var f = window.AmCharts;
    f.ObjectList = f.Class({
        construct: function(a) {
            this.divId = a
        },
        init: function(a) {
            this.chart = a;
            var b = this.divId;
            this.container && (b = this.container);
            this.div = "object" != typeof b ? document.getElementById(b) : b;
            b = document.createElement("div");
            b.className = "ammapObjectList " + a.classNamePrefix + "-object-list-div";
            this.div.appendChild(b);
            this.addObjects(a.dataProvider, b)
        },
        addObjects: function(a, b) {
            var c = this.chart,
                d = document.createElement("ul");
            d.className = c.classNamePrefix + "-object-list-ul";
            var e;
            if (a.areas)
                for (e = 0; e < a.areas.length; e++) {
                    var g = a.areas[e];
                    void 0 === g.showInList && (g.showInList = c.showAreasInList);
                    this.addObject(g, d)
                }
            if (a.images)
                for (e = 0; e < a.images.length; e++) g = a.images[e], void 0 === g.showInList && (g.showInList = c.showImagesInList), this.addObject(g, d);
            if (a.lines)
                for (e = 0; e < a.lines.length; e++) g = a.lines[e], void 0 === g.showInList && (g.showInList = c.showLinesInList), this.addObject(g, d);
            0 < d.childNodes.length && b.appendChild(d)
        },
        addObject: function(a, b) {
            var c = this;
            if (a.showInList && void 0 !== a.title) {
                var d = c.chart,
                    e = document.createElement("li");
                e.className = d.classNamePrefix + "-object-list-li";
                var g = document.createTextNode(a.title),
                    f = document.createElement("a");
                f.className = d.classNamePrefix + "-object-list-a";
                f.appendChild(g);
                e.appendChild(f);
                b.appendChild(e);
                this.addObjects(a, e);
                f.onmouseover = function() {
                    c.chart.rollOverMapObject(a, !1)
                };
                f.onmouseout = function() {
                    c.chart.rollOutMapObject(a)
                };
                f.onclick = function() {
                    c.chart.clickMapObject(a)
                }
            }
        }
    })
})();;
AmCharts.AmExport = AmCharts.Class({
    construct: function(chart, cfg, init) {
        var _this = this;
        _this.DEBUG = false;
        _this.chart = chart;
        _this.canvas = null;
        _this.svgs = [];
        _this.userCFG = cfg;
        _this.buttonIcon = 'export.png';
        _this.exportPNG = true;
        _this.exportPDF = false;
        _this.exportJPG = false;
        _this.exportSVG = false;
        _this.right = 0;
        _this.top = 0;
        _this.buttonRollOverColor = "#EFEFEF";
        _this.textRollOverColor = "#CC0000";
        _this.buttonTitle = "Save chart as an image";
        _this.buttonAlpha = 0.75;
        _this.imageFileName = "amChart";
        _this.imageBackgroundColor = "#FFFFFF";
        if (init) {
            _this.init();
        }
    },
    toCoordinate: function(value) {
        if (value === undefined) {
            return "auto";
        }
        if (String(value).indexOf("%") != -1) {
            return value;
        } else {
            return value + "px";
        }
    },
    init: function() {
        var _this = this;
        var formats = [];
        if (_this.exportPNG) {
            formats.push("png");
        }
        if (_this.exportPDF) {
            formats.push("pdf");
        }
        if (_this.exportJPG) {
            formats.push("jpg");
        }
        if (_this.exportSVG) {
            formats.push("svg");
        }
        var menuItems = [];
        if (formats.length == 1) {
            var format = formats[0];
            menuItems.push({
                format: format,
                iconTitle: _this.buttonTitle,
                icon: _this.chart.pathToImages + _this.buttonIcon
            })
        } else if (formats.length > 1) {
            var subItems = [];
            for (var i = 0; i < formats.length; i++) {
                subItems.push({
                    format: formats[i],
                    title: formats[i].toUpperCase()
                });
            }
            menuItems.push({
                onclick: function() {},
                icon: _this.chart.pathToImages + _this.buttonIcon,
                items: subItems
            })
        }
        var color = _this.color;
        if (color === undefined) {
            color = _this.chart.color;
        }
        var buttonColor = _this.buttonColor;
        if (buttonColor === undefined) {
            buttonColor = "transparent";
        }
        _this.cfg = {
            menuTop: _this.toCoordinate(_this.top),
            menuLeft: _this.toCoordinate(_this.left),
            menuRight: _this.toCoordinate(_this.right),
            menuBottom: _this.toCoordinate(_this.bottom),
            menuItems: menuItems,
            menuItemStyle: {
                backgroundColor: buttonColor,
                opacity: _this.buttonAlpha,
                rollOverBackgroundColor: _this.buttonRollOverColor,
                color: color,
                rollOverColor: _this.textRollOverColor,
                paddingTop: '6px',
                paddingRight: '6px',
                paddingBottom: '6px',
                paddingLeft: '6px',
                marginTop: '0px',
                marginRight: '0px',
                marginBottom: '0px',
                marginLeft: '0px',
                textAlign: 'left',
                textDecoration: 'none',
                fontFamily: _this.chart.fontFamily,
                fontSize: _this.chart.fontSize + 'px'
            },
            menuItemOutput: {
                backgroundColor: _this.imageBackgroundColor,
                fileName: _this.imageFileName,
                format: 'png',
                output: 'dataurlnewwindow',
                render: 'browser',
                dpi: 90,
                onclick: function(instance, config, event) {
                    event.preventDefault();
                    instance.output(config);
                }
            },
            removeImagery: true
        };
        _this.processing = {
            buffer: [],
            drawn: 0,
            timer: 0
        };
        if (typeof(window.canvg) != 'undefined' && typeof(window.RGBColor) != 'undefined') {
            _this.cfg.menuItemOutput.render = 'canvg';
        }
        if (typeof(window.saveAs) != 'undefined') {
            _this.cfg.menuItemOutput.output = 'save';
        }
        if (AmCharts.isIE && AmCharts.IEversion < 10) {
            _this.cfg.menuItemOutput.output = 'dataurlnewwindow';
        }
        var cfg = _this.userCFG;
        if (cfg) {
            cfg.menuItemOutput = AmCharts.extend(_this.cfg.menuItemOutput, cfg.menuItemOutput || {});
            cfg.menuItemStyle = AmCharts.extend(_this.cfg.menuItemStyle, cfg.menuItemStyle || {});
            _this.cfg = AmCharts.extend(_this.cfg, cfg);
        }
        _this.chart.AmExport = _this;
        _this.chart.addListener('rendered', function() {
            _this.setup();
        });
        if (_this.DEBUG) {
            window.AmExport = _this;
        }
    },
    log: function() {
        console.log('AmExport: ', arguments);
    },
    setup: function() {
        var _this = this;
        if (!AmCharts.isIE || (AmCharts.isIE && AmCharts.IEversion > 9)) {
            _this.generateButtons();
        }
    },
    generateBinaryArray: function(base64_string) {
        var
            len = base64_string.length,
            buffer = new Uint8Array(len / 4 * 3 | 0),
            i = 0,
            outptr = 0,
            last = [0, 0],
            state = 0,
            save = 0,
            rank, code, undef, base64_ranks = new Uint8Array([62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 0, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51]);
        while (len--) {
            code = base64_string.charCodeAt(i++);
            rank = base64_ranks[code - 43];
            if (rank !== 255 && rank !== undef) {
                last[1] = last[0];
                last[0] = code;
                save = (save << 6) | rank;
                state++;
                if (state === 4) {
                    buffer[outptr++] = save >>> 16;
                    if (last[1] !== 61) {
                        buffer[outptr++] = save >>> 8;
                    }
                    if (last[0] !== 61) {
                        buffer[outptr++] = save;
                    }
                    state = 0;
                }
            }
        }
        return buffer;
    },
    generateBlob: function(datastring, type) {
        var _this = this,
            header_end = type != 'image/svg+xml' ? datastring.indexOf(',') + 1 : 0,
            header = datastring.substring(0, header_end),
            data = datastring,
            blob = new Blob();
        if (header.indexOf('base64') != -1) {
            data = _this.generateBinaryArray(datastring.substring(header_end));
        }
        if (AmCharts.isIE && AmCharts.IEversion < 10) {
            blob.data = data;
            blob.size = data.length;
            blob.type = type;
            blob.encoding = 'base64';
        } else {
            blob = new Blob([data], {
                type: type
            });
        }
        return blob;
    },
    generatePDF: function(cfg) {
        var _this = this,
            pdf = {
                output: function() {
                    return '';
                }
            },
            data = _this.canvas.toDataURL('image/jpeg'),
            width = (_this.canvas.width * 25.4) / cfg.dpi,
            height = (_this.canvas.height * 25.4) / cfg.dpi;
        if (window.jsPDF) {
            pdf = new jsPDF();
            if (pdf.addImage) {
                pdf.addImage(data, 'JPEG', 0, 0, width, height);
            } else {
                alert("Missing jsPDF plugin; Please add the 'addImage' plugin.");
            }
        } else {
            alert("Missing jsPDF lib; Don't forget to add the addImage plugin.");
        }
        return pdf;
    },
    output: function(cfg, externalCallback) {
        var _this = this;
        cfg = AmCharts.extend(AmCharts.extend({}, _this.cfg.menuItemOutput), cfg || {});
        if (_this.chart.prepareForExport) {
            _this.chart.prepareForExport();
        }

        function internalCallback() {
            var data = null;
            var blob;
            if (cfg.format == 'image/svg+xml' || cfg.format == 'svg') {
                data = _this.generateSVG();
                blob = _this.generateBlob(data, 'image/svg+xml');
                if (cfg.output == 'save') {
                    saveAs(blob, cfg.fileName + '.svg');
                } else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
                    blob = 'data:image/svg+xml;base64,' + btoa(data);
                } else if (cfg.output == 'dataurlnewwindow') {
                    window.open('data:image/svg+xml;base64,' + btoa(data));
                } else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
                    location.href = 'data:image/svg+xml;base64,' + btoa(data);
                } else if (cfg.output == 'datastream') {
                    location.href = 'data:image/octet-stream;base64,' + data;
                }
                if (externalCallback) {
                    externalCallback.apply(_this, [blob]);
                }
            } else if (cfg.format == 'application/pdf' || cfg.format == 'pdf') {
                data = _this.generatePDF(cfg).output('dataurlstring');
                blob = _this.generateBlob(data, 'application/pdf');
                if (cfg.output == 'save') {
                    saveAs(blob, cfg.fileName + '.pdf');
                } else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
                    blob = data;
                } else if (cfg.output == 'dataurlnewwindow') {
                    window.open(data);
                } else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
                    location.href = data;
                } else if (cfg.output == 'datastream') {
                    location.href = data.replace('application/pdf', 'application/octet-stream');
                }
                if (externalCallback) {
                    externalCallback.apply(_this, [blob]);
                }
            } else if (cfg.format == 'image/png' || cfg.format == 'png') {
                data = _this.canvas.toDataURL('image/png');
                blob = _this.generateBlob(data, 'image/png');
                if (cfg.output == 'save') {
                    saveAs(blob, cfg.fileName + '.png');
                } else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
                    blob = data;
                } else if (cfg.output == 'dataurlnewwindow') {
                    window.open(data);
                } else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
                    location.href = data;
                } else if (cfg.output == 'datastream') {
                    location.href = data.replace('image/png', 'image/octet-stream');
                }
                if (externalCallback) {
                    externalCallback.apply(_this, [blob]);
                }
            } else if (cfg.format == 'image/jpeg' || cfg.format == 'jpeg' || cfg.format == 'jpg') {
                data = _this.canvas.toDataURL('image/jpeg');
                blob = _this.generateBlob(data, 'image/jpeg');
                if (cfg.output == 'save') {
                    saveAs(blob, cfg.fileName + '.jpg');
                } else if (cfg.output == 'datastring' || cfg.output == 'datauristring' || cfg.output == 'dataurlstring') {
                    blob = data;
                } else if (cfg.output == 'dataurlnewwindow') {
                    window.open(data);
                } else if (cfg.output == 'datauri' || cfg.output == 'dataurl') {
                    location.href = data;
                } else if (cfg.output == 'datastream') {
                    location.href = data.replace('image/jpeg', 'image/octet-stream');
                }
                if (externalCallback) {
                    externalCallback.apply(_this, [blob]);
                }
            }
        }
        return _this.generateOutput(cfg, internalCallback);
    },
    polifySVG: function(svg) {
        var _this = this;

        function recursiveChange(svg, tag) {
            var items = svg.getElementsByTagName(tag);
            var i = items.length;
            while (i--) {
                if (_this.cfg.removeImagery) {
                    items[i].parentNode.removeChild(items[i]);
                } else {
                    var image = document.createElement('img');
                    var canvas = document.createElement('canvas');
                    var ctx = canvas.getContext('2d');
                    canvas.width = items[i].getAttribute('width');
                    canvas.height = items[i].getAttribute('height');
                    image.src = items[i].getAttribute('xlink:href');
                    image.width = items[i].getAttribute('width');
                    image.height = items[i].getAttribute('height');
                    try {
                        ctx.drawImage(image, 0, 0, image.width, image.height);
                        datastring = canvas.toDataURL();
                    } catch (err) {
                        datastring = image.src;
                        _this.log('Tainted canvas, reached browser CORS security; origin from imagery must be equal to the server!');
                        throw new Error(err);
                    }
                    items[i].setAttribute('xlink:href', datastring);
                }
            }
        }
        if (AmCharts.IEversion == 0) {
            svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            if (!_this.cfg.removeImagery) {
                svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            }
        }
        recursiveChange(svg, 'pattern');
        recursiveChange(svg, 'image');
        _this.svgs.push(svg);
        return svg;
    },
    generateSVG: function() {
        var _this = this;
        var context = document.createElement('svg');
        context.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        context.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
        for (var i = 0; i < _this.processing.buffer.length; i++) {
            var group = document.createElement('g'),
                data = _this.processing.buffer[i];
            data[0].setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            data[0].setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');
            group.setAttribute('transform', 'translate(' + data[1].x + ',' + data[1].y + ')');
            group.appendChild(data[0]);
            context.appendChild(group);
        }
        return new XMLSerializer().serializeToString(context);
    },
    generateOutput: function(cfg, callback) {
        var _this = this,
            coll = [],
            svgs = [],
            canvas = document.createElement('canvas'),
            context = canvas.getContext('2d'),
            offset = {
                y: 0,
                x: 0
            },
            coll = _this.chart.div.getElementsByTagName('svg');
        for (var i = 0; i < coll.length; i++) svgs.push(coll[i]);
        if (_this.chart.legend && _this.chart.legend.position == 'outside') {
            _this.chart.legend.container.container.externalLegend = true
            svgs.push(_this.chart.legend.container.container);
            if (_this.cfg.legendPosition == 'left') {
                offset.x = _this.chart.legend.div.offsetWidth;
            } else if (_this.cfg.legendPosition == 'top') {
                offset.y = _this.chart.legend.div.offsetHeight;
            } else if (typeof _this.cfg.legendPosition == 'object') {
                offset.y = _this.cfg.legendPosition.chartTop;
                offset.x = _this.cfg.legendPosition.chartLeft;
            }
        }
        _this.processing.buffer = [];
        _this.processing.drawn = 0;
        _this.canvas = canvas;
        _this.svgs = [];
        var remember = {
            x: 0,
            y: 0
        }
        for (var i = 0; i < svgs.length; i++) {
            var parent = svgs[i].parentNode,
                svgX = Number(parent.style.left.slice(0, -2)),
                svgY = Number(parent.style.top.slice(0, -2)),
                svgClone = _this.polifySVG(svgs[i].cloneNode(true)),
                tmp = AmCharts.extend({}, offset);
            if (svgs[i].externalLegend) {
                if (_this.cfg.legendPosition == 'right') {
                    offset.y = 0;
                    offset.x = _this.chart.divRealWidth;
                } else if (_this.cfg.legendPosition == 'bottom') {
                    offset.y = svgY ? svgY : offset.y;
                } else if (typeof _this.cfg.legendPosition == 'object') {
                    offset.x = _this.cfg.legendPosition.left;
                    offset.y = _this.cfg.legendPosition.top;
                } else {
                    offset.x = 0;
                    offset.y = 0;
                }
            } else {
                if (parent.style.position == 'relative') {
                    offset.x = svgX ? svgX : offset.x;
                    offset.y = svgY ? svgY : offset.y;
                } else {
                    offset.x = svgX + remember.x;
                    offset.y = svgY + remember.y;
                }
            }
            _this.processing.buffer.push([svgClone, AmCharts.extend({}, offset)]);
            if (svgY && svgX) {
                offset = tmp;
            } else {
                offset.y += svgY ? 0 : parent.offsetHeight;
            }
            if (parent.style.position == "absolute" && parent.getAttribute("class") == "amChartsLegend") {
                remember.y += parent.parentNode.offsetHeight;
            }
        }
        canvas.id = AmCharts.getUniqueId();
        canvas.width = _this.chart.divRealWidth;
        canvas.height = _this.chart.divRealHeight;
        if (_this.chart.legend && _this.chart.legend.position == "outside") {
            if (['left', 'right'].indexOf(_this.cfg.legendPosition) != -1) {
                canvas.width += _this.chart.legend.div.offsetWidth;
            } else if (typeof _this.cfg.legendPosition == 'object') {
                canvas.width += _this.cfg.legendPosition.width;
                canvas.height += _this.cfg.legendPosition.height;
            } else {
                canvas.height += _this.chart.legend.div.offsetHeight;
            }
        }
        var adapted = {
            width: false,
            height: false
        };
        if (_this.chart.periodSelector) {
            if (['left', 'right'].indexOf(_this.chart.periodSelector.position) != -1) {
                canvas.width -= _this.chart.periodSelector.div.offsetWidth + 16;
                adapted.width = true;
            } else {
                canvas.height -= _this.chart.periodSelector.div.offsetHeight;
                adapted.height = true;
            }
        }
        if (_this.chart.dataSetSelector) {
            if (['left', 'right'].indexOf(_this.chart.dataSetSelector.position) != -1) {
                if (!adapted.width) {
                    canvas.width -= _this.chart.dataSetSelector.div.offsetWidth + 16;
                }
            } else {
                canvas.height -= _this.chart.dataSetSelector.div.offsetHeight;
            }
        }
        if (cfg.backgroundColor || cfg.format == 'image/jpeg') {
            context.fillStyle = cfg.backgroundColor || '#FFFFFF';
            context.fillRect(0, 0, canvas.width, canvas.height);
        }

        function drawItWhenItsLoaded() {
            var img, buffer, offset, source;
            if (_this.processing.buffer.length == _this.processing.drawn || cfg.format == 'svg') {
                return callback();
            } else {
                buffer = _this.processing.buffer[_this.processing.drawn];
                source = new XMLSerializer().serializeToString(buffer[0]);
                offset = buffer[1];
                if (cfg.render == 'browser') {
                    img = new Image();
                    img.id = AmCharts.getUniqueId();
                    source = 'data:image/svg+xml;base64,' + btoa(source);
                    img.onload = function() {
                        context.drawImage(this, buffer[1].x, buffer[1].y);
                        _this.processing.drawn++;
                        drawItWhenItsLoaded();
                    };
                    img.onerror = function() {
                        context.drawImage(this, buffer[1].x, buffer[1].y);
                        _this.processing.drawn++;
                        drawItWhenItsLoaded();
                    };
                    img.src = source;
                    if (img.complete || typeof(img.complete) == 'undefined' || img.complete === undefined) {
                        img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";
                        img.src = source;
                    }
                } else if (cfg.render == 'canvg') {
                    canvg(canvas, source, {
                        offsetX: offset.x,
                        offsetY: offset.y,
                        ignoreMouse: true,
                        ignoreAnimation: true,
                        ignoreDimensions: true,
                        ignoreClear: true,
                        renderCallback: function() {
                            _this.processing.drawn++;
                            drawItWhenItsLoaded();
                        }
                    });
                }
            }
        }
        return drawItWhenItsLoaded();
    },
    generateButtons: function() {
        var _this = this,
            lvl = 0;
        var div;
        if (_this.div) {
            div = _this.div;
            div.innerHTML = "";
        } else {
            div = document.createElement('div'), _this.div = div;
        }

        function createList(items) {
            var ul = document.createElement('ul');
            ul.setAttribute('style', 'list-style: none; margin: 0; padding: 0;');
            for (var i = 0; i < items.length; i++) {
                var li = document.createElement('li'),
                    img = document.createElement('img'),
                    a = document.createElement('a'),
                    item = items[i],
                    children = null,
                    itemStyle = AmCharts.extend(AmCharts.extend({}, _this.cfg.menuItemStyle), items[i]);
                item = AmCharts.extend(AmCharts.extend({}, _this.cfg.menuItemOutput), item);
                if (item['icon']) {
                    img.alt = '';
                    img.src = item['icon'];
                    img.setAttribute('style', 'margin: 0 auto;border: none;outline: none');
                    if (item['iconTitle']) {
                        img.title = item['iconTitle'];
                    }
                    a.appendChild(img);
                }
                a.href = '#';
                if (item['title']) {
                    img.setAttribute('style', 'margin: 0px 5px;');
                    a.innerHTML += item.title;
                }
                a.setAttribute('style', 'display: block;');
                AmCharts.extend(a.style, itemStyle);
                a.onclick = item.onclick.bind(a, _this, item);
                li.appendChild(a);
                if (item.items) {
                    children = createList(item.items);
                    li.appendChild(children);
                    li.onmouseover = function() {
                        children.style.display = 'block';
                    };
                    li.onmouseout = function() {
                        children.style.display = 'none';
                    };
                    children.style.display = 'none';
                }
                ul.appendChild(li);
                a.onmouseover = function() {
                    this.style.backgroundColor = itemStyle.rollOverBackgroundColor;
                    this.style.color = itemStyle.rollOverColor;
                    this.style.borderColor = itemStyle.rollOverBorderColor;
                };
                a.onmouseout = function() {
                    this.style.backgroundColor = itemStyle.backgroundColor;
                    this.style.color = itemStyle.color;
                    this.style.borderColor = itemStyle.borderColor;
                };
            }
            lvl++;
            return ul;
        }
        div.setAttribute('style', 'position: absolute;top:' + _this.cfg.menuTop + ';right:' + _this.cfg.menuRight + ';bottom:' + _this.cfg.menuBottom + ';left:' + _this.cfg.menuLeft + ';');
        div.setAttribute('class', 'amExportButton');
        div.appendChild(createList(_this.cfg.menuItems));
        _this.chart.containerDiv.appendChild(div);
    }
});;
(function() {
    this.canvg = function(target, s, opts) {
        if (target == null && s == null && opts == null) {
            var svgTags = document.getElementsByTagName('svg');
            for (var i = 0; i < svgTags.length; i++) {
                var svgTag = svgTags[i];
                var c = document.createElement('canvas');
                c.width = svgTag.clientWidth;
                c.height = svgTag.clientHeight;
                svgTag.parentNode.insertBefore(c, svgTag);
                svgTag.parentNode.removeChild(svgTag);
                var div = document.createElement('div');
                div.appendChild(svgTag);
                canvg(c, div.innerHTML);
            }
            return;
        }
        opts = opts || {};
        if (typeof target == 'string') {
            target = document.getElementById(target);
        }
        if (target.svg != null) {
            target.svg.stop();
        }
        var svg = build();
        if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) {
            target.svg = svg;
        }
        svg.opts = opts;
        var ctx = target.getContext('2d');
        if (typeof(s.documentElement) != 'undefined') {
            svg.loadXmlDoc(ctx, s);
        } else if (s.substr(0, 1) == '<') {
            svg.loadXml(ctx, s);
        } else {
            svg.load(ctx, s);
        }
    }

    function build() {
        var svg = {};
        svg.FRAMERATE = 30;
        svg.MAX_VIRTUAL_PIXELS = 30000;
        svg.init = function(ctx) {
            var uniqueId = 0;
            svg.UniqueId = function() {
                uniqueId++;
                return 'canvg' + uniqueId;
            };
            svg.Definitions = {};
            svg.Styles = {};
            svg.Animations = [];
            svg.Images = [];
            svg.ctx = ctx;
            svg.ViewPort = new(function() {
                this.viewPorts = [];
                this.Clear = function() {
                    this.viewPorts = [];
                }
                this.SetCurrent = function(width, height) {
                    this.viewPorts.push({
                        width: width,
                        height: height
                    });
                }
                this.RemoveCurrent = function() {
                    this.viewPorts.pop();
                }
                this.Current = function() {
                    return this.viewPorts[this.viewPorts.length - 1];
                }
                this.width = function() {
                    return this.Current().width;
                }
                this.height = function() {
                    return this.Current().height;
                }
                this.ComputeSize = function(d) {
                    if (d != null && typeof(d) == 'number') {
                        return d;
                    }
                    if (d == 'x') {
                        return this.width();
                    }
                    if (d == 'y') {
                        return this.height();
                    }
                    return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);
                }
            });
        }
        svg.init();
        svg.ImagesLoaded = function() {
            for (var i = 0; i < svg.Images.length; i++) {
                if (!svg.Images[i].loaded) {
                    return false;
                }
            }
            return true;
        }
        svg.trim = function(s) {
            return s.replace(/^\s+|\s+$/g, '');
        }
        svg.compressSpaces = function(s) {
            return s.replace(/[\s\r\t\n]+/gm, ' ');
        }
        svg.ajax = function(url) {
            var AJAX;
            if (window.XMLHttpRequest) {
                AJAX = new XMLHttpRequest();
            } else {
                AJAX = new ActiveXObject('Microsoft.XMLHTTP');
            }
            if (AJAX) {
                AJAX.open('GET', url, false);
                AJAX.send(null);
                return AJAX.responseText;
            }
            return null;
        }
        svg.parseXml = function(xml) {
            xml = xml.replace(/xmlns=\"http:\/\/www.w3.org\/2000\/svg\"/, '');
            if (window.DOMParser) {
                var parser = new DOMParser();
                return parser.parseFromString(xml, 'text/xml');
            } else {
                xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
                var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
                xmlDoc.async = 'false';
                xmlDoc.loadXML(xml);
                return xmlDoc;
            }
        }
        svg.Property = function(name, value) {
            this.name = name;
            this.value = value;
        }
        svg.Property.prototype.getValue = function() {
            return this.value;
        }
        svg.Property.prototype.hasValue = function() {
            return (this.value != null && this.value !== '');
        }
        svg.Property.prototype.numValue = function() {
            if (!this.hasValue()) {
                return 0;
            }
            var n = parseFloat(this.value);
            if ((this.value + '').match(/%$/)) {
                n = n / 100.0;
            }
            return n;
        }
        svg.Property.prototype.valueOrDefault = function(def) {
            if (this.hasValue()) {
                return this.value;
            }
            return def;
        }
        svg.Property.prototype.numValueOrDefault = function(def) {
            if (this.hasValue()) {
                return this.numValue();
            }
            return def;
        }
        svg.Property.prototype.addOpacity = function(opacity) {
            var newValue = this.value;
            if (opacity != null && opacity != '' && typeof(this.value) == 'string') {
                var color = new RGBColor(this.value);
                if (color.ok) {
                    newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacity + ')';
                }
            }
            return new svg.Property(this.name, newValue);
        }
        svg.Property.prototype.getDefinition = function() {
            var name = this.value.match(/#([^\)'"]+)/);
            if (name) {
                name = name[1];
            }
            if (!name) {
                name = this.value;
            }
            return svg.Definitions[name];
        }
        svg.Property.prototype.isUrlDefinition = function() {
            return this.value.indexOf('url(') == 0
        }
        svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
            var def = this.getDefinition();
            if (def != null && def.createGradient) {
                return def.createGradient(svg.ctx, e, opacityProp);
            }
            if (def != null && def.createPattern) {
                if (def.getHrefAttribute().hasValue()) {
                    var pt = def.attribute('patternTransform');
                    def = def.getHrefAttribute().getDefinition();
                    if (pt.hasValue()) {
                        def.attribute('patternTransform', true).value = pt.value;
                    }
                }
                return def.createPattern(svg.ctx, e);
            }
            return null;
        }
        svg.Property.prototype.getDPI = function(viewPort) {
            return 96.0;
        }
        svg.Property.prototype.getEM = function(viewPort) {
            var em = 12;
            var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
            if (fontSize.hasValue()) {
                em = fontSize.toPixels(viewPort);
            }
            return em;
        }
        svg.Property.prototype.getUnits = function() {
            var s = this.value + '';
            return s.replace(/[0-9\.\-]/g, '');
        }
        svg.Property.prototype.toPixels = function(viewPort, processPercent) {
            if (!this.hasValue()) {
                return 0;
            }
            var s = this.value + '';
            if (s.match(/em$/)) {
                return this.numValue() * this.getEM(viewPort);
            }
            if (s.match(/ex$/)) {
                return this.numValue() * this.getEM(viewPort) / 2.0;
            }
            if (s.match(/px$/)) {
                return this.numValue();
            }
            if (s.match(/pt$/)) {
                return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
            }
            if (s.match(/pc$/)) {
                return this.numValue() * 15;
            }
            if (s.match(/cm$/)) {
                return this.numValue() * this.getDPI(viewPort) / 2.54;
            }
            if (s.match(/mm$/)) {
                return this.numValue() * this.getDPI(viewPort) / 25.4;
            }
            if (s.match(/in$/)) {
                return this.numValue() * this.getDPI(viewPort);
            }
            if (s.match(/%$/)) {
                return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
            }
            var n = this.numValue();
            if (processPercent && n < 1.0) {
                return n * svg.ViewPort.ComputeSize(viewPort);
            }
            return n;
        }
        svg.Property.prototype.toMilliseconds = function() {
            if (!this.hasValue()) {
                return 0;
            }
            var s = this.value + '';
            if (s.match(/s$/)) {
                return this.numValue() * 1000;
            }
            if (s.match(/ms$/)) {
                return this.numValue();
            }
            return this.numValue();
        }
        svg.Property.prototype.toRadians = function() {
            if (!this.hasValue()) {
                return 0;
            }
            var s = this.value + '';
            if (s.match(/deg$/)) {
                return this.numValue() * (Math.PI / 180.0);
            }
            if (s.match(/grad$/)) {
                return this.numValue() * (Math.PI / 200.0);
            }
            if (s.match(/rad$/)) {
                return this.numValue();
            }
            return this.numValue() * (Math.PI / 180.0);
        }
        svg.Font = new(function() {
            this.Styles = 'normal|italic|oblique|inherit';
            this.Variants = 'normal|small-caps|inherit';
            this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';
            this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
                var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
                return {
                    fontFamily: fontFamily || f.fontFamily,
                    fontSize: fontSize || f.fontSize,
                    fontStyle: fontStyle || f.fontStyle,
                    fontWeight: fontWeight || f.fontWeight,
                    fontVariant: fontVariant || f.fontVariant,
                    toString: function() {
                        return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ')
                    }
                }
            }
            var that = this;
            this.Parse = function(s) {
                var f = {};
                var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
                var set = {
                    fontSize: false,
                    fontStyle: false,
                    fontWeight: false,
                    fontVariant: false
                }
                var ff = '';
                for (var i = 0; i < d.length; i++) {
                    if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) {
                        if (d[i] != 'inherit') {
                            f.fontStyle = d[i];
                        }
                        set.fontStyle = true;
                    } else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) {
                        if (d[i] != 'inherit') {
                            f.fontVariant = d[i];
                        }
                        set.fontStyle = set.fontVariant = true;
                    } else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {
                        if (d[i] != 'inherit') {
                            f.fontWeight = d[i];
                        }
                        set.fontStyle = set.fontVariant = set.fontWeight = true;
                    } else if (!set.fontSize) {
                        if (d[i] != 'inherit') {
                            f.fontSize = d[i].split('/')[0];
                        }
                        set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true;
                    } else {
                        if (d[i] != 'inherit') {
                            ff += d[i];
                        }
                    }
                }
                if (ff != '') {
                    f.fontFamily = ff;
                }
                return f;
            }
        });
        svg.ToNumberArray = function(s) {
            var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
            for (var i = 0; i < a.length; i++) {
                a[i] = parseFloat(a[i]);
            }
            return a;
        }
        svg.Point = function(x, y) {
            this.x = x;
            this.y = y;
        }
        svg.Point.prototype.angleTo = function(p) {
            return Math.atan2(p.y - this.y, p.x - this.x);
        }
        svg.Point.prototype.applyTransform = function(v) {
            var xp = this.x * v[0] + this.y * v[2] + v[4];
            var yp = this.x * v[1] + this.y * v[3] + v[5];
            this.x = xp;
            this.y = yp;
        }
        svg.CreatePoint = function(s) {
            var a = svg.ToNumberArray(s);
            return new svg.Point(a[0], a[1]);
        }
        svg.CreatePath = function(s) {
            var a = svg.ToNumberArray(s);
            var path = [];
            for (var i = 0; i < a.length; i += 2) {
                path.push(new svg.Point(a[i], a[i + 1]));
            }
            return path;
        }
        svg.BoundingBox = function(x1, y1, x2, y2) {
            this.x1 = Number.NaN;
            this.y1 = Number.NaN;
            this.x2 = Number.NaN;
            this.y2 = Number.NaN;
            this.x = function() {
                return this.x1;
            }
            this.y = function() {
                return this.y1;
            }
            this.width = function() {
                return this.x2 - this.x1;
            }
            this.height = function() {
                return this.y2 - this.y1;
            }
            this.addPoint = function(x, y) {
                if (x != null) {
                    if (isNaN(this.x1) || isNaN(this.x2)) {
                        this.x1 = x;
                        this.x2 = x;
                    }
                    if (x < this.x1) {
                        this.x1 = x;
                    }
                    if (x > this.x2) {
                        this.x2 = x;
                    }
                }
                if (y != null) {
                    if (isNaN(this.y1) || isNaN(this.y2)) {
                        this.y1 = y;
                        this.y2 = y;
                    }
                    if (y < this.y1) {
                        this.y1 = y;
                    }
                    if (y > this.y2) {
                        this.y2 = y;
                    }
                }
            }
            this.addX = function(x) {
                this.addPoint(x, null);
            }
            this.addY = function(y) {
                this.addPoint(null, y);
            }
            this.addBoundingBox = function(bb) {
                this.addPoint(bb.x1, bb.y1);
                this.addPoint(bb.x2, bb.y2);
            }
            this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
                var cp1x = p0x + 2 / 3 * (p1x - p0x);
                var cp1y = p0y + 2 / 3 * (p1y - p0y);
                var cp2x = cp1x + 1 / 3 * (p2x - p0x);
                var cp2y = cp1y + 1 / 3 * (p2y - p0y);
                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
            }
            this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
                var p0 = [p0x, p0y],
                    p1 = [p1x, p1y],
                    p2 = [p2x, p2y],
                    p3 = [p3x, p3y];
                this.addPoint(p0[0], p0[1]);
                this.addPoint(p3[0], p3[1]);
                for (i = 0; i <= 1; i++) {
                    var f = function(t) {
                        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];
                    }
                    var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                    var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                    var c = 3 * p1[i] - 3 * p0[i];
                    if (a == 0) {
                        if (b == 0) {
                            continue;
                        }
                        var t = -c / b;
                        if (0 < t && t < 1) {
                            if (i == 0) {
                                this.addX(f(t));
                            }
                            if (i == 1) {
                                this.addY(f(t));
                            }
                        }
                        continue;
                    }
                    var b2ac = Math.pow(b, 2) - 4 * c * a;
                    if (b2ac < 0) {
                        continue;
                    }
                    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t1 && t1 < 1) {
                        if (i == 0) {
                            this.addX(f(t1));
                        }
                        if (i == 1) {
                            this.addY(f(t1));
                        }
                    }
                    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t2 && t2 < 1) {
                        if (i == 0) {
                            this.addX(f(t2));
                        }
                        if (i == 1) {
                            this.addY(f(t2));
                        }
                    }
                }
            }
            this.isPointInBox = function(x, y) {
                return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
            }
            this.addPoint(x1, y1);
            this.addPoint(x2, y2);
        }
        svg.Transform = function(v) {
            var that = this;
            this.Type = {}
            this.Type.translate = function(s) {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx) {
                    ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
                }
                this.unapply = function(ctx) {
                    ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                }
            }
            this.Type.rotate = function(s) {
                var a = svg.ToNumberArray(s);
                this.angle = new svg.Property('angle', a[0]);
                this.cx = a[1] || 0;
                this.cy = a[2] || 0;
                this.apply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                }
                this.unapply = function(ctx) {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(-1.0 * this.angle.toRadians());
                    ctx.translate(-this.cx, -this.cy);
                }
                this.applyToPoint = function(p) {
                    var a = this.angle.toRadians();
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                    p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
                    p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
                }
            }
            this.Type.scale = function(s) {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx) {
                    ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
                }
                this.unapply = function(ctx) {
                    ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
                }
            }
            this.Type.matrix = function(s) {
                this.m = svg.ToNumberArray(s);
                this.apply = function(ctx) {
                    ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
                }
                this.applyToPoint = function(p) {
                    p.applyTransform(this.m);
                }
            }
            this.Type.SkewBase = function(s) {
                this.base = that.Type.matrix;
                this.base(s);
                this.angle = new svg.Property('angle', s);
            }
            this.Type.SkewBase.prototype = new this.Type.matrix;
            this.Type.skewX = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
            }
            this.Type.skewX.prototype = new this.Type.SkewBase;
            this.Type.skewY = function(s) {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
            }
            this.Type.skewY.prototype = new this.Type.SkewBase;
            this.transforms = [];
            this.apply = function(ctx) {
                for (var i = 0; i < this.transforms.length; i++) {
                    this.transforms[i].apply(ctx);
                }
            }
            this.unapply = function(ctx) {
                for (var i = this.transforms.length - 1; i >= 0; i--) {
                    this.transforms[i].unapply(ctx);
                }
            }
            this.applyToPoint = function(p) {
                for (var i = 0; i < this.transforms.length; i++) {
                    this.transforms[i].applyToPoint(p);
                }
            }
            var data = svg.trim(svg.compressSpaces(v)).replace(/\)(\s?,\s?)/g, ') ').split(/\s(?=[a-z])/);
            for (var i = 0; i < data.length; i++) {
                var type = svg.trim(data[i].split('(')[0]);
                var s = data[i].split('(')[1].replace(')', '');
                var transform = new this.Type[type](s);
                transform.type = type;
                this.transforms.push(transform);
            }
        }
        svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
            aspectRatio = svg.compressSpaces(aspectRatio);
            aspectRatio = aspectRatio.replace(/^defer\s/, '');
            var align = aspectRatio.split(' ')[0] || 'xMidYMid';
            var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';
            var scaleX = width / desiredWidth;
            var scaleY = height / desiredHeight;
            var scaleMin = Math.min(scaleX, scaleY);
            var scaleMax = Math.max(scaleX, scaleY);
            if (meetOrSlice == 'meet') {
                desiredWidth *= scaleMin;
                desiredHeight *= scaleMin;
            }
            if (meetOrSlice == 'slice') {
                desiredWidth *= scaleMax;
                desiredHeight *= scaleMax;
            }
            refX = new svg.Property('refX', refX);
            refY = new svg.Property('refY', refY);
            if (refX.hasValue() && refY.hasValue()) {
                ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
            } else {
                if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) {
                    ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);
                }
                if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) {
                    ctx.translate(0, height / 2.0 - desiredHeight / 2.0);
                }
                if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) {
                    ctx.translate(width - desiredWidth, 0);
                }
                if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) {
                    ctx.translate(0, height - desiredHeight);
                }
            }
            if (align == 'none') {
                ctx.scale(scaleX, scaleY);
            } else if (meetOrSlice == 'meet') {
                ctx.scale(scaleMin, scaleMin);
            } else if (meetOrSlice == 'slice') {
                ctx.scale(scaleMax, scaleMax);
            }
            ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);
        }
        svg.Element = {}
        svg.EmptyProperty = new svg.Property('EMPTY', '');
        svg.Element.ElementBase = function(node) {
            this.attributes = {};
            this.styles = {};
            this.children = [];
            this.attribute = function(name, createIfNotExists) {
                var a = this.attributes[name];
                if (a != null) {
                    return a;
                }
                if (createIfNotExists == true) {
                    a = new svg.Property(name, '');
                    this.attributes[name] = a;
                }
                return a || svg.EmptyProperty;
            }
            this.getHrefAttribute = function() {
                for (var a in this.attributes) {
                    if (a.match(/:href$/)) {
                        return this.attributes[a];
                    }
                }
                return svg.EmptyProperty;
            }
            this.style = function(name, createIfNotExists) {
                var s = this.styles[name];
                if (s != null) {
                    return s;
                }
                var a = this.attribute(name);
                if (a != null && a.hasValue()) {
                    this.styles[name] = a;
                    return a;
                }
                var p = this.parent;
                if (p != null) {
                    var ps = p.style(name);
                    if (ps != null && ps.hasValue()) {
                        return ps;
                    }
                }
                if (createIfNotExists == true) {
                    s = new svg.Property(name, '');
                    this.styles[name] = s;
                }
                return s || svg.EmptyProperty;
            }
            this.render = function(ctx) {
                if (this.style('display').value == 'none') {
                    return;
                }
                if (this.attribute('visibility').value == 'hidden') {
                    return;
                }
                ctx.save();
                if (this.attribute('mask').hasValue()) {
                    var mask = this.attribute('mask').getDefinition();
                    if (mask != null) {
                        mask.apply(ctx, this);
                    }
                } else if (this.style('filter').hasValue()) {
                    var filter = this.style('filter').getDefinition();
                    if (filter != null) {
                        filter.apply(ctx, this);
                    }
                } else {
                    this.setContext(ctx);
                    this.renderChildren(ctx);
                    this.clearContext(ctx);
                }
                ctx.restore();
            }
            this.setContext = function(ctx) {}
            this.clearContext = function(ctx) {}
            this.renderChildren = function(ctx) {
                for (var i = 0; i < this.children.length; i++) {
                    this.children[i].render(ctx);
                }
            }
            this.addChild = function(childNode, create) {
                var child = childNode;
                if (create) {
                    child = svg.CreateElement(childNode);
                }
                child.parent = this;
                this.children.push(child);
            }
            if (node != null && node.nodeType == 1) {
                for (var i = 0; i < node.childNodes.length; i++) {
                    var childNode = node.childNodes[i];
                    if (childNode.nodeType == 1) {
                        this.addChild(childNode, true);
                    }
                    if (this.captureTextNodes && childNode.nodeType == 3) {
                        var text = childNode.nodeValue || childNode.text || '';
                        if (svg.trim(svg.compressSpaces(text)) != '') {
                            this.addChild(new svg.Element.tspan(childNode), false);
                        }
                    }
                }
                for (var i = 0; i < node.attributes.length; i++) {
                    var attribute = node.attributes[i];
                    this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.nodeValue);
                }
                var styles = svg.Styles[node.nodeName];
                if (styles != null) {
                    for (var name in styles) {
                        this.styles[name] = styles[name];
                    }
                }
                if (this.attribute('class').hasValue()) {
                    var classes = svg.compressSpaces(this.attribute('class').value).split(' ');
                    for (var j = 0; j < classes.length; j++) {
                        styles = svg.Styles['.' + classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                        styles = svg.Styles[node.nodeName + '.' + classes[j]];
                        if (styles != null) {
                            for (var name in styles) {
                                this.styles[name] = styles[name];
                            }
                        }
                    }
                }
                if (this.attribute('id').hasValue()) {
                    var styles = svg.Styles['#' + this.attribute('id').value];
                    if (styles != null) {
                        for (var name in styles) {
                            this.styles[name] = styles[name];
                        }
                    }
                }
                if (this.attribute('style').hasValue()) {
                    var styles = this.attribute('style').value.split(';');
                    for (var i = 0; i < styles.length; i++) {
                        if (svg.trim(styles[i]) != '') {
                            var style = styles[i].split(':');
                            var name = svg.trim(style[0]);
                            var value = svg.trim(style[1]);
                            this.styles[name] = new svg.Property(name, value);
                        }
                    }
                }
                if (this.attribute('id').hasValue()) {
                    if (svg.Definitions[this.attribute('id').value] == null) {
                        svg.Definitions[this.attribute('id').value] = this;
                    }
                }
            }
        }
        svg.Element.RenderedElementBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.setContext = function(ctx) {
                if (this.style('fill').isUrlDefinition()) {
                    var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
                    if (fs != null) {
                        ctx.fillStyle = fs;
                    }
                } else if (this.style('fill').hasValue()) {
                    var fillStyle = this.style('fill');
                    if (fillStyle.value == 'currentColor') {
                        fillStyle.value = this.style('color').value;
                    }
                    ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
                }
                if (this.style('fill-opacity').hasValue()) {
                    var fillStyle = new svg.Property('fill', ctx.fillStyle);
                    fillStyle = fillStyle.addOpacity(this.style('fill-opacity').value);
                    ctx.fillStyle = fillStyle.value;
                }
                if (this.style('stroke').isUrlDefinition()) {
                    var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
                    if (fs != null) {
                        ctx.strokeStyle = fs;
                    }
                } else if (this.style('stroke').hasValue()) {
                    var strokeStyle = this.style('stroke');
                    if (strokeStyle.value == 'currentColor') {
                        strokeStyle.value = this.style('color').value;
                    }
                    ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
                }
                if (this.style('stroke-opacity').hasValue()) {
                    var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
                    strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity').value);
                    ctx.strokeStyle = strokeStyle.value;
                }
                if (this.style('stroke-width').hasValue()) {
                    var newLineWidth = this.style('stroke-width').toPixels();
                    ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth;
                }
                if (this.style('stroke-linecap').hasValue()) {
                    ctx.lineCap = this.style('stroke-linecap').value;
                }
                if (this.style('stroke-linejoin').hasValue()) {
                    ctx.lineJoin = this.style('stroke-linejoin').value;
                }
                if (this.style('stroke-miterlimit').hasValue()) {
                    ctx.miterLimit = this.style('stroke-miterlimit').value;
                }
                if (this.style('stroke-dasharray').hasValue()) {
                    var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
                    if (typeof(ctx.setLineDash) != 'undefined') {
                        ctx.setLineDash(gaps);
                    } else if (typeof(ctx.webkitLineDash) != 'undefined') {
                        ctx.webkitLineDash = gaps;
                    } else if (typeof(ctx.mozDash) != 'undefined') {
                        ctx.mozDash = gaps;
                    }
                    var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
                    if (typeof(ctx.lineDashOffset) != 'undefined') {
                        ctx.lineDashOffset = offset;
                    } else if (typeof(ctx.webkitLineDashOffset) != 'undefined') {
                        ctx.webkitLineDashOffset = offset;
                    } else if (typeof(ctx.mozDashOffset) != 'undefined') {
                        ctx.mozDashOffset = offset;
                    }
                }
                if (typeof(ctx.font) != 'undefined') {
                    ctx.font = svg.Font.CreateFont(this.style('font-style').value, this.style('font-variant').value, this.style('font-weight').value, this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '', this.style('font-family').value).toString();
                }
                if (this.attribute('transform').hasValue()) {
                    var transform = new svg.Transform(this.attribute('transform').value);
                    transform.apply(ctx);
                }
                if (this.style('clip-path').hasValue()) {
                    var clip = this.style('clip-path').getDefinition();
                    if (clip != null) {
                        clip.apply(ctx);
                    }
                }
                if (this.style('opacity').hasValue()) {
                    ctx.globalAlpha = this.style('opacity').numValue();
                }
            }
        }
        svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;
        svg.Element.PathElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.path = function(ctx) {
                if (ctx != null) {
                    ctx.beginPath();
                }
                return new svg.BoundingBox();
            }
            this.renderChildren = function(ctx) {
                this.path(ctx);
                svg.Mouse.checkPath(this, ctx);
                if (ctx.fillStyle != '') {
                    if (this.attribute('fill-rule').hasValue()) {
                        ctx.fill(this.attribute('fill-rule').value);
                    } else {
                        ctx.fill();
                    }
                }
                if (ctx.strokeStyle != '') {
                    ctx.stroke();
                }
                var markers = this.getMarkers();
                if (markers != null) {
                    if (this.style('marker-start').isUrlDefinition()) {
                        var marker = this.style('marker-start').getDefinition();
                        marker.render(ctx, markers[0][0], markers[0][1]);
                    }
                    if (this.style('marker-mid').isUrlDefinition()) {
                        var marker = this.style('marker-mid').getDefinition();
                        for (var i = 1; i < markers.length - 1; i++) {
                            marker.render(ctx, markers[i][0], markers[i][1]);
                        }
                    }
                    if (this.style('marker-end').isUrlDefinition()) {
                        var marker = this.style('marker-end').getDefinition();
                        marker.render(ctx, markers[markers.length - 1][0], markers[markers.length - 1][1]);
                    }
                }
            }
            this.getBoundingBox = function() {
                return this.path();
            }
            this.getMarkers = function() {
                return null;
            }
        }
        svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;
        svg.Element.svg = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.baseClearContext = this.clearContext;
            this.clearContext = function(ctx) {
                this.baseClearContext(ctx);
                svg.ViewPort.RemoveCurrent();
            }
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                ctx.strokeStyle = 'rgba(0,0,0,0)';
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';
                ctx.miterLimit = 4;
                this.baseSetContext(ctx);
                if (!this.attribute('x').hasValue()) {
                    this.attribute('x', true).value = 0;
                }
                if (!this.attribute('y').hasValue()) {
                    this.attribute('y', true).value = 0;
                }
                ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));
                var width = svg.ViewPort.width();
                var height = svg.ViewPort.height();
                if (!this.attribute('width').hasValue()) {
                    this.attribute('width', true).value = '100%';
                }
                if (!this.attribute('height').hasValue()) {
                    this.attribute('height', true).value = '100%';
                }
                if (typeof(this.root) == 'undefined') {
                    width = this.attribute('width').toPixels('x');
                    height = this.attribute('height').toPixels('y');
                    var x = 0;
                    var y = 0;
                    if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
                        x = -this.attribute('refX').toPixels('x');
                        y = -this.attribute('refY').toPixels('y');
                    }
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(width, y);
                    ctx.lineTo(width, height);
                    ctx.lineTo(x, height);
                    ctx.closePath();
                    ctx.clip();
                }
                svg.ViewPort.SetCurrent(width, height);
                if (this.attribute('viewBox').hasValue()) {
                    var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];
                    svg.AspectRatio(ctx, this.attribute('preserveAspectRatio').value, svg.ViewPort.width(), width, svg.ViewPort.height(), height, minX, minY, this.attribute('refX').value, this.attribute('refY').value);
                    svg.ViewPort.RemoveCurrent();
                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
                }
            }
        }
        svg.Element.svg.prototype = new svg.Element.RenderedElementBase;
        svg.Element.rect = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.path = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) {
                    ry = rx;
                }
                if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) {
                    rx = ry;
                }
                rx = Math.min(rx, width / 2.0);
                ry = Math.min(ry, height / 2.0);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(x + rx, y);
                    ctx.lineTo(x + width - rx, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
                    ctx.lineTo(x + width, y + height - ry);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
                    ctx.lineTo(x + rx, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
                    ctx.lineTo(x, y + ry);
                    ctx.quadraticCurveTo(x, y, x + rx, y)
                    ctx.closePath();
                }
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        }
        svg.Element.rect.prototype = new svg.Element.PathElementBase;
        svg.Element.circle = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.path = function(ctx) {
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');
                var r = this.attribute('r').toPixels();
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
                    ctx.closePath();
                }
                return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
            }
        }
        svg.Element.circle.prototype = new svg.Element.PathElementBase;
        svg.Element.ellipse = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.path = function(ctx) {
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                var rx = this.attribute('rx').toPixels('x');
                var ry = this.attribute('ry').toPixels('y');
                var cx = this.attribute('cx').toPixels('x');
                var cy = this.attribute('cy').toPixels('y');
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - ry);
                    ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry, cx + rx, cy - (KAPPA * ry), cx + rx, cy);
                    ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
                    ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
                    ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
                    ctx.closePath();
                }
                return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
            }
        }
        svg.Element.ellipse.prototype = new svg.Element.PathElementBase;
        svg.Element.line = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.getPoints = function() {
                return [new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')), new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
            }
            this.path = function(ctx) {
                var points = this.getPoints();
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                }
                return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
            }
            this.getMarkers = function() {
                var points = this.getPoints();
                var a = points[0].angleTo(points[1]);
                return [
                    [points[0], a],
                    [points[1], a]
                ];
            }
        }
        svg.Element.line.prototype = new svg.Element.PathElementBase;
        svg.Element.polyline = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.points = svg.CreatePath(this.attribute('points').value);
            this.path = function(ctx) {
                var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
                if (ctx != null) {
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y);
                }
                for (var i = 1; i < this.points.length; i++) {
                    bb.addPoint(this.points[i].x, this.points[i].y);
                    if (ctx != null) {
                        ctx.lineTo(this.points[i].x, this.points[i].y);
                    }
                }
                return bb;
            }
            this.getMarkers = function() {
                var markers = [];
                for (var i = 0; i < this.points.length - 1; i++) {
                    markers.push([this.points[i], this.points[i].angleTo(this.points[i + 1])]);
                }
                markers.push([this.points[this.points.length - 1], markers[markers.length - 1][1]]);
                return markers;
            }
        }
        svg.Element.polyline.prototype = new svg.Element.PathElementBase;
        svg.Element.polygon = function(node) {
            this.base = svg.Element.polyline;
            this.base(node);
            this.basePath = this.path;
            this.path = function(ctx) {
                var bb = this.basePath(ctx);
                if (ctx != null) {
                    ctx.lineTo(this.points[0].x, this.points[0].y);
                    ctx.closePath();
                }
                return bb;
            }
        }
        svg.Element.polygon.prototype = new svg.Element.polyline;
        svg.Element.path = function(node) {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            var d = this.attribute('d').value;
            d = d.replace(/,/gm, ' ');
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, '$1 $2');
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, '$1 $2');
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, '$1 $2');
            d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, '$1 $2');
            d = d.replace(/([0-9])([+\-])/gm, '$1 $2');
            d = d.replace(/(\.[0-9]*)(\.)/gm, '$1 $2');
            d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, '$1 $3 $4 ');
            d = svg.compressSpaces(d);
            d = svg.trim(d);
            this.PathParser = new(function(d) {
                this.tokens = d.split(' ');
                this.reset = function() {
                    this.i = -1;
                    this.command = '';
                    this.previousCommand = '';
                    this.start = new svg.Point(0, 0);
                    this.control = new svg.Point(0, 0);
                    this.current = new svg.Point(0, 0);
                    this.points = [];
                    this.angles = [];
                }
                this.isEnd = function() {
                    return this.i >= this.tokens.length - 1;
                }
                this.isCommandOrEnd = function() {
                    if (this.isEnd()) {
                        return true;
                    }
                    return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
                }
                this.isRelativeCommand = function() {
                    switch (this.command) {
                        case 'm':
                        case 'l':
                        case 'h':
                        case 'v':
                        case 'c':
                        case 's':
                        case 'q':
                        case 't':
                        case 'a':
                        case 'z':
                            return true;
                            break;
                    }
                    return false;
                }
                this.getToken = function() {
                    this.i++;
                    return this.tokens[this.i];
                }
                this.getScalar = function() {
                    return parseFloat(this.getToken());
                }
                this.nextCommand = function() {
                    this.previousCommand = this.command;
                    this.command = this.getToken();
                }
                this.getPoint = function() {
                    var p = new svg.Point(this.getScalar(), this.getScalar());
                    return this.makeAbsolute(p);
                }
                this.getAsControlPoint = function() {
                    var p = this.getPoint();
                    this.control = p;
                    return p;
                }
                this.getAsCurrentPoint = function() {
                    var p = this.getPoint();
                    this.current = p;
                    return p;
                }
                this.getReflectedControlPoint = function() {
                    if (this.previousCommand.toLowerCase() != 'c' && this.previousCommand.toLowerCase() != 's' && this.previousCommand.toLowerCase() != 'q' && this.previousCommand.toLowerCase() != 't') {
                        return this.current;
                    }
                    var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
                    return p;
                }
                this.makeAbsolute = function(p) {
                    if (this.isRelativeCommand()) {
                        p.x += this.current.x;
                        p.y += this.current.y;
                    }
                    return p;
                }
                this.addMarker = function(p, from, priorTo) {
                    if (priorTo != null && this.angles.length && this.angles[this.angles.length - 1] == null) {
                        this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(priorTo);
                    }
                    this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
                }
                this.addMarkerAngle = function(p, a) {
                    this.points.push(p);
                    this.angles.push(a);
                }
                this.getMarkerPoints = function() {
                    return this.points;
                }
                this.getMarkerAngles = function() {
                    for (var i = 0; i < this.angles.length; i++) {
                        if (this.angles[i] == null) {
                            for (var j = i + 1; j < this.angles.length; j++) {
                                if (this.angles[j] != null) {
                                    this.angles[i] = this.angles[j];
                                    break;
                                }
                            }
                        }
                    }
                    return this.angles;
                }
            })(d);
            this.path = function(ctx) {
                var pp = this.PathParser;
                pp.reset();
                var bb = new svg.BoundingBox();
                if (ctx != null) {
                    ctx.beginPath();
                }
                while (!pp.isEnd()) {
                    pp.nextCommand();
                    switch (pp.command) {
                        case 'M':
                        case 'm':
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null) {
                                ctx.moveTo(p.x, p.y);
                            }
                            pp.start = pp.current;
                            while (!pp.isCommandOrEnd()) {
                                var p = pp.getAsCurrentPoint();
                                pp.addMarker(p, pp.start);
                                bb.addPoint(p.x, p.y);
                                if (ctx != null) {
                                    ctx.lineTo(p.x, p.y);
                                }
                            }
                            break;
                        case 'L':
                        case 'l':
                            while (!pp.isCommandOrEnd()) {
                                var c = pp.current;
                                var p = pp.getAsCurrentPoint();
                                pp.addMarker(p, c);
                                bb.addPoint(p.x, p.y);
                                if (ctx != null) {
                                    ctx.lineTo(p.x, p.y);
                                }
                            }
                            break;
                        case 'H':
                        case 'h':
                            while (!pp.isCommandOrEnd()) {
                                var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                                pp.addMarker(newP, pp.current);
                                pp.current = newP;
                                bb.addPoint(pp.current.x, pp.current.y);
                                if (ctx != null) {
                                    ctx.lineTo(pp.current.x, pp.current.y);
                                }
                            }
                            break;
                        case 'V':
                        case 'v':
                            while (!pp.isCommandOrEnd()) {
                                var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                                pp.addMarker(newP, pp.current);
                                pp.current = newP;
                                bb.addPoint(pp.current.x, pp.current.y);
                                if (ctx != null) {
                                    ctx.lineTo(pp.current.x, pp.current.y);
                                }
                            }
                            break;
                        case 'C':
                        case 'c':
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var p1 = pp.getPoint();
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, p1);
                                bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null) {
                                    ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                }
                            }
                            break;
                        case 'S':
                        case 's':
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var p1 = pp.getReflectedControlPoint();
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, p1);
                                bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null) {
                                    ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                }
                            }
                            break;
                        case 'Q':
                        case 'q':
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, cntrl);
                                bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null) {
                                    ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                                }
                            }
                            break;
                        case 'T':
                        case 't':
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var cntrl = pp.getReflectedControlPoint();
                                pp.control = cntrl;
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, cntrl);
                                bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null) {
                                    ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
                                }
                            }
                            break;
                        case 'A':
                        case 'a':
                            while (!pp.isCommandOrEnd()) {
                                var curr = pp.current;
                                var rx = pp.getScalar();
                                var ry = pp.getScalar();
                                var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
                                var largeArcFlag = pp.getScalar();
                                var sweepFlag = pp.getScalar();
                                var cp = pp.getAsCurrentPoint();
                                var currp = new svg.Point(Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0, -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0);
                                var l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);
                                if (l > 1) {
                                    rx *= Math.sqrt(l);
                                    ry *= Math.sqrt(l);
                                }
                                var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(((Math.pow(rx, 2) * Math.pow(ry, 2)) - (Math.pow(rx, 2) * Math.pow(currp.y, 2)) - (Math.pow(ry, 2) * Math.pow(currp.x, 2))) / (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2)));
                                if (isNaN(s)) {
                                    s = 0;
                                }
                                var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                                var centp = new svg.Point((curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
                                var m = function(v) {
                                    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));
                                }
                                var r = function(u, v) {
                                    return (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v))
                                }
                                var a = function(u, v) {
                                    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v));
                                }
                                var a1 = a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);
                                var u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];
                                var v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];
                                var ad = a(u, v);
                                if (r(u, v) <= -1) {
                                    ad = Math.PI;
                                }
                                if (r(u, v) >= 1) {
                                    ad = 0;
                                }
                                var dir = 1 - sweepFlag ? 1.0 : -1.0;
                                var ah = a1 + dir * (ad / 2.0);
                                var halfWay = new svg.Point(centp.x + rx * Math.cos(ah), centp.y + ry * Math.sin(ah));
                                pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
                                pp.addMarkerAngle(cp, ah - dir * Math.PI);
                                bb.addPoint(cp.x, cp.y);
                                if (ctx != null) {
                                    var r = rx > ry ? rx : ry;
                                    var sx = rx > ry ? 1 : rx / ry;
                                    var sy = rx > ry ? ry / rx : 1;
                                    ctx.translate(centp.x, centp.y);
                                    ctx.rotate(xAxisRotation);
                                    ctx.scale(sx, sy);
                                    ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                                    ctx.scale(1 / sx, 1 / sy);
                                    ctx.rotate(-xAxisRotation);
                                    ctx.translate(-centp.x, -centp.y);
                                }
                            }
                            break;
                        case 'Z':
                        case 'z':
                            if (ctx != null) {
                                ctx.closePath();
                            }
                            pp.current = pp.start;
                    }
                }
                return bb;
            }
            this.getMarkers = function() {
                var points = this.PathParser.getMarkerPoints();
                var angles = this.PathParser.getMarkerAngles();
                var markers = [];
                for (var i = 0; i < points.length; i++) {
                    markers.push([points[i], angles[i]]);
                }
                return markers;
            }
        }
        svg.Element.path.prototype = new svg.Element.PathElementBase;
        svg.Element.pattern = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.createPattern = function(ctx, element) {
                var width = this.attribute('width').toPixels('x', true);
                var height = this.attribute('height').toPixels('y', true);
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
                tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
                tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
                tempSvg.children = this.children;
                var c = document.createElement('canvas');
                c.width = width;
                c.height = height;
                var cctx = c.getContext('2d');
                if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
                    cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
                }
                for (var x = -1; x <= 1; x++) {
                    for (var y = -1; y <= 1; y++) {
                        cctx.save();
                        cctx.translate(x * c.width, y * c.height);
                        tempSvg.render(cctx);
                        cctx.restore();
                    }
                }
                var pattern = ctx.createPattern(c, 'repeat');
                return pattern;
            }
        }
        svg.Element.pattern.prototype = new svg.Element.ElementBase;
        svg.Element.marker = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.baseRender = this.render;
            this.render = function(ctx, point, angle) {
                ctx.translate(point.x, point.y);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') {
                    ctx.rotate(angle);
                }
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') {
                    ctx.scale(ctx.lineWidth, ctx.lineWidth);
                }
                ctx.save();
                var tempSvg = new svg.Element.svg();
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
                tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
                tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
                tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
                tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
                tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
                tempSvg.children = this.children;
                tempSvg.render(ctx);
                ctx.restore();
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') {
                    ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
                }
                if (this.attribute('orient').valueOrDefault('auto') == 'auto') {
                    ctx.rotate(-angle);
                }
                ctx.translate(-point.x, -point.y);
            }
        }
        svg.Element.marker.prototype = new svg.Element.ElementBase;
        svg.Element.defs = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.render = function(ctx) {}
        }
        svg.Element.defs.prototype = new svg.Element.ElementBase;
        svg.Element.GradientBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.gradientUnits = this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
            this.stops = [];
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'stop') {
                    this.stops.push(child);
                }
            }
            this.getGradient = function() {}
            this.createGradient = function(ctx, element, parentOpacityProp) {
                var stopsContainer = this;
                if (this.getHrefAttribute().hasValue()) {
                    stopsContainer = this.getHrefAttribute().getDefinition();
                }
                var addParentOpacity = function(color) {
                    if (parentOpacityProp.hasValue()) {
                        var p = new svg.Property('color', color);
                        return p.addOpacity(parentOpacityProp.value).value;
                    }
                    return color;
                };
                var g = this.getGradient(ctx, element);
                if (g == null) {
                    return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
                }
                for (var i = 0; i < stopsContainer.stops.length; i++) {
                    g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
                }
                if (this.attribute('gradientTransform').hasValue()) {
                    var rootView = svg.ViewPort.viewPorts[0];
                    var rect = new svg.Element.rect();
                    rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS / 3.0);
                    rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS / 3.0);
                    rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
                    rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);
                    var group = new svg.Element.g();
                    group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
                    group.children = [rect];
                    var tempSvg = new svg.Element.svg();
                    tempSvg.attributes['x'] = new svg.Property('x', 0);
                    tempSvg.attributes['y'] = new svg.Property('y', 0);
                    tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
                    tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
                    tempSvg.children = [group];
                    var c = document.createElement('canvas');
                    c.width = rootView.width;
                    c.height = rootView.height;
                    var tempCtx = c.getContext('2d');
                    tempCtx.fillStyle = g;
                    tempSvg.render(tempCtx);
                    return tempCtx.createPattern(c, 'no-repeat');
                }
                return g;
            }
        }
        svg.Element.GradientBase.prototype = new svg.Element.ElementBase;
        svg.Element.linearGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            this.getGradient = function(ctx, element) {
                var bb = element.getBoundingBox();
                if (!this.attribute('x1').hasValue() && !this.attribute('y1').hasValue() && !this.attribute('x2').hasValue() && !this.attribute('y2').hasValue()) {
                    this.attribute('x1', true).value = 0;
                    this.attribute('y1', true).value = 0;
                    this.attribute('x2', true).value = 1;
                    this.attribute('y2', true).value = 0;
                }
                var x1 = (this.gradientUnits == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('x1').numValue() : this.attribute('x1').toPixels('x'));
                var y1 = (this.gradientUnits == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('y1').numValue() : this.attribute('y1').toPixels('y'));
                var x2 = (this.gradientUnits == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('x2').numValue() : this.attribute('x2').toPixels('x'));
                var y2 = (this.gradientUnits == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('y2').numValue() : this.attribute('y2').toPixels('y'));
                if (x1 == x2 && y1 == y2) {
                    return null;
                }
                return ctx.createLinearGradient(x1, y1, x2, y2);
            }
        }
        svg.Element.linearGradient.prototype = new svg.Element.GradientBase;
        svg.Element.radialGradient = function(node) {
            this.base = svg.Element.GradientBase;
            this.base(node);
            this.getGradient = function(ctx, element) {
                var bb = element.getBoundingBox();
                if (!this.attribute('cx').hasValue()) {
                    this.attribute('cx', true).value = '50%';
                }
                if (!this.attribute('cy').hasValue()) {
                    this.attribute('cy', true).value = '50%';
                }
                if (!this.attribute('r').hasValue()) {
                    this.attribute('r', true).value = '50%';
                }
                var cx = (this.gradientUnits == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('cx').numValue() : this.attribute('cx').toPixels('x'));
                var cy = (this.gradientUnits == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('cy').numValue() : this.attribute('cy').toPixels('y'));
                var fx = cx;
                var fy = cy;
                if (this.attribute('fx').hasValue()) {
                    fx = (this.gradientUnits == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('fx').numValue() : this.attribute('fx').toPixels('x'));
                }
                if (this.attribute('fy').hasValue()) {
                    fy = (this.gradientUnits == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('fy').numValue() : this.attribute('fy').toPixels('y'));
                }
                var r = (this.gradientUnits == 'objectBoundingBox' ? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue() : this.attribute('r').toPixels());
                return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
            }
        }
        svg.Element.radialGradient.prototype = new svg.Element.GradientBase;
        svg.Element.stop = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.offset = this.attribute('offset').numValue();
            if (this.offset < 0) {
                this.offset = 0;
            }
            if (this.offset > 1) {
                this.offset = 1;
            }
            var stopColor = this.style('stop-color');
            if (this.style('stop-opacity').hasValue()) {
                stopColor = stopColor.addOpacity(this.style('stop-opacity').value);
            }
            this.color = stopColor.value;
        }
        svg.Element.stop.prototype = new svg.Element.ElementBase;
        svg.Element.AnimateBase = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            svg.Animations.push(this);
            this.duration = 0.0;
            this.begin = this.attribute('begin').toMilliseconds();
            this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();
            this.getProperty = function() {
                var attributeType = this.attribute('attributeType').value;
                var attributeName = this.attribute('attributeName').value;
                if (attributeType == 'CSS') {
                    return this.parent.style(attributeName, true);
                }
                return this.parent.attribute(attributeName, true);
            };
            this.initialValue = null;
            this.initialUnits = '';
            this.removed = false;
            this.calcValue = function() {
                return '';
            }
            this.update = function(delta) {
                if (this.initialValue == null) {
                    this.initialValue = this.getProperty().value;
                    this.initialUnits = this.getProperty().getUnits();
                }
                if (this.duration > this.maxDuration) {
                    if (this.attribute('repeatCount').value == 'indefinite' || this.attribute('repeatDur').value == 'indefinite') {
                        this.duration = 0.0
                    } else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
                        this.removed = true;
                        this.getProperty().value = this.initialValue;
                        return true;
                    } else {
                        return false;
                    }
                }
                this.duration = this.duration + delta;
                var updated = false;
                if (this.begin < this.duration) {
                    var newValue = this.calcValue();
                    if (this.attribute('type').hasValue()) {
                        var type = this.attribute('type').value;
                        newValue = type + '(' + newValue + ')';
                    }
                    this.getProperty().value = newValue;
                    updated = true;
                }
                return updated;
            }
            this.from = this.attribute('from');
            this.to = this.attribute('to');
            this.values = this.attribute('values');
            if (this.values.hasValue()) {
                this.values.value = this.values.value.split(';');
            }
            this.progress = function() {
                var ret = {
                    progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
                };
                if (this.values.hasValue()) {
                    var p = ret.progress * (this.values.value.length - 1);
                    var lb = Math.floor(p),
                        ub = Math.ceil(p);
                    ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
                    ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
                    ret.progress = (p - lb) / (ub - lb);
                } else {
                    ret.from = this.from;
                    ret.to = this.to;
                }
                return ret;
            }
        }
        svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;
        svg.Element.animate = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            this.calcValue = function() {
                var p = this.progress();
                var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;
                return newValue + this.initialUnits;
            };
        }
        svg.Element.animate.prototype = new svg.Element.AnimateBase;
        svg.Element.animateColor = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            this.calcValue = function() {
                var p = this.progress();
                var from = new RGBColor(p.from.value);
                var to = new RGBColor(p.to.value);
                if (from.ok && to.ok) {
                    var r = from.r + (to.r - from.r) * p.progress;
                    var g = from.g + (to.g - from.g) * p.progress;
                    var b = from.b + (to.b - from.b) * p.progress;
                    return 'rgb(' + parseInt(r, 10) + ',' + parseInt(g, 10) + ',' + parseInt(b, 10) + ')';
                }
                return this.attribute('from').value;
            };
        }
        svg.Element.animateColor.prototype = new svg.Element.AnimateBase;
        svg.Element.animateTransform = function(node) {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            this.calcValue = function() {
                var p = this.progress();
                var from = svg.ToNumberArray(p.from.value);
                var to = svg.ToNumberArray(p.to.value);
                var newValue = '';
                for (var i = 0; i < from.length; i++) {
                    newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
                }
                return newValue;
            };
        }
        svg.Element.animateTransform.prototype = new svg.Element.animate;
        svg.Element.font = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.horizAdvX = this.attribute('horiz-adv-x').numValue();
            this.isRTL = false;
            this.isArabic = false;
            this.fontFace = null;
            this.missingGlyph = null;
            this.glyphs = [];
            for (var i = 0; i < this.children.length; i++) {
                var child = this.children[i];
                if (child.type == 'font-face') {
                    this.fontFace = child;
                    if (child.style('font-family').hasValue()) {
                        svg.Definitions[child.style('font-family').value] = this;
                    }
                } else if (child.type == 'missing-glyph') {
                    this.missingGlyph = child;
                } else if (child.type == 'glyph') {
                    if (child.arabicForm != '') {
                        this.isRTL = true;
                        this.isArabic = true;
                        if (typeof(this.glyphs[child.unicode]) == 'undefined') {
                            this.glyphs[child.unicode] = [];
                        }
                        this.glyphs[child.unicode][child.arabicForm] = child;
                    } else {
                        this.glyphs[child.unicode] = child;
                    }
                }
            }
        }
        svg.Element.font.prototype = new svg.Element.ElementBase;
        svg.Element.fontface = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.ascent = this.attribute('ascent').value;
            this.descent = this.attribute('descent').value;
            this.unitsPerEm = this.attribute('units-per-em').numValue();
        }
        svg.Element.fontface.prototype = new svg.Element.ElementBase;
        svg.Element.missingglyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);
            this.horizAdvX = 0;
        }
        svg.Element.missingglyph.prototype = new svg.Element.path;
        svg.Element.glyph = function(node) {
            this.base = svg.Element.path;
            this.base(node);
            this.horizAdvX = this.attribute('horiz-adv-x').numValue();
            this.unicode = this.attribute('unicode').value;
            this.arabicForm = this.attribute('arabic-form').value;
        }
        svg.Element.glyph.prototype = new svg.Element.path;
        svg.Element.text = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                if (this.style('dominant-baseline').hasValue()) {
                    ctx.textBaseline = this.style('dominant-baseline').value;
                }
                if (this.style('alignment-baseline').hasValue()) {
                    ctx.textBaseline = this.style('alignment-baseline').value;
                }
            }
            this.getBoundingBox = function() {
                return new svg.BoundingBox(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'), 0, 0);
            }
            this.renderChildren = function(ctx) {
                this.x = this.attribute('x').toPixels('x');
                this.y = this.attribute('y').toPixels('y');
                this.x += this.getAnchorDelta(ctx, this, 0);
                for (var i = 0; i < this.children.length; i++) {
                    this.renderChild(ctx, this, i);
                }
            }
            this.getAnchorDelta = function(ctx, parent, startI) {
                var textAnchor = this.style('text-anchor').valueOrDefault('start');
                if (textAnchor != 'start') {
                    var width = 0;
                    for (var i = startI; i < parent.children.length; i++) {
                        var child = parent.children[i];
                        if (i > startI && child.attribute('x').hasValue()) {
                            break;
                        }
                        width += child.measureTextRecursive(ctx);
                    }
                    return -1 * (textAnchor == 'end' ? width : width / 2.0);
                }
                return 0;
            }
            this.renderChild = function(ctx, parent, i) {
                var child = parent.children[i];
                if (child.attribute('x').hasValue()) {
                    child.x = child.attribute('x').toPixels('x') + this.getAnchorDelta(ctx, parent, i);
                } else {
                    if (this.attribute('dx').hasValue()) {
                        this.x += this.attribute('dx').toPixels('x');
                    }
                    if (child.attribute('dx').hasValue()) {
                        this.x += child.attribute('dx').toPixels('x');
                    }
                    child.x = this.x;
                }
                this.x = child.x + child.measureText(ctx);
                if (child.attribute('y').hasValue()) {
                    child.y = child.attribute('y').toPixels('y');
                } else {
                    if (this.attribute('dy').hasValue()) {
                        this.y += this.attribute('dy').toPixels('y');
                    }
                    if (child.attribute('dy').hasValue()) {
                        this.y += child.attribute('dy').toPixels('y');
                    }
                    child.y = this.y;
                }
                this.y = child.y;
                child.render(ctx);
                for (var i = 0; i < child.children.length; i++) {
                    this.renderChild(ctx, child, i);
                }
            }
        }
        svg.Element.text.prototype = new svg.Element.RenderedElementBase;
        svg.Element.TextElementBase = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.getGlyph = function(font, text, i) {
                var c = text[i];
                var glyph = null;
                if (font.isArabic) {
                    var arabicForm = 'isolated';
                    if ((i == 0 || text[i - 1] == ' ') && i < text.length - 2 && text[i + 1] != ' ') {
                        arabicForm = 'terminal';
                    }
                    if (i > 0 && text[i - 1] != ' ' && i < text.length - 2 && text[i + 1] != ' ') {
                        arabicForm = 'medial';
                    }
                    if (i > 0 && text[i - 1] != ' ' && (i == text.length - 1 || text[i + 1] == ' ')) {
                        arabicForm = 'initial';
                    }
                    if (typeof(font.glyphs[c]) != 'undefined') {
                        glyph = font.glyphs[c][arabicForm];
                        if (glyph == null && font.glyphs[c].type == 'glyph') {
                            glyph = font.glyphs[c];
                        }
                    }
                } else {
                    glyph = font.glyphs[c];
                }
                if (glyph == null) {
                    glyph = font.missingGlyph;
                }
                return glyph;
            }
            this.renderChildren = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
                    var text = this.getText();
                    if (customFont.isRTL) {
                        text = text.split("").reverse().join("");
                    }
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i = 0; i < text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        var scale = fontSize / customFont.fontFace.unitsPerEm;
                        ctx.translate(this.x, this.y);
                        ctx.scale(scale, -scale);
                        var lw = ctx.lineWidth;
                        ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
                        if (fontStyle == 'italic') {
                            ctx.transform(1, 0, .4, 1, 0, 0);
                        }
                        glyph.render(ctx);
                        if (fontStyle == 'italic') {
                            ctx.transform(1, 0, -.4, 1, 0, 0);
                        }
                        ctx.lineWidth = lw;
                        ctx.scale(1 / scale, -1 / scale);
                        ctx.translate(-this.x, -this.y);
                        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            this.x += dx[i];
                        }
                    }
                    return;
                }
                if (ctx.fillStyle != '') {
                    ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
                }
                if (ctx.strokeStyle != '') {
                    ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
                }
            }
            this.getText = function() {}
            this.measureTextRecursive = function(ctx) {
                var width = this.measureText(ctx);
                for (var i = 0; i < this.children.length; i++) {
                    width += this.children[i].measureTextRecursive(ctx);
                }
                return width;
            }
            this.measureText = function(ctx) {
                var customFont = this.parent.style('font-family').getDefinition();
                if (customFont != null) {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var measure = 0;
                    var text = this.getText();
                    if (customFont.isRTL) {
                        text = text.split("").reverse().join("");
                    }
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i = 0; i < text.length; i++) {
                        var glyph = this.getGlyph(customFont, text, i);
                        measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
                            measure += dx[i];
                        }
                    }
                    return measure;
                }
                var textToMeasure = svg.compressSpaces(this.getText());
                if (!ctx.measureText) {
                    return textToMeasure.length * 10;
                }
                ctx.save();
                this.setContext(ctx);
                var width = ctx.measureText(textToMeasure).width;
                ctx.restore();
                return width;
            }
        }
        svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;
        svg.Element.tspan = function(node) {
            this.captureTextNodes = true;
            this.base = svg.Element.TextElementBase;
            this.base(node);
            this.text = node.nodeValue || node.text || '';
            this.getText = function() {
                return this.text;
            }
        }
        svg.Element.tspan.prototype = new svg.Element.TextElementBase;
        svg.Element.tref = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            this.getText = function() {
                var element = this.getHrefAttribute().getDefinition();
                if (element != null) {
                    return element.children[0].getText();
                }
            }
        }
        svg.Element.tref.prototype = new svg.Element.TextElementBase;
        svg.Element.a = function(node) {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            this.hasText = true;
            for (var i = 0; i < node.childNodes.length; i++) {
                if (node.childNodes[i].nodeType != 3) {
                    this.hasText = false;
                }
            }
            this.text = this.hasText ? node.childNodes[0].nodeValue : '';
            this.getText = function() {
                return this.text;
            }
            this.baseRenderChildren = this.renderChildren;
            this.renderChildren = function(ctx) {
                if (this.hasText) {
                    this.baseRenderChildren(ctx);
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));
                } else {
                    var g = new svg.Element.g();
                    g.children = this.children;
                    g.parent = this;
                    g.render(ctx);
                }
            }
            this.onclick = function() {
                window.open(this.getHrefAttribute().value);
            }
            this.onmousemove = function() {
                svg.ctx.canvas.style.cursor = 'pointer';
            }
        }
        svg.Element.a.prototype = new svg.Element.TextElementBase;
        svg.Element.image = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            var href = this.getHrefAttribute().value;
            var isSvg = href.match(/\.svg$/)
            svg.Images.push(this);
            this.loaded = false;
            if (!isSvg) {
                this.img = document.createElement('img');
                var self = this;
                this.img.onload = function() {
                    self.loaded = true;
                }
                this.img.onerror = function() {
                    if (typeof(console) != 'undefined') {
                        console.log('ERROR: image "' + href + '" not found');
                        self.loaded = true;
                    }
                }
                this.img.src = href;
            } else {
                this.img = svg.ajax(href);
                this.loaded = true;
            }
            this.renderChildren = function(ctx) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                if (width == 0 || height == 0) {
                    return;
                }
                ctx.save();
                if (isSvg) {
                    ctx.drawSvg(this.img, x, y, width, height);
                } else {
                    ctx.translate(x, y);
                    svg.AspectRatio(ctx, this.attribute('preserveAspectRatio').value, width, this.img.width, height, this.img.height, 0, 0);
                    ctx.drawImage(this.img, 0, 0);
                }
                ctx.restore();
            }
            this.getBoundingBox = function() {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                return new svg.BoundingBox(x, y, x + width, y + height);
            }
        }
        svg.Element.image.prototype = new svg.Element.RenderedElementBase;
        svg.Element.g = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.getBoundingBox = function() {
                var bb = new svg.BoundingBox();
                for (var i = 0; i < this.children.length; i++) {
                    bb.addBoundingBox(this.children[i].getBoundingBox());
                }
                return bb;
            };
        }
        svg.Element.g.prototype = new svg.Element.RenderedElementBase;
        svg.Element.symbol = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                if (this.attribute('viewBox').hasValue()) {
                    var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];
                    svg.AspectRatio(ctx, this.attribute('preserveAspectRatio').value, this.attribute('width').toPixels('x'), width, this.attribute('height').toPixels('y'), height, minX, minY);
                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
                }
            }
        }
        svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;
        svg.Element.style = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            var css = ''
            for (var i = 0; i < node.childNodes.length; i++) {
                css += node.childNodes[i].nodeValue;
            }
            css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, '');
            css = svg.compressSpaces(css);
            var cssDefs = css.split('}');
            for (var i = 0; i < cssDefs.length; i++) {
                if (svg.trim(cssDefs[i]) != '') {
                    var cssDef = cssDefs[i].split('{');
                    var cssClasses = cssDef[0].split(',');
                    var cssProps = cssDef[1].split(';');
                    for (var j = 0; j < cssClasses.length; j++) {
                        var cssClass = svg.trim(cssClasses[j]);
                        if (cssClass != '') {
                            var props = {};
                            for (var k = 0; k < cssProps.length; k++) {
                                var prop = cssProps[k].indexOf(':');
                                var name = cssProps[k].substr(0, prop);
                                var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
                                if (name != null && value != null) {
                                    props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
                                }
                            }
                            svg.Styles[cssClass] = props;
                            if (cssClass == '@font-face') {
                                var fontFamily = props['font-family'].value.replace(/"/g, '');
                                var srcs = props['src'].value.split(',');
                                for (var s = 0; s < srcs.length; s++) {
                                    if (srcs[s].indexOf('format("svg")')) {
                                        var urlStart = srcs[s].indexOf('url');
                                        var urlEnd = srcs[s].indexOf(')', urlStart);
                                        var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
                                        var doc = svg.parseXml(svg.ajax(url));
                                        var fonts = doc.getElementsByTagName('font');
                                        for (var f = 0; f < fonts.length; f++) {
                                            var font = svg.CreateElement(fonts[f]);
                                            svg.Definitions[fontFamily] = font;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        svg.Element.style.prototype = new svg.Element.ElementBase;
        svg.Element.use = function(node) {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx) {
                this.baseSetContext(ctx);
                if (this.attribute('x').hasValue()) {
                    ctx.translate(this.attribute('x').toPixels('x'), 0);
                }
                if (this.attribute('y').hasValue()) {
                    ctx.translate(0, this.attribute('y').toPixels('y'));
                }
            }
            this.getDefinition = function() {
                var element = this.getHrefAttribute().getDefinition();
                if (this.attribute('width').hasValue()) {
                    element.attribute('width', true).value = this.attribute('width').value;
                }
                if (this.attribute('height').hasValue()) {
                    element.attribute('height', true).value = this.attribute('height').value;
                }
                return element;
            }
            this.path = function(ctx) {
                var element = this.getDefinition();
                if (element != null) {
                    element.path(ctx);
                }
            }
            this.getBoundingBox = function() {
                var element = this.getDefinition();
                if (element != null) {
                    return element.getBoundingBox();
                }
            }
            this.renderChildren = function(ctx) {
                var element = this.getDefinition();
                if (element != null) {
                    var oldParent = element.parent;
                    element.parent = null;
                    element.render(ctx);
                    element.parent = oldParent;
                }
            }
        }
        svg.Element.use.prototype = new svg.Element.RenderedElementBase;
        svg.Element.mask = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx, element) {
                var x = this.attribute('x').toPixels('x');
                var y = this.attribute('y').toPixels('y');
                var width = this.attribute('width').toPixels('x');
                var height = this.attribute('height').toPixels('y');
                if (width == 0 && height == 0) {
                    var bb = new svg.BoundingBox();
                    for (var i = 0; i < this.children.length; i++) {
                        bb.addBoundingBox(this.children[i].getBoundingBox());
                    }
                    var x = Math.floor(bb.x1);
                    var y = Math.floor(bb.y1);
                    var width = Math.floor(bb.width());
                    var height = Math.floor(bb.height());
                }
                var mask = element.attribute('mask').value;
                element.attribute('mask').value = '';
                var cMask = document.createElement('canvas');
                cMask.width = x + width;
                cMask.height = y + height;
                var maskCtx = cMask.getContext('2d');
                this.renderChildren(maskCtx);
                var c = document.createElement('canvas');
                c.width = x + width;
                c.height = y + height;
                var tempCtx = c.getContext('2d');
                element.render(tempCtx);
                tempCtx.globalCompositeOperation = 'destination-in';
                tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
                tempCtx.fillRect(0, 0, x + width, y + height);
                ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
                ctx.fillRect(0, 0, x + width, y + height);
                element.attribute('mask').value = mask;
            }
            this.render = function(ctx) {}
        }
        svg.Element.mask.prototype = new svg.Element.ElementBase;
        svg.Element.clipPath = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx) {
                for (var i = 0; i < this.children.length; i++) {
                    var child = this.children[i];
                    if (typeof(child.path) != 'undefined') {
                        var transform = null;
                        if (child.attribute('transform').hasValue()) {
                            transform = new svg.Transform(child.attribute('transform').value);
                            transform.apply(ctx);
                        }
                        child.path(ctx);
                        ctx.clip();
                        if (transform) {
                            transform.unapply(ctx);
                        }
                    }
                }
            }
            this.render = function(ctx) {}
        }
        svg.Element.clipPath.prototype = new svg.Element.ElementBase;
        svg.Element.filter = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx, element) {
                var bb = element.getBoundingBox();
                var x = Math.floor(bb.x1);
                var y = Math.floor(bb.y1);
                var width = Math.floor(bb.width());
                var height = Math.floor(bb.height());
                var filter = element.style('filter').value;
                element.style('filter').value = '';
                var px = 0,
                    py = 0;
                for (var i = 0; i < this.children.length; i++) {
                    var efd = this.children[i].extraFilterDistance || 0;
                    px = Math.max(px, efd);
                    py = Math.max(py, efd);
                }
                var c = document.createElement('canvas');
                c.width = width + 2 * px;
                c.height = height + 2 * py;
                var tempCtx = c.getContext('2d');
                tempCtx.translate(-x + px, -y + py);
                element.render(tempCtx);
                for (var i = 0; i < this.children.length; i++) {
                    this.children[i].apply(tempCtx, 0, 0, width + 2 * px, height + 2 * py);
                }
                ctx.drawImage(c, 0, 0, width + 2 * px, height + 2 * py, x - px, y - py, width + 2 * px, height + 2 * py);
                element.style('filter', true).value = filter;
            }
            this.render = function(ctx) {}
        }
        svg.Element.filter.prototype = new svg.Element.ElementBase;
        svg.Element.feMorphology = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx, x, y, width, height) {}
        }
        svg.Element.feMorphology.prototype = new svg.Element.ElementBase;
        svg.Element.feColorMatrix = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);

            function imGet(img, x, y, width, height, rgba) {
                return img[y * width * 4 + x * 4 + rgba];
            }

            function imSet(img, x, y, width, height, rgba, val) {
                img[y * width * 4 + x * 4 + rgba] = val;
            }
            this.apply = function(ctx, x, y, width, height) {
                var srcData = ctx.getImageData(0, 0, width, height);
                for (var y = 0; y < height; y++) {
                    for (var x = 0; x < width; x++) {
                        var r = imGet(srcData.data, x, y, width, height, 0);
                        var g = imGet(srcData.data, x, y, width, height, 1);
                        var b = imGet(srcData.data, x, y, width, height, 2);
                        var gray = (r + g + b) / 3;
                        imSet(srcData.data, x, y, width, height, 0, gray);
                        imSet(srcData.data, x, y, width, height, 1, gray);
                        imSet(srcData.data, x, y, width, height, 2, gray);
                    }
                }
                ctx.clearRect(0, 0, width, height);
                ctx.putImageData(srcData, 0, 0);
            }
        }
        svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;
        svg.Element.feGaussianBlur = function(node) {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
            this.extraFilterDistance = this.blurRadius;
            this.apply = function(ctx, x, y, width, height) {
                if (typeof(stackBlurCanvasRGBA) == 'undefined') {
                    if (typeof(console) != 'undefined') {
                        console.log('ERROR: StackBlur.js must be included for blur to work');
                    }
                    return;
                }
                ctx.canvas.id = svg.UniqueId();
                ctx.canvas.style.display = 'none';
                document.body.appendChild(ctx.canvas);
                stackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
                document.body.removeChild(ctx.canvas);
            }
        }
        svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;
        svg.Element.title = function(node) {}
        svg.Element.title.prototype = new svg.Element.ElementBase;
        svg.Element.desc = function(node) {}
        svg.Element.desc.prototype = new svg.Element.ElementBase;
        svg.Element.MISSING = function(node) {
            if (typeof(console) != 'undefined') {
                console.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
            }
        }
        svg.Element.MISSING.prototype = new svg.Element.ElementBase;
        svg.CreateElement = function(node) {
            var className = node.nodeName.replace(/^[^:]+:/, '');
            className = className.replace(/\-/g, '');
            var e = null;
            if (typeof(svg.Element[className]) != 'undefined') {
                e = new svg.Element[className](node);
            } else {
                e = new svg.Element.MISSING(node);
            }
            e.type = node.nodeName;
            return e;
        }
        svg.load = function(ctx, url) {
            svg.loadXml(ctx, svg.ajax(url));
        }
        svg.loadXml = function(ctx, xml) {
            svg.loadXmlDoc(ctx, svg.parseXml(xml));
        }
        svg.loadXmlDoc = function(ctx, dom) {
            svg.init(ctx);
            var mapXY = function(p) {
                var e = ctx.canvas;
                while (e) {
                    p.x -= e.offsetLeft;
                    p.y -= e.offsetTop;
                    e = e.offsetParent;
                }
                if (window.scrollX) {
                    p.x += window.scrollX;
                }
                if (window.scrollY) {
                    p.y += window.scrollY;
                }
                return p;
            }
            if (svg.opts['ignoreMouse'] != true) {
                ctx.canvas.onclick = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onclick(p.x, p.y);
                };
                ctx.canvas.onmousemove = function(e) {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onmousemove(p.x, p.y);
                };
            }
            var e = svg.CreateElement(dom.documentElement);
            e.root = true;
            var isFirstRender = true;
            var draw = function() {
                svg.ViewPort.Clear();
                if (ctx.canvas.parentNode) {
                    svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);
                }
                if (svg.opts['ignoreDimensions'] != true) {
                    if (e.style('width').hasValue()) {
                        ctx.canvas.width = e.style('width').toPixels('x');
                        ctx.canvas.style.width = ctx.canvas.width + 'px';
                    }
                    if (e.style('height').hasValue()) {
                        ctx.canvas.height = e.style('height').toPixels('y');
                        ctx.canvas.style.height = ctx.canvas.height + 'px';
                    }
                }
                var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
                var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
                if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
                    cWidth = e.style('width').toPixels('x');
                    cHeight = e.style('height').toPixels('y');
                }
                svg.ViewPort.SetCurrent(cWidth, cHeight);
                if (svg.opts['offsetX'] != null) {
                    e.attribute('x', true).value = svg.opts['offsetX'];
                }
                if (svg.opts['offsetY'] != null) {
                    e.attribute('y', true).value = svg.opts['offsetY'];
                }
                if (svg.opts['scaleWidth'] != null && svg.opts['scaleHeight'] != null) {
                    var xRatio = 1,
                        yRatio = 1,
                        viewBox = svg.ToNumberArray(e.attribute('viewBox').value);
                    if (e.attribute('width').hasValue()) {
                        xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
                    } else if (!isNaN(viewBox[2])) {
                        xRatio = viewBox[2] / svg.opts['scaleWidth'];
                    }
                    if (e.attribute('height').hasValue()) {
                        yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
                    } else if (!isNaN(viewBox[3])) {
                        yRatio = viewBox[3] / svg.opts['scaleHeight'];
                    }
                    e.attribute('width', true).value = svg.opts['scaleWidth'];
                    e.attribute('height', true).value = svg.opts['scaleHeight'];
                    e.attribute('viewBox', true).value = '0 0 ' + (cWidth * xRatio) + ' ' + (cHeight * yRatio);
                    e.attribute('preserveAspectRatio', true).value = 'none';
                }
                if (svg.opts['ignoreClear'] != true) {
                    ctx.clearRect(0, 0, cWidth, cHeight);
                }
                e.render(ctx);
                if (isFirstRender) {
                    isFirstRender = false;
                    if (typeof(svg.opts['renderCallback']) == 'function') {
                        svg.opts['renderCallback'](dom);
                    }
                }
            }
            var waitingForImages = true;
            if (svg.ImagesLoaded()) {
                waitingForImages = false;
                draw();
            }
            svg.intervalID = setInterval(function() {
                var needUpdate = false;
                if (waitingForImages && svg.ImagesLoaded()) {
                    waitingForImages = false;
                    needUpdate = true;
                }
                if (svg.opts['ignoreMouse'] != true) {
                    needUpdate = needUpdate | svg.Mouse.hasEvents();
                }
                if (svg.opts['ignoreAnimation'] != true) {
                    for (var i = 0; i < svg.Animations.length; i++) {
                        needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
                    }
                }
                if (typeof(svg.opts['forceRedraw']) == 'function') {
                    if (svg.opts['forceRedraw']() == true) {
                        needUpdate = true;
                    }
                }
                if (needUpdate) {
                    draw();
                    svg.Mouse.runEvents();
                }
            }, 1000 / svg.FRAMERATE);
        }
        svg.stop = function() {
            if (svg.intervalID) {
                clearInterval(svg.intervalID);
            }
        }
        svg.Mouse = new(function() {
            this.events = [];
            this.hasEvents = function() {
                return this.events.length != 0;
            }
            this.onclick = function(x, y) {
                this.events.push({
                    type: 'onclick',
                    x: x,
                    y: y,
                    run: function(e) {
                        if (e.onclick) {
                            e.onclick();
                        }
                    }
                });
            }
            this.onmousemove = function(x, y) {
                this.events.push({
                    type: 'onmousemove',
                    x: x,
                    y: y,
                    run: function(e) {
                        if (e.onmousemove) {
                            e.onmousemove();
                        }
                    }
                });
            }
            this.eventElements = [];
            this.checkPath = function(element, ctx) {
                for (var i = 0; i < this.events.length; i++) {
                    var e = this.events[i];
                    if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) {
                        this.eventElements[i] = element;
                    }
                }
            }
            this.checkBoundingBox = function(element, bb) {
                for (var i = 0; i < this.events.length; i++) {
                    var e = this.events[i];
                    if (bb.isPointInBox(e.x, e.y)) {
                        this.eventElements[i] = element;
                    }
                }
            }
            this.runEvents = function() {
                svg.ctx.canvas.style.cursor = '';
                for (var i = 0; i < this.events.length; i++) {
                    var e = this.events[i];
                    var element = this.eventElements[i];
                    while (element) {
                        e.run(element);
                        element = element.parent;
                    }
                }
                this.events = [];
                this.eventElements = [];
            }
        });
        return svg;
    }
})();
if (typeof(CanvasRenderingContext2D) != 'undefined') {
    CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
        canvg(this.canvas, s, {
            ignoreMouse: true,
            ignoreAnimation: true,
            ignoreDimensions: true,
            ignoreClear: true,
            offsetX: dx,
            offsetY: dy,
            scaleWidth: dw,
            scaleHeight: dh
        });
    }
};

function RGBColor(color_string) {
    this.ok = false;
    if (color_string.charAt(0) == '#') {
        color_string = color_string.substr(1, 6);
    }
    color_string = color_string.replace(/ /g, '');
    color_string = color_string.toLowerCase();
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred: 'cd5c5c',
        indigo: '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key];
        }
    }
    var color_defs = [{
        re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
        example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
        process: function(bits) {
            return [parseInt(bits[1]), parseInt(bits[2]), parseInt(bits[3])];
        }
    }, {
        re: /^(\w{2})(\w{2})(\w{2})$/,
        example: ['#00ff00', '336699'],
        process: function(bits) {
            return [parseInt(bits[1], 16), parseInt(bits[2], 16), parseInt(bits[3], 16)];
        }
    }, {
        re: /^(\w{1})(\w{1})(\w{1})$/,
        example: ['#fb0', 'f0f'],
        process: function(bits) {
            return [parseInt(bits[1] + bits[1], 16), parseInt(bits[2] + bits[2], 16), parseInt(bits[3] + bits[3], 16)];
        }
    }];
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }
    }
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);
    this.toRGB = function() {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toHex = function() {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }
    this.getHelpXML = function() {
        var examples = new Array();
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }
        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText = 'margin: 3px; ' +
                    'border: 1px solid black; ' +
                    'background:' + list_color.toHex() + '; ' +
                    'color:' + list_color.toHex();
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex());
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);
            } catch (e) {}
        }
        return xml;
    }
};
var DecodeStream = (function() {
    function constructor() {
        this.pos = 0;
        this.bufferLength = 0;
        this.eof = false;
        this.buffer = null;
    }
    constructor.prototype = {
        ensureBuffer: function decodestream_ensureBuffer(requested) {
            var buffer = this.buffer;
            var current = buffer ? buffer.byteLength : 0;
            if (requested < current)
                return buffer;
            var size = 512;
            while (size < requested)
                size <<= 1;
            var buffer2 = new Uint8Array(size);
            for (var i = 0; i < current; ++i)
                buffer2[i] = buffer[i];
            return this.buffer = buffer2;
        },
        getByte: function decodestream_getByte() {
            var pos = this.pos;
            while (this.bufferLength <= pos) {
                if (this.eof)
                    return null;
                this.readBlock();
            }
            return this.buffer[this.pos++];
        },
        getBytes: function decodestream_getBytes(length) {
            var pos = this.pos;
            if (length) {
                this.ensureBuffer(pos + length);
                var end = pos + length;
                while (!this.eof && this.bufferLength < end)
                    this.readBlock();
                var bufEnd = this.bufferLength;
                if (end > bufEnd)
                    end = bufEnd;
            } else {
                while (!this.eof)
                    this.readBlock();
                var end = this.bufferLength;
            }
            this.pos = end;
            return this.buffer.subarray(pos, end);
        },
        lookChar: function decodestream_lookChar() {
            var pos = this.pos;
            while (this.bufferLength <= pos) {
                if (this.eof)
                    return null;
                this.readBlock();
            }
            return String.fromCharCode(this.buffer[this.pos]);
        },
        getChar: function decodestream_getChar() {
            var pos = this.pos;
            while (this.bufferLength <= pos) {
                if (this.eof)
                    return null;
                this.readBlock();
            }
            return String.fromCharCode(this.buffer[this.pos++]);
        },
        makeSubStream: function decodestream_makeSubstream(start, length, dict) {
            var end = start + length;
            while (this.bufferLength <= end && !this.eof)
                this.readBlock();
            return new Stream(this.buffer, start, length, dict);
        },
        skip: function decodestream_skip(n) {
            if (!n)
                n = 1;
            this.pos += n;
        },
        reset: function decodestream_reset() {
            this.pos = 0;
        }
    };
    return constructor;
})();
var FlateStream = (function() {
    if (typeof Uint32Array === 'undefined') {
        return undefined;
    }
    var codeLenCodeMap = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var lengthDecode = new Uint32Array([0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a, 0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f, 0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073, 0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102]);
    var distDecode = new Uint32Array([0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d, 0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1, 0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01, 0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001]);
    var fixedLitCodeTab = [new Uint32Array([0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0, 0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0, 0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0, 0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8, 0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8, 0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8, 0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4, 0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4, 0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4, 0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc, 0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec, 0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc, 0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2, 0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2, 0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2, 0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca, 0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea, 0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da, 0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6, 0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6, 0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6, 0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce, 0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee, 0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de, 0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe, 0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1, 0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1, 0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1, 0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1, 0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9, 0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9, 0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9, 0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9, 0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5, 0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5, 0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5, 0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5, 0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd, 0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed, 0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd, 0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd, 0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3, 0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3, 0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3, 0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3, 0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb, 0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb, 0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db, 0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb, 0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7, 0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7, 0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7, 0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7, 0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf, 0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef, 0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df, 0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff]), 9];
    var fixedDistCodeTab = [new Uint32Array([0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c, 0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000, 0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d, 0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000]), 5];

    function error(e) {
        throw new Error(e)
    }

    function constructor(bytes) {
        var bytesPos = 0;
        var cmf = bytes[bytesPos++];
        var flg = bytes[bytesPos++];
        if (cmf == -1 || flg == -1)
            error('Invalid header in flate stream');
        if ((cmf & 0x0f) != 0x08)
            error('Unknown compression method in flate stream');
        if ((((cmf << 8) + flg) % 31) != 0)
            error('Bad FCHECK in flate stream');
        if (flg & 0x20)
            error('FDICT bit set in flate stream');
        this.bytes = bytes;
        this.bytesPos = bytesPos;
        this.codeSize = 0;
        this.codeBuf = 0;
        DecodeStream.call(this);
    }
    constructor.prototype = Object.create(DecodeStream.prototype);
    constructor.prototype.getBits = function(bits) {
        var codeSize = this.codeSize;
        var codeBuf = this.codeBuf;
        var bytes = this.bytes;
        var bytesPos = this.bytesPos;
        var b;
        while (codeSize < bits) {
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad encoding in flate stream');
            codeBuf |= b << codeSize;
            codeSize += 8;
        }
        b = codeBuf & ((1 << bits) - 1);
        this.codeBuf = codeBuf >> bits;
        this.codeSize = codeSize -= bits;
        this.bytesPos = bytesPos;
        return b;
    };
    constructor.prototype.getCode = function(table) {
        var codes = table[0];
        var maxLen = table[1];
        var codeSize = this.codeSize;
        var codeBuf = this.codeBuf;
        var bytes = this.bytes;
        var bytesPos = this.bytesPos;
        while (codeSize < maxLen) {
            var b;
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad encoding in flate stream');
            codeBuf |= (b << codeSize);
            codeSize += 8;
        }
        var code = codes[codeBuf & ((1 << maxLen) - 1)];
        var codeLen = code >> 16;
        var codeVal = code & 0xffff;
        if (codeSize == 0 || codeSize < codeLen || codeLen == 0)
            error('Bad encoding in flate stream');
        this.codeBuf = (codeBuf >> codeLen);
        this.codeSize = (codeSize - codeLen);
        this.bytesPos = bytesPos;
        return codeVal;
    };
    constructor.prototype.generateHuffmanTable = function(lengths) {
        var n = lengths.length;
        var maxLen = 0;
        for (var i = 0; i < n; ++i) {
            if (lengths[i] > maxLen)
                maxLen = lengths[i];
        }
        var size = 1 << maxLen;
        var codes = new Uint32Array(size);
        for (var len = 1, code = 0, skip = 2; len <= maxLen; ++len, code <<= 1, skip <<= 1) {
            for (var val = 0; val < n; ++val) {
                if (lengths[val] == len) {
                    var code2 = 0;
                    var t = code;
                    for (var i = 0; i < len; ++i) {
                        code2 = (code2 << 1) | (t & 1);
                        t >>= 1;
                    }
                    for (var i = code2; i < size; i += skip)
                        codes[i] = (len << 16) | val;
                    ++code;
                }
            }
        }
        return [codes, maxLen];
    };
    constructor.prototype.readBlock = function() {
        function repeat(stream, array, len, offset, what) {
            var repeat = stream.getBits(len) + offset;
            while (repeat-- > 0)
                array[i++] = what;
        }
        var hdr = this.getBits(3);
        if (hdr & 1)
            this.eof = true;
        hdr >>= 1;
        if (hdr == 0) {
            var bytes = this.bytes;
            var bytesPos = this.bytesPos;
            var b;
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad block header in flate stream');
            var blockLen = b;
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad block header in flate stream');
            blockLen |= (b << 8);
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad block header in flate stream');
            var check = b;
            if (typeof(b = bytes[bytesPos++]) == 'undefined')
                error('Bad block header in flate stream');
            check |= (b << 8);
            if (check != (~blockLen & 0xffff))
                error('Bad uncompressed block length in flate stream');
            this.codeBuf = 0;
            this.codeSize = 0;
            var bufferLength = this.bufferLength;
            var buffer = this.ensureBuffer(bufferLength + blockLen);
            var end = bufferLength + blockLen;
            this.bufferLength = end;
            for (var n = bufferLength; n < end; ++n) {
                if (typeof(b = bytes[bytesPos++]) == 'undefined') {
                    this.eof = true;
                    break;
                }
                buffer[n] = b;
            }
            this.bytesPos = bytesPos;
            return;
        }
        var litCodeTable;
        var distCodeTable;
        if (hdr == 1) {
            litCodeTable = fixedLitCodeTab;
            distCodeTable = fixedDistCodeTab;
        } else if (hdr == 2) {
            var numLitCodes = this.getBits(5) + 257;
            var numDistCodes = this.getBits(5) + 1;
            var numCodeLenCodes = this.getBits(4) + 4;
            var codeLenCodeLengths = Array(codeLenCodeMap.length);
            var i = 0;
            while (i < numCodeLenCodes)
                codeLenCodeLengths[codeLenCodeMap[i++]] = this.getBits(3);
            var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);
            var len = 0;
            var i = 0;
            var codes = numLitCodes + numDistCodes;
            var codeLengths = new Array(codes);
            while (i < codes) {
                var code = this.getCode(codeLenCodeTab);
                if (code == 16) {
                    repeat(this, codeLengths, 2, 3, len);
                } else if (code == 17) {
                    repeat(this, codeLengths, 3, 3, len = 0);
                } else if (code == 18) {
                    repeat(this, codeLengths, 7, 11, len = 0);
                } else {
                    codeLengths[i++] = len = code;
                }
            }
            litCodeTable = this.generateHuffmanTable(codeLengths.slice(0, numLitCodes));
            distCodeTable = this.generateHuffmanTable(codeLengths.slice(numLitCodes, codes));
        } else {
            error('Unknown block type in flate stream');
        }
        var buffer = this.buffer;
        var limit = buffer ? buffer.length : 0;
        var pos = this.bufferLength;
        while (true) {
            var code1 = this.getCode(litCodeTable);
            if (code1 < 256) {
                if (pos + 1 >= limit) {
                    buffer = this.ensureBuffer(pos + 1);
                    limit = buffer.length;
                }
                buffer[pos++] = code1;
                continue;
            }
            if (code1 == 256) {
                this.bufferLength = pos;
                return;
            }
            code1 -= 257;
            code1 = lengthDecode[code1];
            var code2 = code1 >> 16;
            if (code2 > 0)
                code2 = this.getBits(code2);
            var len = (code1 & 0xffff) + code2;
            code1 = this.getCode(distCodeTable);
            code1 = distDecode[code1];
            code2 = code1 >> 16;
            if (code2 > 0)
                code2 = this.getBits(code2);
            var dist = (code1 & 0xffff) + code2;
            if (pos + len >= limit) {
                buffer = this.ensureBuffer(pos + len);
                limit = buffer.length;
            }
            for (var k = 0; k < len; ++k, ++pos)
                buffer[pos] = buffer[pos - dist];
        }
    };
    return constructor;
})();;
(function(global) {
    var PNG;
    PNG = (function() {
        var APNG_BLEND_OP_OVER, APNG_BLEND_OP_SOURCE, APNG_DISPOSE_OP_BACKGROUND, APNG_DISPOSE_OP_NONE, APNG_DISPOSE_OP_PREVIOUS, makeImage, scratchCanvas, scratchCtx;
        PNG.load = function(url, canvas, callback) {
            var xhr, _this = this;
            if (typeof canvas === 'function') {
                callback = canvas;
            }
            xhr = new XMLHttpRequest;
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.onload = function() {
                var data, png;
                data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
                png = new PNG(data);
                if (typeof(canvas != null ? canvas.getContext : void 0) === 'function') {
                    png.render(canvas);
                }
                return typeof callback === "function" ? callback(png) : void 0;
            };
            return xhr.send(null);
        };
        APNG_DISPOSE_OP_NONE = 0;
        APNG_DISPOSE_OP_BACKGROUND = 1;
        APNG_DISPOSE_OP_PREVIOUS = 2;
        APNG_BLEND_OP_SOURCE = 0;
        APNG_BLEND_OP_OVER = 1;

        function PNG(data) {
            var chunkSize, colors, palLen, delayDen, delayNum, frame, i, index, key, section, palShort, text, _i, _j, _ref;
            this.data = data;
            this.pos = 8;
            this.palette = [];
            this.imgData = [];
            this.transparency = {};
            this.animation = null;
            this.text = {};
            frame = null;
            while (true) {
                chunkSize = this.readUInt32();
                section = ((function() {
                    var _i, _results;
                    _results = [];
                    for (i = _i = 0; _i < 4; i = ++_i) {
                        _results.push(String.fromCharCode(this.data[this.pos++]));
                    }
                    return _results;
                }).call(this)).join('');
                switch (section) {
                    case 'IHDR':
                        this.width = this.readUInt32();
                        this.height = this.readUInt32();
                        this.bits = this.data[this.pos++];
                        this.colorType = this.data[this.pos++];
                        this.compressionMethod = this.data[this.pos++];
                        this.filterMethod = this.data[this.pos++];
                        this.interlaceMethod = this.data[this.pos++];
                        break;
                    case 'acTL':
                        this.animation = {
                            numFrames: this.readUInt32(),
                            numPlays: this.readUInt32() || Infinity,
                            frames: []
                        };
                        break;
                    case 'PLTE':
                        this.palette = this.read(chunkSize);
                        break;
                    case 'fcTL':
                        if (frame) {
                            this.animation.frames.push(frame);
                        }
                        this.pos += 4;
                        frame = {
                            width: this.readUInt32(),
                            height: this.readUInt32(),
                            xOffset: this.readUInt32(),
                            yOffset: this.readUInt32()
                        };
                        delayNum = this.readUInt16();
                        delayDen = this.readUInt16() || 100;
                        frame.delay = 1000 * delayNum / delayDen;
                        frame.disposeOp = this.data[this.pos++];
                        frame.blendOp = this.data[this.pos++];
                        frame.data = [];
                        break;
                    case 'IDAT':
                    case 'fdAT':
                        if (section === 'fdAT') {
                            this.pos += 4;
                            chunkSize -= 4;
                        }
                        data = (frame != null ? frame.data : void 0) || this.imgData;
                        for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) {
                            data.push(this.data[this.pos++]);
                        }
                        break;
                    case 'tRNS':
                        this.transparency = {};
                        switch (this.colorType) {
                            case 3:
                                palLen = this.palette.length / 3;
                                this.transparency.indexed = this.read(chunkSize);
                                if (this.transparency.indexed.length > palLen)
                                    throw new Error('More transparent colors than palette size');
                                palShort = palLen - this.transparency.indexed.length;
                                if (palShort > 0) {
                                    for (i = _j = 0; 0 <= palShort ? _j < palShort : _j > palShort; i = 0 <= palShort ? ++_j : --_j) {
                                        this.transparency.indexed.push(255);
                                    }
                                }
                                break;
                            case 0:
                                this.transparency.grayscale = this.read(chunkSize)[0];
                                break;
                            case 2:
                                this.transparency.rgb = this.read(chunkSize);
                        }
                        break;
                    case 'tEXt':
                        text = this.read(chunkSize);
                        index = text.indexOf(0);
                        key = String.fromCharCode.apply(String, text.slice(0, index));
                        this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                        break;
                    case 'IEND':
                        if (frame) {
                            this.animation.frames.push(frame);
                        }
                        this.colors = (function() {
                            switch (this.colorType) {
                                case 0:
                                case 3:
                                case 4:
                                    return 1;
                                case 2:
                                case 6:
                                    return 3;
                            }
                        }).call(this);
                        this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;
                        colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                        this.pixelBitlength = this.bits * colors;
                        this.colorSpace = (function() {
                            switch (this.colors) {
                                case 1:
                                    return 'DeviceGray';
                                case 3:
                                    return 'DeviceRGB';
                            }
                        }).call(this);
                        this.imgData = new Uint8Array(this.imgData);
                        return;
                    default:
                        this.pos += chunkSize;
                }
                this.pos += 4;
                if (this.pos > this.data.length) {
                    throw new Error("Incomplete or corrupt PNG file");
                }
            }
            return;
        }
        PNG.prototype.read = function(bytes) {
            var i, _i, _results;
            _results = [];
            for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {
                _results.push(this.data[this.pos++]);
            }
            return _results;
        };
        PNG.prototype.readUInt32 = function() {
            var b1, b2, b3, b4;
            b1 = this.data[this.pos++] << 24;
            b2 = this.data[this.pos++] << 16;
            b3 = this.data[this.pos++] << 8;
            b4 = this.data[this.pos++];
            return b1 | b2 | b3 | b4;
        };
        PNG.prototype.readUInt16 = function() {
            var b1, b2;
            b1 = this.data[this.pos++] << 8;
            b2 = this.data[this.pos++];
            return b1 | b2;
        };
        PNG.prototype.decodePixels = function(data) {
            var abyte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
            if (data == null) {
                data = this.imgData;
            }
            if (data.length === 0) {
                return new Uint8Array(0);
            }
            data = new FlateStream(data);
            data = data.getBytes();
            pixelBytes = this.pixelBitlength / 8;
            scanlineLength = pixelBytes * this.width;
            pixels = new Uint8Array(scanlineLength * this.height);
            length = data.length;
            row = 0;
            pos = 0;
            c = 0;
            while (pos < length) {
                switch (data[pos++]) {
                    case 0:
                        for (i = _i = 0; _i < scanlineLength; i = _i += 1) {
                            pixels[c++] = data[pos++];
                        }
                        break;
                    case 1:
                        for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
                            abyte = data[pos++];
                            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                            pixels[c++] = (abyte + left) % 256;
                        }
                        break;
                    case 2:
                        for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
                            abyte = data[pos++];
                            col = (i - (i % pixelBytes)) / pixelBytes;
                            upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
                            pixels[c++] = (upper + abyte) % 256;
                        }
                        break;
                    case 3:
                        for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
                            abyte = data[pos++];
                            col = (i - (i % pixelBytes)) / pixelBytes;
                            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                            upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
                            pixels[c++] = (abyte + Math.floor((left + upper) / 2)) % 256;
                        }
                        break;
                    case 4:
                        for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
                            abyte = data[pos++];
                            col = (i - (i % pixelBytes)) / pixelBytes;
                            left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                            if (row === 0) {
                                upper = upperLeft = 0;
                            } else {
                                upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
                                upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + (i % pixelBytes)];
                            }
                            p = left + upper - upperLeft;
                            pa = Math.abs(p - left);
                            pb = Math.abs(p - upper);
                            pc = Math.abs(p - upperLeft);
                            if (pa <= pb && pa <= pc) {
                                paeth = left;
                            } else if (pb <= pc) {
                                paeth = upper;
                            } else {
                                paeth = upperLeft;
                            }
                            pixels[c++] = (abyte + paeth) % 256;
                        }
                        break;
                    default:
                        throw new Error("Invalid filter algorithm: " + data[pos - 1]);
                }
                row++;
            }
            return pixels;
        };
        PNG.prototype.decodePalette = function() {
            var c, i, length, palette, pos, ret, transparency, _i, _ref, _ref1;
            palette = this.palette;
            transparency = this.transparency.indexed || [];
            ret = new Uint8Array((transparency.length || 0) + palette.length);
            pos = 0;
            length = palette.length;
            c = 0;
            for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
                ret[pos++] = palette[i];
                ret[pos++] = palette[i + 1];
                ret[pos++] = palette[i + 2];
                ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255;
            }
            return ret;
        };
        PNG.prototype.copyToImageData = function(imageData, pixels) {
            var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
            colors = this.colors;
            palette = null;
            alpha = this.hasAlphaChannel;
            if (this.palette.length) {
                palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();
                colors = 4;
                alpha = true;
            }
            data = imageData.data || imageData;
            length = data.length;
            input = palette || pixels;
            i = j = 0;
            if (colors === 1) {
                while (i < length) {
                    k = palette ? pixels[i / 4] * 4 : j;
                    v = input[k++];
                    data[i++] = v;
                    data[i++] = v;
                    data[i++] = v;
                    data[i++] = alpha ? input[k++] : 255;
                    j = k;
                }
            } else {
                while (i < length) {
                    k = palette ? pixels[i / 4] * 4 : j;
                    data[i++] = input[k++];
                    data[i++] = input[k++];
                    data[i++] = input[k++];
                    data[i++] = alpha ? input[k++] : 255;
                    j = k;
                }
            }
        };
        PNG.prototype.decode = function() {
            var ret;
            ret = new Uint8Array(this.width * this.height * 4);
            this.copyToImageData(ret, this.decodePixels());
            return ret;
        };
        try {
            scratchCanvas = global.document.createElement('canvas');
            scratchCtx = scratchCanvas.getContext('2d');
        } catch (e) {
            return -1;
        }
        makeImage = function(imageData) {
            var img;
            scratchCtx.width = imageData.width;
            scratchCtx.height = imageData.height;
            scratchCtx.clearRect(0, 0, imageData.width, imageData.height);
            scratchCtx.putImageData(imageData, 0, 0);
            img = new Image;
            img.src = scratchCanvas.toDataURL();
            return img;
        };
        PNG.prototype.decodeFrames = function(ctx) {
            var frame, i, imageData, pixels, _i, _len, _ref, _results;
            if (!this.animation) {
                return;
            }
            _ref = this.animation.frames;
            _results = [];
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                frame = _ref[i];
                imageData = ctx.createImageData(frame.width, frame.height);
                pixels = this.decodePixels(new Uint8Array(frame.data));
                this.copyToImageData(imageData, pixels);
                frame.imageData = imageData;
                _results.push(frame.image = makeImage(imageData));
            }
            return _results;
        };
        PNG.prototype.renderFrame = function(ctx, number) {
            var frame, frames, prev;
            frames = this.animation.frames;
            frame = frames[number];
            prev = frames[number - 1];
            if (number === 0) {
                ctx.clearRect(0, 0, this.width, this.height);
            }
            if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_BACKGROUND) {
                ctx.clearRect(prev.xOffset, prev.yOffset, prev.width, prev.height);
            } else if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_PREVIOUS) {
                ctx.putImageData(prev.imageData, prev.xOffset, prev.yOffset);
            }
            if (frame.blendOp === APNG_BLEND_OP_SOURCE) {
                ctx.clearRect(frame.xOffset, frame.yOffset, frame.width, frame.height);
            }
            return ctx.drawImage(frame.image, frame.xOffset, frame.yOffset);
        };
        PNG.prototype.animate = function(ctx) {
            var doFrame, frameNumber, frames, numFrames, numPlays, _ref, _this = this;
            frameNumber = 0;
            _ref = this.animation, numFrames = _ref.numFrames, frames = _ref.frames, numPlays = _ref.numPlays;
            return (doFrame = function() {
                var f, frame;
                f = frameNumber++ % numFrames;
                frame = frames[f];
                _this.renderFrame(ctx, f);
                if (numFrames > 1 && frameNumber / numFrames < numPlays) {
                    return _this.animation._timeout = setTimeout(doFrame, frame.delay);
                }
            })();
        };
        PNG.prototype.stopAnimation = function() {
            var _ref;
            return clearTimeout((_ref = this.animation) != null ? _ref._timeout : void 0);
        };
        PNG.prototype.render = function(canvas) {
            var ctx, data;
            if (canvas._png) {
                canvas._png.stopAnimation();
            }
            canvas._png = this;
            canvas.width = this.width;
            canvas.height = this.height;
            ctx = canvas.getContext("2d");
            if (this.animation) {
                this.decodeFrames(ctx);
                return this.animate(ctx);
            } else {
                data = ctx.createImageData(this.width, this.height);
                this.copyToImageData(data, this.decodePixels());
                return ctx.putImageData(data, 0, 0);
            }
        };
        return PNG;
    })();
    global.PNG = PNG;
})(typeof window !== "undefined" && window || this);;
! function(t, e) {
    e["true"] = t;
    var n = function(t) {
        "use strict";

        function e(e) {
            var n = {};
            this.subscribe = function(t, e, r) {
                if ("function" != typeof e) return !1;
                n.hasOwnProperty(t) || (n[t] = {});
                var i = Math.random().toString(35);
                return n[t][i] = [e, !!r], i
            }, this.unsubscribe = function(t) {
                for (var e in n)
                    if (n[e][t]) return delete n[e][t], !0;
                return !1
            }, this.publish = function(r) {
                if (n.hasOwnProperty(r)) {
                    var i = Array.prototype.slice.call(arguments, 1),
                        s = [];
                    for (var o in n[r]) {
                        var a = n[r][o];
                        try {
                            a[0].apply(e, i)
                        } catch (u) {
                            t.console && console.error("jsPDF PubSub Error", u.message, u)
                        }
                        a[1] && s.push(o)
                    }
                    s.length && s.forEach(this.unsubscribe)
                }
            }
        }

        function n(a, u, l, c) {
            var f = {};
            "object" == typeof a && (f = a, a = f.orientation, u = f.unit || u, l = f.format || l, c = f.compress || f.compressPdf || c), u = u || "mm", l = l || "a4", a = ("" + (a || "P")).toLowerCase();
            var h, d, p, m, w, g, y, v, b, x = (("" + l).toLowerCase(), !!c && "function" == typeof Uint8Array),
                k = f.textColor || "0 g",
                q = f.drawColor || "0 G",
                _ = f.fontSize || 16,
                A = f.lineHeight || 1.15,
                S = f.lineWidth || .200025,
                C = 2,
                I = !1,
                z = [],
                E = {},
                T = {},
                P = 0,
                B = [],
                F = {},
                R = [],
                O = 0,
                D = 0,
                j = 0,
                N = {
                    title: "",
                    subject: "",
                    author: "",
                    keywords: "",
                    creator: ""
                },
                L = {},
                U = new e(L),
                M = function(t) {
                    return t.toFixed(2)
                },
                H = function(t) {
                    return t.toFixed(3)
                },
                W = function(t) {
                    return ("0" + parseInt(t)).slice(-2)
                },
                G = function(t) {
                    I ? B[m].push(t) : (j += t.length + 1, R.push(t))
                },
                J = function() {
                    return C++, z[C] = j, G(C + " 0 obj"), C
                },
                V = function() {
                    return C++, z[C] = function() {
                        return j
                    }, C
                },
                X = function(t) {
                    z[t] = j
                },
                Y = function(t) {
                    G("stream"), G(t), G("endstream")
                },
                Z = function() {
                    var e, i, s, o, a, u, l, c, f;
                    for (l = t.adler32cs || n.adler32cs, x && "undefined" == typeof l && (x = !1), e = 1; P >= e; e++) {
                        if (J(), c = (w = F[e].width) * d, f = (g = F[e].height) * d, G("<</Type /Page"), G("/Parent 1 0 R"), G("/Resources 2 0 R"), G("/MediaBox [0 0 " + M(c) + " " + M(f) + "]"), G("/Contents " + (C + 1) + " 0 R"), U.publish("putPage", {
                                pageNumber: e,
                                page: B[e]
                            }), G(">>"), G("endobj"), i = B[e].join("\n"), J(), x) {
                            for (s = [], o = i.length; o--;) s[o] = i.charCodeAt(o);
                            u = l.from(i), a = new r(6), a.append(new Uint8Array(s)), i = a.flush(), s = new Uint8Array(i.length + 6), s.set(new Uint8Array([120, 156])), s.set(i, 2), s.set(new Uint8Array([255 & u, u >> 8 & 255, u >> 16 & 255, u >> 24 & 255]), i.length + 2), i = String.fromCharCode.apply(null, s), G("<</Length " + i.length + " /Filter [/FlateDecode]>>")
                        } else G("<</Length " + i.length + ">>");
                        Y(i), G("endobj")
                    }
                    z[1] = j, G("1 0 obj"), G("<</Type /Pages");
                    var h = "/Kids [";
                    for (o = 0; P > o; o++) h += 3 + 2 * o + " 0 R ";
                    G(h + "]"), G("/Count " + P), G(">>"), G("endobj")
                },
                K = function(t) {
                    t.objectNumber = J(), G("<</BaseFont/" + t.PostScriptName + "/Type/Font"), "string" == typeof t.encoding && G("/Encoding/" + t.encoding), G("/Subtype/Type1>>"), G("endobj")
                },
                Q = function() {
                    for (var t in E) E.hasOwnProperty(t) && K(E[t])
                },
                $ = function() {
                    U.publish("putXobjectDict")
                },
                te = function() {
                    G("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), G("/Font <<");
                    for (var t in E) E.hasOwnProperty(t) && G("/" + t + " " + E[t].objectNumber + " 0 R");
                    G(">>"), G("/XObject <<"), $(), G(">>")
                },
                ee = function() {
                    Q(), U.publish("putResources"), z[2] = j, G("2 0 obj"), G("<<"), te(), G(">>"), G("endobj"), U.publish("postPutResources")
                },
                ne = function(t, e, n) {
                    T.hasOwnProperty(e) || (T[e] = {}), T[e][n] = t
                },
                re = function(t, e, n, r) {
                    var i = "F" + (Object.keys(E).length + 1).toString(10),
                        s = E[i] = {
                            id: i,
                            PostScriptName: t,
                            fontName: e,
                            fontStyle: n,
                            encoding: r,
                            metadata: {}
                        };
                    return ne(i, e, n), U.publish("addFont", s), i
                },
                ie = function() {
                    for (var t = "helvetica", e = "times", n = "courier", r = "normal", i = "bold", s = "italic", o = "bolditalic", a = "StandardEncoding", u = [
                            ["Helvetica", t, r],
                            ["Helvetica-Bold", t, i],
                            ["Helvetica-Oblique", t, s],
                            ["Helvetica-BoldOblique", t, o],
                            ["Courier", n, r],
                            ["Courier-Bold", n, i],
                            ["Courier-Oblique", n, s],
                            ["Courier-BoldOblique", n, o],
                            ["Times-Roman", e, r],
                            ["Times-Bold", e, i],
                            ["Times-Italic", e, s],
                            ["Times-BoldItalic", e, o]
                        ], l = 0, c = u.length; c > l; l++) {
                        var f = re(u[l][0], u[l][1], u[l][2], a),
                            h = u[l][0].split("-");
                        ne(f, h[0], h[1] || "")
                    }
                    U.publish("addFonts", {
                        fonts: E,
                        dictionary: T
                    })
                },
                se = function(e) {
                    return e.foo = function() {
                        try {
                            return e.apply(this, arguments)
                        } catch (n) {
                            var r = n.stack || "";
                            ~r.indexOf(" at ") && (r = r.split(" at ")[1]);
                            var i = "Error in function " + r.split("\n")[0].split("<")[0] + ": " + n.message;
                            if (!t.console) throw new Error(i);
                            t.console.error(i, n), t.alert && alert(i)
                        }
                    }, e.foo.bar = e, e.foo
                },
                oe = function(t, e) {
                    var n, r, i, s, o, a, u, l, c;
                    if (e = e || {}, i = e.sourceEncoding || "Unicode", o = e.outputEncoding, (e.autoencode || o) && E[h].metadata && E[h].metadata[i] && E[h].metadata[i].encoding && (s = E[h].metadata[i].encoding, !o && E[h].encoding && (o = E[h].encoding), !o && s.codePages && (o = s.codePages[0]), "string" == typeof o && (o = s[o]), o)) {
                        for (u = !1, a = [], n = 0, r = t.length; r > n; n++) l = o[t.charCodeAt(n)], a.push(l ? String.fromCharCode(l) : t[n]), a[n].charCodeAt(0) >> 8 && (u = !0);
                        t = a.join("")
                    }
                    for (n = t.length; void 0 === u && 0 !== n;) t.charCodeAt(n - 1) >> 8 && (u = !0), n--;
                    if (!u) return t;
                    for (a = e.noBOM ? [] : [254, 255], n = 0, r = t.length; r > n; n++) {
                        if (l = t.charCodeAt(n), c = l >> 8, c >> 8) throw new Error("Character at position " + n + " of string '" + t + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
                        a.push(c), a.push(l - (c << 8))
                    }
                    return String.fromCharCode.apply(void 0, a)
                },
                ae = function(t, e) {
                    return oe(t, e).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)")
                },
                ue = function() {
                    G("/Producer (jsPDF " + n.version + ")");
                    for (var t in N) N.hasOwnProperty(t) && N[t] && G("/" + t.substr(0, 1).toUpperCase() + t.substr(1) + " (" + ae(N[t]) + ")");
                    var e = new Date,
                        r = e.getTimezoneOffset(),
                        i = 0 > r ? "+" : "-",
                        s = Math.floor(Math.abs(r / 60)),
                        o = Math.abs(r % 60),
                        a = [i, W(s), "'", W(o), "'"].join("");
                    G(["/CreationDate (D:", e.getFullYear(), W(e.getMonth() + 1), W(e.getDate()), W(e.getHours()), W(e.getMinutes()), W(e.getSeconds()), a, ")"].join(""))
                },
                le = function() {
                    switch (G("/Type /Catalog"), G("/Pages 1 0 R"), v || (v = "fullwidth"), v) {
                        case "fullwidth":
                            G("/OpenAction [3 0 R /FitH null]");
                            break;
                        case "fullheight":
                            G("/OpenAction [3 0 R /FitV null]");
                            break;
                        case "fullpage":
                            G("/OpenAction [3 0 R /Fit]");
                            break;
                        case "original":
                            G("/OpenAction [3 0 R /XYZ null null 1]");
                            break;
                        default:
                            var t = "" + v;
                            "%" === t.substr(t.length - 1) && (v = parseInt(v) / 100), "number" == typeof v && G("/OpenAction [3 0 R /XYZ null null " + M(v) + "]")
                    }
                    switch (b || (b = "continuous"), b) {
                        case "continuous":
                            G("/PageLayout /OneColumn");
                            break;
                        case "single":
                            G("/PageLayout /SinglePage");
                            break;
                        case "two":
                        case "twoleft":
                            G("/PageLayout /TwoColumnLeft");
                            break;
                        case "tworight":
                            G("/PageLayout /TwoColumnRight")
                    }
                    y && G("/PageMode /" + y), U.publish("putCatalog")
                },
                ce = function() {
                    G("/Size " + (C + 1)), G("/Root " + C + " 0 R"), G("/Info " + (C - 1) + " 0 R")
                },
                fe = function(t, e) {
                    var n = "string" == typeof e && e.toLowerCase();
                    if ("string" == typeof t) {
                        var r = t.toLowerCase();
                        o.hasOwnProperty(r) && (t = o[r][0] / d, e = o[r][1] / d)
                    }
                    if (Array.isArray(t) && (e = t[1], t = t[0]), n) {
                        switch (n.substr(0, 1)) {
                            case "l":
                                e > t && (n = "s");
                                break;
                            case "p":
                                t > e && (n = "s")
                        }
                        "s" === n && (p = t, t = e, e = p)
                    }
                    I = !0, B[++P] = [], F[P] = {
                        width: Number(t) || w,
                        height: Number(e) || g
                    }, de(P)
                },
                he = function() {
                    fe.apply(this, arguments), G(M(S * d) + " w"), G(q), 0 !== O && G(O + " J"), 0 !== D && G(D + " j"), U.publish("addPage", {
                        pageNumber: P
                    })
                },
                de = function(t) {
                    t > 0 && P >= t && (m = t, w = F[t].width, g = F[t].height)
                },
                pe = function(t, e) {
                    var n;
                    t = void 0 !== t ? t : E[h].fontName, e = void 0 !== e ? e : E[h].fontStyle;
                    try {
                        n = T[t][e]
                    } catch (r) {}
                    if (!n) throw new Error("Unable to look up font label for font '" + t + "', '" + e + "'. Refer to getFontList() for available fonts.");
                    return n
                },
                me = function() {
                    I = !1, C = 2, R = [], z = [], G("%PDF-" + s), Z(), ee(), J(), G("<<"), ue(), G(">>"), G("endobj"), J(), G("<<"), le(), G(">>"), G("endobj");
                    var t, e = j,
                        n = "0000000000";
                    for (G("xref"), G("0 " + (C + 1)), G(n + " 65535 f "), t = 1; C >= t; t++) {
                        var r = z[t];
                        G("function" == typeof r ? (n + z[t]()).slice(-10) + " 00000 n " : (n + z[t]).slice(-10) + " 00000 n ")
                    }
                    return G("trailer"), G("<<"), ce(), G(">>"), G("startxref"), G(e), G("%%EOF"), I = !0, R.join("\n")
                },
                we = function(t) {
                    var e = "S";
                    return "F" === t ? e = "f" : "FD" === t || "DF" === t ? e = "B" : ("f" === t || "f*" === t || "B" === t || "B*" === t) && (e = t), e
                },
                ge = function() {
                    for (var t = me(), e = t.length, n = new ArrayBuffer(e), r = new Uint8Array(n); e--;) r[e] = t.charCodeAt(e);
                    return n
                },
                ye = function() {
                    return new Blob([ge()], {
                        type: "application/pdf"
                    })
                },
                ve = se(function(e, n) {
                    var r = "dataur" === ("" + e).substr(0, 6) ? "data:application/pdf;base64," + btoa(me()) : 0;
                    switch (e) {
                        case void 0:
                            return me();
                        case "save":
                            if (navigator.getUserMedia && (void 0 === t.URL || void 0 === t.URL.createObjectURL)) return L.output("dataurlnewwindow");
                            i(ye(), n), "function" == typeof i.unload && t.setTimeout && setTimeout(i.unload, 911);
                            break;
                        case "arraybuffer":
                            return ge();
                        case "blob":
                            return ye();
                        case "bloburi":
                        case "bloburl":
                            return t.URL && t.URL.createObjectURL(ye()) || void 0;
                        case "datauristring":
                        case "dataurlstring":
                            return r;
                        case "dataurlnewwindow":
                            var s = t.open(r);
                            if (s || "undefined" == typeof safari) return s;
                        case "datauri":
                        case "dataurl":
                            return t.document.location.href = r;
                        default:
                            throw new Error('Output type "' + e + '" is not supported.')
                    }
                });
            switch (u) {
                case "pt":
                    d = 1;
                    break;
                case "mm":
                    d = 72 / 25.4000508;
                    break;
                case "cm":
                    d = 72 / 2.54000508;
                    break;
                case "in":
                    d = 72;
                    break;
                case "px":
                    d = 96 / 72;
                    break;
                case "pc":
                    d = 12;
                    break;
                case "em":
                    d = 12;
                    break;
                case "ex":
                    d = 6;
                    break;
                default:
                    throw "Invalid unit: " + u
            }
            L.internal = {
                pdfEscape: ae,
                getStyle: we,
                getFont: function() {
                    return E[pe.apply(L, arguments)]
                },
                getFontSize: function() {
                    return _
                },
                getLineHeight: function() {
                    return _ * A
                },
                write: function(t) {
                    G(1 === arguments.length ? t : Array.prototype.join.call(arguments, " "))
                },
                getCoordinateString: function(t) {
                    return M(t * d)
                },
                getVerticalCoordinateString: function(t) {
                    return M((g - t) * d)
                },
                collections: {},
                newObject: J,
                newObjectDeferred: V,
                newObjectDeferredBegin: X,
                putStream: Y,
                events: U,
                scaleFactor: d,
                pageSize: {
                    get width() {
                        return w
                    },
                    get height() {
                        return g
                    }
                },
                output: function(t, e) {
                    return ve(t, e)
                },
                getNumberOfPages: function() {
                    return B.length - 1
                },
                pages: B,
                out: G,
                f2: M,
                getPageInfo: function(t) {
                    var e = 2 * (t - 1) + 3;
                    return {
                        objId: e,
                        pageNumber: t
                    }
                },
                getCurrentPageInfo: function() {
                    var t = 2 * (m - 1) + 3;
                    return {
                        objId: t,
                        pageNumber: m
                    }
                }
            }, L.addPage = function() {
                return he.apply(this, arguments), this
            }, L.setPage = function() {
                return de.apply(this, arguments), this
            }, L.insertPage = function(t) {
                return this.addPage(), this.movePage(m, t), this
            }, L.movePage = function(t, e) {
                if (t > e) {
                    for (var n = B[t], r = F[t], i = t; i > e; i--) B[i] = B[i - 1], F[i] = F[i - 1];
                    B[e] = n, F[e] = r, this.setPage(e)
                } else if (e > t) {
                    for (var n = B[t], r = F[t], i = t; e > i; i++) B[i] = B[i + 1], F[i] = F[i + 1];
                    B[e] = n, F[e] = r, this.setPage(e)
                }
                return this
            }, L.deletePage = function(t) {
                for (var e = t; P > e; e++) B[e] = B[e + 1], F[e] = F[e + 1];
                return P--, m > P && (m = P), this.setPage(m), this
            }, L.setDisplayMode = function(t, e, n) {
                return v = t, b = e, y = n, this
            }, L.text = function(t, e, n, r, i, s) {
                function o(t) {
                    return t = t.split("	").join(Array(f.TabLen || 9).join(" ")), ae(t, r)
                }
                "number" == typeof t && (p = n, n = e, e = t, t = p), "string" == typeof t && (t = t.match(/[\n\r]/) ? t.split(/\r\n|\r|\n/g) : [t]), "string" == typeof i && (s = i, i = null), "string" == typeof r && (s = r, r = null), "number" == typeof r && (i = r, r = null);
                var a, u = "",
                    l = "Td";
                if (i) {
                    i *= Math.PI / 180;
                    var c = Math.cos(i),
                        m = Math.sin(i);
                    u = [M(c), M(m), M(-1 * m), M(c), ""].join(" "), l = "Tm"
                }
                r = r || {}, "noBOM" in r || (r.noBOM = !0), "autoencode" in r || (r.autoencode = !0);
                var w = "";
                if (!0 === r.stroke ? this.lastTextWasStroke !== !0 && (w = "1 Tr\n", this.lastTextWasStroke = !0) : (this.lastTextWasStroke && (w = "0 Tr\n"), this.lastTextWasStroke = !1), !(t instanceof Array)) throw new Error('Type of text must be string or Array. "' + t + '" is not recognized.');
                for (var y, v = t.concat(), b = [], x = v.length; x--;) b.push(o(v.shift()));
                var q = Math.ceil((g - n) * d / (_ * A));
                if (q >= 0 && q < b.length + 1 && (a = b.splice(q - 1)), s) {
                    var S, C = _ * A,
                        I = t.map(function(t) {
                            return this.getStringUnitWidth(t) * _ / d
                        }, this);
                    if ("center" === s) e -= I[0] / 2;
                    else {
                        if ("right" !== s) throw new Error('Unrecognized alignment option, use "center" or "right".');
                        e -= I[0]
                    }
                    for (S = e, t = b[0], y = 1, x = b.length; x > y; y++) {
                        var z = I[y - 1] - I[y];
                        "center" === s && (z /= 2), t += ") Tj\n" + z + " -" + C + " Td (" + b[y], S += z
                    }
                } else t = b.join(") Tj\nT* (");
                return G("BT\n/" + h + " " + _ + " Tf\n" + _ * A + " TL\n" + w + k + "\n" + u + M(e * d) + " " + M((g - n) * d) + " " + l + "\n(" + t + ") Tj\nET"), a && (this.addPage(), this.text(a, e, 1.7 * _ / d)), this
            }, L.lstext = function(t, e, n, r) {
                for (var i = 0, s = t.length; s > i; i++, e += r) this.text(t[i], e, n)
            }, L.line = function(t, e, n, r) {
                return this.lines([
                    [n - t, r - e]
                ], t, e)
            }, L.clip = function() {
                G("W"), G("S")
            }, L.lines = function(t, e, n, r, i, s) {
                var o, a, u, l, c, f, h, m, w, y, v;
                for ("number" == typeof t && (p = n, n = e, e = t, t = p), r = r || [1, 1], G(H(e * d) + " " + H((g - n) * d) + " m "), o = r[0], a = r[1], l = t.length, y = e, v = n, u = 0; l > u; u++) c = t[u], 2 === c.length ? (y = c[0] * o + y, v = c[1] * a + v, G(H(y * d) + " " + H((g - v) * d) + " l")) : (f = c[0] * o + y, h = c[1] * a + v, m = c[2] * o + y, w = c[3] * a + v, y = c[4] * o + y, v = c[5] * a + v, G(H(f * d) + " " + H((g - h) * d) + " " + H(m * d) + " " + H((g - w) * d) + " " + H(y * d) + " " + H((g - v) * d) + " c"));
                return s && G(" h"), null !== i && G(we(i)), this
            }, L.rect = function(t, e, n, r, i) {
                we(i);
                return G([M(t * d), M((g - e) * d), M(n * d), M(-r * d), "re"].join(" ")), null !== i && G(we(i)), this
            }, L.triangle = function(t, e, n, r, i, s, o) {
                return this.lines([
                    [n - t, r - e],
                    [i - n, s - r],
                    [t - i, e - s]
                ], t, e, [1, 1], o, !0), this
            }, L.roundedRect = function(t, e, n, r, i, s, o) {
                var a = 4 / 3 * (Math.SQRT2 - 1);
                return this.lines([
                    [n - 2 * i, 0],
                    [i * a, 0, i, s - s * a, i, s],
                    [0, r - 2 * s],
                    [0, s * a, -(i * a), s, -i, s],
                    [-n + 2 * i, 0],
                    [-(i * a), 0, -i, -(s * a), -i, -s],
                    [0, -r + 2 * s],
                    [0, -(s * a), i * a, -s, i, -s]
                ], t + i, e, [1, 1], o), this
            }, L.ellipse = function(t, e, n, r, i) {
                var s = 4 / 3 * (Math.SQRT2 - 1) * n,
                    o = 4 / 3 * (Math.SQRT2 - 1) * r;
                return G([M((t + n) * d), M((g - e) * d), "m", M((t + n) * d), M((g - (e - o)) * d), M((t + s) * d), M((g - (e - r)) * d), M(t * d), M((g - (e - r)) * d), "c"].join(" ")), G([M((t - s) * d), M((g - (e - r)) * d), M((t - n) * d), M((g - (e - o)) * d), M((t - n) * d), M((g - e) * d), "c"].join(" ")), G([M((t - n) * d), M((g - (e + o)) * d), M((t - s) * d), M((g - (e + r)) * d), M(t * d), M((g - (e + r)) * d), "c"].join(" ")), G([M((t + s) * d), M((g - (e + r)) * d), M((t + n) * d), M((g - (e + o)) * d), M((t + n) * d), M((g - e) * d), "c"].join(" ")), null !== i && G(we(i)), this
            }, L.circle = function(t, e, n, r) {
                return this.ellipse(t, e, n, n, r)
            }, L.setProperties = function(t) {
                for (var e in N) N.hasOwnProperty(e) && t[e] && (N[e] = t[e]);
                return this
            }, L.setFontSize = function(t) {
                return _ = t, this
            }, L.setFont = function(t, e) {
                return h = pe(t, e), this
            }, L.setFontStyle = L.setFontType = function(t) {
                return h = pe(void 0, t), this
            }, L.getFontList = function() {
                var t, e, n, r = {};
                for (t in T)
                    if (T.hasOwnProperty(t)) {
                        r[t] = n = [];
                        for (e in T[t]) T[t].hasOwnProperty(e) && n.push(e)
                    }
                return r
            }, L.setLineWidth = function(t) {
                return G((t * d).toFixed(2) + " w"), this
            }, L.setDrawColor = function(t, e, n, r) {
                var i;
                return i = void 0 === e || void 0 === r && t === e === n ? "string" == typeof t ? t + " G" : M(t / 255) + " G" : void 0 === r ? "string" == typeof t ? [t, e, n, "RG"].join(" ") : [M(t / 255), M(e / 255), M(n / 255), "RG"].join(" ") : "string" == typeof t ? [t, e, n, r, "K"].join(" ") : [M(t), M(e), M(n), M(r), "K"].join(" "), G(i), this
            }, L.setFillColor = function(t, e, n, r) {
                var i;
                return i = void 0 === e || void 0 === r && t === e === n ? "string" == typeof t ? t + " g" : M(t / 255) + " g" : void 0 === r ? "string" == typeof t ? [t, e, n, "rg"].join(" ") : [M(t / 255), M(e / 255), M(n / 255), "rg"].join(" ") : "string" == typeof t ? [t, e, n, r, "k"].join(" ") : [M(t), M(e), M(n), M(r), "k"].join(" "), G(i), this
            }, L.setTextColor = function(t, e, n) {
                if ("string" == typeof t && /^#[0-9A-Fa-f]{6}$/.test(t)) {
                    var r = parseInt(t.substr(1), 16);
                    t = r >> 16 & 255, e = r >> 8 & 255, n = 255 & r
                }
                return k = 0 === t && 0 === e && 0 === n || "undefined" == typeof e ? H(t / 255) + " g" : [H(t / 255), H(e / 255), H(n / 255), "rg"].join(" "), this
            }, L.CapJoinStyles = {
                0: 0,
                butt: 0,
                but: 0,
                miter: 0,
                1: 1,
                round: 1,
                rounded: 1,
                circle: 1,
                2: 2,
                projecting: 2,
                project: 2,
                square: 2,
                bevel: 2
            }, L.setLineCap = function(t) {
                var e = this.CapJoinStyles[t];
                if (void 0 === e) throw new Error("Line cap style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
                return O = e, G(e + " J"), this
            }, L.setLineJoin = function(t) {
                var e = this.CapJoinStyles[t];
                if (void 0 === e) throw new Error("Line join style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
                return D = e, G(e + " j"), this
            }, L.output = ve, L.save = function(t) {
                L.output("save", t)
            };
            for (var be in n.API) n.API.hasOwnProperty(be) && ("events" === be && n.API.events.length ? ! function(t, e) {
                var n, r, i;
                for (i = e.length - 1; - 1 !== i; i--) n = e[i][0], r = e[i][1], t.subscribe.apply(t, [n].concat("function" == typeof r ? [r] : r))
            }(U, n.API.events) : L[be] = n.API[be]);
            return ie(), h = "F1", he(l, a), U.publish("initialized"), L
        }
        var s = "1.3",
            o = {
                a0: [2383.94, 3370.39],
                a1: [1683.78, 2383.94],
                a2: [1190.55, 1683.78],
                a3: [841.89, 1190.55],
                a4: [595.28, 841.89],
                a5: [419.53, 595.28],
                a6: [297.64, 419.53],
                a7: [209.76, 297.64],
                a8: [147.4, 209.76],
                a9: [104.88, 147.4],
                a10: [73.7, 104.88],
                b0: [2834.65, 4008.19],
                b1: [2004.09, 2834.65],
                b2: [1417.32, 2004.09],
                b3: [1000.63, 1417.32],
                b4: [708.66, 1000.63],
                b5: [498.9, 708.66],
                b6: [354.33, 498.9],
                b7: [249.45, 354.33],
                b8: [175.75, 249.45],
                b9: [124.72, 175.75],
                b10: [87.87, 124.72],
                c0: [2599.37, 3676.54],
                c1: [1836.85, 2599.37],
                c2: [1298.27, 1836.85],
                c3: [918.43, 1298.27],
                c4: [649.13, 918.43],
                c5: [459.21, 649.13],
                c6: [323.15, 459.21],
                c7: [229.61, 323.15],
                c8: [161.57, 229.61],
                c9: [113.39, 161.57],
                c10: [79.37, 113.39],
                dl: [311.81, 623.62],
                letter: [612, 792],
                "government-letter": [576, 756],
                legal: [612, 1008],
                "junior-legal": [576, 360],
                ledger: [1224, 792],
                tabloid: [792, 1224],
                "credit-card": [153, 243]
            };
        return n.API = {
            events: []
        }, n.version = "1.1.49-git 2015-02-18T09:24:rob", "function" == typeof define && define.amd ? define("jsPDF", function() {
            return n
        }) : t.jsPDF = n, n
    }("undefined" != typeof self && self || "undefined" != typeof window && window || this);
    ! function(t) {
        "use strict";
        t.addHTML = function(t, e, n, r, i) {
            if ("undefined" == typeof html2canvas && "undefined" == typeof rasterizeHTML) throw new Error("You need either https://github.com/niklasvh/html2canvas or https://github.com/cburgmer/rasterizeHTML.js");
            "number" != typeof e && (r = e, i = n), "function" == typeof r && (i = r, r = null);
            var s = this.internal,
                o = s.scaleFactor,
                a = s.pageSize.width,
                u = s.pageSize.height;
            if (r = r || {}, r.onrendered = function(t) {
                    e = parseInt(e) || 0, n = parseInt(n) || 0;
                    var s = r.dim || {},
                        l = s.h || 0,
                        c = s.w || Math.min(a, t.width / o) - e,
                        f = r.format || "JPEG";
                    if (t.height > u && r.pagesplit) {
                        var h = function() {
                            for (var e = t.height / (t.width / a), n = 0, r = Math.random().toString(35);;) {
                                var s = [t, 0, -n, a, e, f, r, "SLOW"];
                                if (this.addImage.apply(this, s), n += u, n >= e) break;
                                this.addPage()
                            }
                            i(c, n, null, s)
                        }.bind(this);
                        if ("CANVAS" === t.nodeName) {
                            var d = new Image;
                            d.onload = h, d.src = t.toDataURL("image/png"), t = d
                        } else h()
                    } else {
                        var p = Math.random().toString(35),
                            m = [t, e, n, c, l, f, p, "SLOW"];
                        this.addImage.apply(this, m), i(c, l, p, m)
                    }
                }.bind(this), "undefined" != typeof html2canvas && !r.rstz) return html2canvas(t, r);
            if ("undefined" != typeof rasterizeHTML) {
                var l = "drawDocument";
                return "string" == typeof t && (l = /^http/.test(t) ? "drawURL" : "drawHTML"), r.width = r.width || a * o, rasterizeHTML[l](t, void 0, r).then(function(t) {
                    r.onrendered(t.image)
                }, function(t) {
                    i(null, t)
                })
            }
            return null
        }
    }(n.API),
    function(t) {
        "use strict";
        var e = "addImage_",
            n = ["jpeg", "jpg", "png"],
            r = function(t) {
                var e = this.internal.newObject(),
                    n = this.internal.write,
                    i = this.internal.putStream;
                if (t.n = e, n("<</Type /XObject"), n("/Subtype /Image"), n("/Width " + t.w), n("/Height " + t.h), t.cs === this.color_spaces.INDEXED ? n("/ColorSpace [/Indexed /DeviceRGB " + (t.pal.length / 3 - 1) + " " + ("smask" in t ? e + 2 : e + 1) + " 0 R]") : (n("/ColorSpace /" + t.cs), t.cs === this.color_spaces.DEVICE_CMYK && n("/Decode [1 0 1 0 1 0 1 0]")), n("/BitsPerComponent " + t.bpc), "f" in t && n("/Filter /" + t.f), "dp" in t && n("/DecodeParms <<" + t.dp + ">>"), "trns" in t && t.trns.constructor == Array) {
                    for (var s = "", o = 0, a = t.trns.length; a > o; o++) s += t.trns[o] + " " + t.trns[o] + " ";
                    n("/Mask [" + s + "]")
                }
                if ("smask" in t && n("/SMask " + (e + 1) + " 0 R"), n("/Length " + t.data.length + ">>"), i(t.data), n("endobj"), "smask" in t) {
                    var u = "/Predictor 15 /Colors 1 /BitsPerComponent " + t.bpc + " /Columns " + t.w,
                        l = {
                            w: t.w,
                            h: t.h,
                            cs: "DeviceGray",
                            bpc: t.bpc,
                            dp: u,
                            data: t.smask
                        };
                    "f" in t && (l.f = t.f), r.call(this, l)
                }
                t.cs === this.color_spaces.INDEXED && (this.internal.newObject(), n("<< /Length " + t.pal.length + ">>"), i(this.arrayBufferToBinaryString(new Uint8Array(t.pal))), n("endobj"))
            },
            i = function() {
                var t = this.internal.collections[e + "images"];
                for (var n in t) r.call(this, t[n])
            },
            s = function() {
                var t, n = this.internal.collections[e + "images"],
                    r = this.internal.write;
                for (var i in n) t = n[i], r("/I" + t.i, t.n, "0", "R")
            },
            o = function(e) {
                return e && "string" == typeof e && (e = e.toUpperCase()), e in t.image_compression ? e : t.image_compression.NONE
            },
            a = function() {
                var t = this.internal.collections[e + "images"];
                return t || (this.internal.collections[e + "images"] = t = {}, this.internal.events.subscribe("putResources", i), this.internal.events.subscribe("putXobjectDict", s)), t
            },
            u = function(t) {
                var e = 0;
                return t && (e = Object.keys ? Object.keys(t).length : function(t) {
                    var e = 0;
                    for (var n in t) t.hasOwnProperty(n) && e++;
                    return e
                }(t)), e
            },
            l = function(t) {
                return "undefined" == typeof t || null === t
            },
            c = function(e) {
                return "string" == typeof e && t.sHashCode(e)
            },
            f = function(t) {
                return -1 === n.indexOf(t)
            },
            h = function(e) {
                return "function" != typeof t["process" + e.toUpperCase()]
            },
            d = function(t) {
                return "object" == typeof t && 1 === t.nodeType
            },
            p = function(t, e, n) {
                if ("IMG" === t.nodeName && t.hasAttribute("src")) {
                    var r = "" + t.getAttribute("src");
                    if (!n && 0 === r.indexOf("data:image/")) return r;
                    !e && /\.png(?:[?#].*)?$/i.test(r) && (e = "png")
                }
                if ("CANVAS" === t.nodeName) var i = t;
                else {
                    var i = document.createElement("canvas");
                    i.width = t.clientWidth || t.width, i.height = t.clientHeight || t.height;
                    var s = i.getContext("2d");
                    if (!s) throw "addImage requires canvas to be supported by browser.";
                    if (n) {
                        var o, a, u, l, c, f, h, d, p = Math.PI / 180;
                        "object" == typeof n && (o = n.x, a = n.y, u = n.bg, n = n.angle), d = n * p, l = Math.abs(Math.cos(d)), c = Math.abs(Math.sin(d)), f = i.width, h = i.height, i.width = h * c + f * l, i.height = h * l + f * c, isNaN(o) && (o = i.width / 2), isNaN(a) && (a = i.height / 2), s.clearRect(0, 0, i.width, i.height), s.fillStyle = u || "white", s.fillRect(0, 0, i.width, i.height), s.save(), s.translate(o, a), s.rotate(d), s.drawImage(t, -(f / 2), -(h / 2)), s.rotate(-d), s.translate(-o, -a), s.restore()
                    } else s.drawImage(t, 0, 0, i.width, i.height)
                }
                return i.toDataURL("png" == ("" + e).toLowerCase() ? "image/png" : "image/jpeg")
            },
            m = function(t, e) {
                var n;
                if (e)
                    for (var r in e)
                        if (t === e[r].alias) {
                            n = e[r];
                            break
                        }
                return n
            },
            w = function(t, e, n) {
                return t || e || (t = -96, e = -96), 0 > t && (t = -1 * n.w * 72 / t / this.internal.scaleFactor), 0 > e && (e = -1 * n.h * 72 / e / this.internal.scaleFactor), 0 === t && (t = e * n.w / n.h), 0 === e && (e = t * n.h / n.w), [t, e]
            },
            g = function(t, e, n, r, i, s, o) {
                var a = w.call(this, n, r, i),
                    u = this.internal.getCoordinateString,
                    l = this.internal.getVerticalCoordinateString;
                n = a[0], r = a[1], o[s] = i, this.internal.write("q", u(n), "0 0", u(r), u(t), l(e + r), "cm /I" + i.i, "Do Q")
            };
        t.color_spaces = {
            DEVICE_RGB: "DeviceRGB",
            DEVICE_GRAY: "DeviceGray",
            DEVICE_CMYK: "DeviceCMYK",
            CAL_GREY: "CalGray",
            CAL_RGB: "CalRGB",
            LAB: "Lab",
            ICC_BASED: "ICCBased",
            INDEXED: "Indexed",
            PATTERN: "Pattern",
            SEPERATION: "Seperation",
            DEVICE_N: "DeviceN"
        }, t.decode = {
            DCT_DECODE: "DCTDecode",
            FLATE_DECODE: "FlateDecode",
            LZW_DECODE: "LZWDecode",
            JPX_DECODE: "JPXDecode",
            JBIG2_DECODE: "JBIG2Decode",
            ASCII85_DECODE: "ASCII85Decode",
            ASCII_HEX_DECODE: "ASCIIHexDecode",
            RUN_LENGTH_DECODE: "RunLengthDecode",
            CCITT_FAX_DECODE: "CCITTFaxDecode"
        }, t.image_compression = {
            NONE: "NONE",
            FAST: "FAST",
            MEDIUM: "MEDIUM",
            SLOW: "SLOW"
        }, t.sHashCode = function(t) {
            return Array.prototype.reduce && t.split("").reduce(function(t, e) {
                return t = (t << 5) - t + e.charCodeAt(0), t & t
            }, 0)
        }, t.isString = function(t) {
            return "string" == typeof t
        }, t.extractInfoFromBase64DataURI = function(t) {
            return /^data:([\w]+?\/([\w]+?));base64,(.+?)$/g.exec(t)
        }, t.supportsArrayBuffer = function() {
            return "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array
        }, t.isArrayBuffer = function(t) {
            return this.supportsArrayBuffer() ? t instanceof ArrayBuffer : !1
        }, t.isArrayBufferView = function(t) {
            return this.supportsArrayBuffer() ? "undefined" == typeof Uint32Array ? !1 : t instanceof Int8Array || t instanceof Uint8Array || "undefined" != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array : !1
        }, t.binaryStringToUint8Array = function(t) {
            for (var e = t.length, n = new Uint8Array(e), r = 0; e > r; r++) n[r] = t.charCodeAt(r);
            return n
        }, t.arrayBufferToBinaryString = function(t) {
            this.isArrayBuffer(t) && (t = new Uint8Array(t));
            for (var e = "", n = t.byteLength, r = 0; n > r; r++) e += String.fromCharCode(t[r]);
            return e
        }, t.arrayBufferToBase64 = function(t) {
            for (var e, n, r, i, s, o = "", a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", u = new Uint8Array(t), l = u.byteLength, c = l % 3, f = l - c, h = 0; f > h; h += 3) s = u[h] << 16 | u[h + 1] << 8 | u[h + 2], e = (16515072 & s) >> 18, n = (258048 & s) >> 12, r = (4032 & s) >> 6, i = 63 & s, o += a[e] + a[n] + a[r] + a[i];
            return 1 == c ? (s = u[f], e = (252 & s) >> 2, n = (3 & s) << 4, o += a[e] + a[n] + "==") : 2 == c && (s = u[f] << 8 | u[f + 1], e = (64512 & s) >> 10, n = (1008 & s) >> 4, r = (15 & s) << 2, o += a[e] + a[n] + a[r] + "="), o
        }, t.createImageInfo = function(t, e, n, r, i, s, o, a, u, l, c, f) {
            var h = {
                alias: a,
                w: e,
                h: n,
                cs: r,
                bpc: i,
                i: o,
                data: t
            };
            return s && (h.f = s), u && (h.dp = u), l && (h.trns = l), c && (h.pal = c), f && (h.smask = f), h
        }, t.addImage = function(t, e, r, i, s, w, y, v, b) {
            if ("string" != typeof e) {
                var x = w;
                w = s, s = i, i = r, r = e, e = x
            }
            if ("object" == typeof t && !d(t) && "imageData" in t) {
                var k = t;
                t = k.imageData, e = k.format || e, r = k.x || r || 0, i = k.y || i || 0, s = k.w || s, w = k.h || w, y = k.alias || y, v = k.compression || v, b = k.rotation || k.angle || b
            }
            if (isNaN(r) || isNaN(i)) throw console.error("jsPDF.addImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addImage");
            var q, _ = a.call(this);
            if (!(q = m(t, _))) {
                var A;
                if (d(t) && (t = p(t, e, b)), l(y) && (y = c(t)), !(q = m(y, _))) {
                    if (this.isString(t)) {
                        var S = this.extractInfoFromBase64DataURI(t);
                        S ? (e = S[2], t = atob(S[3])) : 137 === t.charCodeAt(0) && 80 === t.charCodeAt(1) && 78 === t.charCodeAt(2) && 71 === t.charCodeAt(3) && (e = "png")
                    }
                    if (e = (e || "JPEG").toLowerCase(), f(e)) throw new Error("addImage currently only supports formats " + n + ", not '" + e + "'");
                    if (h(e)) throw new Error("please ensure that the plugin for '" + e + "' support is added");
                    if (this.supportsArrayBuffer() && (A = t, t = this.binaryStringToUint8Array(t)), q = this["process" + e.toUpperCase()](t, u(_), y, o(v), A), !q) throw new Error("An unkwown error occurred whilst processing the image")
                }
            }
            return g.call(this, r, i, s, w, q, q.i, _), this
        };
        var y = function(t) {
                var e, n, r;
                if (255 === !t.charCodeAt(0) || 216 === !t.charCodeAt(1) || 255 === !t.charCodeAt(2) || 224 === !t.charCodeAt(3) || !t.charCodeAt(6) === "J".charCodeAt(0) || !t.charCodeAt(7) === "F".charCodeAt(0) || !t.charCodeAt(8) === "I".charCodeAt(0) || !t.charCodeAt(9) === "F".charCodeAt(0) || 0 === !t.charCodeAt(10)) throw new Error("getJpegSize requires a binary string jpeg file");
                for (var i = 256 * t.charCodeAt(4) + t.charCodeAt(5), s = 4, o = t.length; o > s;) {
                    if (s += i, 255 !== t.charCodeAt(s)) throw new Error("getJpegSize could not find the size of the image");
                    if (192 === t.charCodeAt(s + 1) || 193 === t.charCodeAt(s + 1) || 194 === t.charCodeAt(s + 1) || 195 === t.charCodeAt(s + 1) || 196 === t.charCodeAt(s + 1) || 197 === t.charCodeAt(s + 1) || 198 === t.charCodeAt(s + 1) || 199 === t.charCodeAt(s + 1)) return n = 256 * t.charCodeAt(s + 5) + t.charCodeAt(s + 6), e = 256 * t.charCodeAt(s + 7) + t.charCodeAt(s + 8), r = t.charCodeAt(s + 9), [e, n, r];
                    s += 2, i = 256 * t.charCodeAt(s) + t.charCodeAt(s + 1)
                }
            },
            v = function(t) {
                var e = t[0] << 8 | t[1];
                if (65496 !== e) throw new Error("Supplied data is not a JPEG");
                for (var n, r, i, s, o = t.length, a = (t[4] << 8) + t[5], u = 4; o > u;) {
                    if (u += a, n = b(t, u), a = (n[2] << 8) + n[3], (192 === n[1] || 194 === n[1]) && 255 === n[0] && a > 7) return n = b(t, u + 5), r = (n[2] << 8) + n[3], i = (n[0] << 8) + n[1], s = n[4], {
                        width: r,
                        height: i,
                        numcomponents: s
                    };
                    u += 2
                }
                throw new Error("getJpegSizeFromBytes could not find the size of the image")
            },
            b = function(t, e) {
                return t.subarray(e, e + 5)
            };
        t.processJPEG = function(t, e, n, r, i) {
            var s, o = this.color_spaces.DEVICE_RGB,
                a = this.decode.DCT_DECODE,
                u = 8;
            return this.isString(t) ? (s = y(t), this.createImageInfo(t, s[0], s[1], 1 == s[3] ? this.color_spaces.DEVICE_GRAY : o, u, a, e, n)) : (this.isArrayBuffer(t) && (t = new Uint8Array(t)), this.isArrayBufferView(t) ? (s = v(t), t = i || this.arrayBufferToBinaryString(t), this.createImageInfo(t, s.width, s.height, 1 == s.numcomponents ? this.color_spaces.DEVICE_GRAY : o, u, a, e, n)) : null)
        }, t.processJPG = function() {
            return this.processJPEG.apply(this, arguments)
        }
    }(n.API),
    function(t) {
        "use strict";
        var e = {
            annotations: [],
            f2: function(t) {
                return t.toFixed(2)
            },
            notEmpty: function(t) {
                return "undefined" != typeof t && "" != t ? !0 : void 0
            }
        };
        return n.API.annotationPlugin = e, n.API.events.push(["addPage", function(t) {
            this.annotationPlugin.annotations[t.pageNumber] = []
        }]), t.events.push(["putPage", function(t) {
            for (var n = this.annotationPlugin.annotations[t.pageNumber], r = !1, i = 0; i < n.length; i++) {
                var s = n[i];
                if ("link" === s.type && (e.notEmpty(s.options.url) || e.notEmpty(s.options.pageNumber))) {
                    r = !0;
                    break
                }
            }
            if (0 != r) {
                this.internal.write("/Annots [");
                for (var o = this.annotationPlugin.f2, i = 0; i < n.length; i++) {
                    var s = n[i],
                        a = this.internal.scaleFactor,
                        u = this.internal.pageSize.height,
                        l = "/Rect [" + o(s.x * a) + " " + o((u - s.y) * a) + " " + o(s.x + s.w * a) + " " + o(u - (s.y + s.h) * a) + "] ",
                        c = "";
                    if (s.options.url) c = "<</Type /Annot /Subtype /Link " + l + "/Border [0 0 0] /A <</S /URI /URI (" + s.options.url + ") >>";
                    else if (s.options.pageNumber) {
                        var t = this.internal.getPageInfo(s.options.pageNumber);
                        switch (c = "<</Type /Annot /Subtype /Link " + l + "/Border [0 0 0] /Dest [" + t.objId + " 0 R", s.options.magFactor = s.options.magFactor || "XYZ", s.options.magFactor) {
                            case "Fit":
                                c += " /Fit]";
                                break;
                            case "FitH":
                                s.options.top = s.options.top || o(u * a), c += " /FitH " + s.options.top + "]";
                                break;
                            case "FitV":
                                s.options.left = s.options.left || 0, c += " /FitV " + s.options.left + "]";
                                break;
                            case "XYZ":
                            default:
                                s.options.top = s.options.top || o(u * a), s.options.left = s.options.left || 0, "undefined" == typeof s.options.zoom && (s.options.zoom = 0), c += " /XYZ " + s.options.left + " " + s.options.top + " " + s.options.zoom + "]"
                        }
                    }
                    "" != c && (c += " >>", this.internal.write(c))
                }
                this.internal.write("]")
            }
        }]), t.link = function(t, e, n, r, i) {
            this.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push({
                x: t,
                y: e,
                w: n,
                h: r,
                options: i,
                type: "link"
            })
        }, t.textWithLink = function(t, e, n, r) {
            var i = this.getTextWidth(t),
                s = this.internal.getLineHeight();
            return this.text(t, e, n), n += .2 * s, this.link(e, n - s, i, s, r), i
        }, t.getTextWidth = function(t) {
            var e = this.internal.getFontSize(),
                n = this.getStringUnitWidth(t) * e / this.internal.scaleFactor;
            return n
        }, t.getLineHeight = function() {
            return this.internal.getLineHeight()
        }, this
    }(n.API),
    function(t) {
        "use strict";
        t.autoPrint = function() {
            var t;
            return this.internal.events.subscribe("postPutResources", function() {
                t = this.internal.newObject(), this.internal.write("<< /S/Named /Type/Action /N/Print >>", "endobj")
            }), this.internal.events.subscribe("putCatalog", function() {
                this.internal.write("/OpenAction " + t + " 0 R")
            }), this
        }
    }(n.API),
    function(t) {
        "use strict";
        var e, n, r, i, s = 3,
            o = 13,
            a = {
                x: void 0,
                y: void 0,
                w: void 0,
                h: void 0,
                ln: void 0
            },
            u = 1,
            l = function(t, e, n, r, i) {
                a = {
                    x: t,
                    y: e,
                    w: n,
                    h: r,
                    ln: i
                }
            },
            c = function() {
                return a
            },
            f = {
                left: 0,
                top: 0,
                bottom: 0
            };
        t.setHeaderFunction = function(t) {
            i = t
        }, t.getTextDimensions = function(t) {
            e = this.internal.getFont().fontName, n = this.table_font_size || this.internal.getFontSize(), r = this.internal.getFont().fontStyle;
            var i, s, o = 19.049976 / 25.4;
            return s = document.createElement("font"), s.id = "jsPDFCell", s.style.fontStyle = r, s.style.fontName = e, s.style.fontSize = n + "pt", s.textContent = t, document.body.appendChild(s), i = {
                w: (s.offsetWidth + 1) * o,
                h: (s.offsetHeight + 1) * o
            }, document.body.removeChild(s), i
        }, t.cellAddPage = function() {
            var t = this.margins || f;
            this.addPage(), l(t.left, t.top, void 0, void 0), u += 1
        }, t.cellInitialize = function() {
            a = {
                x: void 0,
                y: void 0,
                w: void 0,
                h: void 0,
                ln: void 0
            }, u = 1
        }, t.cell = function(t, e, n, r, i, a, u) {
            var h = c();
            if (void 0 !== h.ln)
                if (h.ln === a) t = h.x + h.w, e = h.y;
                else {
                    var d = this.margins || f;
                    h.y + h.h + r + o >= this.internal.pageSize.height - d.bottom && (this.cellAddPage(), this.printHeaders && this.tableHeaderRow && this.printHeaderRow(a, !0)), e = c().y + c().h
                }
            if (void 0 !== i[0])
                if (this.printingHeaderRow ? this.rect(t, e, n, r, "FD") : this.rect(t, e, n, r), "right" === u) {
                    if (i instanceof Array)
                        for (var p = 0; p < i.length; p++) {
                            var m = i[p],
                                w = this.getStringUnitWidth(m) * this.internal.getFontSize();
                            this.text(m, t + n - w - s, e + this.internal.getLineHeight() * (p + 1))
                        }
                } else this.text(i, t + s, e + this.internal.getLineHeight());
            return l(t, e, n, r, a), this
        }, t.arrayMax = function(t, e) {
            var n, r, i, s = t[0];
            for (n = 0, r = t.length; r > n; n += 1) i = t[n], e ? -1 === e(s, i) && (s = i) : i > s && (s = i);
            return s
        }, t.table = function(e, n, r, i, s) {
            if (!r) throw "No data for PDF table";
            var o, l, c, h, d, p, m, w, g, y, v = [],
                b = [],
                x = {},
                k = {},
                q = [],
                _ = [],
                A = !1,
                S = !0,
                C = 12,
                I = f;
            if (I.width = this.internal.pageSize.width, s && (s.autoSize === !0 && (A = !0), s.printHeaders === !1 && (S = !1), s.fontSize && (C = s.fontSize), s.margins && (I = s.margins)), this.lnMod = 0, a = {
                    x: void 0,
                    y: void 0,
                    w: void 0,
                    h: void 0,
                    ln: void 0
                }, u = 1, this.printHeaders = S, this.margins = I, this.setFontSize(C), this.table_font_size = C, void 0 === i || null === i) v = Object.keys(r[0]);
            else if (i[0] && "string" != typeof i[0]) {
                var z = 19.049976 / 25.4;
                for (l = 0, c = i.length; c > l; l += 1) o = i[l], v.push(o.name), b.push(o.prompt), k[o.name] = o.width * z
            } else v = i;
            if (A)
                for (y = function(t) {
                        return t[o]
                    }, l = 0, c = v.length; c > l; l += 1) {
                    for (o = v[l], x[o] = r.map(y), q.push(this.getTextDimensions(b[l] || o).w), p = x[o], m = 0, h = p.length; h > m; m += 1) d = p[m], q.push(this.getTextDimensions(d).w);
                    k[o] = t.arrayMax(q)
                }
            if (S) {
                var E = this.calculateLineHeight(v, k, b.length ? b : v);
                for (l = 0, c = v.length; c > l; l += 1) o = v[l], _.push([e, n, k[o], E, String(b.length ? b[l] : o)]);
                this.setTableHeaderRow(_), this.printHeaderRow(1, !1)
            }
            for (l = 0, c = r.length; c > l; l += 1) {
                var E;
                for (w = r[l], E = this.calculateLineHeight(v, k, w), m = 0, g = v.length; g > m; m += 1) o = v[m], this.cell(e, n, k[o], E, w[o], l + 2, o.align)
            }
            return this.lastCellPos = a, this.table_x = e, this.table_y = n, this
        }, t.calculateLineHeight = function(t, e, n) {
            for (var r, i = 0, o = 0; o < t.length; o++) {
                r = t[o], n[r] = this.splitTextToSize(String(n[r]), e[r] - s);
                var a = this.internal.getLineHeight() * n[r].length + s;
                a > i && (i = a)
            }
            return i
        }, t.setTableHeaderRow = function(t) {
            this.tableHeaderRow = t
        }, t.printHeaderRow = function(t, e) {
            if (!this.tableHeaderRow) throw "Property tableHeaderRow does not exist.";
            var n, r, s, o;
            if (this.printingHeaderRow = !0, void 0 !== i) {
                var a = i(this, u);
                l(a[0], a[1], a[2], a[3], -1)
            }
            this.setFontStyle("bold");
            var c = [];
            for (s = 0, o = this.tableHeaderRow.length; o > s; s += 1) this.setFillColor(200, 200, 200), n = this.tableHeaderRow[s], e && (n[1] = this.margins && this.margins.top || 0, c.push(n)), r = [].concat(n), this.cell.apply(this, r.concat(t));
            c.length > 0 && this.setTableHeaderRow(c), this.setFontStyle("normal"), this.printingHeaderRow = !1
        }
    }(n.API),
    function(t) {
        "use strict";

        function e() {
            this.fillStyle = "#000000", this.strokeStyle = "#000000", this.font = "12pt times", this.textBaseline = "alphabetic", this.lineWidth = 1, this.lineJoin = "miter", this.lineCap = "butt", this.copy = function(t) {
                this.fillStyle = t.fillStyle, this.strokeStyle = t.strokeStyle, this.font = t.font, this.lineWidth = t.lineWidth, this.lineJoin = t.lineJoin, this.lineCap = t.lineCap, this.textBaseline = t.textBaseline, this._fontSize = t._fontSize
            }
        }
        t.events.push(["initialized", function() {
            this.context2d.pdf = this, this.context2d.internal.pdf = this, this.context2d.ctx = new e, this.context2d.ctxStack = [], this.context2d.path = []
        }]), t.context2d = {
            f2: function(t) {
                return t.toFixed(2)
            },
            fillRect: function(t, e, n, r) {
                this.pdf.rect(t, e, n, r, "f")
            },
            strokeRect: function(t, e, n, r) {
                this.pdf.rect(t, e, n, r, "s")
            },
            clearRect: function(t, e, n, r) {
                this.save(), this.setFillStyle("#ffffff"), this.pdf.rect(t, e, n, r, "f"), this.restore()
            },
            save: function() {
                this.ctx._fontSize = this.pdf.internal.getFontSize();
                var t = new e;
                t.copy(this.ctx), this.ctxStack.push(this.ctx), this.ctx = t
            },
            restore: function() {
                this.ctx = this.ctxStack.pop(), this.setFillStyle(this.ctx.fillStyle), this.setStrokeStyle(this.ctx.strokeStyle), this.setFont(this.ctx.font), this.pdf.setFontSize(this.ctx._fontSize), this.setLineCap(this.ctx.lineCap), this.setLineWidth(this.ctx.lineWidth), this.setLineJoin(this.ctx.lineJoin)
            },
            beginPath: function() {
                this.path = []
            },
            closePath: function() {
                this.path.push({
                    type: "close"
                })
            },
            setFillStyle: function(t) {
                "#" != t.charAt(0) && (t = this.internal.colorNameToHex(t), t || (t = "#000000")), this.ctx.fillStyle = t;
                var e = this.ctx.fillStyle.substring(1, 3);
                e = parseInt(e, 16);
                var n = this.ctx.fillStyle.substring(3, 5);
                n = parseInt(n, 16);
                var r = this.ctx.fillStyle.substring(5, 7);
                r = parseInt(r, 16), this.pdf.setFillColor(e, n, r), this.pdf.setTextColor(e, n, r)
            },
            setStrokeStyle: function(t) {
                "#" != t.charAt(0) && (t = this.internal.colorNameToHex(t), t || (t = "#000000")), this.ctx.strokeStyle = t;
                var e = this.ctx.strokeStyle.substring(1, 3);
                e = parseInt(e, 16);
                var n = this.ctx.strokeStyle.substring(3, 5);
                n = parseInt(n, 16);
                var r = this.ctx.strokeStyle.substring(5, 7);
                r = parseInt(r, 16), this.pdf.setDrawColor(e, n, r)
            },
            fillText: function(t, e, n) {
                this.pdf.text(t, e, this._getBaseline(n))
            },
            strokeText: function(t, e, n) {
                this.pdf.text(t, e, this._getBaseline(n), {
                    stroke: !0
                })
            },
            setFont: function(t) {
                this.ctx.font = t;
                var e = /(\d+)pt\s+(\w+)\s*(\w+)?/,
                    n = e.exec(t),
                    r = n[1],
                    i = n[2],
                    s = n[3];
                s || (s = "normal"), this.pdf.setFontSize(r), this.pdf.setFont(i, s)
            },
            setTextBaseline: function(t) {
                this.ctx.textBaseline = t
            },
            setLineWidth: function(t) {
                this.ctx.lineWidth = t, this.pdf.setLineWidth(t)
            },
            setLineCap: function(t) {
                this.ctx.lineCap = t, this.pdf.setLineCap(t)
            },
            setLineJoin: function(t) {
                this.ctx.lineJon = t, this.pdf.setLineJoin(t)
            },
            moveTo: function(t, e) {
                var n = {
                    type: "mt",
                    x: t,
                    y: e
                };
                this.path.push(n)
            },
            lineTo: function(t, e) {
                var n = {
                    type: "lt",
                    x: t,
                    y: e
                };
                this.path.push(n)
            },
            arc: function(t, e, n, r, i, s) {
                var o = {
                    type: "arc",
                    x: t,
                    y: e,
                    radius: n,
                    startAngle: r,
                    endAngle: i,
                    anticlockwise: s
                };
                this.path.push(o)
            },
            drawImage: function(t, e, n, r, i) {
                var s, o = /data:image\/(\w+).*/i,
                    a = o.exec(t);
                s = null != a ? a[1] : "png", this.pdf.addImage(t, s, e, n, r, i)
            },
            stroke: function() {
                for (var t, e = [], n = 0; n < this.path.length; n++) {
                    var r = this.path[n];
                    switch (r.type) {
                        case "mt":
                            t = r, "undefined" != typeof t && (this.pdf.lines(e, t.x, t.y, null, "s"), e = []);
                            break;
                        case "lt":
                            var i = [r.x - this.path[n - 1].x, r.y - this.path[n - 1].y];
                            e.push(i)
                    }
                }
                "undefined" != typeof t && this.pdf.lines(e, t.x, t.y, null, "s");
                for (var n = 0; n < this.path.length; n++) {
                    var r = this.path[n];
                    switch (r.type) {
                        case "arc":
                            var t = 360 * r.startAngle / (2 * Math.PI),
                                s = 360 * r.endAngle / (2 * Math.PI);
                            this.internal.arc(r.x, r.y, r.radius, t, s, r.anticlockwise, "s")
                    }
                }
                this.path = []
            },
            fill: function() {
                for (var t, e = [], n = 0; n < this.path.length; n++) {
                    var r = this.path[n];
                    switch (r.type) {
                        case "mt":
                            t = r, "undefined" != typeof t && (this.pdf.lines(e, t.x, t.y, null, "f"), e = []);
                            break;
                        case "lt":
                            var i = [r.x - this.path[n - 1].x, r.y - this.path[n - 1].y];
                            e.push(i)
                    }
                }
                "undefined" != typeof t && this.pdf.lines(e, t.x, t.y, null, "f");
                for (var n = 0; n < this.path.length; n++) {
                    var r = this.path[n];
                    switch (r.type) {
                        case "arc":
                            var t = 360 * r.startAngle / (2 * Math.PI),
                                s = 360 * r.endAngle / (2 * Math.PI);
                            this.internal.arc(r.x, r.y, r.radius, t, s, r.anticlockwise, "f");
                            break;
                        case "close":
                            this.pdf.internal.out("h")
                    }
                }
                this.path = []
            },
            _getBaseline: function(t) {
                var e = parseInt(this.pdf.internal.getFontSize()),
                    n = .25 * e;
                switch (this.ctx.textBaseline) {
                    case "bottom":
                        return t - n;
                    case "top":
                        return t + e;
                    case "hanging":
                        return t + e - n;
                    case "middle":
                        return t + e / 2 - n;
                    case "ideographic":
                        return t;
                    case "alphabetic":
                    default:
                        return t
                }
            }
        };
        var n = t.context2d;
        return n.internal = {}, n.internal.arc = function(t, e, n, r, i, s, o) {
            for (var a = this.pdf.internal.scaleFactor, u = this.pdf.internal.pageSize.height, l = this.pdf.internal.f2, c = r * (Math.PI / 180), f = i * (Math.PI / 180), h = this.createArc(n, c, f, s), d = 0; d < h.length; d++) {
                var p = h[d];
                this.pdf.internal.out(0 == d ? [l((p.x1 + t) * a), l((u - (p.y1 + e)) * a), "m", l((p.x2 + t) * a), l((u - (p.y2 + e)) * a), l((p.x3 + t) * a), l((u - (p.y3 + e)) * a), l((p.x4 + t) * a), l((u - (p.y4 + e)) * a), "c"].join(" ") : [l((p.x2 + t) * a), l((u - (p.y2 + e)) * a), l((p.x3 + t) * a), l((u - (p.y3 + e)) * a), l((p.x4 + t) * a), l((u - (p.y4 + e)) * a), "c"].join(" "))
            }
            null !== o && this.pdf.internal.out(this.pdf.internal.getStyle(o))
        }, n.internal.createArc = function(t, e, n, r) {
            var i = 1e-5,
                s = 2 * Math.PI,
                o = e;
            (s > o || o > s) && (o %= s);
            var a = n;
            (s > a || a > s) && (a %= s);
            for (var u = [], l = Math.PI / 2, c = r ? -1 : 1, f = e, h = Math.min(s, Math.abs(a - o)); h > i;) {
                var d = f + c * Math.min(h, l);
                u.push(this.createSmallArc(t, f, d)), h -= Math.abs(d - f), f = d
            }
            return u
        }, n.internal.createSmallArc = function(t, e, n) {
            var r = (n - e) / 2,
                i = t * Math.cos(r),
                s = t * Math.sin(r),
                o = i,
                a = -s,
                u = o * o + a * a,
                l = u + o * i + a * s,
                c = 4 / 3 * (Math.sqrt(2 * u * l) - l) / (o * s - a * i),
                f = o - c * a,
                h = a + c * o,
                d = f,
                p = -h,
                m = r + e,
                w = Math.cos(m),
                g = Math.sin(m);
            return {
                x1: t * Math.cos(e),
                y1: t * Math.sin(e),
                x2: f * w - h * g,
                y2: f * g + h * w,
                x3: d * w - p * g,
                y3: d * g + p * w,
                x4: t * Math.cos(n),
                y4: t * Math.sin(n)
            }
        }, n.internal.colorNameToHex = function(t) {
            var e = {
                aliceblue: "#f0f8ff",
                antiquewhite: "#faebd7",
                aqua: "#00ffff",
                aquamarine: "#7fffd4",
                azure: "#f0ffff",
                beige: "#f5f5dc",
                bisque: "#ffe4c4",
                black: "#000000",
                blanchedalmond: "#ffebcd",
                blue: "#0000ff",
                blueviolet: "#8a2be2",
                brown: "#a52a2a",
                burlywood: "#deb887",
                cadetblue: "#5f9ea0",
                chartreuse: "#7fff00",
                chocolate: "#d2691e",
                coral: "#ff7f50",
                cornflowerblue: "#6495ed",
                cornsilk: "#fff8dc",
                crimson: "#dc143c",
                cyan: "#00ffff",
                darkblue: "#00008b",
                darkcyan: "#008b8b",
                darkgoldenrod: "#b8860b",
                darkgray: "#a9a9a9",
                darkgreen: "#006400",
                darkkhaki: "#bdb76b",
                darkmagenta: "#8b008b",
                darkolivegreen: "#556b2f",
                darkorange: "#ff8c00",
                darkorchid: "#9932cc",
                darkred: "#8b0000",
                darksalmon: "#e9967a",
                darkseagreen: "#8fbc8f",
                darkslateblue: "#483d8b",
                darkslategray: "#2f4f4f",
                darkturquoise: "#00ced1",
                darkviolet: "#9400d3",
                deeppink: "#ff1493",
                deepskyblue: "#00bfff",
                dimgray: "#696969",
                dodgerblue: "#1e90ff",
                firebrick: "#b22222",
                floralwhite: "#fffaf0",
                forestgreen: "#228b22",
                fuchsia: "#ff00ff",
                gainsboro: "#dcdcdc",
                ghostwhite: "#f8f8ff",
                gold: "#ffd700",
                goldenrod: "#daa520",
                gray: "#808080",
                green: "#008000",
                greenyellow: "#adff2f",
                honeydew: "#f0fff0",
                hotpink: "#ff69b4",
                "indianred ": "#cd5c5c",
                indigo: "#4b0082",
                ivory: "#fffff0",
                khaki: "#f0e68c",
                lavender: "#e6e6fa",
                lavenderblush: "#fff0f5",
                lawngreen: "#7cfc00",
                lemonchiffon: "#fffacd",
                lightblue: "#add8e6",
                lightcoral: "#f08080",
                lightcyan: "#e0ffff",
                lightgoldenrodyellow: "#fafad2",
                lightgrey: "#d3d3d3",
                lightgreen: "#90ee90",
                lightpink: "#ffb6c1",
                lightsalmon: "#ffa07a",
                lightseagreen: "#20b2aa",
                lightskyblue: "#87cefa",
                lightslategray: "#778899",
                lightsteelblue: "#b0c4de",
                lightyellow: "#ffffe0",
                lime: "#00ff00",
                limegreen: "#32cd32",
                linen: "#faf0e6",
                magenta: "#ff00ff",
                maroon: "#800000",
                mediumaquamarine: "#66cdaa",
                mediumblue: "#0000cd",
                mediumorchid: "#ba55d3",
                mediumpurple: "#9370d8",
                mediumseagreen: "#3cb371",
                mediumslateblue: "#7b68ee",
                mediumspringgreen: "#00fa9a",
                mediumturquoise: "#48d1cc",
                mediumvioletred: "#c71585",
                midnightblue: "#191970",
                mintcream: "#f5fffa",
                mistyrose: "#ffe4e1",
                moccasin: "#ffe4b5",
                navajowhite: "#ffdead",
                navy: "#000080",
                oldlace: "#fdf5e6",
                olive: "#808000",
                olivedrab: "#6b8e23",
                orange: "#ffa500",
                orangered: "#ff4500",
                orchid: "#da70d6",
                palegoldenrod: "#eee8aa",
                palegreen: "#98fb98",
                paleturquoise: "#afeeee",
                palevioletred: "#d87093",
                papayawhip: "#ffefd5",
                peachpuff: "#ffdab9",
                peru: "#cd853f",
                pink: "#ffc0cb",
                plum: "#dda0dd",
                powderblue: "#b0e0e6",
                purple: "#800080",
                red: "#ff0000",
                rosybrown: "#bc8f8f",
                royalblue: "#4169e1",
                saddlebrown: "#8b4513",
                salmon: "#fa8072",
                sandybrown: "#f4a460",
                seagreen: "#2e8b57",
                seashell: "#fff5ee",
                sienna: "#a0522d",
                silver: "#c0c0c0",
                skyblue: "#87ceeb",
                slateblue: "#6a5acd",
                slategray: "#708090",
                snow: "#fffafa",
                springgreen: "#00ff7f",
                steelblue: "#4682b4",
                tan: "#d2b48c",
                teal: "#008080",
                thistle: "#d8bfd8",
                tomato: "#ff6347",
                turquoise: "#40e0d0",
                violet: "#ee82ee",
                wheat: "#f5deb3",
                white: "#ffffff",
                whitesmoke: "#f5f5f5",
                yellow: "#ffff00",
                yellowgreen: "#9acd32"
            };
            return "undefined" != typeof e[t.toLowerCase()] ? e[t.toLowerCase()] : !1
        }, this
    }(n.API),
    function(t) {
        var e, n, r, i, s, o, a, u, l, c, f, h, d, p, m, w, g, y, v;
        e = function() {
            function t() {}
            return function(e) {
                return t.prototype = e, new t
            }
        }(), l = function(t) {
            var e, n, r, i, s, o, a;
            for (n = 0, r = t.length, e = void 0, i = !1, o = !1; !i && n !== r;) e = t[n] = t[n].trimLeft(), e && (i = !0), n++;
            for (n = r - 1; r && !o && -1 !== n;) e = t[n] = t[n].trimRight(), e && (o = !0), n--;
            for (s = /\s+$/g, a = !0, n = 0; n !== r;) e = t[n].replace(/\s+/g, " "), a && (e = e.trimLeft()), e && (a = s.test(e)), t[n] = e, n++;
            return t
        }, c = function(t, e, n, r) {
            return this.pdf = t, this.x = e, this.y = n, this.settings = r, this.watchFunctions = [], this.init(), this
        }, f = function(t) {
            var e, n, i;
            for (e = void 0, i = t.split(","), n = i.shift(); !e && n;) e = r[n.trim().toLowerCase()], n = i.shift();
            return e
        }, h = function(t) {
            t = "auto" === t ? "0px" : t, t.indexOf("em") > -1 && !isNaN(Number(t.replace("em", ""))) && (t = 18.719 * Number(t.replace("em", "")) + "px"), t.indexOf("pt") > -1 && !isNaN(Number(t.replace("pt", ""))) && (t = 1.333 * Number(t.replace("pt", "")) + "px");
            var e, n, r;
            return n = void 0, e = 16, (r = d[t]) ? r : (r = {
                "xx-small": 9,
                "x-small": 11,
                small: 13,
                medium: 16,
                large: 19,
                "x-large": 23,
                "xx-large": 28,
                auto: 0
            }[{
                css_line_height_string: t
            }], r !== n ? d[t] = r / e : (r = parseFloat(t)) ? d[t] = r / e : (r = t.match(/([\d\.]+)(px)/), d[t] = 3 === r.length ? parseFloat(r[1]) / e : 1))
        }, u = function(t) {
            var e, n, r;
            return r = function(t) {
                var e;
                return e = function(t) {
                        return document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(t, null) : t.currentStyle ? t.currentStyle : t.style
                    }(t),
                    function(t) {
                        return t = t.replace(/-\D/g, function(t) {
                            return t.charAt(1).toUpperCase()
                        }), e[t]
                    }
            }(t), e = {}, n = void 0, e["font-family"] = f(r("font-family")) || "times", e["font-style"] = i[r("font-style")] || "normal", e["text-align"] = TextAlignMap[r("text-align")] || "left", n = s[r("font-weight")] || "normal", "bold" === n && (e["font-style"] = "normal" === e["font-style"] ? n : n + e["font-style"]), e["font-size"] = h(r("font-size")) || 1, e["line-height"] = h(r("line-height")) || 1, e.display = "inline" === r("display") ? "inline" : "block", n = "block" === e.display, e["margin-top"] = n && h(r("margin-top")) || 0, e["margin-bottom"] = n && h(r("margin-bottom")) || 0, e["padding-top"] = n && h(r("padding-top")) || 0, e["padding-bottom"] = n && h(r("padding-bottom")) || 0, e["margin-left"] = n && h(r("margin-left")) || 0, e["margin-right"] = n && h(r("margin-right")) || 0, e["padding-left"] = n && h(r("padding-left")) || 0, e["padding-right"] = n && h(r("padding-right")) || 0, e["float"] = o[r("cssFloat")] || "none", e.clear = a[r("clear")] || "none", e
        }, p = function(t, e, n) {
            var r, i, s, o, a;
            if (s = !1, i = void 0, o = void 0, a = void 0, r = n["#" + t.id])
                if ("function" == typeof r) s = r(t, e);
                else
                    for (i = 0, o = r.length; !s && i !== o;) s = r[i](t, e), i++;
            if (r = n[t.nodeName], !s && r)
                if ("function" == typeof r) s = r(t, e);
                else
                    for (i = 0, o = r.length; !s && i !== o;) s = r[i](t, e), i++;
            return s
        }, v = function(t, e) {
            var n, r, i, s, o, a, u, l, c, f;
            for (n = [], r = [], i = 0, f = t.rows[0].cells.length, l = t.clientWidth; f > i;) c = t.rows[0].cells[i], r[i] = {
                name: c.textContent.toLowerCase().replace(/\s+/g, ""),
                prompt: c.textContent.replace(/\r?\n/g, ""),
                width: c.clientWidth / l * e.pdf.internal.pageSize.width
            }, i++;
            for (i = 1; i < t.rows.length;) {
                for (a = t.rows[i], o = {}, s = 0; s < a.cells.length;) o[r[s].name] = a.cells[s].textContent.replace(/\r?\n/g, ""), s++;
                n.push(o), i++
            }
            return u = {
                rows: n,
                headers: r
            }
        };
        var b = {
                SCRIPT: 1,
                STYLE: 1,
                NOSCRIPT: 1,
                OBJECT: 1,
                EMBED: 1,
                SELECT: 1
            },
            x = 1;
        n = function(t, e, r) {
            var i, s, o, a, l, c, f, h, d;
            for (s = t.childNodes, i = void 0, o = u(t), l = "block" === o.display, l && (e.setBlockBoundary(), e.setBlockStyle(o)), f = 19.049976 / 25.4, a = 0, c = s.length; c > a;) {
                if (i = s[a], "object" == typeof i) {
                    if (e.executeWatchFunctions(i), 1 === i.nodeType && "HEADER" === i.nodeName) {
                        var w = i,
                            g = e.pdf.margins_doc.top;
                        e.pdf.internal.events.subscribe("addPage", function() {
                            e.y = g, n(w, e, r), e.pdf.margins_doc.top = e.y + 10, e.y += 10
                        }, !1)
                    }
                    if (8 === i.nodeType && "#comment" === i.nodeName) ~i.textContent.indexOf("ADD_PAGE") && (e.pdf.addPage(), e.y = e.pdf.margins_doc.top);
                    else if (1 !== i.nodeType || b[i.nodeName])
                        if (3 === i.nodeType) {
                            var y = i.nodeValue;
                            if (i.nodeValue && "LI" === i.parentNode.nodeName)
                                if ("OL" === i.parentNode.parentNode.nodeName) y = x++ + ". " + y;
                                else {
                                    var k = 16 * o["font-size"],
                                        q = 2;
                                    k > 20 && (q = 3), d = function(t, e) {
                                        this.pdf.circle(t, e, q, "FD")
                                    }
                                }
                            e.addText(y, o)
                        } else "string" == typeof i && e.addText(i, o);
                    else {
                        var _;
                        if ("IMG" === i.nodeName) {
                            var A = i.getAttribute("src");
                            _ = m[e.pdf.sHashCode(A) || A]
                        }
                        if (_) {
                            e.pdf.internal.pageSize.height - e.pdf.margins_doc.bottom < e.y + i.height && e.y > e.pdf.margins_doc.top && (e.pdf.addPage(), e.y = e.pdf.margins_doc.top, e.executeWatchFunctions(i));
                            var S = u(i),
                                C = e.x,
                                I = 12 / e.pdf.internal.scaleFactor,
                                z = (S["margin-left"] + S["padding-left"]) * I,
                                E = (S["margin-right"] + S["padding-right"]) * I,
                                T = (S["margin-top"] + S["padding-top"]) * I,
                                P = (S["margin-bottom"] + S["padding-bottom"]) * I;
                            C += void 0 !== S["float"] && "right" === S["float"] ? e.settings.width - i.width - E : z, e.pdf.addImage(_, C, e.y + T, i.width, i.height), _ = void 0, "right" === S["float"] || "left" === S["float"] ? (e.watchFunctions.push(function(t, n, r, i) {
                                return e.y >= n ? (e.x += t, e.settings.width += r, !0) : i && 1 === i.nodeType && !b[i.nodeName] && e.x + i.width > e.pdf.margins_doc.left + e.pdf.margins_doc.width ? (e.x += t, e.y = n, e.settings.width += r, !0) : !1
                            }.bind(this, "left" === S["float"] ? -i.width - z - E : 0, e.y + i.height + T + P, i.width)), e.watchFunctions.push(function(t, n, r) {
                                return e.y < t && n === e.pdf.internal.getNumberOfPages() ? 1 === r.nodeType && "both" === u(r).clear ? (e.y = t, !0) : !1 : !0
                            }.bind(this, e.y + i.height, e.pdf.internal.getNumberOfPages())), e.settings.width -= i.width + z + E, "left" === S["float"] && (e.x += i.width + z + E)) : e.y += i.height + P
                        } else if ("TABLE" === i.nodeName) h = v(i, e), e.y += 10, e.pdf.table(e.x, e.y, h.rows, h.headers, {
                            autoSize: !1,
                            printHeaders: !0,
                            margins: e.pdf.margins_doc
                        }), e.y = e.pdf.lastCellPos.y + e.pdf.lastCellPos.h + 20;
                        else if ("OL" === i.nodeName || "UL" === i.nodeName) x = 1, p(i, e, r) || n(i, e, r), e.y += 10;
                        else if ("LI" === i.nodeName) {
                            var B = e.x;
                            e.x += "UL" === i.parentNode.nodeName ? 22 : 10, e.y += 3, p(i, e, r) || n(i, e, r), e.x = B
                        } else "BR" === i.nodeName ? e.y += o["font-size"] * e.pdf.internal.scaleFactor : p(i, e, r) || n(i, e, r)
                    }
                }
                a++
            }
            return l ? e.setBlockBoundary(d) : void 0
        }, m = {}, w = function(t, e, n, r) {
            function i() {
                e.pdf.internal.events.publish("imagesLoaded"), r(o)
            }

            function s(t, n, r) {
                if (t) {
                    var s = new Image;
                    o = ++l, s.crossOrigin = "", s.onerror = s.onload = function() {
                        if (s.complete && (0 === s.src.indexOf("data:image/") && (s.width = n || s.width || 0, s.height = r || s.height || 0), s.width + s.height)) {
                            var o = e.pdf.sHashCode(t) || t;
                            m[o] = m[o] || s
                        }--l || i()
                    }, s.src = t
                }
            }
            for (var o, a = t.getElementsByTagName("img"), u = a.length, l = 0; u--;) s(a[u].getAttribute("src"), a[u].width, a[u].height);
            return l || i()
        }, g = function(t, e, r) {
            var i = t.getElementsByTagName("footer");
            if (i.length > 0) {
                i = i[0];
                var s = e.pdf.internal.write,
                    o = e.y;
                e.pdf.internal.write = function() {}, n(i, e, r);
                var a = Math.ceil(e.y - o) + 5;
                e.y = o, e.pdf.internal.write = s, e.pdf.margins_doc.bottom += a;
                for (var u = function(t) {
                        var s = void 0 !== t ? t.pageNumber : 1,
                            o = e.y;
                        e.y = e.pdf.internal.pageSize.height - e.pdf.margins_doc.bottom, e.pdf.margins_doc.bottom -= a;
                        for (var u = i.getElementsByTagName("span"), l = 0; l < u.length; ++l)(" " + u[l].className + " ").replace(/[\n\t]/g, " ").indexOf(" pageCounter ") > -1 && (u[l].innerHTML = s), (" " + u[l].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") > -1 && (u[l].innerHTML = "###jsPDFVarTotalPages###");
                        n(i, e, r), e.pdf.margins_doc.bottom += a, e.y = o
                    }, l = i.getElementsByTagName("span"), c = 0; c < l.length; ++c)(" " + l[c].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") > -1 && e.pdf.internal.events.subscribe("htmlRenderingFinished", e.pdf.putTotalPages.bind(e.pdf, "###jsPDFVarTotalPages###"), !0);
                e.pdf.internal.events.subscribe("addPage", u, !1), u(), b.FOOTER = 1
            }
        }, y = function(t, e, r, i, s, o) {
            if (!e) return !1;
            "string" == typeof e || e.parentNode || (e = "" + e.innerHTML), "string" == typeof e && (e = function(t) {
                var e, n, r, i;
                return r = "jsPDFhtmlText" + Date.now().toString() + (1e3 * Math.random()).toFixed(0), i = "position: absolute !important;clip: rect(1px 1px 1px 1px); /* IE6, IE7 */clip: rect(1px, 1px, 1px, 1px);padding:0 !important;border:0 !important;height: 1px !important;width: 1px !important; top:auto;left:-100px;overflow: hidden;", n = document.createElement("div"), n.style.cssText = i, n.innerHTML = '<iframe style="height:1px;width:1px" name="' + r + '" />', document.body.appendChild(n), e = window.frames[r], e.document.body.innerHTML = t, e.document.body
            }(e.replace(/<\/?script[^>]*?>/gi, "")));
            var a, u = new c(t, r, i, s);
            return w.call(this, e, u, s.elementHandlers, function(t) {
                g(e, u, s.elementHandlers), n(e, u, s.elementHandlers), u.pdf.internal.events.publish("htmlRenderingFinished"), a = u.dispose(), "function" == typeof o ? o(a) : t && console.error("jsPDF Warning: rendering issues? provide a callback to fromHTML!")
            }), a || {
                x: u.x,
                y: u.y
            }
        }, c.prototype.init = function() {
            return this.paragraph = {
                text: [],
                style: []
            }, this.pdf.internal.write("q")
        }, c.prototype.dispose = function() {
            return this.pdf.internal.write("Q"), {
                x: this.x,
                y: this.y,
                ready: !0
            }
        }, c.prototype.executeWatchFunctions = function(t) {
            var e = !1,
                n = [];
            if (this.watchFunctions.length > 0) {
                for (var r = 0; r < this.watchFunctions.length; ++r) this.watchFunctions[r](t) === !0 ? e = !0 : n.push(this.watchFunctions[r]);
                this.watchFunctions = n
            }
            return e
        }, c.prototype.splitFragmentsIntoLines = function(t, n) {
            var r, i, s, o, a, u, l, c, f, h, d, p, m, w, g;
            for (i = 12, d = this.pdf.internal.scaleFactor, a = {}, s = void 0, h = void 0, o = void 0, u = void 0, g = void 0, f = void 0, c = void 0, l = void 0, p = [], m = [p], r = 0, w = this.settings.width; t.length;)
                if (u = t.shift(), g = n.shift(), u)
                    if (s = g["font-family"], h = g["font-style"], o = a[s + h], o || (o = this.pdf.internal.getFont(s, h).metadata.Unicode, a[s + h] = o), f = {
                            widths: o.widths,
                            kerning: o.kerning,
                            fontSize: g["font-size"] * i,
                            textIndent: r
                        }, c = this.pdf.getStringUnitWidth(u, f) * f.fontSize / d, r + c > w) {
                        for (l = this.pdf.splitTextToSize(u, w, f), p.push([l.shift(), g]); l.length;) p = [
                            [l.shift(), g]
                        ], m.push(p);
                        r = this.pdf.getStringUnitWidth(p[0][0], f) * f.fontSize / d
                    } else p.push([u, g]), r += c;
            if (void 0 !== g["text-align"] && ("center" === g["text-align"] || "right" === g["text-align"] || "justify" === g["text-align"]))
                for (var y = 0; y < m.length; ++y) {
                    var v = this.pdf.getStringUnitWidth(m[y][0][0], f) * f.fontSize / d;
                    y > 0 && (m[y][0][1] = e(m[y][0][1]));
                    var b = w - v;
                    if ("right" === g["text-align"]) m[y][0][1]["margin-left"] = b;
                    else if ("center" === g["text-align"]) m[y][0][1]["margin-left"] = b / 2;
                    else if ("justify" === g["text-align"]) {
                        var x = m[y][0][0].split(" ").length - 1;
                        m[y][0][1]["word-spacing"] = b / x, y === m.length - 1 && (m[y][0][1]["word-spacing"] = 0)
                    }
                }
            return m
        }, c.prototype.RenderTextFragment = function(t, e) {
            var n, r, i;
            i = 0, n = 12, this.pdf.internal.pageSize.height - this.pdf.margins_doc.bottom < this.y + this.pdf.internal.getFontSize() && (this.pdf.internal.write("ET", "Q"), this.pdf.addPage(), this.y = this.pdf.margins_doc.top, this.pdf.internal.write("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td"), i = Math.max(i, e["line-height"], e["font-size"]), this.pdf.internal.write(0, (-1 * n * i).toFixed(2), "Td")), r = this.pdf.internal.getFont(e["font-family"], e["font-style"]), void 0 !== e["word-spacing"] && e["word-spacing"] > 0 && this.pdf.internal.write(e["word-spacing"].toFixed(2), "Tw"), this.pdf.internal.write("/" + r.id, (n * e["font-size"]).toFixed(2), "Tf", "(" + this.pdf.internal.pdfEscape(t) + ") Tj"), void 0 !== e["word-spacing"] && this.pdf.internal.write(0, "Tw")
        }, c.prototype.renderParagraph = function(t) {
            var e, n, r, i, s, o, a, u, c, f, h, d, p, m, w;
            if (i = l(this.paragraph.text), m = this.paragraph.style, e = this.paragraph.blockstyle, p = this.paragraph.priorblockstyle || {}, this.paragraph = {
                    text: [],
                    style: [],
                    blockstyle: {},
                    priorblockstyle: e
                }, i.join("").trim()) {
                u = this.splitFragmentsIntoLines(i, m), a = void 0, c = void 0, n = 12, r = n / this.pdf.internal.scaleFactor, this.priorMarginBottom = this.priorMarginBottom || 0, d = (Math.max((e["margin-top"] || 0) - this.priorMarginBottom, 0) + (e["padding-top"] || 0)) * r, h = ((e["margin-bottom"] || 0) + (e["padding-bottom"] || 0)) * r, this.priorMarginBottom = e["margin-bottom"] || 0, f = this.pdf.internal.write, s = void 0, o = void 0, this.y += d, f("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");
                for (var g = 0; u.length;) {
                    for (a = u.shift(), c = 0, s = 0, o = a.length; s !== o;) a[s][0].trim() && (c = Math.max(c, a[s][1]["line-height"], a[s][1]["font-size"]), w = 7 * a[s][1]["font-size"]), s++;
                    var y = 0;
                    void 0 !== a[0][1]["margin-left"] && a[0][1]["margin-left"] > 0 && (wantedIndent = this.pdf.internal.getCoordinateString(a[0][1]["margin-left"]), y = wantedIndent - g, g = wantedIndent);
                    var v = Math.max(e["margin-left"] || 0, 0) * r;
                    for (f(y + v, (-1 * n * c).toFixed(2), "Td"), s = 0, o = a.length; s !== o;) a[s][0] && this.RenderTextFragment(a[s][0], a[s][1]), s++;
                    if (this.y += c * r, this.executeWatchFunctions(a[0][1]) && u.length > 0) {
                        var b = [],
                            x = [];
                        u.forEach(function(t) {
                            for (var e = 0, n = t.length; e !== n;) t[e][0] && (b.push(t[e][0] + " "), x.push(t[e][1])), ++e
                        }), u = this.splitFragmentsIntoLines(l(b), x), f("ET", "Q"), f("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td")
                    }
                }
                return t && "function" == typeof t && t.call(this, this.x - 9, this.y - w / 2), f("ET", "Q"), this.y += h
            }
        }, c.prototype.setBlockBoundary = function(t) {
            return this.renderParagraph(t)
        }, c.prototype.setBlockStyle = function(t) {
            return this.paragraph.blockstyle = t
        }, c.prototype.addText = function(t, e) {
            return this.paragraph.text.push(t), this.paragraph.style.push(e)
        }, r = {
            helvetica: "helvetica",
            "sans-serif": "helvetica",
            "times new roman": "times",
            serif: "times",
            times: "times",
            monospace: "courier",
            courier: "courier"
        }, s = {
            100: "normal",
            200: "normal",
            300: "normal",
            400: "normal",
            500: "bold",
            600: "bold",
            700: "bold",
            800: "bold",
            900: "bold",
            normal: "normal",
            bold: "bold",
            bolder: "bold",
            lighter: "normal"
        }, i = {
            normal: "normal",
            italic: "italic",
            oblique: "italic"
        }, TextAlignMap = {
            left: "left",
            right: "right",
            center: "center",
            justify: "justify"
        }, o = {
            none: "none",
            right: "right",
            left: "left"
        }, a = {
            none: "none",
            both: "both"
        }, d = {
            normal: 1
        }, t.fromHTML = function(t, e, n, r, i, s) {
            "use strict";
            return this.margins_doc = s || {
                top: 0,
                bottom: 0
            }, r || (r = {}), r.elementHandlers || (r.elementHandlers = {}), y(this, t, isNaN(e) ? 4 : e, isNaN(n) ? 4 : n, r, i)
        }
    }(n.API),
    function(t) {
        "use strict";
        var e, n, r;
        t.addJS = function(t) {
            return r = t, this.internal.events.subscribe("postPutResources", function() {
                e = this.internal.newObject(), this.internal.write("<< /Names [(EmbeddedJS) " + (e + 1) + " 0 R] >>", "endobj"), n = this.internal.newObject(), this.internal.write("<< /S /JavaScript /JS (", r, ") >>", "endobj")
            }), this.internal.events.subscribe("putCatalog", function() {
                void 0 !== e && void 0 !== n && this.internal.write("/Names <</JavaScript " + e + " 0 R>>")
            }), this
        }
    }(n.API),
    function(t) {
        "use strict";
        return t.events.push(["postPutResources", function() {
            var t = this,
                e = /^(\d+) 0 obj$/;
            if (this.outline.root.children.length > 0)
                for (var n = t.outline.render().split(/\r\n/), r = 0; r < n.length; r++) {
                    var i = n[r],
                        s = e.exec(i);
                    if (null != s) {
                        var o = s[1];
                        t.internal.newObjectDeferredBegin(o)
                    }
                    t.internal.write(i)
                }
            if (this.outline.createNamedDestinations) {
                for (var a = this.internal.pages.length, u = [], r = 0; a > r; r++) {
                    var l = t.internal.newObject();
                    u.push(l);
                    var c = t.internal.getPageInfo(r + 1);
                    t.internal.write("<< /D[" + c.objId + " 0 R /XYZ null null null]>> endobj")
                }
                var f = t.internal.newObject();
                t.internal.write("<< /Names [ ");
                for (var r = 0; r < u.length; r++) t.internal.write("(page_" + (r + 1) + ")" + u[r] + " 0 R");
                t.internal.write(" ] >>", "endobj"), namesOid = t.internal.newObject(), t.internal.write("<< /Dests " + f + " 0 R"), t.internal.write(">>", "endobj")
            }
        }]), t.events.push(["putCatalog", function() {
            var t = this;
            t.outline.root.children.length > 0 && (t.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && t.internal.write("/Names " + namesOid + " 0 R"))
        }]), t.events.push(["initialized", function() {
            var t = this;
            t.outline = {
                createNamedDestinations: !1,
                root: {
                    children: []
                }
            };
            t.outline.add = function(t, e, n) {
                var r = {
                    title: e,
                    options: n,
                    children: []
                };
                return null == t && (t = this.root), t.children.push(r), r
            }, t.outline.render = function() {
                return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val
            }, t.outline.genIds_r = function(e) {
                e.id = t.internal.newObjectDeferred();
                for (var n = 0; n < e.children.length; n++) this.genIds_r(e.children[n])
            }, t.outline.renderRoot = function(t) {
                this.objStart(t), this.line("/Type /Outlines"), t.children.length > 0 && (this.line("/First " + this.makeRef(t.children[0])), this.line("/Last " + this.makeRef(t.children[t.children.length - 1]))), this.line("/Count " + this.count_r({
                    count: 0
                }, t)), this.objEnd()
            }, t.outline.renderItems = function(e) {
                for (var n = 0; n < e.children.length; n++) {
                    var r = e.children[n];
                    this.objStart(r), this.line("/Title " + this.makeString(r.title)), this.line("/Parent " + this.makeRef(e)), n > 0 && this.line("/Prev " + this.makeRef(e.children[n - 1])), n < e.children.length - 1 && this.line("/Next " + this.makeRef(e.children[n + 1])), r.children.length > 0 && (this.line("/First " + this.makeRef(r.children[0])), this.line("/Last " + this.makeRef(r.children[r.children.length - 1])));
                    var i = this.count = this.count_r({
                        count: 0
                    }, r);
                    if (i > 0 && this.line("/Count " + i), r.options && r.options.pageNumber) {
                        var s = t.internal.getPageInfo(r.options.pageNumber);
                        this.line("/Dest [" + s.objId + " 0 R /XYZ 0 " + this.ctx.pdf.internal.pageSize.height + " 0]")
                    }
                    this.objEnd()
                }
                for (var n = 0; n < e.children.length; n++) {
                    var r = e.children[n];
                    this.renderItems(r)
                }
            }, t.outline.line = function(t) {
                this.ctx.val += t + "\r\n"
            }, t.outline.makeRef = function(t) {
                return t.id + " 0 R"
            }, t.outline.makeString = function(e) {
                return "(" + t.internal.pdfEscape(e) + ")"
            }, t.outline.objStart = function(t) {
                this.ctx.val += "\r\n" + t.id + " 0 obj\r\n<<\r\n"
            }, t.outline.objEnd = function() {
                this.ctx.val += ">> \r\nendobj\r\n"
            }, t.outline.count_r = function(t, e) {
                for (var n = 0; n < e.children.length; n++) t.count++, this.count_r(t, e.children[n]);
                return t.count
            }
        }]), this
    }(n.API),
    function(t) {
        "use strict";
        var e = function() {
                return "function" != typeof PNG || "function" != typeof o
            },
            n = function(e) {
                return e !== t.image_compression.NONE && i()
            },
            i = function() {
                var t = "function" == typeof r;
                if (!t) throw new Error("requires deflate.js for compression");
                return t
            },
            s = function(e, n, i, s) {
                var o = 5,
                    c = h;
                switch (s) {
                    case t.image_compression.FAST:
                        o = 3, c = f;
                        break;
                    case t.image_compression.MEDIUM:
                        o = 6, c = d;
                        break;
                    case t.image_compression.SLOW:
                        o = 9, c = p
                }
                e = l(e, n, i, c);
                var m = new Uint8Array(a(o)),
                    w = u(e),
                    g = new r(o),
                    y = g.append(e),
                    v = g.flush(),
                    b = m.length + y.length + v.length,
                    x = new Uint8Array(b + 4);
                return x.set(m), x.set(y, m.length), x.set(v, m.length + y.length), x[b++] = w >>> 24 & 255, x[b++] = w >>> 16 & 255, x[b++] = w >>> 8 & 255, x[b++] = 255 & w, t.arrayBufferToBinaryString(x)
            },
            a = function(t, e) {
                var n = 8,
                    r = Math.LOG2E * Math.log(32768) - 8,
                    i = r << 4 | n,
                    s = i << 8,
                    o = Math.min(3, (e - 1 & 255) >> 1);
                return s |= o << 6, s |= 0, s += 31 - s % 31, [i, 255 & s & 255]
            },
            u = function(t, e) {
                for (var n, r = 1, i = 65535 & r, s = r >>> 16 & 65535, o = t.length, a = 0; o > 0;) {
                    n = o > e ? e : o, o -= n;
                    do i += t[a++], s += i; while (--n);
                    i %= 65521, s %= 65521
                }
                return (s << 16 | i) >>> 0
            },
            l = function(t, e, n, r) {
                for (var i, s, o, a = t.length / e, u = new Uint8Array(t.length + a), l = w(), c = 0; a > c; c++) {
                    if (o = c * e, i = t.subarray(o, o + e), r) u.set(r(i, n, s), o + c);
                    else {
                        for (var f = 0, h = l.length, d = []; h > f; f++) d[f] = l[f](i, n, s);
                        var p = g(d.concat());
                        u.set(d[p], o + c)
                    }
                    s = i
                }
                return u
            },
            c = function(t) {
                var e = Array.apply([], t);
                return e.unshift(0), e
            },
            f = function(t, e) {
                var n, r = [],
                    i = 0,
                    s = t.length;
                for (r[0] = 1; s > i; i++) n = t[i - e] || 0, r[i + 1] = t[i] - n + 256 & 255;
                return r
            },
            h = function(t, e, n) {
                var r, i = [],
                    s = 0,
                    o = t.length;
                for (i[0] = 2; o > s; s++) r = n && n[s] || 0, i[s + 1] = t[s] - r + 256 & 255;
                return i
            },
            d = function(t, e, n) {
                var r, i, s = [],
                    o = 0,
                    a = t.length;
                for (s[0] = 3; a > o; o++) r = t[o - e] || 0, i = n && n[o] || 0, s[o + 1] = t[o] + 256 - (r + i >>> 1) & 255;
                return s
            },
            p = function(t, e, n) {
                var r, i, s, o, a = [],
                    u = 0,
                    l = t.length;
                for (a[0] = 4; l > u; u++) r = t[u - e] || 0, i = n && n[u] || 0, s = n && n[u - e] || 0, o = m(r, i, s), a[u + 1] = t[u] - o + 256 & 255;
                return a
            },
            m = function(t, e, n) {
                var r = t + e - n,
                    i = Math.abs(r - t),
                    s = Math.abs(r - e),
                    o = Math.abs(r - n);
                return s >= i && o >= i ? t : o >= s ? e : n
            },
            w = function() {
                return [c, f, h, d, p]
            },
            g = function(t) {
                for (var e, n, r, i = 0, s = t.length; s > i;) e = y(t[i].slice(1)), (n > e || !n) && (n = e, r = i), i++;
                return r
            },
            y = function(t) {
                for (var e = 0, n = t.length, r = 0; n > e;) r += Math.abs(t[e++]);
                return r
            };
        t.processPNG = function(t, r, i, o) {
            var a, u, l, c, f, h, d = this.color_spaces.DEVICE_RGB,
                p = this.decode.FLATE_DECODE,
                m = 8;
            if (this.isArrayBuffer(t) && (t = new Uint8Array(t)), this.isArrayBufferView(t)) {
                if (e()) throw new Error("PNG support requires png.js and zlib.js");
                if (a = new PNG(t), t = a.imgData, m = a.bits, d = a.colorSpace, c = a.colors, -1 !== [4, 6].indexOf(a.colorType)) {
                    if (8 === a.bits)
                        for (var w, g, y = 32 == a.pixelBitlength ? new Uint32Array(a.decodePixels().buffer) : 16 == a.pixelBitlength ? new Uint16Array(a.decodePixels().buffer) : new Uint8Array(a.decodePixels().buffer), v = y.length, b = new Uint8Array(v * a.colors), x = new Uint8Array(v), k = a.pixelBitlength - a.bits, q = 0, _ = 0; v > q; q++) {
                            for (w = y[q], g = 0; k > g;) b[_++] = w >>> g & 255, g += a.bits;
                            x[q] = w >>> g & 255
                        }
                    if (16 === a.bits) {
                        for (var w, y = new Uint32Array(a.decodePixels().buffer), v = y.length, b = new Uint8Array(v * (32 / a.pixelBitlength) * a.colors), x = new Uint8Array(v * (32 / a.pixelBitlength)), A = a.colors > 1, q = 0, _ = 0, S = 0; v > q;) w = y[q++], b[_++] = w >>> 0 & 255, A && (b[_++] = w >>> 16 & 255, w = y[q++], b[_++] = w >>> 0 & 255), x[S++] = w >>> 16 & 255;
                        m = 8
                    }
                    n(o) ? (t = s(b, a.width * a.colors, a.colors, o), h = s(x, a.width, 1, o)) : (t = b, h = x, p = null)
                }
                if (3 === a.colorType && (d = this.color_spaces.INDEXED, f = a.palette, a.transparency.indexed)) {
                    for (var C = a.transparency.indexed, I = 0, q = 0, v = C.length; v > q; ++q) I += C[q];
                    if (I /= 255, I === v - 1 && -1 !== C.indexOf(0)) l = [C.indexOf(0)];
                    else if (I !== v) {
                        for (var y = a.decodePixels(), x = new Uint8Array(y.length), q = 0, v = y.length; v > q; q++) x[q] = C[y[q]];
                        h = s(x, a.width, 1)
                    }
                }
                return u = p === this.decode.FLATE_DECODE ? "/Predictor 15 /Colors " + c + " /BitsPerComponent " + m + " /Columns " + a.width : "/Colors " + c + " /BitsPerComponent " + m + " /Columns " + a.width, (this.isArrayBuffer(t) || this.isArrayBufferView(t)) && (t = this.arrayBufferToBinaryString(t)), (h && this.isArrayBuffer(h) || this.isArrayBufferView(h)) && (h = this.arrayBufferToBinaryString(h)), this.createImageInfo(t, a.width, a.height, d, m, p, r, i, u, l, f, h)
            }
            throw new Error("Unsupported PNG image data, try using JPEG instead.")
        }
    }(n.API),
    function(t) {
        "use strict";
        t.addSVG = function(t, e, n, r, i) {
            function s(t, e) {
                var n = e.createElement("style");
                n.type = "text/css", n.styleSheet ? n.styleSheet.cssText = t : n.appendChild(e.createTextNode(t)), e.getElementsByTagName("head")[0].appendChild(n)
            }

            function o(t) {
                var e = "childframe",
                    n = t.createElement("iframe");
                return s(".jsPDF_sillysvg_iframe {display:none;position:absolute;}", t), n.name = e, n.setAttribute("width", 0), n.setAttribute("height", 0), n.setAttribute("frameborder", "0"), n.setAttribute("scrolling", "no"), n.setAttribute("seamless", "seamless"), n.setAttribute("class", "jsPDF_sillysvg_iframe"), t.body.appendChild(n), n
            }

            function a(t, e) {
                var n = (e.contentWindow || e.contentDocument).document;
                return n.write(t), n.close(), n.getElementsByTagName("svg")[0]
            }

            function u(t) {
                for (var e = parseFloat(t[1]), n = parseFloat(t[2]), r = [], i = 3, s = t.length; s > i;) "c" === t[i] ? (r.push([parseFloat(t[i + 1]), parseFloat(t[i + 2]), parseFloat(t[i + 3]), parseFloat(t[i + 4]), parseFloat(t[i + 5]), parseFloat(t[i + 6])]), i += 7) : "l" === t[i] ? (r.push([parseFloat(t[i + 1]), parseFloat(t[i + 2])]), i += 3) : i += 1;
                return [e, n, r]
            }
            var l;
            if (e === l || n === l) throw new Error("addSVG needs values for 'x' and 'y'");
            var c = o(document),
                f = a(t, c),
                h = [1, 1],
                d = parseFloat(f.getAttribute("width")),
                p = parseFloat(f.getAttribute("height"));
            d && p && (r && i ? h = [r / d, i / p] : r ? h = [r / d, r / d] : i && (h = [i / p, i / p]));
            var m, w, g, y, v = f.childNodes;
            for (m = 0, w = v.length; w > m; m++) g = v[m], g.tagName && "PATH" === g.tagName.toUpperCase() && (y = u(g.getAttribute("d").split(" ")), y[0] = y[0] * h[0] + e, y[1] = y[1] * h[1] + n, this.lines.call(this, y[2], y[0], y[1], h));
            return this
        }
    }(n.API),
    function(t) {
        "use strict";
        var e = t.getCharWidthsArray = function(t, e) {
                e || (e = {});
                var n, r, i, s = e.widths ? e.widths : this.internal.getFont().metadata.Unicode.widths,
                    o = s.fof ? s.fof : 1,
                    a = e.kerning ? e.kerning : this.internal.getFont().metadata.Unicode.kerning,
                    u = a.fof ? a.fof : 1,
                    l = 0,
                    c = s[0] || o,
                    f = [];
                for (n = 0, r = t.length; r > n; n++) i = t.charCodeAt(n), f.push((s[i] || c) / o + (a[i] && a[i][l] || 0) / u), l = i;
                return f
            },
            n = function(t) {
                for (var e = t.length, n = 0; e;) e--, n += t[e];
                return n
            },
            r = t.getStringUnitWidth = function(t, r) {
                return n(e.call(this, t, r))
            },
            i = function(t, e, n, r) {
                for (var i = [], s = 0, o = t.length, a = 0; s !== o && a + e[s] < n;) a += e[s], s++;
                i.push(t.slice(0, s));
                var u = s;
                for (a = 0; s !== o;) a + e[s] > r && (i.push(t.slice(u, s)), a = 0, u = s), a += e[s], s++;
                return u !== s && i.push(t.slice(u, s)), i
            },
            s = function(t, s, o) {
                o || (o = {});
                var a, u, l, c, f, h, d = [],
                    p = [d],
                    m = o.textIndent || 0,
                    w = 0,
                    g = 0,
                    y = t.split(" "),
                    v = e(" ", o)[0];
                if (h = -1 === o.lineIndent ? y[0].length + 2 : o.lineIndent || 0) {
                    var b = Array(h).join(" "),
                        x = [];
                    y.map(function(t) {
                        t = t.split(/\s*\n/), t.length > 1 ? x = x.concat(t.map(function(t, e) {
                            return (e && t.length ? "\n" : "") + t
                        })) : x.push(t[0])
                    }), y = x, h = r(b, o)
                }
                for (l = 0, c = y.length; c > l; l++) {
                    var k = 0;
                    if (a = y[l], h && "\n" == a[0] && (a = a.substr(1), k = 1), u = e(a, o), g = n(u), m + w + g > s || k) {
                        if (g > s) {
                            for (f = i(a, u, s - (m + w), s), d.push(f.shift()), d = [f.pop()]; f.length;) p.push([f.shift()]);
                            g = n(u.slice(a.length - d[0].length))
                        } else d = [a];
                        p.push(d), m = g + h, w = v
                    } else d.push(a), m += w + g, w = v
                }
                if (h) var q = function(t, e) {
                    return (e ? b : "") + t.join(" ")
                };
                else var q = function(t) {
                    return t.join(" ")
                };
                return p.map(q)
            };
        t.splitTextToSize = function(t, e, n) {
            n || (n = {});
            var r, i = n.fontSize || this.internal.getFontSize(),
                o = function(t) {
                    var e = {
                            0: 1
                        },
                        n = {};
                    if (t.widths && t.kerning) return {
                        widths: t.widths,
                        kerning: t.kerning
                    };
                    var r = this.internal.getFont(t.fontName, t.fontStyle),
                        i = "Unicode";
                    return r.metadata[i] ? {
                        widths: r.metadata[i].widths || e,
                        kerning: r.metadata[i].kerning || n
                    } : {
                        widths: e,
                        kerning: n
                    }
                }.call(this, n);
            r = Array.isArray(t) ? t : t.split(/\r?\n/);
            var a = 1 * this.internal.scaleFactor * e / i;
            o.textIndent = n.textIndent ? 1 * n.textIndent * this.internal.scaleFactor / i : 0, o.lineIndent = n.lineIndent;
            var u, l, c = [];
            for (u = 0, l = r.length; l > u; u++) c = c.concat(s(r[u], a, o));
            return c
        }
    }(n.API),
    function(t) {
        "use strict";
        var e = function(t) {
                for (var e = "0123456789abcdef", n = "klmnopqrstuvwxyz", r = {}, i = 0; i < n.length; i++) r[n[i]] = e[i];
                var s, o, a, u, l, c = {},
                    f = 1,
                    h = c,
                    d = [],
                    p = "",
                    m = "",
                    w = t.length - 1;
                for (i = 1; i != w;) l = t[i], i += 1, "'" == l ? o ? (u = o.join(""), o = s) : o = [] : o ? o.push(l) : "{" == l ? (d.push([h, u]), h = {}, u = s) : "}" == l ? (a = d.pop(), a[0][a[1]] = h, u = s, h = a[0]) : "-" == l ? f = -1 : u === s ? r.hasOwnProperty(l) ? (p += r[l], u = parseInt(p, 16) * f, f = 1, p = "") : p += l : r.hasOwnProperty(l) ? (m += r[l], h[u] = parseInt(m, 16) * f, f = 1, u = s, m = "") : m += l;
                return c
            },
            n = {
                codePages: ["WinAnsiEncoding"],
                WinAnsiEncoding: e("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
            },
            r = {
                Unicode: {
                    Courier: n,
                    "Courier-Bold": n,
                    "Courier-BoldOblique": n,
                    "Courier-Oblique": n,
                    Helvetica: n,
                    "Helvetica-Bold": n,
                    "Helvetica-BoldOblique": n,
                    "Helvetica-Oblique": n,
                    "Times-Roman": n,
                    "Times-Bold": n,
                    "Times-BoldItalic": n,
                    "Times-Italic": n
                }
            },
            i = {
                Unicode: {
                    "Courier-Oblique": e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
                    "Times-BoldItalic": e("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),
                    "Helvetica-Bold": e("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
                    Courier: e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
                    "Courier-BoldOblique": e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
                    "Times-Bold": e("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),
                    Helvetica: e("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),
                    "Helvetica-BoldOblique": e("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
                    "Courier-Bold": e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
                    "Times-Italic": e("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),
                    "Times-Roman": e("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),
                    "Helvetica-Oblique": e("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
                }
            };
        t.events.push(["addFonts", function(t) {
            var e, n, s, o, a, u = "Unicode";
            for (n in t.fonts) t.fonts.hasOwnProperty(n) && (e = t.fonts[n], s = i[u][e.PostScriptName], s && (o = e.metadata[u] ? e.metadata[u] : e.metadata[u] = {}, o.widths = s.widths, o.kerning = s.kerning), a = r[u][e.PostScriptName], a && (o = e.metadata[u] ? e.metadata[u] : e.metadata[u] = {}, o.encoding = a, a.codePages && a.codePages.length && (e.encoding = a.codePages[0])))
        }])
    }(n.API),
    function(t) {
        "use strict";
        t.putTotalPages = function(t) {
            for (var e = new RegExp(t, "g"), n = 1; n <= this.internal.getNumberOfPages(); n++)
                for (var r = 0; r < this.internal.pages[n].length; r++) this.internal.pages[n][r] = this.internal.pages[n][r].replace(e, this.internal.getNumberOfPages());
            return this
        }
    }(n.API), void
    function(t, e) {
        "object" == typeof module ? module.exports = e() : t.adler32cs = e()
    }(n, function() {
        var t = "function" == typeof ArrayBuffer && "function" == typeof Uint8Array,
            e = null,
            n = function() {
                if (!t) return function() {
                    return !1
                };
                try {
                    var n = require("buffer");
                    "function" == typeof n.Buffer && (e = n.Buffer)
                } catch (r) {}
                return function(t) {
                    return t instanceof ArrayBuffer || null !== e && t instanceof e
                }
            }(),
            r = function() {
                return null !== e ? function(t) {
                    return new e(t, "utf8").toString("binary")
                } : function(t) {
                    return unescape(encodeURIComponent(t))
                }
            }(),
            i = 65521,
            s = function(t, e) {
                for (var n = 65535 & t, r = t >>> 16, s = 0, o = e.length; o > s; s++) n = (n + (255 & e.charCodeAt(s))) % i, r = (r + n) % i;
                return (r << 16 | n) >>> 0
            },
            o = function(t, e) {
                for (var n = 65535 & t, r = t >>> 16, s = 0, o = e.length; o > s; s++) n = (n + e[s]) % i, r = (r + n) % i;
                return (r << 16 | n) >>> 0
            },
            a = {},
            u = a.Adler32 = function() {
                var e = function(t) {
                        if (!(this instanceof e)) throw new TypeError("Constructor cannot called be as a function.");
                        if (!isFinite(t = null == t ? 1 : +t)) throw new Error("First arguments needs to be a finite number.");
                        this.checksum = t >>> 0
                    },
                    i = e.prototype = {};
                return i.constructor = e, e.from = function(t) {
                    return t.prototype = i, t
                }(function(t) {
                    if (!(this instanceof e)) throw new TypeError("Constructor cannot called be as a function.");
                    if (null == t) throw new Error("First argument needs to be a string.");
                    this.checksum = s(1, t.toString())
                }), e.fromUtf8 = function(t) {
                    return t.prototype = i, t
                }(function(t) {
                    if (!(this instanceof e)) throw new TypeError("Constructor cannot called be as a function.");
                    if (null == t) throw new Error("First argument needs to be a string.");
                    var n = r(t.toString());
                    this.checksum = s(1, n)
                }), t && (e.fromBuffer = function(t) {
                    return t.prototype = i, t
                }(function(t) {
                    if (!(this instanceof e)) throw new TypeError("Constructor cannot called be as a function.");
                    if (!n(t)) throw new Error("First argument needs to be ArrayBuffer.");
                    var r = new Uint8Array(t);
                    return this.checksum = o(1, r)
                })), i.update = function(t) {
                    if (null == t) throw new Error("First argument needs to be a string.");
                    return t = t.toString(), this.checksum = s(this.checksum, t)
                }, i.updateUtf8 = function(t) {
                    if (null == t) throw new Error("First argument needs to be a string.");
                    var e = r(t.toString());
                    return this.checksum = s(this.checksum, e)
                }, t && (i.updateBuffer = function(t) {
                    if (!n(t)) throw new Error("First argument needs to be ArrayBuffer.");
                    var e = new Uint8Array(t);
                    return this.checksum = o(this.checksum, e)
                }), i.clone = function() {
                    return new u(this.checksum)
                }, e
            }();
        return a.from = function(t) {
            if (null == t) throw new Error("First argument needs to be a string.");
            return s(1, t.toString())
        }, a.fromUtf8 = function(t) {
            if (null == t) throw new Error("First argument needs to be a string.");
            var e = r(t.toString());
            return s(1, e)
        }, t && (a.fromBuffer = function(t) {
            if (!n(t)) throw new Error("First argument need to be ArrayBuffer.");
            var e = new Uint8Array(t);
            return o(1, e)
        }), a
    }),
    function(t) {
        "use strict";
        if (t.URL = t.URL || t.webkitURL, t.Blob && t.URL) try {
            return void new Blob
        } catch (e) {}
        var n = t.BlobBuilder || t.WebKitBlobBuilder || t.MozBlobBuilder || function(t) {
            var e = function(t) {
                    return Object.prototype.toString.call(t).match(/^\[object\s(.*)\]$/)[1]
                },
                n = function() {
                    this.data = []
                },
                r = function(t, e, n) {
                    this.data = t, this.size = t.length, this.type = e, this.encoding = n
                },
                i = n.prototype,
                s = r.prototype,
                o = t.FileReaderSync,
                a = function(t) {
                    this.code = this[this.name = t]
                },
                u = "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR".split(" "),
                l = u.length,
                c = t.URL || t.webkitURL || t,
                f = c.createObjectURL,
                h = c.revokeObjectURL,
                d = c,
                p = t.btoa,
                m = t.atob,
                w = t.ArrayBuffer,
                g = t.Uint8Array,
                y = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/;
            for (r.fake = s.fake = !0; l--;) a.prototype[u[l]] = l + 1;
            return c.createObjectURL || (d = t.URL = function(t) {
                var e, n = document.createElementNS("http://www.w3.org/1999/xhtml", "a");
                return n.href = t, "origin" in n || ("data:" === n.protocol.toLowerCase() ? n.origin = null : (e = t.match(y), n.origin = e && e[1])), n
            }), d.createObjectURL = function(t) {
                var e, n = t.type;
                return null === n && (n = "application/octet-stream"), t instanceof r ? (e = "data:" + n, "base64" === t.encoding ? e + ";base64," + t.data : "URI" === t.encoding ? e + "," + decodeURIComponent(t.data) : p ? e + ";base64," + p(t.data) : e + "," + encodeURIComponent(t.data)) : f ? f.call(c, t) : void 0
            }, d.revokeObjectURL = function(t) {
                "data:" !== t.substring(0, 5) && h && h.call(c, t)
            }, i.append = function(t) {
                var n = this.data;
                if (g && (t instanceof w || t instanceof g)) {
                    for (var i = "", s = new g(t), u = 0, l = s.length; l > u; u++) i += String.fromCharCode(s[u]);
                    n.push(i)
                } else if ("Blob" === e(t) || "File" === e(t)) {
                    if (!o) throw new a("NOT_READABLE_ERR");
                    var c = new o;
                    n.push(c.readAsBinaryString(t))
                } else t instanceof r ? "base64" === t.encoding && m ? n.push(m(t.data)) : "URI" === t.encoding ? n.push(decodeURIComponent(t.data)) : "raw" === t.encoding && n.push(t.data) : ("string" != typeof t && (t += ""), n.push(unescape(encodeURIComponent(t))))
            }, i.getBlob = function(t) {
                return arguments.length || (t = null), new r(this.data.join(""), t, "raw")
            }, i.toString = function() {
                return "[object BlobBuilder]"
            }, s.slice = function(t, e, n) {
                var i = arguments.length;
                return 3 > i && (n = null), new r(this.data.slice(t, i > 1 ? e : this.data.length), n, this.encoding)
            }, s.toString = function() {
                return "[object Blob]"
            }, s.close = function() {
                this.size = 0, delete this.data
            }, n
        }(t);
        t.Blob = function(t, e) {
            var r = e ? e.type || "" : "",
                i = new n;
            if (t)
                for (var s = 0, o = t.length; o > s; s++) i.append(t[s]);
            return i.getBlob(r)
        }
    }("undefined" != typeof self && self || "undefined" != typeof window && window || this.content || this);
    var r = function() {
            function t() {
                function t(t) {
                    var e, n, i, s, a, u, l = r.dyn_tree,
                        c = r.stat_desc.static_tree,
                        f = r.stat_desc.extra_bits,
                        d = r.stat_desc.extra_base,
                        p = r.stat_desc.max_length,
                        m = 0;
                    for (s = 0; o >= s; s++) t.bl_count[s] = 0;
                    for (l[2 * t.heap[t.heap_max] + 1] = 0, e = t.heap_max + 1; h > e; e++) n = t.heap[e], s = l[2 * l[2 * n + 1] + 1] + 1, s > p && (s = p, m++), l[2 * n + 1] = s, n > r.max_code || (t.bl_count[s]++, a = 0, n >= d && (a = f[n - d]), u = l[2 * n], t.opt_len += u * (s + a), c && (t.static_len += u * (c[2 * n + 1] + a)));
                    if (0 !== m) {
                        do {
                            for (s = p - 1; 0 === t.bl_count[s];) s--;
                            t.bl_count[s]--, t.bl_count[s + 1] += 2, t.bl_count[p]--, m -= 2
                        } while (m > 0);
                        for (s = p; 0 !== s; s--)
                            for (n = t.bl_count[s]; 0 !== n;) i = t.heap[--e], i > r.max_code || (l[2 * i + 1] != s && (t.opt_len += (s - l[2 * i + 1]) * l[2 * i], l[2 * i + 1] = s), n--)
                    }
                }

                function e(t, e) {
                    var n = 0;
                    do n |= 1 & t, t >>>= 1, n <<= 1; while (--e > 0);
                    return n >>> 1
                }

                function n(t, n, r) {
                    var i, s, a, u = [],
                        l = 0;
                    for (i = 1; o >= i; i++) u[i] = l = l + r[i - 1] << 1;
                    for (s = 0; n >= s; s++) a = t[2 * s + 1], 0 !== a && (t[2 * s] = e(u[a]++, a))
                }
                var r = this;
                r.build_tree = function(e) {
                    var i, s, o, a = r.dyn_tree,
                        u = r.stat_desc.static_tree,
                        l = r.stat_desc.elems,
                        c = -1;
                    for (e.heap_len = 0, e.heap_max = h, i = 0; l > i; i++) 0 !== a[2 * i] ? (e.heap[++e.heap_len] = c = i, e.depth[i] = 0) : a[2 * i + 1] = 0;
                    for (; e.heap_len < 2;) o = e.heap[++e.heap_len] = 2 > c ? ++c : 0, a[2 * o] = 1, e.depth[o] = 0, e.opt_len--, u && (e.static_len -= u[2 * o + 1]);
                    for (r.max_code = c, i = Math.floor(e.heap_len / 2); i >= 1; i--) e.pqdownheap(a, i);
                    o = l;
                    do i = e.heap[1], e.heap[1] = e.heap[e.heap_len--], e.pqdownheap(a, 1), s = e.heap[1], e.heap[--e.heap_max] = i, e.heap[--e.heap_max] = s, a[2 * o] = a[2 * i] + a[2 * s], e.depth[o] = Math.max(e.depth[i], e.depth[s]) + 1, a[2 * i + 1] = a[2 * s + 1] = o, e.heap[1] = o++, e.pqdownheap(a, 1); while (e.heap_len >= 2);
                    e.heap[--e.heap_max] = e.heap[1], t(e), n(a, r.max_code, e.bl_count)
                }
            }

            function e(t, e, n, r, i) {
                var s = this;
                s.static_tree = t, s.extra_bits = e, s.extra_base = n, s.elems = r, s.max_length = i
            }

            function n(t, e, n, r, i) {
                var s = this;
                s.good_length = t, s.max_lazy = e, s.nice_length = n, s.max_chain = r, s.func = i
            }

            function r(t, e, n, r) {
                var i = t[2 * e],
                    s = t[2 * n];
                return s > i || i == s && r[e] <= r[n]
            }

            function i() {
                function n() {
                    var t;
                    for (Ee = 2 * Se, Pe[Fe - 1] = 0, t = 0; Fe - 1 > t; t++) Pe[t] = 0;
                    Ve = N[Xe].max_lazy, Ze = N[Xe].good_length, Ke = N[Xe].nice_length, Je = N[Xe].max_chain, Me = 0, je = 0, We = 0, Ne = Ge = $ - 1, Ue = 0, Be = 0
                }

                function i() {
                    var t;
                    for (t = 0; f > t; t++) Qe[2 * t] = 0;
                    for (t = 0; a > t; t++) $e[2 * t] = 0;
                    for (t = 0; u > t; t++) tn[2 * t] = 0;
                    Qe[2 * d] = 1, en.opt_len = en.static_len = 0, un = cn = 0
                }

                function s() {
                    nn.dyn_tree = Qe, nn.stat_desc = e.static_l_desc, rn.dyn_tree = $e, rn.stat_desc = e.static_d_desc, sn.dyn_tree = tn, sn.stat_desc = e.static_bl_desc, hn = 0, dn = 0, fn = 8, i()
                }

                function o(t, e) {
                    var n, r, i = -1,
                        s = t[1],
                        o = 0,
                        a = 7,
                        u = 4;
                    for (0 === s && (a = 138, u = 3), t[2 * (e + 1) + 1] = 65535, n = 0; e >= n; n++) r = s, s = t[2 * (n + 1) + 1], ++o < a && r == s || (u > o ? tn[2 * r] += o : 0 !== r ? (r != i && tn[2 * r]++, tn[2 * m]++) : 10 >= o ? tn[2 * w]++ : tn[2 * g]++, o = 0, i = r, 0 === s ? (a = 138, u = 3) : r == s ? (a = 6, u = 3) : (a = 7, u = 4))
                }

                function l() {
                    var e;
                    for (o(Qe, nn.max_code), o($e, rn.max_code), sn.build_tree(en), e = u - 1; e >= 3 && 0 === tn[2 * t.bl_order[e] + 1]; e--);
                    return en.opt_len += 3 * (e + 1) + 5 + 5 + 4, e
                }

                function h(t) {
                    en.pending_buf[en.pending++] = t
                }

                function p(t) {
                    h(255 & t), h(t >>> 8 & 255)
                }

                function B(t) {
                    h(t >> 8 & 255), h(255 & t & 255)
                }

                function ne(t, e) {
                    var n, r = e;
                    dn > y - r ? (n = t, hn |= n << dn & 65535, p(hn), hn = n >>> y - dn, dn += r - y) : (hn |= t << dn & 65535, dn += r)
                }

                function re(t, e) {
                    var n = 2 * t;
                    ne(65535 & e[n], 65535 & e[n + 1])
                }

                function ie(t, e) {
                    var n, r, i = -1,
                        s = t[1],
                        o = 0,
                        a = 7,
                        u = 4;
                    for (0 === s && (a = 138, u = 3), n = 0; e >= n; n++)
                        if (r = s, s = t[2 * (n + 1) + 1], !(++o < a && r == s)) {
                            if (u > o) {
                                do re(r, tn); while (0 !== --o)
                            } else 0 !== r ? (r != i && (re(r, tn), o--), re(m, tn), ne(o - 3, 2)) : 10 >= o ? (re(w, tn), ne(o - 3, 3)) : (re(g, tn), ne(o - 11, 7));
                            o = 0, i = r, 0 === s ? (a = 138, u = 3) : r == s ? (a = 6, u = 3) : (a = 7, u = 4)
                        }
                }

                function se(e, n, r) {
                    var i;
                    for (ne(e - 257, 5), ne(n - 1, 5), ne(r - 4, 4), i = 0; r > i; i++) ne(tn[2 * t.bl_order[i] + 1], 3);
                    ie(Qe, e - 1), ie($e, n - 1)
                }

                function oe() {
                    16 == dn ? (p(hn), hn = 0, dn = 0) : dn >= 8 && (h(255 & hn), hn >>>= 8, dn -= 8)
                }

                function ae() {
                    ne(K << 1, 3), re(d, e.static_ltree), oe(), 9 > 1 + fn + 10 - dn && (ne(K << 1, 3), re(d, e.static_ltree), oe()), fn = 7
                }

                function ue(e, n) {
                    var r, i, s;
                    if (en.pending_buf[ln + 2 * un] = e >>> 8 & 255, en.pending_buf[ln + 2 * un + 1] = 255 & e, en.pending_buf[on + un] = 255 & n, un++, 0 === e ? Qe[2 * n]++ : (cn++, e--, Qe[2 * (t._length_code[n] + c + 1)]++, $e[2 * t.d_code(e)]++), 0 === (8191 & un) && Xe > 2) {
                        for (r = 8 * un, i = Me - je, s = 0; a > s; s++) r += $e[2 * s] * (5 + t.extra_dbits[s]);
                        if (r >>>= 3, cn < Math.floor(un / 2) && r < Math.floor(i / 2)) return !0
                    }
                    return un == an - 1
                }

                function le(e, n) {
                    var r, i, s, o, a = 0;
                    if (0 !== un)
                        do r = en.pending_buf[ln + 2 * a] << 8 & 65280 | 255 & en.pending_buf[ln + 2 * a + 1], i = 255 & en.pending_buf[on + a], a++, 0 === r ? re(i, e) : (s = t._length_code[i], re(s + c + 1, e), o = t.extra_lbits[s], 0 !== o && (i -= t.base_length[s], ne(i, o)), r--, s = t.d_code(r), re(s, n), o = t.extra_dbits[s], 0 !== o && (r -= t.base_dist[s], ne(r, o))); while (un > a);
                    re(d, e), fn = e[2 * d + 1]
                }

                function ce() {
                    dn > 8 ? p(hn) : dn > 0 && h(255 & hn), hn = 0, dn = 0
                }

                function fe(t, e, n) {
                    ce(), fn = 8, n && (p(e), p(~e)), en.pending_buf.set(ze.subarray(t, t + e), en.pending), en.pending += e
                }

                function he(t, e, n) {
                    ne((Z << 1) + (n ? 1 : 0), 3), fe(t, e, !0)
                }

                function de(t, n, r) {
                    var s, o, a = 0;
                    Xe > 0 ? (nn.build_tree(en), rn.build_tree(en), a = l(), s = en.opt_len + 3 + 7 >>> 3, o = en.static_len + 3 + 7 >>> 3, s >= o && (s = o)) : s = o = n + 5, s >= n + 4 && -1 != t ? he(t, n, r) : o == s ? (ne((K << 1) + (r ? 1 : 0), 3), le(e.static_ltree, e.static_dtree)) : (ne((Q << 1) + (r ? 1 : 0), 3), se(nn.max_code + 1, rn.max_code + 1, a + 1), le(Qe, $e)), i(), r && ce()
                }

                function pe(t) {
                    de(je >= 0 ? je : -1, Me - je, t), je = Me, xe.flush_pending()
                }

                function me() {
                    var t, e, n, r;
                    do {
                        if (r = Ee - We - Me, 0 === r && 0 === Me && 0 === We) r = Se;
                        else if (-1 == r) r--;
                        else if (Me >= Se + Se - ee) {
                            ze.set(ze.subarray(Se, Se + Se), 0), He -= Se, Me -= Se, je -= Se, t = Fe, n = t;
                            do e = 65535 & Pe[--n], Pe[n] = e >= Se ? e - Se : 0; while (0 !== --t);
                            t = Se, n = t;
                            do e = 65535 & Te[--n], Te[n] = e >= Se ? e - Se : 0; while (0 !== --t);
                            r += Se
                        }
                        if (0 === xe.avail_in) return;
                        t = xe.read_buf(ze, Me + We, r), We += t, We >= $ && (Be = 255 & ze[Me], Be = (Be << De ^ 255 & ze[Me + 1]) & Oe)
                    } while (ee > We && 0 !== xe.avail_in)
                }

                function we(t) {
                    var e, n = 65535;
                    for (n > qe - 5 && (n = qe - 5);;) {
                        if (1 >= We) {
                            if (me(), 0 === We && t == q) return U;
                            if (0 === We) break
                        }
                        if (Me += We, We = 0, e = je + n, (0 === Me || Me >= e) && (We = Me - e, Me = e, pe(!1), 0 === xe.avail_out)) return U;
                        if (Me - je >= Se - ee && (pe(!1), 0 === xe.avail_out)) return U
                    }
                    return pe(t == S), 0 === xe.avail_out ? t == S ? H : U : t == S ? W : M
                }

                function ge(t) {
                    var e, n, r = Je,
                        i = Me,
                        s = Ge,
                        o = Me > Se - ee ? Me - (Se - ee) : 0,
                        a = Ke,
                        u = Ie,
                        l = Me + te,
                        c = ze[i + s - 1],
                        f = ze[i + s];
                    Ge >= Ze && (r >>= 2), a > We && (a = We);
                    do
                        if (e = t, ze[e + s] == f && ze[e + s - 1] == c && ze[e] == ze[i] && ze[++e] == ze[i + 1]) {
                            i += 2, e++;
                            do; while (ze[++i] == ze[++e] && ze[++i] == ze[++e] && ze[++i] == ze[++e] && ze[++i] == ze[++e] && ze[++i] == ze[++e] && ze[++i] == ze[++e] && ze[++i] == ze[++e] && ze[++i] == ze[++e] && l > i);
                            if (n = te - (l - i), i = l - te, n > s) {
                                if (He = t, s = n, n >= a) break;
                                c = ze[i + s - 1], f = ze[i + s]
                            }
                        }
                    while ((t = 65535 & Te[t & u]) > o && 0 !== --r);
                    return We >= s ? s : We
                }

                function ye(t) {
                    for (var e, n = 0;;) {
                        if (ee > We) {
                            if (me(), ee > We && t == q) return U;
                            if (0 === We) break
                        }
                        if (We >= $ && (Be = (Be << De ^ 255 & ze[Me + ($ - 1)]) & Oe, n = 65535 & Pe[Be], Te[Me & Ie] = Pe[Be], Pe[Be] = Me), 0 !== n && Se - ee >= (Me - n & 65535) && Ye != x && (Ne = ge(n)), Ne >= $)
                            if (e = ue(Me - He, Ne - $), We -= Ne, Ve >= Ne && We >= $) {
                                Ne--;
                                do Me++, Be = (Be << De ^ 255 & ze[Me + ($ - 1)]) & Oe, n = 65535 & Pe[Be], Te[Me & Ie] = Pe[Be], Pe[Be] = Me; while (0 !== --Ne);
                                Me++
                            } else Me += Ne, Ne = 0, Be = 255 & ze[Me], Be = (Be << De ^ 255 & ze[Me + 1]) & Oe;
                        else e = ue(0, 255 & ze[Me]), We--, Me++;
                        if (e && (pe(!1), 0 === xe.avail_out)) return U
                    }
                    return pe(t == S), 0 === xe.avail_out ? t == S ? H : U : t == S ? W : M
                }

                function ve(t) {
                    for (var e, n, r = 0;;) {
                        if (ee > We) {
                            if (me(), ee > We && t == q) return U;
                            if (0 === We) break
                        }
                        if (We >= $ && (Be = (Be << De ^ 255 & ze[Me + ($ - 1)]) & Oe, r = 65535 & Pe[Be], Te[Me & Ie] = Pe[Be], Pe[Be] = Me), Ge = Ne, Le = He, Ne = $ - 1, 0 !== r && Ve > Ge && Se - ee >= (Me - r & 65535) && (Ye != x && (Ne = ge(r)), 5 >= Ne && (Ye == b || Ne == $ && Me - He > 4096) && (Ne = $ - 1)), Ge >= $ && Ge >= Ne) {
                            n = Me + We - $, e = ue(Me - 1 - Le, Ge - $), We -= Ge - 1, Ge -= 2;
                            do ++Me <= n && (Be = (Be << De ^ 255 & ze[Me + ($ - 1)]) & Oe, r = 65535 & Pe[Be], Te[Me & Ie] = Pe[Be], Pe[Be] = Me); while (0 !== --Ge);
                            if (Ue = 0, Ne = $ - 1, Me++, e && (pe(!1), 0 === xe.avail_out)) return U
                        } else if (0 !== Ue) {
                            if (e = ue(0, 255 & ze[Me - 1]), e && pe(!1), Me++, We--, 0 === xe.avail_out) return U
                        } else Ue = 1, Me++, We--
                    }
                    return 0 !== Ue && (e = ue(0, 255 & ze[Me - 1]), Ue = 0), pe(t == S), 0 === xe.avail_out ? t == S ? H : U : t == S ? W : M
                }

                function be(t) {
                    return t.total_in = t.total_out = 0, t.msg = null, en.pending = 0, en.pending_out = 0, ke = V, Ae = q, s(), n(), C
                }
                var xe, ke, qe, _e, Ae, Se, Ce, Ie, ze, Ee, Te, Pe, Be, Fe, Re, Oe, De, je, Ne, Le, Ue, Me, He, We, Ge, Je, Ve, Xe, Ye, Ze, Ke, Qe, $e, tn, en = this,
                    nn = new t,
                    rn = new t,
                    sn = new t;
                en.depth = [];
                var on, an, un, ln, cn, fn, hn, dn;
                en.bl_count = [], en.heap = [], Qe = [], $e = [], tn = [], en.pqdownheap = function(t, e) {
                    for (var n = en.heap, i = n[e], s = e << 1; s <= en.heap_len && (s < en.heap_len && r(t, n[s + 1], n[s], en.depth) && s++, !r(t, i, n[s], en.depth));) n[e] = n[s], e = s, s <<= 1;
                    n[e] = i
                }, en.deflateInit = function(t, e, n, r, i, s) {
                    return r || (r = Y), i || (i = R), s || (s = k), t.msg = null, e == v && (e = 6), 1 > i || i > F || r != Y || 9 > n || n > 15 || 0 > e || e > 9 || 0 > s || s > x ? E : (t.dstate = en, Ce = n, Se = 1 << Ce, Ie = Se - 1, Re = i + 7, Fe = 1 << Re, Oe = Fe - 1, De = Math.floor((Re + $ - 1) / $), ze = new Uint8Array(2 * Se), Te = [], Pe = [], an = 1 << i + 6, en.pending_buf = new Uint8Array(4 * an), qe = 4 * an, ln = Math.floor(an / 2), on = 3 * an, Xe = e, Ye = s, _e = 255 & r, be(t))
                }, en.deflateEnd = function() {
                    return ke != J && ke != V && ke != X ? E : (en.pending_buf = null, Pe = null, Te = null, ze = null, en.dstate = null, ke == V ? T : C)
                }, en.deflateParams = function(t, e, n) {
                    var r = C;
                    return e == v && (e = 6), 0 > e || e > 9 || 0 > n || n > x ? E : (N[Xe].func != N[e].func && 0 !== t.total_in && (r = t.deflate(_)), Xe != e && (Xe = e, Ve = N[Xe].max_lazy, Ze = N[Xe].good_length, Ke = N[Xe].nice_length, Je = N[Xe].max_chain), Ye = n, r)
                }, en.deflateSetDictionary = function(t, e, n) {
                    var r, i = n,
                        s = 0;
                    if (!e || ke != J) return E;
                    if ($ > i) return C;
                    for (i > Se - ee && (i = Se - ee, s = n - i), ze.set(e.subarray(s, s + i), 0), Me = i, je = i, Be = 255 & ze[0], Be = (Be << De ^ 255 & ze[1]) & Oe, r = 0; i - $ >= r; r++) Be = (Be << De ^ 255 & ze[r + ($ - 1)]) & Oe, Te[r & Ie] = Pe[Be], Pe[Be] = r;
                    return C
                }, en.deflate = function(t, e) {
                    var n, r, i, s, o;
                    if (e > S || 0 > e) return E;
                    if (!t.next_out || !t.next_in && 0 !== t.avail_in || ke == X && e != S) return t.msg = L[z - E], E;
                    if (0 === t.avail_out) return t.msg = L[z - P], P;
                    if (xe = t, s = Ae, Ae = e, ke == J && (r = Y + (Ce - 8 << 4) << 8, i = (Xe - 1 & 255) >> 1, i > 3 && (i = 3), r |= i << 6, 0 !== Me && (r |= G), r += 31 - r % 31, ke = V, B(r)), 0 !== en.pending) {
                        if (xe.flush_pending(), 0 === xe.avail_out) return Ae = -1, C
                    } else if (0 === xe.avail_in && s >= e && e != S) return xe.msg = L[z - P], P;
                    if (ke == X && 0 !== xe.avail_in) return t.msg = L[z - P], P;
                    if (0 !== xe.avail_in || 0 !== We || e != q && ke != X) {
                        switch (o = -1, N[Xe].func) {
                            case O:
                                o = we(e);
                                break;
                            case D:
                                o = ye(e);
                                break;
                            case j:
                                o = ve(e)
                        }
                        if ((o == H || o == W) && (ke = X), o == U || o == H) return 0 === xe.avail_out && (Ae = -1), C;
                        if (o == M) {
                            if (e == _) ae();
                            else if (he(0, 0, !1), e == A)
                                for (n = 0; Fe > n; n++) Pe[n] = 0;
                            if (xe.flush_pending(), 0 === xe.avail_out) return Ae = -1, C
                        }
                    }
                    return e != S ? C : I
                }
            }

            function s() {
                var t = this;
                t.next_in_index = 0, t.next_out_index = 0, t.avail_in = 0, t.total_in = 0, t.avail_out = 0, t.total_out = 0
            }
            var o = 15,
                a = 30,
                u = 19,
                l = 29,
                c = 256,
                f = c + 1 + l,
                h = 2 * f + 1,
                d = 256,
                p = 7,
                m = 16,
                w = 17,
                g = 18,
                y = 16,
                v = -1,
                b = 1,
                x = 2,
                k = 0,
                q = 0,
                _ = 1,
                A = 3,
                S = 4,
                C = 0,
                I = 1,
                z = 2,
                E = -2,
                T = -3,
                P = -5,
                B = [0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29];
            t._length_code = [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28], t.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0], t.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576], t.d_code = function(t) {
                return 256 > t ? B[t] : B[256 + (t >>> 7)]
            }, t.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], t.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], t.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], t.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], e.static_ltree = [12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8, 130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42, 8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8, 22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8, 222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113, 8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8, 69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8, 173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9, 51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9, 427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379, 9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23, 9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9, 399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9, 223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7, 40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8, 99, 8, 227, 8], e.static_dtree = [0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5, 25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5], e.static_l_desc = new e(e.static_ltree, t.extra_lbits, c + 1, f, o), e.static_d_desc = new e(e.static_dtree, t.extra_dbits, 0, a, o), e.static_bl_desc = new e(null, t.extra_blbits, 0, u, p);
            var F = 9,
                R = 8,
                O = 0,
                D = 1,
                j = 2,
                N = [new n(0, 0, 0, 0, O), new n(4, 4, 8, 4, D), new n(4, 5, 16, 8, D), new n(4, 6, 32, 32, D), new n(4, 4, 16, 16, j), new n(8, 16, 32, 32, j), new n(8, 16, 128, 128, j), new n(8, 32, 128, 256, j), new n(32, 128, 258, 1024, j), new n(32, 258, 258, 4096, j)],
                L = ["need dictionary", "stream end", "", "", "stream error", "data error", "", "buffer error", "", ""],
                U = 0,
                M = 1,
                H = 2,
                W = 3,
                G = 32,
                J = 42,
                V = 113,
                X = 666,
                Y = 8,
                Z = 0,
                K = 1,
                Q = 2,
                $ = 3,
                te = 258,
                ee = te + $ + 1;
            return s.prototype = {
                    deflateInit: function(t, e) {
                        var n = this;
                        return n.dstate = new i, e || (e = o), n.dstate.deflateInit(n, t, e)
                    },
                    deflate: function(t) {
                        var e = this;
                        return e.dstate ? e.dstate.deflate(e, t) : E
                    },
                    deflateEnd: function() {
                        var t = this;
                        if (!t.dstate) return E;
                        var e = t.dstate.deflateEnd();
                        return t.dstate = null, e
                    },
                    deflateParams: function(t, e) {
                        var n = this;
                        return n.dstate ? n.dstate.deflateParams(n, t, e) : E
                    },
                    deflateSetDictionary: function(t, e) {
                        var n = this;
                        return n.dstate ? n.dstate.deflateSetDictionary(n, t, e) : E
                    },
                    read_buf: function(t, e, n) {
                        var r = this,
                            i = r.avail_in;
                        return i > n && (i = n), 0 === i ? 0 : (r.avail_in -= i, t.set(r.next_in.subarray(r.next_in_index, r.next_in_index + i), e), r.next_in_index += i, r.total_in += i, i)
                    },
                    flush_pending: function() {
                        var t = this,
                            e = t.dstate.pending;
                        e > t.avail_out && (e = t.avail_out), 0 !== e && (t.next_out.set(t.dstate.pending_buf.subarray(t.dstate.pending_out, t.dstate.pending_out + e), t.next_out_index), t.next_out_index += e, t.dstate.pending_out += e, t.total_out += e, t.avail_out -= e, t.dstate.pending -= e, 0 === t.dstate.pending && (t.dstate.pending_out = 0))
                    }
                },
                function(t) {
                    var e = this,
                        n = new s,
                        r = 512,
                        i = q,
                        o = new Uint8Array(r);
                    "undefined" == typeof t && (t = v), n.deflateInit(t), n.next_out = o, e.append = function(t, e) {
                        var s, a, u = [],
                            l = 0,
                            c = 0,
                            f = 0;
                        if (t.length) {
                            n.next_in_index = 0, n.next_in = t, n.avail_in = t.length;
                            do {
                                if (n.next_out_index = 0, n.avail_out = r, s = n.deflate(i), s != C) throw "deflating: " + n.msg;
                                n.next_out_index && u.push(n.next_out_index == r ? new Uint8Array(o) : new Uint8Array(o.subarray(0, n.next_out_index))), f += n.next_out_index, e && n.next_in_index > 0 && n.next_in_index != l && (e(n.next_in_index), l = n.next_in_index)
                            } while (n.avail_in > 0 || 0 === n.avail_out);
                            return a = new Uint8Array(f), u.forEach(function(t) {
                                a.set(t, c), c += t.length
                            }), a
                        }
                    }, e.flush = function() {
                        var t, e, i = [],
                            s = 0,
                            a = 0;
                        do {
                            if (n.next_out_index = 0, n.avail_out = r, t = n.deflate(S), t != I && t != C) throw "deflating: " + n.msg;
                            r - n.avail_out > 0 && i.push(new Uint8Array(o.subarray(0, n.next_out_index))), a += n.next_out_index
                        } while (n.avail_in > 0 || 0 === n.avail_out);
                        return n.deflateEnd(), e = new Uint8Array(a), i.forEach(function(t) {
                            e.set(t, s), s += t.length
                        }), e
                    }
                }
        }(this),
        i = i || "undefined" != typeof navigator && navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator) || function(t) {
            "use strict";
            if ("undefined" == typeof navigator || !/MSIE [1-9]\./.test(navigator.userAgent)) {
                var e = t.document,
                    n = function() {
                        return t.URL || t.webkitURL || t
                    },
                    r = e.createElementNS("http://www.w3.org/1999/xhtml", "a"),
                    i = "download" in r,
                    s = function(n) {
                        var r = e.createEvent("MouseEvents");
                        r.initMouseEvent("click", !0, !1, t, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), n.dispatchEvent(r)
                    },
                    o = t.webkitRequestFileSystem,
                    a = t.requestFileSystem || o || t.mozRequestFileSystem,
                    u = function(e) {
                        (t.setImmediate || t.setTimeout)(function() {
                            throw e
                        }, 0)
                    },
                    l = "application/octet-stream",
                    c = 0,
                    f = 500,
                    h = function(e) {
                        var r = function() {
                            "string" == typeof e ? n().revokeObjectURL(e) : e.remove()
                        };
                        t.chrome ? r() : setTimeout(r, f)
                    },
                    d = function(t, e, n) {
                        e = [].concat(e);
                        for (var r = e.length; r--;) {
                            var i = t["on" + e[r]];
                            if ("function" == typeof i) try {
                                i.call(t, n || t)
                            } catch (s) {
                                u(s)
                            }
                        }
                    },
                    p = function(e, u) {
                        var f, p, m, w = this,
                            g = e.type,
                            y = !1,
                            v = function() {
                                d(w, "writestart progress write writeend".split(" "))
                            },
                            b = function() {
                                if ((y || !f) && (f = n().createObjectURL(e)), p) p.location.href = f;
                                else {
                                    var r = t.open(f, "_blank");
                                    void 0 == r && "undefined" != typeof safari && (t.location.href = f)
                                }
                                w.readyState = w.DONE, v(), h(f)
                            },
                            x = function(t) {
                                return function() {
                                    return w.readyState !== w.DONE ? t.apply(this, arguments) : void 0
                                }
                            },
                            k = {
                                create: !0,
                                exclusive: !1
                            };
                        return w.readyState = w.INIT, u || (u = "download"), i ? (f = n().createObjectURL(e), r.href = f, r.download = u, s(r), w.readyState = w.DONE, v(), void h(f)) : (t.chrome && g && g !== l && (m = e.slice || e.webkitSlice, e = m.call(e, 0, e.size, l), y = !0), o && "download" !== u && (u += ".download"), (g === l || o) && (p = t), a ? (c += e.size, void a(t.TEMPORARY, c, x(function(t) {
                            t.root.getDirectory("saved", k, x(function(t) {
                                var n = function() {
                                    t.getFile(u, k, x(function(t) {
                                        t.createWriter(x(function(n) {
                                            n.onwriteend = function(e) {
                                                p.location.href = t.toURL(), w.readyState = w.DONE, d(w, "writeend", e), h(t)
                                            }, n.onerror = function() {
                                                var t = n.error;
                                                t.code !== t.ABORT_ERR && b()
                                            }, "writestart progress write abort".split(" ").forEach(function(t) {
                                                n["on" + t] = w["on" + t]
                                            }), n.write(e), w.abort = function() {
                                                n.abort(), w.readyState = w.DONE
                                            }, w.readyState = w.WRITING
                                        }), b)
                                    }), b)
                                };
                                t.getFile(u, {
                                    create: !1
                                }, x(function(t) {
                                    t.remove(), n()
                                }), x(function(t) {
                                    t.code === t.NOT_FOUND_ERR ? n() : b()
                                }))
                            }), b)
                        }), b)) : void b())
                    },
                    m = p.prototype,
                    w = function(t, e) {
                        return new p(t, e)
                    };
                return m.abort = function() {
                    var t = this;
                    t.readyState = t.DONE, d(t, "abort")
                }, m.readyState = m.INIT = 0, m.WRITING = 1, m.DONE = 2, m.error = m.onwritestart = m.onprogress = m.onwrite = m.onabort = m.onerror = m.onwriteend = null, w
            }
        }("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);
    "undefined" != typeof module && module.exports && (module.exports.saveAs = i);
    var s = function() {
            function t() {
                this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = null
            }
            return t.prototype = {
                ensureBuffer: function(t) {
                    var e = this.buffer,
                        n = e ? e.byteLength : 0;
                    if (n > t) return e;
                    for (var r = 512; t > r;) r <<= 1;
                    for (var i = new Uint8Array(r), s = 0; n > s; ++s) i[s] = e[s];
                    return this.buffer = i
                },
                getByte: function() {
                    for (var t = this.pos; this.bufferLength <= t;) {
                        if (this.eof) return null;
                        this.readBlock()
                    }
                    return this.buffer[this.pos++]
                },
                getBytes: function(t) {
                    var e = this.pos;
                    if (t) {
                        this.ensureBuffer(e + t);
                        for (var n = e + t; !this.eof && this.bufferLength < n;) this.readBlock();
                        var r = this.bufferLength;
                        n > r && (n = r)
                    } else {
                        for (; !this.eof;) this.readBlock();
                        var n = this.bufferLength
                    }
                    return this.pos = n, this.buffer.subarray(e, n)
                },
                lookChar: function() {
                    for (var t = this.pos; this.bufferLength <= t;) {
                        if (this.eof) return null;
                        this.readBlock()
                    }
                    return String.fromCharCode(this.buffer[this.pos])
                },
                getChar: function() {
                    for (var t = this.pos; this.bufferLength <= t;) {
                        if (this.eof) return null;
                        this.readBlock()
                    }
                    return String.fromCharCode(this.buffer[this.pos++])
                },
                makeSubStream: function(t, e, n) {
                    for (var r = t + e; this.bufferLength <= r && !this.eof;) this.readBlock();
                    return new Stream(this.buffer, t, e, n)
                },
                skip: function(t) {
                    t || (t = 1), this.pos += t
                },
                reset: function() {
                    this.pos = 0
                }
            }, t
        }(),
        o = function() {
            function t(t) {
                throw new Error(t)
            }

            function e(e) {
                var n = 0,
                    r = e[n++],
                    i = e[n++];
                (-1 == r || -1 == i) && t("Invalid header in flate stream"), 8 != (15 & r) && t("Unknown compression method in flate stream"), ((r << 8) + i) % 31 != 0 && t("Bad FCHECK in flate stream"), 32 & i && t("FDICT bit set in flate stream"), this.bytes = e, this.bytesPos = n, this.codeSize = 0, this.codeBuf = 0, s.call(this)
            }
            if ("undefined" == typeof Uint32Array) return void 0;
            var n = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
                r = new Uint32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]),
                i = new Uint32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 658433, 724993, 727041, 794625, 798721, 868353, 876545]),
                o = [new Uint32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 59e4, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9],
                a = [new Uint32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
            return e.prototype = Object.create(s.prototype), e.prototype.getBits = function(e) {
                for (var n, r = this.codeSize, i = this.codeBuf, s = this.bytes, o = this.bytesPos; e > r;) "undefined" == typeof(n = s[o++]) && t("Bad encoding in flate stream"), i |= n << r, r += 8;
                return n = i & (1 << e) - 1, this.codeBuf = i >> e, this.codeSize = r -= e, this.bytesPos = o, n
            }, e.prototype.getCode = function(e) {
                for (var n = e[0], r = e[1], i = this.codeSize, s = this.codeBuf, o = this.bytes, a = this.bytesPos; r > i;) {
                    var u;
                    "undefined" == typeof(u = o[a++]) && t("Bad encoding in flate stream"), s |= u << i, i += 8
                }
                var l = n[s & (1 << r) - 1],
                    c = l >> 16,
                    f = 65535 & l;
                return (0 == i || c > i || 0 == c) && t("Bad encoding in flate stream"), this.codeBuf = s >> c, this.codeSize = i - c, this.bytesPos = a, f
            }, e.prototype.generateHuffmanTable = function(t) {
                for (var e = t.length, n = 0, r = 0; e > r; ++r) t[r] > n && (n = t[r]);
                for (var i = 1 << n, s = new Uint32Array(i), o = 1, a = 0, u = 2; n >= o; ++o, a <<= 1, u <<= 1)
                    for (var l = 0; e > l; ++l)
                        if (t[l] == o) {
                            for (var c = 0, f = a, r = 0; o > r; ++r) c = c << 1 | 1 & f, f >>= 1;
                            for (var r = c; i > r; r += u) s[r] = o << 16 | l;
                            ++a
                        }
                return [s, n]
            }, e.prototype.readBlock = function() {
                function e(t, e, n, r, i) {
                    for (var s = t.getBits(n) + r; s-- > 0;) e[q++] = i
                }
                var s = this.getBits(3);
                if (1 & s && (this.eof = !0), s >>= 1, 0 == s) {
                    var u, l = this.bytes,
                        c = this.bytesPos;
                    "undefined" == typeof(u = l[c++]) && t("Bad block header in flate stream");
                    var f = u;
                    "undefined" == typeof(u = l[c++]) && t("Bad block header in flate stream"), f |= u << 8, "undefined" == typeof(u = l[c++]) && t("Bad block header in flate stream");
                    var h = u;
                    "undefined" == typeof(u = l[c++]) && t("Bad block header in flate stream"), h |= u << 8, h != (65535 & ~f) && t("Bad uncompressed block length in flate stream"), this.codeBuf = 0, this.codeSize = 0;
                    var d = this.bufferLength,
                        p = this.ensureBuffer(d + f),
                        m = d + f;
                    this.bufferLength = m;
                    for (var w = d; m > w; ++w) {
                        if ("undefined" == typeof(u = l[c++])) {
                            this.eof = !0;
                            break
                        }
                        p[w] = u
                    }
                    return void(this.bytesPos = c)
                }
                var g, y;
                if (1 == s) g = o, y = a;
                else if (2 == s) {
                    for (var v = this.getBits(5) + 257, b = this.getBits(5) + 1, x = this.getBits(4) + 4, k = Array(n.length), q = 0; x > q;) k[n[q++]] = this.getBits(3);
                    for (var _ = this.generateHuffmanTable(k), A = 0, q = 0, S = v + b, C = new Array(S); S > q;) {
                        var I = this.getCode(_);
                        16 == I ? e(this, C, 2, 3, A) : 17 == I ? e(this, C, 3, 3, A = 0) : 18 == I ? e(this, C, 7, 11, A = 0) : C[q++] = A = I
                    }
                    g = this.generateHuffmanTable(C.slice(0, v)), y = this.generateHuffmanTable(C.slice(v, S))
                } else t("Unknown block type in flate stream");
                for (var p = this.buffer, z = p ? p.length : 0, E = this.bufferLength;;) {
                    var T = this.getCode(g);
                    if (256 > T) E + 1 >= z && (p = this.ensureBuffer(E + 1), z = p.length), p[E++] = T;
                    else {
                        if (256 == T) return void(this.bufferLength = E);
                        T -= 257, T = r[T];
                        var P = T >> 16;
                        P > 0 && (P = this.getBits(P));
                        var A = (65535 & T) + P;
                        T = this.getCode(y), T = i[T], P = T >> 16, P > 0 && (P = this.getBits(P));
                        var B = (65535 & T) + P;
                        E + A >= z && (p = this.ensureBuffer(E + A), z = p.length);
                        for (var F = 0; A > F; ++F, ++E) p[E] = p[E - B]
                    }
                }
            }, e
        }();
    ! function(t) {
        var e;
        e = function() {
            function e(t) {
                var e, n, r, i, s, o, a, u, l, c, f, h, d, p, m;
                for (this.data = t, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, o = null;;) {
                    switch (e = this.readUInt32(), c = function() {
                        var t, e;
                        for (e = [], a = t = 0; 4 > t; a = ++t) e.push(String.fromCharCode(this.data[this.pos++]));
                        return e
                    }.call(this).join("")) {
                        case "IHDR":
                            this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
                            break;
                        case "acTL":
                            this.animation = {
                                numFrames: this.readUInt32(),
                                numPlays: this.readUInt32() || 1 / 0,
                                frames: []
                            };
                            break;
                        case "PLTE":
                            this.palette = this.read(e);
                            break;
                        case "fcTL":
                            o && this.animation.frames.push(o), this.pos += 4, o = {
                                width: this.readUInt32(),
                                height: this.readUInt32(),
                                xOffset: this.readUInt32(),
                                yOffset: this.readUInt32()
                            }, s = this.readUInt16(), i = this.readUInt16() || 100, o.delay = 1e3 * s / i, o.disposeOp = this.data[this.pos++], o.blendOp = this.data[this.pos++], o.data = [];
                            break;
                        case "IDAT":
                        case "fdAT":
                            for ("fdAT" === c && (this.pos += 4, e -= 4), t = (null != o ? o.data : void 0) || this.imgData, a = d = 0; e >= 0 ? e > d : d > e; a = e >= 0 ? ++d : --d) t.push(this.data[this.pos++]);
                            break;
                        case "tRNS":
                            switch (this.transparency = {}, this.colorType) {
                                case 3:
                                    if (r = this.palette.length / 3, this.transparency.indexed = this.read(e), this.transparency.indexed.length > r) throw new Error("More transparent colors than palette size");
                                    if (f = r - this.transparency.indexed.length, f > 0)
                                        for (a = p = 0; f >= 0 ? f > p : p > f; a = f >= 0 ? ++p : --p) this.transparency.indexed.push(255);
                                    break;
                                case 0:
                                    this.transparency.grayscale = this.read(e)[0];
                                    break;
                                case 2:
                                    this.transparency.rgb = this.read(e)
                            }
                            break;
                        case "tEXt":
                            h = this.read(e), u = h.indexOf(0), l = String.fromCharCode.apply(String, h.slice(0, u)), this.text[l] = String.fromCharCode.apply(String, h.slice(u + 1));
                            break;
                        case "IEND":
                            return o && this.animation.frames.push(o), this.colors = function() {
                                switch (this.colorType) {
                                    case 0:
                                    case 3:
                                    case 4:
                                        return 1;
                                    case 2:
                                    case 6:
                                        return 3
                                }
                            }.call(this), this.hasAlphaChannel = 4 === (m = this.colorType) || 6 === m, n = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * n, this.colorSpace = function() {
                                switch (this.colors) {
                                    case 1:
                                        return "DeviceGray";
                                    case 3:
                                        return "DeviceRGB"
                                }
                            }.call(this), void(this.imgData = new Uint8Array(this.imgData));
                        default:
                            this.pos += e
                    }
                    if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file")
                }
            }
            var n, r, i, s, a, u, l, c;
            e.load = function(t, n, r) {
                var i;
                return "function" == typeof n && (r = n), i = new XMLHttpRequest, i.open("GET", t, !0), i.responseType = "arraybuffer", i.onload = function() {
                    var t, s;
                    return t = new Uint8Array(i.response || i.mozResponseArrayBuffer), s = new e(t), "function" == typeof(null != n ? n.getContext : void 0) && s.render(n), "function" == typeof r ? r(s) : void 0
                }, i.send(null)
            }, s = 0, i = 1, a = 2, r = 0, n = 1, e.prototype.read = function(t) {
                var e, n, r;
                for (r = [], e = n = 0; t >= 0 ? t > n : n > t; e = t >= 0 ? ++n : --n) r.push(this.data[this.pos++]);
                return r
            }, e.prototype.readUInt32 = function() {
                var t, e, n, r;
                return t = this.data[this.pos++] << 24, e = this.data[this.pos++] << 16, n = this.data[this.pos++] << 8, r = this.data[this.pos++], t | e | n | r
            }, e.prototype.readUInt16 = function() {
                var t, e;
                return t = this.data[this.pos++] << 8, e = this.data[this.pos++], t | e
            }, e.prototype.decodePixels = function(t) {
                var e, n, r, i, s, a, u, l, c, f, h, d, p, m, w, g, y, v, b, x, k, q, _;
                if (null == t && (t = this.imgData), 0 === t.length) return new Uint8Array(0);
                for (t = new o(t), t = t.getBytes(), d = this.pixelBitlength / 8, g = d * this.width, p = new Uint8Array(g * this.height), a = t.length, w = 0, m = 0, n = 0; a > m;) {
                    switch (t[m++]) {
                        case 0:
                            for (i = b = 0; g > b; i = b += 1) p[n++] = t[m++];
                            break;
                        case 1:
                            for (i = x = 0; g > x; i = x += 1) e = t[m++], s = d > i ? 0 : p[n - d], p[n++] = (e + s) % 256;
                            break;
                        case 2:
                            for (i = k = 0; g > k; i = k += 1) e = t[m++], r = (i - i % d) / d, y = w && p[(w - 1) * g + r * d + i % d], p[n++] = (y + e) % 256;
                            break;
                        case 3:
                            for (i = q = 0; g > q; i = q += 1) e = t[m++], r = (i - i % d) / d, s = d > i ? 0 : p[n - d], y = w && p[(w - 1) * g + r * d + i % d], p[n++] = (e + Math.floor((s + y) / 2)) % 256;
                            break;
                        case 4:
                            for (i = _ = 0; g > _; i = _ += 1) e = t[m++], r = (i - i % d) / d, s = d > i ? 0 : p[n - d], 0 === w ? y = v = 0 : (y = p[(w - 1) * g + r * d + i % d], v = r && p[(w - 1) * g + (r - 1) * d + i % d]), u = s + y - v, l = Math.abs(u - s), f = Math.abs(u - y), h = Math.abs(u - v), c = f >= l && h >= l ? s : h >= f ? y : v, p[n++] = (e + c) % 256;
                            break;
                        default:
                            throw new Error("Invalid filter algorithm: " + t[m - 1])
                    }
                    w++
                }
                return p
            }, e.prototype.decodePalette = function() {
                var t, e, n, r, i, s, o, a, u, l;
                for (r = this.palette, o = this.transparency.indexed || [], s = new Uint8Array((o.length || 0) + r.length), i = 0, n = r.length, t = 0, e = a = 0, u = r.length; u > a; e = a += 3) s[i++] = r[e], s[i++] = r[e + 1], s[i++] = r[e + 2], s[i++] = null != (l = o[t++]) ? l : 255;
                return s
            }, e.prototype.copyToImageData = function(t, e) {
                var n, r, i, s, o, a, u, l, c, f, h;
                if (r = this.colors, c = null, n = this.hasAlphaChannel, this.palette.length && (c = null != (h = this._decodedPalette) ? h : this._decodedPalette = this.decodePalette(), r = 4, n = !0), i = t.data || t, l = i.length, o = c || e, s = a = 0, 1 === r)
                    for (; l > s;) u = c ? 4 * e[s / 4] : a, f = o[u++], i[s++] = f, i[s++] = f, i[s++] = f, i[s++] = n ? o[u++] : 255, a = u;
                else
                    for (; l > s;) u = c ? 4 * e[s / 4] : a, i[s++] = o[u++], i[s++] = o[u++], i[s++] = o[u++], i[s++] = n ? o[u++] : 255, a = u
            }, e.prototype.decode = function() {
                var t;
                return t = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t, this.decodePixels()), t
            };
            try {
                l = t.document.createElement("canvas"), c = l.getContext("2d")
            } catch (f) {
                return -1
            }
            return u = function(t) {
                var e;
                return c.width = t.width, c.height = t.height, c.clearRect(0, 0, t.width, t.height), c.putImageData(t, 0, 0), e = new Image, e.src = l.toDataURL(), e
            }, e.prototype.decodeFrames = function(t) {
                var e, n, r, i, s, o, a, l;
                if (this.animation) {
                    for (a = this.animation.frames, l = [], n = s = 0, o = a.length; o > s; n = ++s) e = a[n], r = t.createImageData(e.width, e.height), i = this.decodePixels(new Uint8Array(e.data)), this.copyToImageData(r, i), e.imageData = r, l.push(e.image = u(r));
                    return l
                }
            }, e.prototype.renderFrame = function(t, e) {
                var n, s, o;
                return s = this.animation.frames, n = s[e], o = s[e - 1], 0 === e && t.clearRect(0, 0, this.width, this.height), (null != o ? o.disposeOp : void 0) === i ? t.clearRect(o.xOffset, o.yOffset, o.width, o.height) : (null != o ? o.disposeOp : void 0) === a && t.putImageData(o.imageData, o.xOffset, o.yOffset), n.blendOp === r && t.clearRect(n.xOffset, n.yOffset, n.width, n.height), t.drawImage(n.image, n.xOffset, n.yOffset)
            }, e.prototype.animate = function(t) {
                var e, n, r, i, s, o, a = this;
                return n = 0, o = this.animation, i = o.numFrames, r = o.frames, s = o.numPlays, (e = function() {
                    var o, u;
                    return o = n++ % i, u = r[o], a.renderFrame(t, o), i > 1 && s > n / i ? a.animation._timeout = setTimeout(e, u.delay) : void 0
                })()
            }, e.prototype.stopAnimation = function() {
                var t;
                return clearTimeout(null != (t = this.animation) ? t._timeout : void 0)
            }, e.prototype.render = function(t) {
                var e, n;
                return t._png && t._png.stopAnimation(), t._png = this, t.width = this.width, t.height = this.height, e = t.getContext("2d"), this.animation ? (this.decodeFrames(e), this.animate(e)) : (n = e.createImageData(this.width, this.height), this.copyToImageData(n, this.decodePixels()), e.putImageData(n, 0, 0))
            }, e
        }(), t.PNG = e
    }("undefined" != typeof window && window || this),
    function(t) {
        var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        "undefined" == typeof t.btoa && (t.btoa = function(t) {
            var n, r, i, s, o, a, u, l, c = 0,
                f = 0,
                h = "",
                d = [];
            if (!t) return t;
            do n = t.charCodeAt(c++), r = t.charCodeAt(c++), i = t.charCodeAt(c++), l = n << 16 | r << 8 | i, s = l >> 18 & 63, o = l >> 12 & 63, a = l >> 6 & 63, u = 63 & l, d[f++] = e.charAt(s) + e.charAt(o) + e.charAt(a) + e.charAt(u); while (c < t.length);
            h = d.join("");
            var p = t.length % 3;
            return (p ? h.slice(0, p - 3) : h) + "===".slice(p || 3)
        }), "undefined" == typeof t.atob && (t.atob = function(t) {
            var n, r, i, s, o, a, u, l, c = 0,
                f = 0,
                h = "",
                d = [];
            if (!t) return t;
            t += "";
            do s = e.indexOf(t.charAt(c++)), o = e.indexOf(t.charAt(c++)), a = e.indexOf(t.charAt(c++)), u = e.indexOf(t.charAt(c++)), l = s << 18 | o << 12 | a << 6 | u, n = l >> 16 & 255, r = l >> 8 & 255, i = 255 & l, d[f++] = 64 == a ? String.fromCharCode(n) : 64 == u ? String.fromCharCode(n, r) : String.fromCharCode(n, r, i); while (c < t.length);
            return h = d.join("")
        }), Array.prototype.map || (Array.prototype.map = function(t) {
            if (void 0 === this || null === this || "function" != typeof t) throw new TypeError;
            for (var e = Object(this), n = e.length >>> 0, r = new Array(n), i = arguments.length > 1 ? arguments[1] : void 0, s = 0; n > s; s++) s in e && (r[s] = t.call(i, e[s], s, e));
            return r
        }), Array.isArray || (Array.isArray = function(t) {
            return "[object Array]" === Object.prototype.toString.call(t)
        }), Array.prototype.forEach || (Array.prototype.forEach = function(t, e) {
            "use strict";
            if (void 0 === this || null === this || "function" != typeof t) throw new TypeError;
            for (var n = Object(this), r = n.length >>> 0, i = 0; r > i; i++) i in n && t.call(e, n[i], i, n)
        }), Object.keys || (Object.keys = function() {
            "use strict";
            var t = Object.prototype.hasOwnProperty,
                e = !{
                    toString: null
                }.propertyIsEnumerable("toString"),
                n = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
                r = n.length;
            return function(i) {
                if ("object" != typeof i && ("function" != typeof i || null === i)) throw new TypeError;
                var s, o, a = [];
                for (s in i) t.call(i, s) && a.push(s);
                if (e)
                    for (o = 0; r > o; o++) t.call(i, n[o]) && a.push(n[o]);
                return a
            }
        }()), String.prototype.trim || (String.prototype.trim = function() {
            return this.replace(/^\s+|\s+$/g, "")
        }), String.prototype.trimLeft || (String.prototype.trimLeft = function() {
            return this.replace(/^\s+/g, "")
        }), String.prototype.trimRight || (String.prototype.trimRight = function() {
            return this.replace(/\s+$/g, "")
        })
    }("undefined" != typeof self && self || "undefined" != typeof window && window || this)
}({}, function() {
    return this
}());;
(function(jsPDFAPI) {
    'use strict'
    var doesNotHavePngJS = function() {
            return typeof PNG !== 'function' || typeof FlateStream !== 'function';
        },
        canCompress = function(value) {
            return value !== jsPDFAPI.image_compression.NONE && hasCompressionJS();
        },
        hasCompressionJS = function() {
            var inst = typeof Deflater === 'function';
            if (!inst)
                throw new Error("requires deflate.js for compression")
            return inst;
        },
        compressBytes = function(bytes, lineLength, colorsPerPixel, compression) {
            var level = 5,
                filter_method = filterUp;
            switch (compression) {
                case jsPDFAPI.image_compression.FAST:
                    level = 3;
                    filter_method = filterSub;
                    break;
                case jsPDFAPI.image_compression.MEDIUM:
                    level = 6;
                    filter_method = filterAverage;
                    break;
                case jsPDFAPI.image_compression.SLOW:
                    level = 9;
                    filter_method = filterPaeth;
                    break;
            }
            bytes = applyPngFilterMethod(bytes, lineLength, colorsPerPixel, filter_method);
            var header = new Uint8Array(createZlibHeader(level));
            var checksum = adler32(bytes);
            var deflate = new Deflater(level);
            var a = deflate.append(bytes);
            var cBytes = deflate.flush();
            var len = header.length + a.length + cBytes.length;
            var cmpd = new Uint8Array(len + 4);
            cmpd.set(header);
            cmpd.set(a, header.length);
            cmpd.set(cBytes, header.length + a.length);
            cmpd[len++] = (checksum >>> 24) & 0xff;
            cmpd[len++] = (checksum >>> 16) & 0xff;
            cmpd[len++] = (checksum >>> 8) & 0xff;
            cmpd[len++] = checksum & 0xff;
            return jsPDFAPI.arrayBufferToBinaryString(cmpd);
        },
        createZlibHeader = function(bytes, level) {
            var cm = 8;
            var cinfo = Math.LOG2E * Math.log(0x8000) - 8;
            var cmf = (cinfo << 4) | cm;
            var hdr = cmf << 8;
            var flevel = Math.min(3, ((level - 1) & 0xff) >> 1);
            hdr |= (flevel << 6);
            hdr |= 0;
            hdr += 31 - (hdr % 31);
            return [cmf, (hdr & 0xff) & 0xff];
        },
        adler32 = function(array, param) {
            var adler = 1;
            var s1 = adler & 0xffff,
                s2 = (adler >>> 16) & 0xffff;
            var len = array.length;
            var tlen;
            var i = 0;
            while (len > 0) {
                tlen = len > param ? param : len;
                len -= tlen;
                do {
                    s1 += array[i++];
                    s2 += s1;
                } while (--tlen);
                s1 %= 65521;
                s2 %= 65521;
            }
            return ((s2 << 16) | s1) >>> 0;
        },
        applyPngFilterMethod = function(bytes, lineLength, colorsPerPixel, filter_method) {
            var lines = bytes.length / lineLength,
                result = new Uint8Array(bytes.length + lines),
                filter_methods = getFilterMethods(),
                i = 0,
                line, prevLine, offset;
            for (; i < lines; i++) {
                offset = i * lineLength;
                line = bytes.subarray(offset, offset + lineLength);
                if (filter_method) {
                    result.set(filter_method(line, colorsPerPixel, prevLine), offset + i);
                } else {
                    var j = 0,
                        len = filter_methods.length,
                        results = [];
                    for (; j < len; j++)
                        results[j] = filter_methods[j](line, colorsPerPixel, prevLine);
                    var ind = getIndexOfSmallestSum(results.concat());
                    result.set(results[ind], offset + i);
                }
                prevLine = line;
            }
            return result;
        },
        filterNone = function(line, colorsPerPixel, prevLine) {
            var result = Array.apply([], line);
            result.unshift(0);
            return result;
        },
        filterSub = function(line, colorsPerPixel, prevLine) {
            var result = [],
                i = 0,
                len = line.length,
                left;
            result[0] = 1;
            for (; i < len; i++) {
                left = line[i - colorsPerPixel] || 0;
                result[i + 1] = (line[i] - left + 0x0100) & 0xff;
            }
            return result;
        },
        filterUp = function(line, colorsPerPixel, prevLine) {
            var result = [],
                i = 0,
                len = line.length,
                up;
            result[0] = 2;
            for (; i < len; i++) {
                up = prevLine && prevLine[i] || 0;
                result[i + 1] = (line[i] - up + 0x0100) & 0xff;
            }
            return result;
        },
        filterAverage = function(line, colorsPerPixel, prevLine) {
            var result = [],
                i = 0,
                len = line.length,
                left, up;
            result[0] = 3;
            for (; i < len; i++) {
                left = line[i - colorsPerPixel] || 0;
                up = prevLine && prevLine[i] || 0;
                result[i + 1] = (line[i] + 0x0100 - ((left + up) >>> 1)) & 0xff;
            }
            return result;
        },
        filterPaeth = function(line, colorsPerPixel, prevLine) {
            var result = [],
                i = 0,
                len = line.length,
                left, up, upLeft, paeth;
            result[0] = 4;
            for (; i < len; i++) {
                left = line[i - colorsPerPixel] || 0;
                up = prevLine && prevLine[i] || 0;
                upLeft = prevLine && prevLine[i - colorsPerPixel] || 0;
                paeth = paethPredictor(left, up, upLeft);
                result[i + 1] = (line[i] - paeth + 0x0100) & 0xff;
            }
            return result;
        },
        paethPredictor = function(left, up, upLeft) {
            var p = left + up - upLeft,
                pLeft = Math.abs(p - left),
                pUp = Math.abs(p - up),
                pUpLeft = Math.abs(p - upLeft);
            return (pLeft <= pUp && pLeft <= pUpLeft) ? left : (pUp <= pUpLeft) ? up : upLeft;
        },
        getFilterMethods = function() {
            return [filterNone, filterSub, filterUp, filterAverage, filterPaeth];
        },
        getIndexOfSmallestSum = function(arrays) {
            var i = 0,
                len = arrays.length,
                sum, min, ind;
            while (i < len) {
                sum = absSum(arrays[i].slice(1));
                if (sum < min || !min) {
                    min = sum;
                    ind = i;
                }
                i++;
            }
            return ind;
        },
        absSum = function(array) {
            var i = 0,
                len = array.length,
                sum = 0;
            while (i < len)
                sum += Math.abs(array[i++]);
            return sum;
        },
        logImg = function(img) {
            console.log("width: " + img.width);
            console.log("height: " + img.height);
            console.log("bits: " + img.bits);
            console.log("colorType: " + img.colorType);
            console.log("transparency:");
            console.log(img.transparency);
            console.log("text:");
            console.log(img.text);
            console.log("compressionMethod: " + img.compressionMethod);
            console.log("filterMethod: " + img.filterMethod);
            console.log("interlaceMethod: " + img.interlaceMethod);
            console.log("imgData:");
            console.log(img.imgData);
            console.log("palette:");
            console.log(img.palette);
            console.log("colors: " + img.colors);
            console.log("colorSpace: " + img.colorSpace);
            console.log("pixelBitlength: " + img.pixelBitlength);
            console.log("hasAlphaChannel: " + img.hasAlphaChannel);
        };
    jsPDFAPI.processPNG = function(imageData, imageIndex, alias, compression, dataAsBinaryString) {
        'use strict'
        var colorSpace = this.color_spaces.DEVICE_RGB,
            decode = this.decode.FLATE_DECODE,
            bpc = 8,
            img, dp, trns, colors, pal, smask;
        if (this.isArrayBuffer(imageData))
            imageData = new Uint8Array(imageData);
        if (this.isArrayBufferView(imageData)) {
            if (doesNotHavePngJS())
                throw new Error("PNG support requires png.js and zlib.js");
            img = new PNG(imageData);
            imageData = img.imgData;
            bpc = img.bits;
            colorSpace = img.colorSpace;
            colors = img.colors;
            if ([4, 6].indexOf(img.colorType) !== -1) {
                if (img.bits === 8) {
                    var pixels = img.pixelBitlength == 32 ? new Uint32Array(img.decodePixels().buffer) : img.pixelBitlength == 16 ? new Uint16Array(img.decodePixels().buffer) : new Uint8Array(img.decodePixels().buffer),
                        len = pixels.length,
                        imgData = new Uint8Array(len * img.colors),
                        alphaData = new Uint8Array(len),
                        pDiff = img.pixelBitlength - img.bits,
                        i = 0,
                        n = 0,
                        pixel, pbl;
                    for (; i < len; i++) {
                        pixel = pixels[i];
                        pbl = 0;
                        while (pbl < pDiff) {
                            imgData[n++] = (pixel >>> pbl) & 0xff;
                            pbl = pbl + img.bits;
                        }
                        alphaData[i] = (pixel >>> pbl) & 0xff;
                    }
                }
                if (img.bits === 16) {
                    var pixels = new Uint32Array(img.decodePixels().buffer),
                        len = pixels.length,
                        imgData = new Uint8Array((len * (32 / img.pixelBitlength)) * img.colors),
                        alphaData = new Uint8Array(len * (32 / img.pixelBitlength)),
                        hasColors = img.colors > 1,
                        i = 0,
                        n = 0,
                        a = 0,
                        pixel;
                    while (i < len) {
                        pixel = pixels[i++];
                        imgData[n++] = (pixel >>> 0) & 0xFF;
                        if (hasColors) {
                            imgData[n++] = (pixel >>> 16) & 0xFF;
                            pixel = pixels[i++];
                            imgData[n++] = (pixel >>> 0) & 0xFF;
                        }
                        alphaData[a++] = (pixel >>> 16) & 0xFF;
                    }
                    bpc = 8;
                }
                if (canCompress(compression)) {
                    imageData = compressBytes(imgData, img.width * img.colors, img.colors, compression);
                    smask = compressBytes(alphaData, img.width, 1, compression);
                } else {
                    imageData = imgData;
                    smask = alphaData;
                    decode = null;
                }
            }
            if (img.colorType === 3) {
                colorSpace = this.color_spaces.INDEXED;
                pal = img.palette;
                if (img.transparency.indexed) {
                    var trans = img.transparency.indexed;
                    var total = 0,
                        i = 0,
                        len = trans.length;
                    for (; i < len; ++i)
                        total += trans[i];
                    total = total / 255;
                    if (total === len - 1 && trans.indexOf(0) !== -1) {
                        trns = [trans.indexOf(0)];
                    } else if (total !== len) {
                        var pixels = img.decodePixels(),
                            alphaData = new Uint8Array(pixels.length),
                            i = 0,
                            len = pixels.length;
                        for (; i < len; i++)
                            alphaData[i] = trans[pixels[i]];
                        smask = compressBytes(alphaData, img.width, 1);
                    }
                }
            }
            if (decode === this.decode.FLATE_DECODE)
                dp = '/Predictor 15 /Colors ' + colors + ' /BitsPerComponent ' + bpc + ' /Columns ' + img.width;
            else
                dp = '/Colors ' + colors + ' /BitsPerComponent ' + bpc + ' /Columns ' + img.width;
            if (this.isArrayBuffer(imageData) || this.isArrayBufferView(imageData))
                imageData = this.arrayBufferToBinaryString(imageData);
            if (smask && this.isArrayBuffer(smask) || this.isArrayBufferView(smask))
                smask = this.arrayBufferToBinaryString(smask);
            return this.createImageInfo(imageData, img.width, img.height, colorSpace, bpc, decode, imageIndex, alias, dp, trns, pal, smask);
        }
        throw new Error("Unsupported PNG image data, try using JPEG instead.");
    }
})(jsPDF.API);
(function(window, document, exports, global, define, undefined) {
    (function() {
        function r(a, b) {
            n[l] = a;
            n[l + 1] = b;
            l += 2;
            2 === l && A()
        }

        function s(a) {
            return "function" === typeof a
        }

        function F() {
            return function() {
                process.nextTick(t)
            }
        }

        function G() {
            var a = 0,
                b = new B(t),
                c = document.createTextNode("");
            b.observe(c, {
                characterData: !0
            });
            return function() {
                c.data = a = ++a % 2
            }
        }

        function H() {
            var a = new MessageChannel;
            a.port1.onmessage = t;
            return function() {
                a.port2.postMessage(0)
            }
        }

        function I() {
            return function() {
                setTimeout(t, 1)
            }
        }

        function t() {
            for (var a = 0; a < l; a += 2) {
                (0, n[a])(n[a + 1]), n[a] = void 0, n[a + 1] = void 0;
            }
            l = 0
        }

        function p() {}

        function J(a, b, c, d) {
            try {
                a.call(b, c, d)
            } catch (e) {
                return e
            }
        }

        function K(a, b, c) {
            r(function(a) {
                var e = !1,
                    f = J(c, b, function(c) {
                        e || (e = !0, b !== c ? q(a, c) : m(a, c))
                    }, function(b) {
                        e || (e = !0, g(a, b))
                    });
                !e && f && (e = !0, g(a, f))
            }, a)
        }

        function L(a, b) {
            1 === b.a ? m(a, b.b) : 2 === a.a ? g(a, b.b) : u(b, void 0, function(b) {
                q(a, b)
            }, function(b) {
                g(a, b)
            })
        }

        function q(a, b) {
            if (a === b) {
                g(a, new TypeError("You cannot resolve a promise with itself"));
            } else if ("function" === typeof b || "object" === typeof b && null !== b) {
                if (b.constructor === a.constructor) {
                    L(a, b);
                } else {
                    var c;
                    try {
                        c = b.then
                    } catch (d) {
                        v.error = d, c = v
                    }
                    c === v ? g(a, v.error) : void 0 === c ? m(a, b) : s(c) ? K(a, b, c) : m(a, b)
                }
            } else {
                m(a, b)
            }
        }

        function M(a) {
            a.f && a.f(a.b);
            x(a)
        }

        function m(a, b) {
            void 0 === a.a && (a.b = b, a.a = 1, 0 !== a.e.length && r(x, a))
        }

        function g(a, b) {
            void 0 === a.a && (a.a = 2, a.b = b, r(M, a))
        }

        function u(a, b, c, d) {
            var e = a.e,
                f = e.length;
            a.f = null;
            e[f] = b;
            e[f + 1] = c;
            e[f + 2] = d;
            0 === f && a.a && r(x, a)
        }

        function x(a) {
            var b = a.e,
                c = a.a;
            if (0 !== b.length) {
                for (var d, e, f = a.b, g = 0; g < b.length; g += 3) {
                    d = b[g], e = b[g + c], d ? C(c, d, e, f) : e(f);
                }
                a.e.length = 0
            }
        }

        function D() {
            this.error = null
        }

        function C(a, b, c, d) {
            var e = s(c),
                f, k, h, l;
            if (e) {
                try {
                    f = c(d)
                } catch (n) {
                    y.error = n, f = y
                }
                f === y ? (l = !0, k = f.error, f = null) : h = !0;
                if (b === f) {
                    g(b, new TypeError("A promises callback cannot return that same promise."));
                    return
                }
            } else {
                f = d, h = !0;
            }
            void 0 === b.a && (e && h ? q(b, f) : l ? g(b, k) : 1 === a ? m(b, f) : 2 === a && g(b, f))
        }

        function N(a, b) {
            try {
                b(function(b) {
                    q(a, b)
                }, function(b) {
                    g(a, b)
                })
            } catch (c) {
                g(a, c)
            }
        }

        function k(a, b, c, d) {
            this.n = a;
            this.c = new a(p, d);
            this.i = c;
            this.o(b) ? (this.m = b, this.d = this.length = b.length, this.l(), 0 === this.length ? m(this.c, this.b) : (this.length = this.length || 0, this.k(), 0 === this.d && m(this.c, this.b))) : g(this.c, this.p())
        }

        function h(a) {
            O++;
            this.b = this.a = void 0;
            this.e = [];
            if (p !== a) {
                if (!s(a)) {
                    throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
                }
                if (!(this instanceof h)) {
                    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                }
                N(this, a)
            }
        }
        var E = Array.isArray ? Array.isArray : function(a) {
                return "[object Array]" === Object.prototype.toString.call(a)
            },
            l = 0,
            w = "undefined" !== typeof window ? window : {},
            B = w.MutationObserver || w.WebKitMutationObserver,
            w = "undefined" !== typeof Uint8ClampedArray && "undefined" !== typeof importScripts && "undefined" !== typeof MessageChannel,
            n = Array(1E3),
            A;
        A = "undefined" !== typeof process && "[object process]" === {}.toString.call(process) ? F() : B ? G() : w ? H() : I();
        var v = new D,
            y = new D;
        k.prototype.o = function(a) {
            return E(a)
        };
        k.prototype.p = function() {
            return Error("Array Methods must be provided an Array")
        };
        k.prototype.l = function() {
            this.b = Array(this.length)
        };
        k.prototype.k = function() {
            for (var a = this.length, b = this.c, c = this.m, d = 0; void 0 === b.a && d < a; d++) {
                this.j(c[d], d)
            }
        };
        k.prototype.j = function(a, b) {
            var c = this.n;
            "object" === typeof a && null !== a ? a.constructor === c && void 0 !== a.a ? (a.f = null, this.g(a.a, b, a.b)) : this.q(c.resolve(a), b) : (this.d--, this.b[b] = this.h(a))
        };
        k.prototype.g = function(a, b, c) {
            var d = this.c;
            void 0 === d.a && (this.d--, this.i && 2 === a ? g(d, c) : this.b[b] = this.h(c));
            0 === this.d && m(d, this.b)
        };
        k.prototype.h = function(a) {
            return a
        };
        k.prototype.q = function(a, b) {
            var c = this;
            u(a, void 0, function(a) {
                c.g(1, b, a)
            }, function(a) {
                c.g(2, b, a)
            })
        };
        var O = 0;
        h.all = function(a, b) {
            return (new k(this, a, !0, b)).c
        };
        h.race = function(a, b) {
            function c(a) {
                q(e, a)
            }

            function d(a) {
                g(e, a)
            }
            var e = new this(p, b);
            if (!E(a)) {
                return (g(e, new TypeError("You must pass an array to race.")), e);
            }
            for (var f = a.length, h = 0; void 0 === e.a && h < f; h++) {
                u(this.resolve(a[h]), void 0, c, d);
            }
            return e
        };
        h.resolve = function(a, b) {
            if (a && "object" === typeof a && a.constructor === this) {
                return a;
            }
            var c = new this(p, b);
            q(c, a);
            return c
        };
        h.reject = function(a, b) {
            var c = new this(p, b);
            g(c, a);
            return c
        };
        h.prototype = {
            constructor: h,
            then: function(a, b) {
                var c = this.a;
                if (1 === c && !a || 2 === c && !b) {
                    return this;
                }
                var d = new this.constructor(p),
                    e = this.b;
                if (c) {
                    var f = arguments[c - 1];
                    r(function() {
                        C(c, d, f, e)
                    })
                } else {
                    u(this, d, a, b);
                }
                return d
            },
            "catch": function(a) {
                return this.then(null, a)
            }
        };
        var z = {
            Promise: h,
            polyfill: function() {
                var a;
                a = "undefined" !== typeof global ? global : "undefined" !== typeof window && window.document ? window : self;
                "Promise" in a && "resolve" in
                    a.Promise && "reject" in a.Promise && "all" in a.Promise && "race" in a.Promise && function() {
                        var b;
                        new a.Promise(function(a) {
                            b = a
                        });
                        return s(b)
                    }() || (a.Promise = h)
            }
        };
        "function" === typeof define && define.amd ? define(function() {
            return z
        }) : "undefined" !== typeof module && module.exports ? module.exports = z : "undefined" !== typeof this && (this.ES6Promise = z);
    }).call(window);
    if (window) {
        window.ES6Promise.polyfill();
    }
    if (typeof(document) === "undefined" || typeof(Object.create) !== "function" || typeof(document.createElement("canvas").getContext) !== "function") {
        (window || module.exports).html2canvas = function() {
            return Promise.reject("No canvas support");
        };
        return;
    };
    (function(root) {
        var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
        var freeModule = typeof module == 'object' && module && !module.nodeType && module;
        var freeGlobal = typeof global == 'object' && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
            root = freeGlobal;
        }
        var punycode, maxInt = 2147483647,
            base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128,
            delimiter = '-',
            regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/,
            regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
            errors = {
                'overflow': 'Overflow: input needs wider integers to process',
                'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                'invalid-input': 'Invalid input'
            },
            baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,
            key;

        function error(type) {
            throw RangeError(errors[type]);
        }

        function map(array, fn) {
            var length = array.length;
            var result = [];
            while (length--) {
                result[length] = fn(array[length]);
            }
            return result;
        }

        function mapDomain(string, fn) {
            var parts = string.split('@');
            var result = '';
            if (parts.length > 1) {
                result = parts[0] + '@';
                string = parts[1];
            }
            var labels = string.split(regexSeparators);
            var encoded = map(labels, fn).join('.');
            return result + encoded;
        }

        function ucs2decode(string) {
            var output = [],
                counter = 0,
                length = string.length,
                value, extra;
            while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                    extra = string.charCodeAt(counter++);
                    if ((extra & 0xFC00) == 0xDC00) {
                        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                    } else {
                        output.push(value);
                        counter--;
                    }
                } else {
                    output.push(value);
                }
            }
            return output;
        }

        function ucs2encode(array) {
            return map(array, function(value) {
                var output = '';
                if (value > 0xFFFF) {
                    value -= 0x10000;
                    output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                    value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
                return output;
            }).join('');
        }

        function basicToDigit(codePoint) {
            if (codePoint - 48 < 10) {
                return codePoint - 22;
            }
            if (codePoint - 65 < 26) {
                return codePoint - 65;
            }
            if (codePoint - 97 < 26) {
                return codePoint - 97;
            }
            return base;
        }

        function digitToBasic(digit, flag) {
            return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }

        function adapt(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                delta = floor(delta / baseMinusTMin);
            }
            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }

        function decode(input) {
            var output = [],
                inputLength = input.length,
                out, i = 0,
                n = initialN,
                bias = initialBias,
                basic, j, index, oldi, w, k, digit, t, baseMinusT;
            basic = input.lastIndexOf(delimiter);
            if (basic < 0) {
                basic = 0;
            }
            for (j = 0; j < basic; ++j) {
                if (input.charCodeAt(j) >= 0x80) {
                    error('not-basic');
                }
                output.push(input.charCodeAt(j));
            }
            for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
                for (oldi = i, w = 1, k = base;; k += base) {
                    if (index >= inputLength) {
                        error('invalid-input');
                    }
                    digit = basicToDigit(input.charCodeAt(index++));
                    if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error('overflow');
                    }
                    i += digit * w;
                    t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                    if (digit < t) {
                        break;
                    }
                    baseMinusT = base - t;
                    if (w > floor(maxInt / baseMinusT)) {
                        error('overflow');
                    }
                    w *= baseMinusT;
                }
                out = output.length + 1;
                bias = adapt(i - oldi, out, oldi == 0);
                if (floor(i / out) > maxInt - n) {
                    error('overflow');
                }
                n += floor(i / out);
                i %= out;
                output.splice(i++, 0, n);
            }
            return ucs2encode(output);
        }

        function encode(input) {
            var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [],
                inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
            input = ucs2decode(input);
            inputLength = input.length;
            n = initialN;
            delta = 0;
            bias = initialBias;
            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < 0x80) {
                    output.push(stringFromCharCode(currentValue));
                }
            }
            handledCPCount = basicLength = output.length;
            if (basicLength) {
                output.push(delimiter);
            }
            while (handledCPCount < inputLength) {
                for (m = maxInt, j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                    }
                }
                handledCPCountPlusOne = handledCPCount + 1;
                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                    error('overflow');
                }
                delta += (m - n) * handledCPCountPlusOne;
                n = m;
                for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue < n && ++delta > maxInt) {
                        error('overflow');
                    }
                    if (currentValue == n) {
                        for (q = delta, k = base;; k += base) {
                            t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
                            if (q < t) {
                                break;
                            }
                            qMinusT = q - t;
                            baseMinusT = base - t;
                            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                            q = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                    }
                }
                ++delta;
                ++n;
            }
            return output.join('');
        }

        function toUnicode(input) {
            return mapDomain(input, function(string) {
                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
            });
        }

        function toASCII(input) {
            return mapDomain(input, function(string) {
                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
            });
        }
        punycode = {
            'version': '1.3.1',
            'ucs2': {
                'decode': ucs2decode,
                'encode': ucs2encode
            },
            'decode': decode,
            'encode': encode,
            'toASCII': toASCII,
            'toUnicode': toUnicode
        };
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
            define('punycode', function() {
                return punycode;
            });
        } else if (freeExports && freeModule) {
            if (module.exports == freeExports) {
                freeModule.exports = punycode;
            } else {
                for (key in punycode) {
                    punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                }
            }
        } else {
            root.punycode = punycode;
        }
    }(this));
    var html2canvasNodeAttribute = "data-html2canvas-node";
    var html2canvasCanvasCloneAttribute = "data-html2canvas-canvas-clone";
    var html2canvasCanvasCloneIndex = 0;
    var html2canvasCloneIndex = 0;
    window.html2canvas = function(nodeList, options) {
        var index = html2canvasCloneIndex++;
        options = options || {};
        if (options.logging) {
            window.html2canvas.logging = true;
            window.html2canvas.start = Date.now();
        }
        options.async = typeof(options.async) === "undefined" ? true : options.async;
        options.allowTaint = typeof(options.allowTaint) === "undefined" ? false : options.allowTaint;
        options.removeContainer = typeof(options.removeContainer) === "undefined" ? true : options.removeContainer;
        options.javascriptEnabled = typeof(options.javascriptEnabled) === "undefined" ? false : options.javascriptEnabled;
        options.imageTimeout = typeof(options.imageTimeout) === "undefined" ? 10000 : options.imageTimeout;
        options.renderer = typeof(options.renderer) === "function" ? options.renderer : CanvasRenderer;
        options.strict = !!options.strict;
        if (typeof(nodeList) === "string") {
            if (typeof(options.proxy) !== "string") {
                return Promise.reject("Proxy must be used when rendering url");
            }
            var width = options.width != null ? options.width : window.innerWidth;
            var height = options.height != null ? options.height : window.innerHeight;
            return loadUrlDocument(absoluteUrl(nodeList), options.proxy, document, width, height, options).then(function(container) {
                return renderWindow(container.contentWindow.document.documentElement, container, options, width, height);
            });
        }
        var node = ((nodeList === undefined) ? [document.documentElement] : ((nodeList.length) ? nodeList : [nodeList]))[0];
        node.setAttribute(html2canvasNodeAttribute + index, index);
        return renderDocument(node.ownerDocument, options, node.ownerDocument.defaultView.innerWidth, node.ownerDocument.defaultView.innerHeight, index).then(function(canvas) {
            if (typeof(options.onrendered) === "function") {
                log("options.onrendered is deprecated, html2canvas returns a Promise containing the canvas");
                options.onrendered(canvas);
            }
            return canvas;
        });
    };
    window.html2canvas.punycode = this.punycode;
    window.html2canvas.proxy = {};

    function renderDocument(document, options, windowWidth, windowHeight, html2canvasIndex) {
        return createWindowClone(document, document, windowWidth, windowHeight, options, document.defaultView.pageXOffset, document.defaultView.pageYOffset).then(function(container) {
            log("Document cloned");
            var attributeName = html2canvasNodeAttribute + html2canvasIndex;
            var selector = "[" + attributeName + "='" + html2canvasIndex + "']";
            document.querySelector(selector).removeAttribute(attributeName);
            var clonedWindow = container.contentWindow;
            var node = clonedWindow.document.querySelector(selector);
            var oncloneHandler = (typeof(options.onclone) === "function") ? Promise.resolve(options.onclone(clonedWindow.document)) : Promise.resolve(true);
            return oncloneHandler.then(function() {
                return renderWindow(node, container, options, windowWidth, windowHeight);
            });
        });
    }

    function renderWindow(node, container, options, windowWidth, windowHeight) {
        var clonedWindow = container.contentWindow;
        var support = new Support(clonedWindow.document);
        var imageLoader = new ImageLoader(options, support);
        var bounds = getBounds(node);
        var width = options.type === "view" ? windowWidth : documentWidth(clonedWindow.document);
        var height = options.type === "view" ? windowHeight : documentHeight(clonedWindow.document);
        var renderer = new options.renderer(width, height, imageLoader, options, document);
        var parser = new NodeParser(node, renderer, support, imageLoader, options);
        return parser.ready.then(function() {
            log("Finished rendering");
            var canvas;
            if (options.type === "view") {
                canvas = crop(renderer.canvas, {
                    width: renderer.canvas.width,
                    height: renderer.canvas.height,
                    top: 0,
                    left: 0,
                    x: 0,
                    y: 0
                });
            } else if (node === clonedWindow.document.body || node === clonedWindow.document.documentElement || options.canvas != null) {
                canvas = renderer.canvas;
            } else {
                canvas = crop(renderer.canvas, {
                    width: options.width != null ? options.width : bounds.width,
                    height: options.height != null ? options.height : bounds.height,
                    top: bounds.top,
                    left: bounds.left,
                    x: clonedWindow.pageXOffset,
                    y: clonedWindow.pageYOffset
                });
            }
            cleanupContainer(container, options);
            return canvas;
        });
    }

    function cleanupContainer(container, options) {
        if (options.removeContainer) {
            container.parentNode.removeChild(container);
            log("Cleaned up container");
        }
    }

    function crop(canvas, bounds) {
        var croppedCanvas = document.createElement("canvas");
        var x1 = Math.floor(Math.min(canvas.width - 1, Math.max(0, bounds.left)));
        var x2 = Math.floor(Math.min(canvas.width, Math.max(1, bounds.left + bounds.width)));
        var y1 = Math.floor(Math.min(canvas.height - 1, Math.max(0, bounds.top)));
        var y2 = Math.floor(Math.min(canvas.height, Math.max(1, bounds.top + bounds.height)));
        croppedCanvas.width = bounds.width;
        croppedCanvas.height = bounds.height;
        log("Cropping canvas at:", "left:", bounds.left, "top:", bounds.top, "width:", (x2 - x1), "height:", (y2 - y1));
        log("Resulting crop with width", bounds.width, "and height", bounds.height, " with x", x1, "and y", y1);
        croppedCanvas.getContext("2d").drawImage(canvas, x1, y1, x2 - x1, y2 - y1, bounds.x, bounds.y, x2 - x1, y2 - y1);
        return croppedCanvas;
    }

    function documentWidth(doc) {
        return Math.max(Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth), Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth), Math.max(doc.body.clientWidth, doc.documentElement.clientWidth));
    }

    function documentHeight(doc) {
        return Math.max(Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight), Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight), Math.max(doc.body.clientHeight, doc.documentElement.clientHeight));
    }

    function smallImage() {
        return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
    }

    function isIE9() {
        return document.documentMode && document.documentMode <= 9;
    }

    function cloneNodeIE9(node, javascriptEnabled) {
        var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);
        var child = node.firstChild;
        while (child) {
            if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== 'SCRIPT') {
                clone.appendChild(cloneNodeIE9(child, javascriptEnabled));
            }
            child = child.nextSibling;
        }
        return clone;
    }

    function createWindowClone(ownerDocument, containerDocument, width, height, options, x, y) {
        labelCanvasElements(ownerDocument);
        var documentElement = isIE9() ? cloneNodeIE9(ownerDocument.documentElement, options.javascriptEnabled) : ownerDocument.documentElement.cloneNode(true);
        var container = containerDocument.createElement("iframe");
        container.className = "html2canvas-container";
        container.style.visibility = "hidden";
        container.style.position = "fixed";
        container.style.left = "-10000px";
        container.style.top = "0px";
        container.style.border = "0";
        container.width = width;
        container.height = height;
        container.scrolling = "no";
        containerDocument.body.appendChild(container);
        return new Promise(function(resolve) {
            var documentClone = container.contentWindow.document;
            cloneNodeValues(ownerDocument.documentElement, documentElement, "textarea");
            cloneNodeValues(ownerDocument.documentElement, documentElement, "select");
            container.contentWindow.onload = container.onload = function() {
                var interval = setInterval(function() {
                    if (documentClone.body.childNodes.length > 0) {
                        cloneCanvasContents(ownerDocument, documentClone);
                        clearInterval(interval);
                        if (options.type === "view") {
                            container.contentWindow.scrollTo(x, y);
                        }
                        resolve(container);
                    }
                }, 50);
            };
            documentClone.open();
            documentClone.write("<!DOCTYPE html><html></html>");
            restoreOwnerScroll(ownerDocument, x, y);
            documentClone.replaceChild(options.javascriptEnabled === true ? documentClone.adoptNode(documentElement) : removeScriptNodes(documentClone.adoptNode(documentElement)), documentClone.documentElement);
            documentClone.close();
        });
    }

    function cloneNodeValues(document, clone, nodeName) {
        var originalNodes = document.getElementsByTagName(nodeName);
        var clonedNodes = clone.getElementsByTagName(nodeName);
        var count = originalNodes.length;
        for (var i = 0; i < count; i++) {
            clonedNodes[i].value = originalNodes[i].value;
        }
    }

    function restoreOwnerScroll(ownerDocument, x, y) {
        if (ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
            ownerDocument.defaultView.scrollTo(x, y);
        }
    }

    function loadUrlDocument(src, proxy, document, width, height, options) {
        return new Proxy(src, proxy, window.document).then(documentFromHTML(src)).then(function(doc) {
            return createWindowClone(doc, document, width, height, options, 0, 0);
        });
    }

    function documentFromHTML(src) {
        return function(html) {
            var parser = new DOMParser(),
                doc;
            try {
                doc = parser.parseFromString(html, "text/html");
            } catch (e) {
                log("DOMParser not supported, falling back to createHTMLDocument");
                doc = document.implementation.createHTMLDocument("");
                try {
                    doc.open();
                    doc.write(html);
                    doc.close();
                } catch (ee) {
                    log("createHTMLDocument write not supported, falling back to document.body.innerHTML");
                    doc.body.innerHTML = html;
                }
            }
            var b = doc.querySelector("base");
            if (!b || !b.href.host) {
                var base = doc.createElement("base");
                base.href = src;
                doc.head.insertBefore(base, doc.head.firstChild);
            }
            return doc;
        };
    }

    function labelCanvasElements(ownerDocument) {
        [].slice.call(ownerDocument.querySelectorAll("canvas"), 0).forEach(function(canvas) {
            canvas.setAttribute(html2canvasCanvasCloneAttribute, "canvas-" + html2canvasCanvasCloneIndex++);
        });
    }

    function cloneCanvasContents(ownerDocument, documentClone) {
        [].slice.call(ownerDocument.querySelectorAll("[" + html2canvasCanvasCloneAttribute + "]"), 0).forEach(function(canvas) {
            try {
                var clonedCanvas = documentClone.querySelector('[' + html2canvasCanvasCloneAttribute + '="' + canvas.getAttribute(html2canvasCanvasCloneAttribute) + '"]');
                if (clonedCanvas) {
                    clonedCanvas.width = canvas.width;
                    clonedCanvas.height = canvas.height;
                    clonedCanvas.getContext("2d").putImageData(canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height), 0, 0);
                }
            } catch (e) {
                log("Unable to copy canvas content from", canvas, e);
            }
            canvas.removeAttribute(html2canvasCanvasCloneAttribute);
        });
    }

    function removeScriptNodes(parent) {
        [].slice.call(parent.childNodes, 0).filter(isElementNode).forEach(function(node) {
            if (node.tagName === "SCRIPT") {
                parent.removeChild(node);
            } else {
                removeScriptNodes(node);
            }
        });
        return parent;
    }

    function isElementNode(node) {
        return node.nodeType === Node.ELEMENT_NODE;
    }

    function absoluteUrl(url) {
        var link = document.createElement("a");
        link.href = url;
        link.href = link.href;
        return link;
    }

    function Color(value) {
        this.r = 0;
        this.g = 0;
        this.b = 0;
        this.a = null;
        var result = this.fromArray(value) || this.namedColor(value) || this.rgb(value) || this.rgba(value) || this.hex6(value) || this.hex3(value);
    }
    Color.prototype.darken = function(amount) {
        var a = 1 - amount;
        return new Color([Math.round(this.r * a), Math.round(this.g * a), Math.round(this.b * a), this.a]);
    };
    Color.prototype.isTransparent = function() {
        return this.a === 0;
    };
    Color.prototype.isBlack = function() {
        return this.r === 0 && this.g === 0 && this.b === 0;
    };
    Color.prototype.fromArray = function(array) {
        if (Array.isArray(array)) {
            this.r = Math.min(array[0], 255);
            this.g = Math.min(array[1], 255);
            this.b = Math.min(array[2], 255);
            if (array.length > 3) {
                this.a = array[3];
            }
        }
        return (Array.isArray(array));
    };
    var _hex3 = /^#([a-f0-9]{3})$/i;
    Color.prototype.hex3 = function(value) {
        var match = null;
        if ((match = value.match(_hex3)) !== null) {
            this.r = parseInt(match[1][0] + match[1][0], 16);
            this.g = parseInt(match[1][1] + match[1][1], 16);
            this.b = parseInt(match[1][2] + match[1][2], 16);
        }
        return match !== null;
    };
    var _hex6 = /^#([a-f0-9]{6})$/i;
    Color.prototype.hex6 = function(value) {
        var match = null;
        if ((match = value.match(_hex6)) !== null) {
            this.r = parseInt(match[1].substring(0, 2), 16);
            this.g = parseInt(match[1].substring(2, 4), 16);
            this.b = parseInt(match[1].substring(4, 6), 16);
        }
        return match !== null;
    };
    var _rgb = /^rgb\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3})\)$/;
    Color.prototype.rgb = function(value) {
        var match = null;
        if ((match = value.match(_rgb)) !== null) {
            this.r = Number(match[1]);
            this.g = Number(match[2]);
            this.b = Number(match[3]);
        }
        return match !== null;
    };
    var _rgba = /^rgba\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3}) *, *(\d+\.?\d*)\)$/;
    Color.prototype.rgba = function(value) {
        var match = null;
        if ((match = value.match(_rgba)) !== null) {
            this.r = Number(match[1]);
            this.g = Number(match[2]);
            this.b = Number(match[3]);
            this.a = Number(match[4]);
        }
        return match !== null;
    };
    Color.prototype.toString = function() {
        return this.a !== null && this.a !== 1 ? "rgba(" + [this.r, this.g, this.b, this.a].join(",") + ")" : "rgb(" + [this.r, this.g, this.b].join(",") + ")";
    };
    Color.prototype.namedColor = function(value) {
        var color = colors[value.toLowerCase()];
        if (color) {
            this.r = color[0];
            this.g = color[1];
            this.b = color[2];
        } else if (value.toLowerCase() === "transparent") {
            this.r = this.g = this.b = this.a = 0;
            return true;
        }
        return !!color;
    };
    Color.prototype.isColor = true;
    var colors = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
    };

    function DummyImageContainer(src) {
        this.src = src;
        log("DummyImageContainer for", src);
        if (!this.promise || !this.image) {
            log("Initiating DummyImageContainer");
            DummyImageContainer.prototype.image = new Image();
            var image = this.image;
            DummyImageContainer.prototype.promise = new Promise(function(resolve, reject) {
                image.onload = resolve;
                image.onerror = reject;
                image.src = smallImage();
                if (image.complete === true) {
                    resolve(image);
                }
            });
        }
    }

    function Font(family, size) {
        var container = document.createElement('div'),
            img = document.createElement('img'),
            span = document.createElement('span'),
            sampleText = 'Hidden Text',
            baseline, middle;
        container.style.visibility = "hidden";
        container.style.fontFamily = family;
        container.style.fontSize = size;
        container.style.margin = 0;
        container.style.padding = 0;
        document.body.appendChild(container);
        img.src = smallImage();
        img.width = 1;
        img.height = 1;
        img.style.margin = 0;
        img.style.padding = 0;
        img.style.verticalAlign = "baseline";
        span.style.fontFamily = family;
        span.style.fontSize = size;
        span.style.margin = 0;
        span.style.padding = 0;
        span.appendChild(document.createTextNode(sampleText));
        container.appendChild(span);
        container.appendChild(img);
        baseline = (img.offsetTop - span.offsetTop) + 1;
        container.removeChild(span);
        container.appendChild(document.createTextNode(sampleText));
        container.style.lineHeight = "normal";
        img.style.verticalAlign = "super";
        middle = (img.offsetTop - container.offsetTop) + 1;
        document.body.removeChild(container);
        this.baseline = baseline;
        this.lineWidth = 1;
        this.middle = middle;
    }

    function FontMetrics() {
        this.data = {};
    }
    FontMetrics.prototype.getMetrics = function(family, size) {
        if (this.data[family + "-" + size] === undefined) {
            this.data[family + "-" + size] = new Font(family, size);
        }
        return this.data[family + "-" + size];
    };

    function FrameContainer(container, sameOrigin, options) {
        this.image = null;
        this.src = container;
        var self = this;
        var bounds = getBounds(container);
        this.promise = (!sameOrigin ? this.proxyLoad(options.proxy, bounds, options) : new Promise(function(resolve) {
            if (container.contentWindow.document.URL === "about:blank" || container.contentWindow.document.documentElement == null) {
                container.contentWindow.onload = container.onload = function() {
                    resolve(container);
                };
            } else {
                resolve(container);
            }
        })).then(function(container) {
            return html2canvas(container.contentWindow.document.documentElement, {
                type: 'view',
                width: container.width,
                height: container.height,
                proxy: options.proxy,
                javascriptEnabled: options.javascriptEnabled,
                removeContainer: options.removeContainer,
                allowTaint: options.allowTaint,
                imageTimeout: options.imageTimeout / 2
            });
        }).then(function(canvas) {
            return self.image = canvas;
        });
    }
    FrameContainer.prototype.proxyLoad = function(proxy, bounds, options) {
        var container = this.src;
        return loadUrlDocument(container.src, proxy, container.ownerDocument, bounds.width, bounds.height, options);
    };

    function GradientContainer(imageData) {
        this.src = imageData.value;
        this.colorStops = [];
        this.type = null;
        this.x0 = 0.5;
        this.y0 = 0.5;
        this.x1 = 0.5;
        this.y1 = 0.5;
        this.promise = Promise.resolve(true);
    }
    GradientContainer.prototype.TYPES = {
        LINEAR: 1,
        RADIAL: 2
    };

    function ImageContainer(src, cors) {
        this.src = src;
        this.image = new Image();
        var self = this;
        this.tainted = null;
        this.promise = new Promise(function(resolve, reject) {
            self.image.onload = resolve;
            self.image.onerror = reject;
            if (cors) {
                self.image.crossOrigin = "anonymous";
            }
            self.image.src = src;
            if (self.image.complete === true) {
                resolve(self.image);
            }
        });
    }

    function ImageLoader(options, support) {
        this.link = null;
        this.options = options;
        this.support = support;
        this.origin = this.getOrigin(window.location.href);
    }
    ImageLoader.prototype.findImages = function(nodes) {
        var images = [];
        nodes.reduce(function(imageNodes, container) {
            switch (container.node.nodeName) {
                case "IMG":
                    return imageNodes.concat([{
                        args: [container.node.src],
                        method: "url"
                    }]);
                case "svg":
                case "IFRAME":
                    return imageNodes.concat([{
                        args: [container.node],
                        method: container.node.nodeName
                    }]);
            }
            return imageNodes;
        }, []).forEach(this.addImage(images, this.loadImage), this);
        return images;
    };
    ImageLoader.prototype.findBackgroundImage = function(images, container) {
        container.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(images, this.loadImage), this);
        return images;
    };
    ImageLoader.prototype.addImage = function(images, callback) {
        return function(newImage) {
            newImage.args.forEach(function(image) {
                if (!this.imageExists(images, image)) {
                    images.splice(0, 0, callback.call(this, newImage));
                    log('Added image #' + (images.length), typeof(image) === "string" ? image.substring(0, 100) : image);
                }
            }, this);
        };
    };
    ImageLoader.prototype.hasImageBackground = function(imageData) {
        return imageData.method !== "none";
    };
    ImageLoader.prototype.loadImage = function(imageData) {
        if (imageData.method === "url") {
            var src = imageData.args[0];
            if (this.isSVG(src) && !this.support.svg && !this.options.allowTaint) {
                return new SVGContainer(src);
            } else if (src.match(/data:image\/.*;base64,/i)) {
                return new ImageContainer(src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, ''), false);
            } else if (this.isSameOrigin(src) || this.options.allowTaint === true || this.isSVG(src)) {
                return new ImageContainer(src, false);
            } else if (this.support.cors && !this.options.allowTaint && this.options.useCORS) {
                return new ImageContainer(src, true);
            } else if (this.options.proxy) {
                return new ProxyImageContainer(src, this.options.proxy);
            } else {
                return new DummyImageContainer(src);
            }
        } else if (imageData.method === "linear-gradient") {
            return new LinearGradientContainer(imageData);
        } else if (imageData.method === "gradient") {
            return new WebkitGradientContainer(imageData);
        } else if (imageData.method === "svg") {
            return new SVGNodeContainer(imageData.args[0], this.support.svg);
        } else if (imageData.method === "IFRAME") {
            return new FrameContainer(imageData.args[0], this.isSameOrigin(imageData.args[0].src), this.options);
        } else {
            return new DummyImageContainer(imageData);
        }
    };
    ImageLoader.prototype.isSVG = function(src) {
        return src.substring(src.length - 3).toLowerCase() === "svg" || SVGContainer.prototype.isInline(src);
    };
    ImageLoader.prototype.imageExists = function(images, src) {
        return images.some(function(image) {
            return image.src === src;
        });
    };
    ImageLoader.prototype.isSameOrigin = function(url) {
        return (this.getOrigin(url) === this.origin);
    };
    ImageLoader.prototype.getOrigin = function(url) {
        var link = this.link || (this.link = document.createElement("a"));
        link.href = url;
        link.href = link.href;
        return link.protocol + link.hostname + link.port;
    };
    ImageLoader.prototype.getPromise = function(container) {
        return this.timeout(container, this.options.imageTimeout)['catch'](function() {
            var dummy = new DummyImageContainer(container.src);
            return dummy.promise.then(function(image) {
                container.image = image;
            });
        });
    };
    ImageLoader.prototype.get = function(src) {
        var found = null;
        return this.images.some(function(img) {
            return (found = img).src === src;
        }) ? found : null;
    };
    ImageLoader.prototype.fetch = function(nodes) {
        this.images = nodes.reduce(bind(this.findBackgroundImage, this), this.findImages(nodes));
        this.images.forEach(function(image, index) {
            image.promise.then(function() {
                log("Succesfully loaded image #" + (index + 1), image);
            }, function(e) {
                log("Failed loading image #" + (index + 1), image, e);
            });
        });
        this.ready = Promise.all(this.images.map(this.getPromise, this));
        log("Finished searching images");
        return this;
    };
    ImageLoader.prototype.timeout = function(container, timeout) {
        var timer;
        var promise = Promise.race([container.promise, new Promise(function(res, reject) {
            timer = setTimeout(function() {
                log("Timed out loading image", container);
                reject(container);
            }, timeout);
        })]).then(function(container) {
            clearTimeout(timer);
            return container;
        });
        promise['catch'](function() {
            clearTimeout(timer);
        });
        return promise;
    };

    function LinearGradientContainer(imageData) {
        GradientContainer.apply(this, arguments);
        this.type = this.TYPES.LINEAR;
        var hasDirection = imageData.args[0].match(this.stepRegExp) === null;
        if (hasDirection) {
            imageData.args[0].split(" ").reverse().forEach(function(position) {
                switch (position) {
                    case "left":
                        this.x0 = 0;
                        this.x1 = 1;
                        break;
                    case "top":
                        this.y0 = 0;
                        this.y1 = 1;
                        break;
                    case "right":
                        this.x0 = 1;
                        this.x1 = 0;
                        break;
                    case "bottom":
                        this.y0 = 1;
                        this.y1 = 0;
                        break;
                    case "to":
                        var y0 = this.y0;
                        var x0 = this.x0;
                        this.y0 = this.y1;
                        this.x0 = this.x1;
                        this.x1 = x0;
                        this.y1 = y0;
                        break;
                }
            }, this);
        } else {
            this.y0 = 0;
            this.y1 = 1;
        }
        this.colorStops = imageData.args.slice(hasDirection ? 1 : 0).map(function(colorStop) {
            var colorStopMatch = colorStop.match(this.stepRegExp);
            return {
                color: new Color(colorStopMatch[1]),
                stop: colorStopMatch[3] === "%" ? colorStopMatch[2] / 100 : null
            };
        }, this);
        if (this.colorStops[0].stop === null) {
            this.colorStops[0].stop = 0;
        }
        if (this.colorStops[this.colorStops.length - 1].stop === null) {
            this.colorStops[this.colorStops.length - 1].stop = 1;
        }
        this.colorStops.forEach(function(colorStop, index) {
            if (colorStop.stop === null) {
                this.colorStops.slice(index).some(function(find, count) {
                    if (find.stop !== null) {
                        colorStop.stop = ((find.stop - this.colorStops[index - 1].stop) / (count + 1)) + this.colorStops[index - 1].stop;
                        return true;
                    } else {
                        return false;
                    }
                }, this);
            }
        }, this);
    }
    LinearGradientContainer.prototype = Object.create(GradientContainer.prototype);
    LinearGradientContainer.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/;

    function log() {
        if (window.html2canvas.logging && window.console && window.console.log) {
            Function.prototype.bind.call(window.console.log, (window.console)).apply(window.console, [(Date.now() - window.html2canvas.start) + "ms", "html2canvas:"].concat([].slice.call(arguments, 0)));
        }
    }

    function NodeContainer(node, parent) {
        this.node = node;
        this.parent = parent;
        this.stack = null;
        this.bounds = null;
        this.borders = null;
        this.clip = [];
        this.backgroundClip = [];
        this.offsetBounds = null;
        this.visible = null;
        this.computedStyles = null;
        this.colors = {};
        this.styles = {};
        this.backgroundImages = null;
        this.transformData = null;
        this.transformMatrix = null;
        this.isPseudoElement = false;
        this.opacity = null;
    }
    NodeContainer.prototype.cloneTo = function(stack) {
        stack.visible = this.visible;
        stack.borders = this.borders;
        stack.bounds = this.bounds;
        stack.clip = this.clip;
        stack.backgroundClip = this.backgroundClip;
        stack.computedStyles = this.computedStyles;
        stack.styles = this.styles;
        stack.backgroundImages = this.backgroundImages;
        stack.opacity = this.opacity;
    };
    NodeContainer.prototype.getOpacity = function() {
        return this.opacity === null ? (this.opacity = this.cssFloat('opacity')) : this.opacity;
    };
    NodeContainer.prototype.assignStack = function(stack) {
        this.stack = stack;
        stack.children.push(this);
    };
    NodeContainer.prototype.isElementVisible = function() {
        return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : (this.css('display') !== "none" && this.css('visibility') !== "hidden" && !this.node.hasAttribute("data-html2canvas-ignore") && (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden"));
    };
    NodeContainer.prototype.css = function(attribute) {
        if (!this.computedStyles) {
            this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null);
        }
        return this.styles[attribute] || (this.styles[attribute] = this.computedStyles[attribute]);
    };
    NodeContainer.prototype.prefixedCss = function(attribute) {
        var prefixes = ["webkit", "moz", "ms", "o"];
        var value = this.css(attribute);
        if (value === undefined) {
            prefixes.some(function(prefix) {
                value = this.css(prefix + attribute.substr(0, 1).toUpperCase() + attribute.substr(1));
                return value !== undefined;
            }, this);
        }
        return value === undefined ? null : value;
    };
    NodeContainer.prototype.computedStyle = function(type) {
        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, type);
    };
    NodeContainer.prototype.cssInt = function(attribute) {
        var value = parseInt(this.css(attribute), 10);
        return (isNaN(value)) ? 0 : value;
    };
    NodeContainer.prototype.color = function(attribute) {
        return this.colors[attribute] || (this.colors[attribute] = new Color(this.css(attribute)));
    };
    NodeContainer.prototype.cssFloat = function(attribute) {
        var value = parseFloat(this.css(attribute));
        return (isNaN(value)) ? 0 : value;
    };
    NodeContainer.prototype.fontWeight = function() {
        var weight = this.css("fontWeight");
        switch (parseInt(weight, 10)) {
            case 401:
                weight = "bold";
                break;
            case 400:
                weight = "normal";
                break;
        }
        return weight;
    };
    NodeContainer.prototype.parseClip = function() {
        var matches = this.css('clip').match(this.CLIP);
        if (matches) {
            return {
                top: parseInt(matches[1], 10),
                right: parseInt(matches[2], 10),
                bottom: parseInt(matches[3], 10),
                left: parseInt(matches[4], 10)
            };
        }
        return null;
    };
    NodeContainer.prototype.parseBackgroundImages = function() {
        return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css("backgroundImage")));
    };
    NodeContainer.prototype.cssList = function(property, index) {
        var value = (this.css(property) || '').split(',');
        value = value[index || 0] || value[0] || 'auto';
        value = value.trim().split(' ');
        if (value.length === 1) {
            value = [value[0], value[0]];
        }
        return value;
    };
    NodeContainer.prototype.parseBackgroundSize = function(bounds, image, index) {
        var size = this.cssList("backgroundSize", index);
        var width, height;
        if (isPercentage(size[0])) {
            width = bounds.width * parseFloat(size[0]) / 100;
        } else if (/contain|cover/.test(size[0])) {
            var targetRatio = bounds.width / bounds.height,
                currentRatio = image.width / image.height;
            return (targetRatio < currentRatio ^ size[0] === 'contain') ? {
                width: bounds.height * currentRatio,
                height: bounds.height
            } : {
                width: bounds.width,
                height: bounds.width / currentRatio
            };
        } else {
            width = parseInt(size[0], 10);
        }
        if (size[0] === 'auto' && size[1] === 'auto') {
            height = image.height;
        } else if (size[1] === 'auto') {
            height = width / image.width * image.height;
        } else if (isPercentage(size[1])) {
            height = bounds.height * parseFloat(size[1]) / 100;
        } else {
            height = parseInt(size[1], 10);
        }
        if (size[0] === 'auto') {
            width = height / image.height * image.width;
        }
        return {
            width: width,
            height: height
        };
    };
    NodeContainer.prototype.parseBackgroundPosition = function(bounds, image, index, backgroundSize) {
        var position = this.cssList('backgroundPosition', index);
        var left, top;
        if (isPercentage(position[0])) {
            left = (bounds.width - (backgroundSize || image).width) * (parseFloat(position[0]) / 100);
        } else {
            left = parseInt(position[0], 10);
        }
        if (position[1] === 'auto') {
            top = left / image.width * image.height;
        } else if (isPercentage(position[1])) {
            top = (bounds.height - (backgroundSize || image).height) * parseFloat(position[1]) / 100;
        } else {
            top = parseInt(position[1], 10);
        }
        if (position[0] === 'auto') {
            left = top / image.height * image.width;
        }
        return {
            left: left,
            top: top
        };
    };
    NodeContainer.prototype.parseBackgroundRepeat = function(index) {
        return this.cssList("backgroundRepeat", index)[0];
    };
    NodeContainer.prototype.parseTextShadows = function() {
        var textShadow = this.css("textShadow");
        var results = [];
        if (textShadow && textShadow !== 'none') {
            var shadows = textShadow.match(this.TEXT_SHADOW_PROPERTY);
            for (var i = 0; shadows && (i < shadows.length); i++) {
                var s = shadows[i].match(this.TEXT_SHADOW_VALUES);
                results.push({
                    color: new Color(s[0]),
                    offsetX: s[1] ? parseFloat(s[1].replace('px', '')) : 0,
                    offsetY: s[2] ? parseFloat(s[2].replace('px', '')) : 0,
                    blur: s[3] ? s[3].replace('px', '') : 0
                });
            }
        }
        return results;
    };
    NodeContainer.prototype.parseTransform = function() {
        if (!this.transformData) {
            if (this.hasTransform()) {
                var offset = this.parseBounds();
                var origin = this.prefixedCss("transformOrigin").split(" ").map(removePx).map(asFloat);
                origin[0] += offset.left;
                origin[1] += offset.top;
                this.transformData = {
                    origin: origin,
                    matrix: this.parseTransformMatrix()
                };
            } else {
                this.transformData = {
                    origin: [0, 0],
                    matrix: [1, 0, 0, 1, 0, 0]
                };
            }
        }
        return this.transformData;
    };
    NodeContainer.prototype.parseTransformMatrix = function() {
        if (!this.transformMatrix) {
            var transform = this.prefixedCss("transform");
            var matrix = transform ? parseMatrix(transform.match(this.MATRIX_PROPERTY)) : null;
            this.transformMatrix = matrix ? matrix : [1, 0, 0, 1, 0, 0];
        }
        return this.transformMatrix;
    };
    NodeContainer.prototype.parseBounds = function() {
        return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));
    };
    NodeContainer.prototype.hasTransform = function() {
        return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || (this.parent && this.parent.hasTransform());
    };
    NodeContainer.prototype.getValue = function() {
        var value = this.node.value || "";
        if (this.node.tagName === "SELECT") {
            value = selectionValue(this.node);
        } else if (this.node.type === "password") {
            value = Array(value.length + 1).join('\u2022');
        }
        return value.length === 0 ? (this.node.placeholder || "") : value;
    };
    NodeContainer.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/;
    NodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
    NodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
    NodeContainer.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/;

    function selectionValue(node) {
        var option = node.options[node.selectedIndex || 0];
        return option ? (option.text || "") : "";
    }

    function parseMatrix(match) {
        if (match && match[1] === "matrix") {
            return match[2].split(",").map(function(s) {
                return parseFloat(s.trim());
            });
        }
    }

    function isPercentage(value) {
        return value.toString().indexOf("%") !== -1;
    }

    function parseBackgrounds(backgroundImage) {
        var whitespace = ' \r\n\t',
            method, definition, prefix, prefix_i, block, results = [],
            mode = 0,
            numParen = 0,
            quote, args;
        var appendResult = function() {
            if (method) {
                if (definition.substr(0, 1) === '"') {
                    definition = definition.substr(1, definition.length - 2);
                }
                if (definition) {
                    args.push(definition);
                }
                if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1) + 1) > 0) {
                    prefix = method.substr(0, prefix_i);
                    method = method.substr(prefix_i);
                }
                results.push({
                    prefix: prefix,
                    method: method.toLowerCase(),
                    value: block,
                    args: args,
                    image: null
                });
            }
            args = [];
            method = prefix = definition = block = '';
        };
        args = [];
        method = prefix = definition = block = '';
        backgroundImage.split("").forEach(function(c) {
            if (mode === 0 && whitespace.indexOf(c) > -1) {
                return;
            }
            switch (c) {
                case '"':
                    if (!quote) {
                        quote = c;
                    } else if (quote === c) {
                        quote = null;
                    }
                    break;
                case '(':
                    if (quote) {
                        break;
                    } else if (mode === 0) {
                        mode = 1;
                        block += c;
                        return;
                    } else {
                        numParen++;
                    }
                    break;
                case ')':
                    if (quote) {
                        break;
                    } else if (mode === 1) {
                        if (numParen === 0) {
                            mode = 0;
                            block += c;
                            appendResult();
                            return;
                        } else {
                            numParen--;
                        }
                    }
                    break;
                case ',':
                    if (quote) {
                        break;
                    } else if (mode === 0) {
                        appendResult();
                        return;
                    } else if (mode === 1) {
                        if (numParen === 0 && !method.match(/^url$/i)) {
                            args.push(definition);
                            definition = '';
                            block += c;
                            return;
                        }
                    }
                    break;
            }
            block += c;
            if (mode === 0) {
                method += c;
            } else {
                definition += c;
            }
        });
        appendResult();
        return results;
    }

    function removePx(str) {
        return str.replace("px", "");
    }

    function asFloat(str) {
        return parseFloat(str);
    }

    function getBounds(node) {
        if (node.getBoundingClientRect) {
            var clientRect = node.getBoundingClientRect();
            var width = node.offsetWidth == null ? clientRect.width : node.offsetWidth;
            return {
                top: Math.floor(clientRect.top),
                bottom: Math.floor(clientRect.bottom || (clientRect.top + clientRect.height)),
                right: Math.floor(clientRect.left + width),
                left: Math.floor(clientRect.left),
                width: width,
                height: node.offsetHeight == null ? clientRect.height : node.offsetHeight
            };
        }
        return {};
    }

    function offsetBounds(node) {
        var parent = node.offsetParent ? offsetBounds(node.offsetParent) : {
            top: 0,
            left: 0
        };
        return {
            top: node.offsetTop + parent.top,
            bottom: node.offsetTop + node.offsetHeight + parent.top,
            right: node.offsetLeft + parent.left + node.offsetWidth,
            left: node.offsetLeft + parent.left,
            width: node.offsetWidth,
            height: node.offsetHeight
        };
    }

    function NodeParser(element, renderer, support, imageLoader, options) {
        log("Starting NodeParser");
        this.renderer = renderer;
        this.options = options;
        this.range = null;
        this.support = support;
        this.renderQueue = [];
        this.stack = new StackingContext(true, 1, element.ownerDocument, null);
        var parent = new NodeContainer(element, null);
        if (options.background) {
            renderer.rectangle(0, 0, renderer.width, renderer.height, new Color(options.background));
        }
        if (element === element.ownerDocument.documentElement) {
            var canvasBackground = new NodeContainer(parent.color('backgroundColor').isTransparent() ? element.ownerDocument.body : element.ownerDocument.documentElement, null);
            renderer.rectangle(0, 0, renderer.width, renderer.height, canvasBackground.color('backgroundColor'));
        }
        parent.visibile = parent.isElementVisible();
        this.createPseudoHideStyles(element.ownerDocument);
        this.disableAnimations(element.ownerDocument);
        this.nodes = flatten([parent].concat(this.getChildren(parent)).filter(function(container) {
            return container.visible = container.isElementVisible();
        }).map(this.getPseudoElements, this));
        this.fontMetrics = new FontMetrics();
        log("Fetched nodes, total:", this.nodes.length);
        log("Calculate overflow clips");
        this.calculateOverflowClips();
        log("Start fetching images");
        this.images = imageLoader.fetch(this.nodes.filter(isElement));
        this.ready = this.images.ready.then(bind(function() {
            log("Images loaded, starting parsing");
            log("Creating stacking contexts");
            this.createStackingContexts();
            log("Sorting stacking contexts");
            this.sortStackingContexts(this.stack);
            this.parse(this.stack);
            log("Render queue created with " + this.renderQueue.length + " items");
            return new Promise(bind(function(resolve) {
                if (!options.async) {
                    this.renderQueue.forEach(this.paint, this);
                    resolve();
                } else if (typeof(options.async) === "function") {
                    options.async.call(this, this.renderQueue, resolve);
                } else if (this.renderQueue.length > 0) {
                    this.renderIndex = 0;
                    this.asyncRenderer(this.renderQueue, resolve);
                } else {
                    resolve();
                }
            }, this));
        }, this));
    }
    NodeParser.prototype.calculateOverflowClips = function() {
        this.nodes.forEach(function(container) {
            if (isElement(container)) {
                if (isPseudoElement(container)) {
                    container.appendToDOM();
                }
                container.borders = this.parseBorders(container);
                var clip = (container.css('overflow') === "hidden") ? [container.borders.clip] : [];
                var cssClip = container.parseClip();
                if (cssClip && ["absolute", "fixed"].indexOf(container.css('position')) !== -1) {
                    clip.push([
                        ["rect", container.bounds.left + cssClip.left, container.bounds.top + cssClip.top, cssClip.right - cssClip.left, cssClip.bottom - cssClip.top]
                    ]);
                }
                container.clip = hasParentClip(container) ? container.parent.clip.concat(clip) : clip;
                container.backgroundClip = (container.css('overflow') !== "hidden") ? container.clip.concat([container.borders.clip]) : container.clip;
                if (isPseudoElement(container)) {
                    container.cleanDOM();
                }
            } else if (isTextNode(container)) {
                container.clip = hasParentClip(container) ? container.parent.clip : [];
            }
            if (!isPseudoElement(container)) {
                container.bounds = null;
            }
        }, this);
    };

    function hasParentClip(container) {
        return container.parent && container.parent.clip.length;
    }
    NodeParser.prototype.asyncRenderer = function(queue, resolve, asyncTimer) {
        asyncTimer = asyncTimer || Date.now();
        this.paint(queue[this.renderIndex++]);
        if (queue.length === this.renderIndex) {
            resolve();
        } else if (asyncTimer + 20 > Date.now()) {
            this.asyncRenderer(queue, resolve, asyncTimer);
        } else {
            setTimeout(bind(function() {
                this.asyncRenderer(queue, resolve);
            }, this), 0);
        }
    };
    NodeParser.prototype.createPseudoHideStyles = function(document) {
        this.createStyles(document, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }' + '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
    };
    NodeParser.prototype.disableAnimations = function(document) {
        this.createStyles(document, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ' + '-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
    };
    NodeParser.prototype.createStyles = function(document, styles) {
        var hidePseudoElements = document.createElement('style');
        hidePseudoElements.innerHTML = styles;
        document.body.appendChild(hidePseudoElements);
    };
    NodeParser.prototype.getPseudoElements = function(container) {
        var nodes = [
            [container]
        ];
        if (container.node.nodeType === Node.ELEMENT_NODE) {
            var before = this.getPseudoElement(container, ":before");
            var after = this.getPseudoElement(container, ":after");
            if (before) {
                nodes.push(before);
            }
            if (after) {
                nodes.push(after);
            }
        }
        return flatten(nodes);
    };

    function toCamelCase(str) {
        return str.replace(/(\-[a-z])/g, function(match) {
            return match.toUpperCase().replace('-', '');
        });
    }
    NodeParser.prototype.getPseudoElement = function(container, type) {
        var style = container.computedStyle(type);
        if (!style || !style.content || style.content === "none" || style.content === "-moz-alt-content" || style.display === "none") {
            return null;
        }
        var content = stripQuotes(style.content);
        var isImage = content.substr(0, 3) === 'url';
        var pseudoNode = document.createElement(isImage ? 'img' : 'html2canvaspseudoelement');
        var pseudoContainer = new PseudoElementContainer(pseudoNode, container, type);
        for (var i = style.length - 1; i >= 0; i--) {
            var property = toCamelCase(style.item(i));
            pseudoNode.style[property] = style[property];
        }
        pseudoNode.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
        if (isImage) {
            pseudoNode.src = parseBackgrounds(content)[0].args[0];
            return [pseudoContainer];
        } else {
            var text = document.createTextNode(content);
            pseudoNode.appendChild(text);
            return [pseudoContainer, new TextContainer(text, pseudoContainer)];
        }
    };
    NodeParser.prototype.getChildren = function(parentContainer) {
        return flatten([].filter.call(parentContainer.node.childNodes, renderableNode).map(function(node) {
            var container = [node.nodeType === Node.TEXT_NODE ? new TextContainer(node, parentContainer) : new NodeContainer(node, parentContainer)].filter(nonIgnoredElement);
            return node.nodeType === Node.ELEMENT_NODE && container.length && node.tagName !== "TEXTAREA" ? (container[0].isElementVisible() ? container.concat(this.getChildren(container[0])) : []) : container;
        }, this));
    };
    NodeParser.prototype.newStackingContext = function(container, hasOwnStacking) {
        var stack = new StackingContext(hasOwnStacking, container.getOpacity(), container.node, container.parent);
        container.cloneTo(stack);
        var parentStack = hasOwnStacking ? stack.getParentStack(this) : stack.parent.stack;
        parentStack.contexts.push(stack);
        container.stack = stack;
    };
    NodeParser.prototype.createStackingContexts = function() {
        this.nodes.forEach(function(container) {
            if (isElement(container) && (this.isRootElement(container) || hasOpacity(container) || isPositionedForStacking(container) || this.isBodyWithTransparentRoot(container) || container.hasTransform())) {
                this.newStackingContext(container, true);
            } else if (isElement(container) && ((isPositioned(container) && zIndex0(container)) || isInlineBlock(container) || isFloating(container))) {
                this.newStackingContext(container, false);
            } else {
                container.assignStack(container.parent.stack);
            }
        }, this);
    };
    NodeParser.prototype.isBodyWithTransparentRoot = function(container) {
        return container.node.nodeName === "BODY" && container.parent.color('backgroundColor').isTransparent();
    };
    NodeParser.prototype.isRootElement = function(container) {
        return container.parent === null;
    };
    NodeParser.prototype.sortStackingContexts = function(stack) {
        stack.contexts.sort(zIndexSort(stack.contexts.slice(0)));
        stack.contexts.forEach(this.sortStackingContexts, this);
    };
    NodeParser.prototype.parseTextBounds = function(container) {
        return function(text, index, textList) {
            if (container.parent.css("textDecoration").substr(0, 4) !== "none" || text.trim().length !== 0) {
                if (this.support.rangeBounds && !container.parent.hasTransform()) {
                    var offset = textList.slice(0, index).join("").length;
                    return this.getRangeBounds(container.node, offset, text.length);
                } else if (container.node && typeof(container.node.data) === "string") {
                    var replacementNode = container.node.splitText(text.length);
                    var bounds = this.getWrapperBounds(container.node, container.parent.hasTransform());
                    container.node = replacementNode;
                    return bounds;
                }
            } else if (!this.support.rangeBounds || container.parent.hasTransform()) {
                container.node = container.node.splitText(text.length);
            }
            return {};
        };
    };
    NodeParser.prototype.getWrapperBounds = function(node, transform) {
        var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
        var parent = node.parentNode,
            backupText = node.cloneNode(true);
        wrapper.appendChild(node.cloneNode(true));
        parent.replaceChild(wrapper, node);
        var bounds = transform ? offsetBounds(wrapper) : getBounds(wrapper);
        parent.replaceChild(backupText, wrapper);
        return bounds;
    };
    NodeParser.prototype.getRangeBounds = function(node, offset, length) {
        var range = this.range || (this.range = node.ownerDocument.createRange());
        range.setStart(node, offset);
        range.setEnd(node, offset + length);
        return range.getBoundingClientRect();
    };

    function ClearTransform() {}
    NodeParser.prototype.parse = function(stack) {
        var negativeZindex = stack.contexts.filter(negativeZIndex);
        var descendantElements = stack.children.filter(isElement);
        var descendantNonFloats = descendantElements.filter(not(isFloating));
        var nonInlineNonPositionedDescendants = descendantNonFloats.filter(not(isPositioned)).filter(not(inlineLevel));
        var nonPositionedFloats = descendantElements.filter(not(isPositioned)).filter(isFloating);
        var inFlow = descendantNonFloats.filter(not(isPositioned)).filter(inlineLevel);
        var stackLevel0 = stack.contexts.concat(descendantNonFloats.filter(isPositioned)).filter(zIndex0);
        var text = stack.children.filter(isTextNode).filter(hasText);
        var positiveZindex = stack.contexts.filter(positiveZIndex);
        negativeZindex.concat(nonInlineNonPositionedDescendants).concat(nonPositionedFloats).concat(inFlow).concat(stackLevel0).concat(text).concat(positiveZindex).forEach(function(container) {
            this.renderQueue.push(container);
            if (isStackingContext(container)) {
                this.parse(container);
                this.renderQueue.push(new ClearTransform());
            }
        }, this);
    };
    NodeParser.prototype.paint = function(container) {
        try {
            if (container instanceof ClearTransform) {
                this.renderer.ctx.restore();
            } else if (isTextNode(container)) {
                if (isPseudoElement(container.parent)) {
                    container.parent.appendToDOM();
                }
                this.paintText(container);
                if (isPseudoElement(container.parent)) {
                    container.parent.cleanDOM();
                }
            } else {
                this.paintNode(container);
            }
        } catch (e) {
            log(e);
            if (this.options.strict) {
                throw e;
            }
        }
    };
    NodeParser.prototype.paintNode = function(container) {
        if (isStackingContext(container)) {
            this.renderer.setOpacity(container.opacity);
            this.renderer.ctx.save();
            if (container.hasTransform()) {
                this.renderer.setTransform(container.parseTransform());
            }
        }
        if (container.node.nodeName === "INPUT" && container.node.type === "checkbox") {
            this.paintCheckbox(container);
        } else if (container.node.nodeName === "INPUT" && container.node.type === "radio") {
            this.paintRadio(container);
        } else {
            this.paintElement(container);
        }
    };
    NodeParser.prototype.paintElement = function(container) {
        var bounds = container.parseBounds();
        this.renderer.clip(container.backgroundClip, function() {
            this.renderer.renderBackground(container, bounds, container.borders.borders.map(getWidth));
        }, this);
        this.renderer.clip(container.clip, function() {
            this.renderer.renderBorders(container.borders.borders);
        }, this);
        this.renderer.clip(container.backgroundClip, function() {
            switch (container.node.nodeName) {
                case "svg":
                case "IFRAME":
                    var imgContainer = this.images.get(container.node);
                    if (imgContainer) {
                        this.renderer.renderImage(container, bounds, container.borders, imgContainer);
                    } else {
                        log("Error loading <" + container.node.nodeName + ">", container.node);
                    }
                    break;
                case "IMG":
                    var imageContainer = this.images.get(container.node.src);
                    if (imageContainer) {
                        this.renderer.renderImage(container, bounds, container.borders, imageContainer);
                    } else {
                        log("Error loading <img>", container.node.src);
                    }
                    break;
                case "CANVAS":
                    this.renderer.renderImage(container, bounds, container.borders, {
                        image: container.node
                    });
                    break;
                case "SELECT":
                case "INPUT":
                case "TEXTAREA":
                    this.paintFormValue(container);
                    break;
            }
        }, this);
    };
    NodeParser.prototype.paintCheckbox = function(container) {
        var b = container.parseBounds();
        var size = Math.min(b.width, b.height);
        var bounds = {
            width: size - 1,
            height: size - 1,
            top: b.top,
            left: b.left
        };
        var r = [3, 3];
        var radius = [r, r, r, r];
        var borders = [1, 1, 1, 1].map(function(w) {
            return {
                color: new Color('#A5A5A5'),
                width: w
            };
        });
        var borderPoints = calculateCurvePoints(bounds, radius, borders);
        this.renderer.clip(container.backgroundClip, function() {
            this.renderer.rectangle(bounds.left + 1, bounds.top + 1, bounds.width - 2, bounds.height - 2, new Color("#DEDEDE"));
            this.renderer.renderBorders(calculateBorders(borders, bounds, borderPoints, radius));
            if (container.node.checked) {
                this.renderer.font(new Color('#424242'), 'normal', 'normal', 'bold', (size - 3) + "px", 'arial');
                this.renderer.text("\u2714", bounds.left + size / 6, bounds.top + size - 1);
            }
        }, this);
    };
    NodeParser.prototype.paintRadio = function(container) {
        var bounds = container.parseBounds();
        var size = Math.min(bounds.width, bounds.height) - 2;
        this.renderer.clip(container.backgroundClip, function() {
            this.renderer.circleStroke(bounds.left + 1, bounds.top + 1, size, new Color('#DEDEDE'), 1, new Color('#A5A5A5'));
            if (container.node.checked) {
                this.renderer.circle(Math.ceil(bounds.left + size / 4) + 1, Math.ceil(bounds.top + size / 4) + 1, Math.floor(size / 2), new Color('#424242'));
            }
        }, this);
    };
    NodeParser.prototype.paintFormValue = function(container) {
        var value = container.getValue();
        if (value.length > 0) {
            var document = container.node.ownerDocument;
            var wrapper = document.createElement('html2canvaswrapper');
            var properties = ['lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth', 'boxSizing', 'whiteSpace', 'wordWrap'];
            properties.forEach(function(property) {
                try {
                    wrapper.style[property] = container.css(property);
                } catch (e) {
                    log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
                }
            });
            var bounds = container.parseBounds();
            wrapper.style.position = "fixed";
            wrapper.style.left = bounds.left + "px";
            wrapper.style.top = bounds.top + "px";
            wrapper.textContent = value;
            document.body.appendChild(wrapper);
            this.paintText(new TextContainer(wrapper.firstChild, container));
            document.body.removeChild(wrapper);
        }
    };
    NodeParser.prototype.paintText = function(container) {
        container.applyTextTransform();
        var characters = window.html2canvas.punycode.ucs2.decode(container.node.data);
        var textList = (!this.options.letterRendering || noLetterSpacing(container)) && !hasUnicode(container.node.data) ? getWords(characters) : characters.map(function(character) {
            return window.html2canvas.punycode.ucs2.encode([character]);
        });
        var weight = container.parent.fontWeight();
        var size = container.parent.css('fontSize');
        var family = container.parent.css('fontFamily');
        var shadows = container.parent.parseTextShadows();
        this.renderer.font(container.parent.color('color'), container.parent.css('fontStyle'), container.parent.css('fontVariant'), weight, size, family);
        if (shadows.length) {
            this.renderer.fontShadow(shadows[0].color, shadows[0].offsetX, shadows[0].offsetY, shadows[0].blur);
        } else {
            this.renderer.clearShadow();
        }
        this.renderer.clip(container.parent.clip, function() {
            textList.map(this.parseTextBounds(container), this).forEach(function(bounds, index) {
                if (bounds) {
                    this.renderer.text(textList[index], bounds.left, bounds.bottom);
                    this.renderTextDecoration(container.parent, bounds, this.fontMetrics.getMetrics(family, size));
                }
            }, this);
        }, this);
    };
    NodeParser.prototype.renderTextDecoration = function(container, bounds, metrics) {
        switch (container.css("textDecoration").split(" ")[0]) {
            case "underline":
                this.renderer.rectangle(bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, container.color("color"));
                break;
            case "overline":
                this.renderer.rectangle(bounds.left, Math.round(bounds.top), bounds.width, 1, container.color("color"));
                break;
            case "line-through":
                this.renderer.rectangle(bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, container.color("color"));
                break;
        }
    };
    var borderColorTransforms = {
        inset: [
            ["darken", 0.60],
            ["darken", 0.10],
            ["darken", 0.10],
            ["darken", 0.60]
        ]
    };
    NodeParser.prototype.parseBorders = function(container) {
        var nodeBounds = container.parseBounds();
        var radius = getBorderRadiusData(container);
        var borders = ["Top", "Right", "Bottom", "Left"].map(function(side, index) {
            var style = container.css('border' + side + 'Style');
            var color = container.color('border' + side + 'Color');
            if (style === "inset" && color.isBlack()) {
                color = new Color([255, 255, 255, color.a]);
            }
            var colorTransform = borderColorTransforms[style] ? borderColorTransforms[style][index] : null;
            return {
                width: container.cssInt('border' + side + 'Width'),
                color: colorTransform ? color[colorTransform[0]](colorTransform[1]) : color,
                args: null
            };
        });
        var borderPoints = calculateCurvePoints(nodeBounds, radius, borders);
        return {
            clip: this.parseBackgroundClip(container, borderPoints, borders, radius, nodeBounds),
            borders: calculateBorders(borders, nodeBounds, borderPoints, radius)
        };
    };

    function calculateBorders(borders, nodeBounds, borderPoints, radius) {
        return borders.map(function(border, borderSide) {
            if (border.width > 0) {
                var bx = nodeBounds.left;
                var by = nodeBounds.top;
                var bw = nodeBounds.width;
                var bh = nodeBounds.height - (borders[2].width);
                switch (borderSide) {
                    case 0:
                        bh = borders[0].width;
                        border.args = drawSide({
                            c1: [bx, by],
                            c2: [bx + bw, by],
                            c3: [bx + bw - borders[1].width, by + bh],
                            c4: [bx + borders[3].width, by + bh]
                        }, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
                        break;
                    case 1:
                        bx = nodeBounds.left + nodeBounds.width - (borders[1].width);
                        bw = borders[1].width;
                        border.args = drawSide({
                            c1: [bx + bw, by],
                            c2: [bx + bw, by + bh + borders[2].width],
                            c3: [bx, by + bh],
                            c4: [bx, by + borders[0].width]
                        }, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
                        break;
                    case 2:
                        by = (by + nodeBounds.height) - (borders[2].width);
                        bh = borders[2].width;
                        border.args = drawSide({
                            c1: [bx + bw, by + bh],
                            c2: [bx, by + bh],
                            c3: [bx + borders[3].width, by],
                            c4: [bx + bw - borders[3].width, by]
                        }, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
                        break;
                    case 3:
                        bw = borders[3].width;
                        border.args = drawSide({
                            c1: [bx, by + bh + borders[2].width],
                            c2: [bx, by],
                            c3: [bx + bw, by + borders[0].width],
                            c4: [bx + bw, by + bh]
                        }, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
                        break;
                }
            }
            return border;
        });
    }
    NodeParser.prototype.parseBackgroundClip = function(container, borderPoints, borders, radius, bounds) {
        var backgroundClip = container.css('backgroundClip'),
            borderArgs = [];
        switch (backgroundClip) {
            case "content-box":
            case "padding-box":
                parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
                parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
                parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
                parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
                break;
            default:
                parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
                parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
                parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
                parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
                break;
        }
        return borderArgs;
    };

    function getCurvePoints(x, y, r1, r2) {
        var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
        var ox = (r1) * kappa,
            oy = (r2) * kappa,
            xm = x + r1,
            ym = y + r2;
        return {
            topLeft: bezierCurve({
                x: x,
                y: ym
            }, {
                x: x,
                y: ym - oy
            }, {
                x: xm - ox,
                y: y
            }, {
                x: xm,
                y: y
            }),
            topRight: bezierCurve({
                x: x,
                y: y
            }, {
                x: x + ox,
                y: y
            }, {
                x: xm,
                y: ym - oy
            }, {
                x: xm,
                y: ym
            }),
            bottomRight: bezierCurve({
                x: xm,
                y: y
            }, {
                x: xm,
                y: y + oy
            }, {
                x: x + ox,
                y: ym
            }, {
                x: x,
                y: ym
            }),
            bottomLeft: bezierCurve({
                x: xm,
                y: ym
            }, {
                x: xm - ox,
                y: ym
            }, {
                x: x,
                y: y + oy
            }, {
                x: x,
                y: y
            })
        };
    }

    function calculateCurvePoints(bounds, borderRadius, borders) {
        var x = bounds.left,
            y = bounds.top,
            width = bounds.width,
            height = bounds.height,
            tlh = borderRadius[0][0],
            tlv = borderRadius[0][1],
            trh = borderRadius[1][0],
            trv = borderRadius[1][1],
            brh = borderRadius[2][0],
            brv = borderRadius[2][1],
            blh = borderRadius[3][0],
            blv = borderRadius[3][1];
        var topWidth = width - trh,
            rightHeight = height - brv,
            bottomWidth = width - brh,
            leftHeight = height - blv;
        return {
            topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5),
            topLeftInner: getCurvePoints(x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width)).topLeft.subdivide(0.5),
            topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5),
            topRightInner: getCurvePoints(x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, (topWidth > width + borders[3].width) ? 0 : trh - borders[3].width, trv - borders[0].width).topRight.subdivide(0.5),
            bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5),
            bottomRightInner: getCurvePoints(x + Math.min(bottomWidth, width - borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width), brv - borders[2].width).bottomRight.subdivide(0.5),
            bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5),
            bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), blv - borders[2].width).bottomLeft.subdivide(0.5)
        };
    }

    function bezierCurve(start, startControl, endControl, end) {
        var lerp = function(a, b, t) {
            return {
                x: a.x + (b.x - a.x) * t,
                y: a.y + (b.y - a.y) * t
            };
        };
        return {
            start: start,
            startControl: startControl,
            endControl: endControl,
            end: end,
            subdivide: function(t) {
                var ab = lerp(start, startControl, t),
                    bc = lerp(startControl, endControl, t),
                    cd = lerp(endControl, end, t),
                    abbc = lerp(ab, bc, t),
                    bccd = lerp(bc, cd, t),
                    dest = lerp(abbc, bccd, t);
                return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
            },
            curveTo: function(borderArgs) {
                borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
            },
            curveToReversed: function(borderArgs) {
                borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
            }
        };
    }

    function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
        var borderArgs = [];
        if (radius1[0] > 0 || radius1[1] > 0) {
            borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
            outer1[1].curveTo(borderArgs);
        } else {
            borderArgs.push(["line", borderData.c1[0], borderData.c1[1]]);
        }
        if (radius2[0] > 0 || radius2[1] > 0) {
            borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
            outer2[0].curveTo(borderArgs);
            borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
            inner2[0].curveToReversed(borderArgs);
        } else {
            borderArgs.push(["line", borderData.c2[0], borderData.c2[1]]);
            borderArgs.push(["line", borderData.c3[0], borderData.c3[1]]);
        }
        if (radius1[0] > 0 || radius1[1] > 0) {
            borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
            inner1[1].curveToReversed(borderArgs);
        } else {
            borderArgs.push(["line", borderData.c4[0], borderData.c4[1]]);
        }
        return borderArgs;
    }

    function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
        if (radius1[0] > 0 || radius1[1] > 0) {
            borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
            corner1[0].curveTo(borderArgs);
            corner1[1].curveTo(borderArgs);
        } else {
            borderArgs.push(["line", x, y]);
        }
        if (radius2[0] > 0 || radius2[1] > 0) {
            borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
        }
    }

    function negativeZIndex(container) {
        return container.cssInt("zIndex") < 0;
    }

    function positiveZIndex(container) {
        return container.cssInt("zIndex") > 0;
    }

    function zIndex0(container) {
        return container.cssInt("zIndex") === 0;
    }

    function inlineLevel(container) {
        return ["inline", "inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
    }

    function isStackingContext(container) {
        return (container instanceof StackingContext);
    }

    function hasText(container) {
        return container.node.data.trim().length > 0;
    }

    function noLetterSpacing(container) {
        return (/^(normal|none|0px)$/.test(container.parent.css("letterSpacing")));
    }

    function getBorderRadiusData(container) {
        return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(side) {
            var value = container.css('border' + side + 'Radius');
            var arr = value.split(" ");
            if (arr.length <= 1) {
                arr[1] = arr[0];
            }
            return arr.map(asInt);
        });
    }

    function renderableNode(node) {
        return (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }

    function isPositionedForStacking(container) {
        var position = container.css("position");
        var zIndex = (["absolute", "relative", "fixed"].indexOf(position) !== -1) ? container.css("zIndex") : "auto";
        return zIndex !== "auto";
    }

    function isPositioned(container) {
        return container.css("position") !== "static";
    }

    function isFloating(container) {
        return container.css("float") !== "none";
    }

    function isInlineBlock(container) {
        return ["inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
    }

    function not(callback) {
        var context = this;
        return function() {
            return !callback.apply(context, arguments);
        };
    }

    function isElement(container) {
        return container.node.nodeType === Node.ELEMENT_NODE;
    }

    function isPseudoElement(container) {
        return container.isPseudoElement === true;
    }

    function isTextNode(container) {
        return container.node.nodeType === Node.TEXT_NODE;
    }

    function zIndexSort(contexts) {
        return function(a, b) {
            return (a.cssInt("zIndex") + (contexts.indexOf(a) / contexts.length)) - (b.cssInt("zIndex") + (contexts.indexOf(b) / contexts.length));
        };
    }

    function hasOpacity(container) {
        return container.getOpacity() < 1;
    }

    function bind(callback, context) {
        return function() {
            return callback.apply(context, arguments);
        };
    }

    function asInt(value) {
        return parseInt(value, 10);
    }

    function getWidth(border) {
        return border.width;
    }

    function nonIgnoredElement(nodeContainer) {
        return (nodeContainer.node.nodeType !== Node.ELEMENT_NODE || ["SCRIPT", "HEAD", "TITLE", "OBJECT", "BR", "OPTION"].indexOf(nodeContainer.node.nodeName) === -1);
    }

    function flatten(arrays) {
        return [].concat.apply([], arrays);
    }

    function stripQuotes(content) {
        var first = content.substr(0, 1);
        return (first === content.substr(content.length - 1) && first.match(/'|"/)) ? content.substr(1, content.length - 2) : content;
    }

    function getWords(characters) {
        var words = [],
            i = 0,
            onWordBoundary = false,
            word;
        while (characters.length) {
            if (isWordBoundary(characters[i]) === onWordBoundary) {
                word = characters.splice(0, i);
                if (word.length) {
                    words.push(window.html2canvas.punycode.ucs2.encode(word));
                }
                onWordBoundary = !onWordBoundary;
                i = 0;
            } else {
                i++;
            }
            if (i >= characters.length) {
                word = characters.splice(0, i);
                if (word.length) {
                    words.push(window.html2canvas.punycode.ucs2.encode(word));
                }
            }
        }
        return words;
    }

    function isWordBoundary(characterCode) {
        return [32, 13, 10, 9, 45].indexOf(characterCode) !== -1;
    }

    function hasUnicode(string) {
        return (/[^\u0000-\u00ff]/).test(string);
    }

    function Proxy(src, proxyUrl, document) {
        if (!proxyUrl) {
            return Promise.reject("No proxy configured");
        }
        var callback = createCallback(supportsCORS);
        var url = createProxyUrl(proxyUrl, src, callback);
        return supportsCORS ? XHR(url) : (jsonp(document, url, callback).then(function(response) {
            return decode64(response.content);
        }));
    }
    var proxyCount = 0;
    var supportsCORS = ('withCredentials' in new XMLHttpRequest());
    var supportsCORSImage = ('crossOrigin' in new Image());

    function ProxyURL(src, proxyUrl, document) {
        var callback = createCallback(supportsCORSImage);
        var url = createProxyUrl(proxyUrl, src, callback);
        return (supportsCORSImage ? Promise.resolve(url) : jsonp(document, url, callback).then(function(response) {
            return "data:" + response.type + ";base64," + response.content;
        }));
    }

    function jsonp(document, url, callback) {
        return new Promise(function(resolve, reject) {
            var s = document.createElement("script");
            var cleanup = function() {
                delete window.html2canvas.proxy[callback];
                document.body.removeChild(s);
            };
            window.html2canvas.proxy[callback] = function(response) {
                cleanup();
                resolve(response);
            };
            s.src = url;
            s.onerror = function(e) {
                cleanup();
                reject(e);
            };
            document.body.appendChild(s);
        });
    }

    function createCallback(useCORS) {
        return !useCORS ? "html2canvas_" + Date.now() + "_" + (++proxyCount) + "_" + Math.round(Math.random() * 100000) : "";
    }

    function createProxyUrl(proxyUrl, src, callback) {
        return proxyUrl + "?url=" + encodeURIComponent(src) + (callback.length ? "&callback=html2canvas.proxy." + callback : "");
    }

    function ProxyImageContainer(src, proxy) {
        var script = document.createElement("script");
        var link = document.createElement("a");
        link.href = src;
        src = link.href;
        this.src = src;
        this.image = new Image();
        var self = this;
        this.promise = new Promise(function(resolve, reject) {
            self.image.crossOrigin = "Anonymous";
            self.image.onload = resolve;
            self.image.onerror = reject;
            new ProxyURL(src, proxy, document).then(function(url) {
                self.image.src = url;
            })['catch'](reject);
        });
    }

    function PseudoElementContainer(node, parent, type) {
        NodeContainer.call(this, node, parent);
        this.isPseudoElement = true;
        this.before = type === ":before";
    }
    PseudoElementContainer.prototype.cloneTo = function(stack) {
        PseudoElementContainer.prototype.cloneTo.call(this, stack);
        stack.isPseudoElement = true;
        stack.before = this.before;
    };
    PseudoElementContainer.prototype = Object.create(NodeContainer.prototype);
    PseudoElementContainer.prototype.appendToDOM = function() {
        if (this.before) {
            this.parent.node.insertBefore(this.node, this.parent.node.firstChild);
        } else {
            this.parent.node.appendChild(this.node);
        }
        this.parent.node.className += " " + this.getHideClass();
    };
    PseudoElementContainer.prototype.cleanDOM = function() {
        this.node.parentNode.removeChild(this.node);
        this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
    };
    PseudoElementContainer.prototype.getHideClass = function() {
        return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
    };
    PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
    PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";

    function Renderer(width, height, images, options, document) {
        this.width = width;
        this.height = height;
        this.images = images;
        this.options = options;
        this.document = document;
    }
    Renderer.prototype.renderImage = function(container, bounds, borderData, imageContainer) {
        var paddingLeft = container.cssInt('paddingLeft'),
            paddingTop = container.cssInt('paddingTop'),
            paddingRight = container.cssInt('paddingRight'),
            paddingBottom = container.cssInt('paddingBottom'),
            borders = borderData.borders;
        var width = bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight);
        var height = bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom);
        this.drawImage(imageContainer, 0, 0, imageContainer.image.width || width, imageContainer.image.height || height, bounds.left + paddingLeft + borders[3].width, bounds.top + paddingTop + borders[0].width, width, height);
    };
    Renderer.prototype.renderBackground = function(container, bounds, borderData) {
        if (bounds.height > 0 && bounds.width > 0) {
            this.renderBackgroundColor(container, bounds);
            this.renderBackgroundImage(container, bounds, borderData);
        }
    };
    Renderer.prototype.renderBackgroundColor = function(container, bounds) {
        var color = container.color("backgroundColor");
        if (!color.isTransparent()) {
            this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, color);
        }
    };
    Renderer.prototype.renderBorders = function(borders) {
        borders.forEach(this.renderBorder, this);
    };
    Renderer.prototype.renderBorder = function(data) {
        if (!data.color.isTransparent() && data.args !== null) {
            this.drawShape(data.args, data.color);
        }
    };
    Renderer.prototype.renderBackgroundImage = function(container, bounds, borderData) {
        var backgroundImages = container.parseBackgroundImages();
        backgroundImages.reverse().forEach(function(backgroundImage, index, arr) {
            switch (backgroundImage.method) {
                case "url":
                    var image = this.images.get(backgroundImage.args[0]);
                    if (image) {
                        this.renderBackgroundRepeating(container, bounds, image, arr.length - (index + 1), borderData);
                    } else {
                        log("Error loading background-image", backgroundImage.args[0]);
                    }
                    break;
                case "linear-gradient":
                case "gradient":
                    var gradientImage = this.images.get(backgroundImage.value);
                    if (gradientImage) {
                        this.renderBackgroundGradient(gradientImage, bounds, borderData);
                    } else {
                        log("Error loading background-image", backgroundImage.args[0]);
                    }
                    break;
                case "none":
                    break;
                default:
                    log("Unknown background-image type", backgroundImage.args[0]);
            }
        }, this);
    };
    Renderer.prototype.renderBackgroundRepeating = function(container, bounds, imageContainer, index, borderData) {
        var size = container.parseBackgroundSize(bounds, imageContainer.image, index);
        var position = container.parseBackgroundPosition(bounds, imageContainer.image, index, size);
        var repeat = container.parseBackgroundRepeat(index);
        switch (repeat) {
            case "repeat-x":
            case "repeat no-repeat":
                this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + borderData[3], bounds.top + position.top + borderData[0], 99999, size.height, borderData);
                break;
            case "repeat-y":
            case "no-repeat repeat":
                this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + borderData[0], size.width, 99999, borderData);
                break;
            case "no-repeat":
                this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + position.top + borderData[0], size.width, size.height, borderData);
                break;
            default:
                this.renderBackgroundRepeat(imageContainer, position, size, {
                    top: bounds.top,
                    left: bounds.left
                }, borderData[3], borderData[0]);
                break;
        }
    };

    function StackingContext(hasOwnStacking, opacity, element, parent) {
        NodeContainer.call(this, element, parent);
        this.ownStacking = hasOwnStacking;
        this.contexts = [];
        this.children = [];
        this.opacity = (this.parent ? this.parent.stack.opacity : 1) * opacity;
    }
    StackingContext.prototype = Object.create(NodeContainer.prototype);
    StackingContext.prototype.getParentStack = function(context) {
        var parentStack = (this.parent) ? this.parent.stack : null;
        return parentStack ? (parentStack.ownStacking ? parentStack : parentStack.getParentStack(context)) : context.stack;
    };

    function Support(document) {
        this.rangeBounds = this.testRangeBounds(document);
        this.cors = this.testCORS();
        this.svg = this.testSVG();
    }
    Support.prototype.testRangeBounds = function(document) {
        var range, testElement, rangeBounds, rangeHeight, support = false;
        if (document.createRange) {
            range = document.createRange();
            if (range.getBoundingClientRect) {
                testElement = document.createElement('boundtest');
                testElement.style.height = "123px";
                testElement.style.display = "block";
                document.body.appendChild(testElement);
                range.selectNode(testElement);
                rangeBounds = range.getBoundingClientRect();
                rangeHeight = rangeBounds.height;
                if (rangeHeight === 123) {
                    support = true;
                }
                document.body.removeChild(testElement);
            }
        }
        return support;
    };
    Support.prototype.testCORS = function() {
        return typeof((new Image()).crossOrigin) !== "undefined";
    };
    Support.prototype.testSVG = function() {
        var img = new Image();
        var canvas = document.createElement("canvas");
        var ctx = canvas.getContext("2d");
        img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
        try {
            ctx.drawImage(img, 0, 0);
            canvas.toDataURL();
        } catch (e) {
            return false;
        }
        return true;
    };

    function SVGContainer(src) {
        this.src = src;
        this.image = null;
        var self = this;
        this.promise = this.hasFabric().then(function() {
            return (self.isInline(src) ? Promise.resolve(self.inlineFormatting(src)) : XHR(src));
        }).then(function(svg) {
            return new Promise(function(resolve) {
                html2canvas.fabric.loadSVGFromString(svg, self.createCanvas.call(self, resolve));
            });
        });
    }
    SVGContainer.prototype.hasFabric = function() {
        return !html2canvas.fabric ? Promise.reject(new Error("html2canvas.svg.js is not loaded, cannot render svg")) : Promise.resolve();
    };
    SVGContainer.prototype.inlineFormatting = function(src) {
        return (/^data:image\/svg\+xml;base64,/.test(src)) ? this.decode64(this.removeContentType(src)) : this.removeContentType(src);
    };
    SVGContainer.prototype.removeContentType = function(src) {
        return src.replace(/^data:image\/svg\+xml(;base64)?,/, '');
    };
    SVGContainer.prototype.isInline = function(src) {
        return (/^data:image\/svg\+xml/i.test(src));
    };
    SVGContainer.prototype.createCanvas = function(resolve) {
        var self = this;
        return function(objects, options) {
            var canvas = new html2canvas.fabric.StaticCanvas('c');
            self.image = canvas.lowerCanvasEl;
            canvas.setWidth(options.width).setHeight(options.height).add(html2canvas.fabric.util.groupSVGElements(objects, options)).renderAll();
            resolve(canvas.lowerCanvasEl);
        };
    };
    SVGContainer.prototype.decode64 = function(str) {
        return (typeof(window.atob) === "function") ? window.atob(str) : decode64(str);
    };

    function decode64(base64) {
        var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var len = base64.length,
            i, encoded1, encoded2, encoded3, encoded4, byte1, byte2, byte3;
        var output = "";
        for (i = 0; i < len; i += 4) {
            encoded1 = chars.indexOf(base64[i]);
            encoded2 = chars.indexOf(base64[i + 1]);
            encoded3 = chars.indexOf(base64[i + 2]);
            encoded4 = chars.indexOf(base64[i + 3]);
            byte1 = (encoded1 << 2) | (encoded2 >> 4);
            byte2 = ((encoded2 & 15) << 4) | (encoded3 >> 2);
            byte3 = ((encoded3 & 3) << 6) | encoded4;
            if (encoded3 === 64) {
                output += String.fromCharCode(byte1);
            } else if (encoded4 === 64 || encoded4 === -1) {
                output += String.fromCharCode(byte1, byte2);
            } else {
                output += String.fromCharCode(byte1, byte2, byte3);
            }
        }
        return output;
    }

    function SVGNodeContainer(node, native) {
        this.src = node;
        this.image = null;
        var self = this;
        this.promise = native ? new Promise(function(resolve, reject) {
            self.image = new Image();
            self.image.onload = resolve;
            self.image.onerror = reject;
            self.image.src = "data:image/svg+xml," + (new XMLSerializer()).serializeToString(node);
            if (self.image.complete === true) {
                resolve(self.image);
            }
        }) : this.hasFabric().then(function() {
            return new Promise(function(resolve) {
                html2canvas.fabric.parseSVGDocument(node, self.createCanvas.call(self, resolve));
            });
        });
    }
    SVGNodeContainer.prototype = Object.create(SVGContainer.prototype);

    function TextContainer(node, parent) {
        NodeContainer.call(this, node, parent);
    }
    TextContainer.prototype = Object.create(NodeContainer.prototype);
    TextContainer.prototype.applyTextTransform = function() {
        this.node.data = this.transform(this.parent.css("textTransform"));
    };
    TextContainer.prototype.transform = function(transform) {
        var text = this.node.data;
        switch (transform) {
            case "lowercase":
                return text.toLowerCase();
            case "capitalize":
                return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
            case "uppercase":
                return text.toUpperCase();
            default:
                return text;
        }
    };

    function capitalize(m, p1, p2) {
        if (m.length > 0) {
            return p1 + p2.toUpperCase();
        }
    }

    function WebkitGradientContainer(imageData) {
        GradientContainer.apply(this, arguments);
        this.type = (imageData.args[0] === "linear") ? this.TYPES.LINEAR : this.TYPES.RADIAL;
    }
    WebkitGradientContainer.prototype = Object.create(GradientContainer.prototype);

    function XHR(url) {
        return new Promise(function(resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url);
            xhr.onload = function() {
                if (xhr.status === 200) {
                    resolve(xhr.responseText);
                } else {
                    reject(new Error(xhr.statusText));
                }
            };
            xhr.onerror = function() {
                reject(new Error("Network Error"));
            };
            xhr.send();
        });
    }

    function CanvasRenderer(width, height) {
        Renderer.apply(this, arguments);
        this.canvas = this.options.canvas || this.document.createElement("canvas");
        if (!this.options.canvas) {
            this.canvas.width = width;
            this.canvas.height = height;
        }
        this.ctx = this.canvas.getContext("2d");
        this.taintCtx = this.document.createElement("canvas").getContext("2d");
        this.ctx.textBaseline = "bottom";
        this.variables = {};
        log("Initialized CanvasRenderer with size", width, "x", height);
    }
    CanvasRenderer.prototype = Object.create(Renderer.prototype);
    CanvasRenderer.prototype.setFillStyle = function(fillStyle) {
        this.ctx.fillStyle = typeof(fillStyle) === "object" && !!fillStyle.isColor ? fillStyle.toString() : fillStyle;
        return this.ctx;
    };
    CanvasRenderer.prototype.rectangle = function(left, top, width, height, color) {
        this.setFillStyle(color).fillRect(left, top, width, height);
    };
    CanvasRenderer.prototype.circle = function(left, top, size, color) {
        this.setFillStyle(color);
        this.ctx.beginPath();
        this.ctx.arc(left + size / 2, top + size / 2, size / 2, 0, Math.PI * 2, true);
        this.ctx.closePath();
        this.ctx.fill();
    };
    CanvasRenderer.prototype.circleStroke = function(left, top, size, color, stroke, strokeColor) {
        this.circle(left, top, size, color);
        this.ctx.strokeStyle = strokeColor.toString();
        this.ctx.stroke();
    };
    CanvasRenderer.prototype.drawShape = function(shape, color) {
        this.shape(shape);
        this.setFillStyle(color).fill();
    };
    CanvasRenderer.prototype.taints = function(imageContainer) {
        if (imageContainer.tainted === null) {
            this.taintCtx.drawImage(imageContainer.image, 0, 0);
            try {
                this.taintCtx.getImageData(0, 0, 1, 1);
                imageContainer.tainted = false;
            } catch (e) {
                this.taintCtx = document.createElement("canvas").getContext("2d");
                imageContainer.tainted = true;
            }
        }
        return imageContainer.tainted;
    };
    CanvasRenderer.prototype.drawImage = function(imageContainer, sx, sy, sw, sh, dx, dy, dw, dh) {
        if (!this.taints(imageContainer) || this.options.allowTaint) {
            this.ctx.drawImage(imageContainer.image, sx, sy, sw, sh, dx, dy, dw, dh);
        }
    };
    CanvasRenderer.prototype.clip = function(shapes, callback, context) {
        this.ctx.save();
        shapes.filter(hasEntries).forEach(function(shape) {
            this.shape(shape).clip();
        }, this);
        callback.call(context);
        this.ctx.restore();
    };
    CanvasRenderer.prototype.shape = function(shape) {
        this.ctx.beginPath();
        shape.forEach(function(point, index) {
            if (point[0] === "rect") {
                this.ctx.rect.apply(this.ctx, point.slice(1));
            } else {
                this.ctx[(index === 0) ? "moveTo" : point[0] + "To"].apply(this.ctx, point.slice(1));
            }
        }, this);
        this.ctx.closePath();
        return this.ctx;
    };
    CanvasRenderer.prototype.font = function(color, style, variant, weight, size, family) {
        this.setFillStyle(color).font = [style, variant, weight, size, family].join(" ").split(",")[0];
    };
    CanvasRenderer.prototype.fontShadow = function(color, offsetX, offsetY, blur) {
        this.setVariable("shadowColor", color.toString()).setVariable("shadowOffsetY", offsetX).setVariable("shadowOffsetX", offsetY).setVariable("shadowBlur", blur);
    };
    CanvasRenderer.prototype.clearShadow = function() {
        this.setVariable("shadowColor", "rgba(0,0,0,0)");
    };
    CanvasRenderer.prototype.setOpacity = function(opacity) {
        this.ctx.globalAlpha = opacity;
    };
    CanvasRenderer.prototype.setTransform = function(transform) {
        this.ctx.translate(transform.origin[0], transform.origin[1]);
        this.ctx.transform.apply(this.ctx, transform.matrix);
        this.ctx.translate(-transform.origin[0], -transform.origin[1]);
    };
    CanvasRenderer.prototype.setVariable = function(property, value) {
        if (this.variables[property] !== value) {
            this.variables[property] = this.ctx[property] = value;
        }
        return this;
    };
    CanvasRenderer.prototype.text = function(text, left, bottom) {
        this.ctx.fillText(text, left, bottom);
    };
    CanvasRenderer.prototype.backgroundRepeatShape = function(imageContainer, backgroundPosition, size, bounds, left, top, width, height, borderData) {
        var shape = [
            ["line", Math.round(left), Math.round(top)],
            ["line", Math.round(left + width), Math.round(top)],
            ["line", Math.round(left + width), Math.round(height + top)],
            ["line", Math.round(left), Math.round(height + top)]
        ];
        this.clip([shape], function() {
            this.renderBackgroundRepeat(imageContainer, backgroundPosition, size, bounds, borderData[3], borderData[0]);
        }, this);
    };
    CanvasRenderer.prototype.renderBackgroundRepeat = function(imageContainer, backgroundPosition, size, bounds, borderLeft, borderTop) {
        var offsetX = Math.round(bounds.left + backgroundPosition.left + borderLeft),
            offsetY = Math.round(bounds.top + backgroundPosition.top + borderTop);
        this.setFillStyle(this.ctx.createPattern(this.resizeImage(imageContainer, size), "repeat"));
        this.ctx.translate(offsetX, offsetY);
        this.ctx.fill();
        this.ctx.translate(-offsetX, -offsetY);
    };
    CanvasRenderer.prototype.renderBackgroundGradient = function(gradientImage, bounds) {
        if (gradientImage instanceof LinearGradientContainer) {
            var gradient = this.ctx.createLinearGradient(bounds.left + bounds.width * gradientImage.x0, bounds.top + bounds.height * gradientImage.y0, bounds.left + bounds.width * gradientImage.x1, bounds.top + bounds.height * gradientImage.y1);
            gradientImage.colorStops.forEach(function(colorStop) {
                gradient.addColorStop(colorStop.stop, colorStop.color.toString());
            });
            this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, gradient);
        }
    };
    CanvasRenderer.prototype.resizeImage = function(imageContainer, size) {
        var image = imageContainer.image;
        if (image.width === size.width && image.height === size.height) {
            return image;
        }
        var ctx, canvas = document.createElement('canvas');
        canvas.width = size.width;
        canvas.height = size.height;
        ctx = canvas.getContext("2d");
        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height);
        return canvas;
    };

    function hasEntries(array) {
        return array.length > 0;
    }
}).call({}, typeof(window) !== "undefined" ? window : undefined, typeof(document) !== "undefined" ? document : undefined);;
(function(window, document, exports, undefined) {
    var fabric = fabric || {
        version: "1.4.11"
    };
    if (typeof exports !== 'undefined') {
        exports.fabric = fabric;
    }
    if (typeof document !== 'undefined' && typeof window !== 'undefined') {
        fabric.document = document;
        fabric.window = window;
    } else {
        fabric.document = require("jsdom").jsdom("<!DOCTYPE html><html><head></head><body></body></html>");
        fabric.window = fabric.document.createWindow();
    }
    fabric.isTouchSupported = "ontouchstart" in fabric.document.documentElement;
    fabric.isLikelyNode = typeof Buffer !== 'undefined' && typeof window === 'undefined';
    fabric.SHARED_ATTRIBUTES = ["display", "transform", "fill", "fill-opacity", "fill-rule", "opacity", "stroke", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width"];
    fabric.DPI = 96;
    var Cufon = (function() {
        var api = function() {
            return api.replace.apply(null, arguments);
        };
        var DOM = api.DOM = {
            ready: (function() {
                var complete = false,
                    readyStatus = {
                        loaded: 1,
                        complete: 1
                    };
                var queue = [],
                    perform = function() {
                        if (complete) return;
                        complete = true;
                        for (var fn; fn = queue.shift(); fn());
                    };
                if (fabric.document.addEventListener) {
                    fabric.document.addEventListener('DOMContentLoaded', perform, false);
                    fabric.window.addEventListener('pageshow', perform, false);
                }
                if (!fabric.window.opera && fabric.document.readyState)(function() {
                    readyStatus[fabric.document.readyState] ? perform() : setTimeout(arguments.callee, 10);
                })();
                if (fabric.document.readyState && fabric.document.createStyleSheet)(function() {
                    try {
                        fabric.document.body.doScroll('left');
                        perform();
                    } catch (e) {
                        setTimeout(arguments.callee, 1);
                    }
                })();
                addEvent(fabric.window, 'load', perform);
                return function(listener) {
                    if (!arguments.length) perform();
                    else complete ? listener() : queue.push(listener);
                };
            })()
        };
        var CSS = api.CSS = {
            Size: function(value, base) {
                this.value = parseFloat(value);
                this.unit = String(value).match(/[a-z%]*$/)[0] || 'px';
                this.convert = function(value) {
                    return value / base * this.value;
                };
                this.convertFrom = function(value) {
                    return value / this.value * base;
                };
                this.toString = function() {
                    return this.value + this.unit;
                };
            },
            getStyle: function(el) {
                return new Style(el.style);
            },
            quotedList: cached(function(value) {
                var list = [],
                    re = /\s*((["'])([\s\S]*?[^\\])\2|[^,]+)\s*/g,
                    match;
                while (match = re.exec(value)) list.push(match[3] || match[1]);
                return list;
            }),
            ready: (function() {
                var complete = false;
                var queue = [],
                    perform = function() {
                        complete = true;
                        for (var fn; fn = queue.shift(); fn());
                    };
                var styleElements = Object.prototype.propertyIsEnumerable ? elementsByTagName('style') : {
                    length: 0
                };
                var linkElements = elementsByTagName('link');
                DOM.ready(function() {
                    var linkStyles = 0,
                        link;
                    for (var i = 0, l = linkElements.length; link = linkElements[i], i < l; ++i) {
                        if (!link.disabled && link.rel.toLowerCase() == 'stylesheet') ++linkStyles;
                    }
                    if (fabric.document.styleSheets.length >= styleElements.length + linkStyles) perform();
                    else setTimeout(arguments.callee, 10);
                });
                return function(listener) {
                    if (complete) listener();
                    else queue.push(listener);
                };
            })(),
            supports: function(property, value) {
                var checker = fabric.document.createElement('span').style;
                if (checker[property] === undefined) return false;
                checker[property] = value;
                return checker[property] === value;
            },
            textAlign: function(word, style, position, wordCount) {
                if (style.get('textAlign') == 'right') {
                    if (position > 0) word = ' ' + word;
                } else if (position < wordCount - 1) word += ' ';
                return word;
            },
            textDecoration: function(el, style) {
                if (!style) style = this.getStyle(el);
                var types = {
                    underline: null,
                    overline: null,
                    'line-through': null
                };
                for (var search = el; search.parentNode && search.parentNode.nodeType == 1;) {
                    var foundAll = true;
                    for (var type in types) {
                        if (types[type]) continue;
                        if (style.get('textDecoration').indexOf(type) != -1) types[type] = style.get('color');
                        foundAll = false;
                    }
                    if (foundAll) break;
                    style = this.getStyle(search = search.parentNode);
                }
                return types;
            },
            textShadow: cached(function(value) {
                if (value == 'none') return null;
                var shadows = [],
                    currentShadow = {},
                    result, offCount = 0;
                var re = /(#[a-f0-9]+|[a-z]+\(.*?\)|[a-z]+)|(-?[\d.]+[a-z%]*)|,/ig;
                while (result = re.exec(value)) {
                    if (result[0] == ',') {
                        shadows.push(currentShadow);
                        currentShadow = {}, offCount = 0;
                    } else if (result[1]) {
                        currentShadow.color = result[1];
                    } else {
                        currentShadow[['offX', 'offY', 'blur'][offCount++]] = result[2];
                    }
                }
                shadows.push(currentShadow);
                return shadows;
            }),
            color: cached(function(value) {
                var parsed = {};
                parsed.color = value.replace(/^rgba\((.*?),\s*([\d.]+)\)/, function($0, $1, $2) {
                    parsed.opacity = parseFloat($2);
                    return 'rgb(' + $1 + ')';
                });
                return parsed;
            }),
            textTransform: function(text, style) {
                return text[{
                    uppercase: 'toUpperCase',
                    lowercase: 'toLowerCase'
                }[style.get('textTransform')] || 'toString']();
            }
        };

        function Font(data) {
            var face = this.face = data.face;
            this.glyphs = data.glyphs;
            this.w = data.w;
            this.baseSize = parseInt(face['units-per-em'], 10);
            this.family = face['font-family'].toLowerCase();
            this.weight = face['font-weight'];
            this.style = face['font-style'] || 'normal';
            this.viewBox = (function() {
                var parts = face.bbox.split(/\s+/);
                var box = {
                    minX: parseInt(parts[0], 10),
                    minY: parseInt(parts[1], 10),
                    maxX: parseInt(parts[2], 10),
                    maxY: parseInt(parts[3], 10)
                };
                box.width = box.maxX - box.minX, box.height = box.maxY - box.minY;
                box.toString = function() {
                    return [this.minX, this.minY, this.width, this.height].join(' ');
                };
                return box;
            })();
            this.ascent = -parseInt(face.ascent, 10);
            this.descent = -parseInt(face.descent, 10);
            this.height = -this.ascent + this.descent;
        }

        function FontFamily() {
            var styles = {},
                mapping = {
                    oblique: 'italic',
                    italic: 'oblique'
                };
            this.add = function(font) {
                (styles[font.style] || (styles[font.style] = {}))[font.weight] = font;
            };
            this.get = function(style, weight) {
                var weights = styles[style] || styles[mapping[style]] || styles.normal || styles.italic || styles.oblique;
                if (!weights) return null;
                weight = {
                    normal: 400,
                    bold: 700
                }[weight] || parseInt(weight, 10);
                if (weights[weight]) return weights[weight];
                var up = {
                        1: 1,
                        99: 0
                    }[weight % 100],
                    alts = [],
                    min, max;
                if (up === undefined) up = weight > 400;
                if (weight == 500) weight = 400;
                for (var alt in weights) {
                    alt = parseInt(alt, 10);
                    if (!min || alt < min) min = alt;
                    if (!max || alt > max) max = alt;
                    alts.push(alt);
                }
                if (weight < min) weight = min;
                if (weight > max) weight = max;
                alts.sort(function(a, b) {
                    return (up ? (a > weight && b > weight) ? a < b : a > b : (a < weight && b < weight) ? a > b : a < b) ? -1 : 1;
                });
                return weights[alts[0]];
            };
        }

        function HoverHandler() {
            function contains(node, anotherNode) {
                if (node.contains) return node.contains(anotherNode);
                return node.compareDocumentPosition(anotherNode) & 16;
            }

            function onOverOut(e) {
                var related = e.relatedTarget;
                if (!related || contains(this, related)) return;
                trigger(this);
            }

            function onEnterLeave(e) {
                trigger(this);
            }

            function trigger(el) {
                setTimeout(function() {
                    api.replace(el, sharedStorage.get(el).options, true);
                }, 10);
            }
            this.attach = function(el) {
                if (el.onmouseenter === undefined) {
                    addEvent(el, 'mouseover', onOverOut);
                    addEvent(el, 'mouseout', onOverOut);
                } else {
                    addEvent(el, 'mouseenter', onEnterLeave);
                    addEvent(el, 'mouseleave', onEnterLeave);
                }
            };
        }

        function Storage() {
            var map = {},
                at = 0;

            function identify(el) {
                return el.cufid || (el.cufid = ++at);
            }
            this.get = function(el) {
                var id = identify(el);
                return map[id] || (map[id] = {});
            };
        }

        function Style(style) {
            var custom = {},
                sizes = {};
            this.get = function(property) {
                return custom[property] != undefined ? custom[property] : style[property];
            };
            this.getSize = function(property, base) {
                return sizes[property] || (sizes[property] = new CSS.Size(this.get(property), base));
            };
            this.extend = function(styles) {
                for (var property in styles) custom[property] = styles[property];
                return this;
            };
        }

        function addEvent(el, type, listener) {
            if (el.addEventListener) {
                el.addEventListener(type, listener, false);
            } else if (el.attachEvent) {
                el.attachEvent('on' + type, function() {
                    return listener.call(el, fabric.window.event);
                });
            }
        }

        function attach(el, options) {
            var storage = sharedStorage.get(el);
            if (storage.options) return el;
            if (options.hover && options.hoverables[el.nodeName.toLowerCase()]) {
                hoverHandler.attach(el);
            }
            storage.options = options;
            return el;
        }

        function cached(fun) {
            var cache = {};
            return function(key) {
                if (!cache.hasOwnProperty(key)) cache[key] = fun.apply(null, arguments);
                return cache[key];
            };
        }

        function getFont(el, style) {
            if (!style) style = CSS.getStyle(el);
            var families = CSS.quotedList(style.get('fontFamily').toLowerCase()),
                family;
            for (var i = 0, l = families.length; i < l; ++i) {
                family = families[i];
                if (fonts[family]) return fonts[family].get(style.get('fontStyle'), style.get('fontWeight'));
            }
            return null;
        }

        function elementsByTagName(query) {
            return fabric.document.getElementsByTagName(query);
        }

        function merge() {
            var merged = {},
                key;
            for (var i = 0, l = arguments.length; i < l; ++i) {
                for (key in arguments[i]) merged[key] = arguments[i][key];
            }
            return merged;
        }

        function process(font, text, style, options, node, el) {
            var separate = options.separate;
            if (separate == 'none') return engines[options.engine].apply(null, arguments);
            var fragment = fabric.document.createDocumentFragment(),
                processed;
            var parts = text.split(separators[separate]),
                needsAligning = (separate == 'words');
            if (needsAligning && HAS_BROKEN_REGEXP) {
                if (/^\s/.test(text)) parts.unshift('');
                if (/\s$/.test(text)) parts.push('');
            }
            for (var i = 0, l = parts.length; i < l; ++i) {
                processed = engines[options.engine](font, needsAligning ? CSS.textAlign(parts[i], style, i, l) : parts[i], style, options, node, el, i < l - 1);
                if (processed) fragment.appendChild(processed);
            }
            return fragment;
        }

        function replaceElement(el, options) {
            var font, style, nextNode, redraw;
            for (var node = attach(el, options).firstChild; node; node = nextNode) {
                nextNode = node.nextSibling;
                redraw = false;
                if (node.nodeType == 1) {
                    if (!node.firstChild) continue;
                    if (!/cufon/.test(node.className)) {
                        arguments.callee(node, options);
                        continue;
                    } else redraw = true;
                }
                if (!style) style = CSS.getStyle(el).extend(options);
                if (!font) font = getFont(el, style);
                if (!font) continue;
                if (redraw) {
                    engines[options.engine](font, null, style, options, node, el);
                    continue;
                }
                var text = node.data;
                if (typeof G_vmlCanvasManager != 'undefined') {
                    text = text.replace(/\r/g, "\n");
                }
                if (text === '') continue;
                var processed = process(font, text, style, options, node, el);
                if (processed) node.parentNode.replaceChild(processed, node);
                else node.parentNode.removeChild(node);
            }
        }
        var HAS_BROKEN_REGEXP = ' '.split(/\s+/).length == 0;
        var sharedStorage = new Storage();
        var hoverHandler = new HoverHandler();
        var replaceHistory = [];
        var engines = {},
            fonts = {},
            defaultOptions = {
                engine: null,
                hover: false,
                hoverables: {
                    a: true
                },
                printable: true,
                selector: (fabric.window.Sizzle || (fabric.window.jQuery && function(query) {
                    return jQuery(query);
                }) || (fabric.window.dojo && dojo.query) || (fabric.window.$$ && function(query) {
                    return $$(query);
                }) || (fabric.window.$ && function(query) {
                    return $(query);
                }) || (fabric.document.querySelectorAll && function(query) {
                    return fabric.document.querySelectorAll(query);
                }) || elementsByTagName),
                separate: 'words',
                textShadow: 'none'
            };
        var separators = {
            words: /\s+/,
            characters: ''
        };
        api.now = function() {
            DOM.ready();
            return api;
        };
        api.refresh = function() {
            var currentHistory = replaceHistory.splice(0, replaceHistory.length);
            for (var i = 0, l = currentHistory.length; i < l; ++i) {
                api.replace.apply(null, currentHistory[i]);
            }
            return api;
        };
        api.registerEngine = function(id, engine) {
            if (!engine) return api;
            engines[id] = engine;
            return api.set('engine', id);
        };
        api.registerFont = function(data) {
            var font = new Font(data),
                family = font.family;
            if (!fonts[family]) fonts[family] = new FontFamily();
            fonts[family].add(font);
            return api.set('fontFamily', '"' + family + '"');
        };
        api.replace = function(elements, options, ignoreHistory) {
            options = merge(defaultOptions, options);
            if (!options.engine) return api;
            if (typeof options.textShadow == 'string' && options.textShadow)
                options.textShadow = CSS.textShadow(options.textShadow);
            if (!ignoreHistory) replaceHistory.push(arguments);
            if (elements.nodeType || typeof elements == 'string') elements = [elements];
            CSS.ready(function() {
                for (var i = 0, l = elements.length; i < l; ++i) {
                    var el = elements[i];
                    if (typeof el == 'string') api.replace(options.selector(el), options, true);
                    else replaceElement(el, options);
                }
            });
            return api;
        };
        api.replaceElement = function(el, options) {
            options = merge(defaultOptions, options);
            if (typeof options.textShadow == 'string' && options.textShadow)
                options.textShadow = CSS.textShadow(options.textShadow);
            return replaceElement(el, options);
        };
        api.engines = engines;
        api.fonts = fonts;
        api.getOptions = function() {
            return merge(defaultOptions);
        };
        api.set = function(option, value) {
            defaultOptions[option] = value;
            return api;
        };
        return api;
    })();
    Cufon.registerEngine('canvas', (function() {
        var HAS_INLINE_BLOCK = Cufon.CSS.supports('display', 'inline-block');
        var HAS_BROKEN_LINEHEIGHT = !HAS_INLINE_BLOCK && (fabric.document.compatMode == 'BackCompat' || /frameset|transitional/i.test(fabric.document.doctype.publicId));
        var styleSheet = fabric.document.createElement('style');
        styleSheet.type = 'text/css';
        var textNode = fabric.document.createTextNode('.cufon-canvas{text-indent:0}' + '@media screen,projection{' + '.cufon-canvas{display:inline;display:inline-block;position:relative;vertical-align:middle' +
            (HAS_BROKEN_LINEHEIGHT ? '' : ';font-size:1px;line-height:1px') + '}.cufon-canvas .cufon-alt{display:-moz-inline-box;display:inline-block;width:0;height:0;overflow:hidden}' +
            (HAS_INLINE_BLOCK ? '.cufon-canvas canvas{position:relative}' : '.cufon-canvas canvas{position:absolute}') + '}' + '@media print{' + '.cufon-canvas{padding:0 !important}' + '.cufon-canvas canvas{display:none}' + '.cufon-canvas .cufon-alt{display:inline}' + '}')
        try {
            styleSheet.appendChild(textNode);
        } catch (e) {
            styleSheet.setAttribute("type", "text/css");
            styleSheet.styleSheet.cssText = textNode.data;
        }
        fabric.document.getElementsByTagName('head')[0].appendChild(styleSheet);

        function generateFromVML(path, context) {
            var atX = 0,
                atY = 0;
            var code = [],
                re = /([mrvxe])([^a-z]*)/g,
                match;
            generate: for (var i = 0; match = re.exec(path); ++i) {
                var c = match[2].split(',');
                switch (match[1]) {
                    case 'v':
                        code[i] = {
                            m: 'bezierCurveTo',
                            a: [atX + ~~c[0], atY + ~~c[1], atX + ~~c[2], atY + ~~c[3], atX += ~~c[4], atY += ~~c[5]]
                        };
                        break;
                    case 'r':
                        code[i] = {
                            m: 'lineTo',
                            a: [atX += ~~c[0], atY += ~~c[1]]
                        };
                        break;
                    case 'm':
                        code[i] = {
                            m: 'moveTo',
                            a: [atX = ~~c[0], atY = ~~c[1]]
                        };
                        break;
                    case 'x':
                        code[i] = {
                            m: 'closePath',
                            a: []
                        };
                        break;
                    case 'e':
                        break generate;
                }
                context[code[i].m].apply(context, code[i].a);
            }
            return code;
        }

        function interpret(code, context) {
            for (var i = 0, l = code.length; i < l; ++i) {
                var line = code[i];
                context[line.m].apply(context, line.a);
            }
        }
        return function(font, text, style, options, node, el) {
            var redraw = (text === null);
            var viewBox = font.viewBox;
            var size = style.getSize('fontSize', font.baseSize);
            var letterSpacing = style.get('letterSpacing');
            letterSpacing = (letterSpacing == 'normal') ? 0 : size.convertFrom(parseInt(letterSpacing, 10));
            var expandTop = 0,
                expandRight = 0,
                expandBottom = 0,
                expandLeft = 0;
            var shadows = options.textShadow,
                shadowOffsets = [];
            Cufon.textOptions.shadowOffsets = [];
            Cufon.textOptions.shadows = null;
            if (shadows) {
                Cufon.textOptions.shadows = shadows;
                for (var i = 0, l = shadows.length; i < l; ++i) {
                    var shadow = shadows[i];
                    var x = size.convertFrom(parseFloat(shadow.offX));
                    var y = size.convertFrom(parseFloat(shadow.offY));
                    shadowOffsets[i] = [x, y];
                }
            }
            var chars = Cufon.CSS.textTransform(redraw ? node.alt : text, style).split('');
            var width = 0,
                lastWidth = null;
            var maxWidth = 0,
                lines = 1,
                lineWidths = [];
            for (var i = 0, l = chars.length; i < l; ++i) {
                if (chars[i] === '\n') {
                    lines++;
                    if (width > maxWidth) {
                        maxWidth = width;
                    }
                    lineWidths.push(width);
                    width = 0;
                    continue;
                }
                var glyph = font.glyphs[chars[i]] || font.missingGlyph;
                if (!glyph) continue;
                width += lastWidth = Number(glyph.w || font.w) + letterSpacing;
            }
            lineWidths.push(width);
            width = Math.max(maxWidth, width);
            var lineOffsets = [];
            for (var i = lineWidths.length; i--;) {
                lineOffsets[i] = width - lineWidths[i];
            }
            if (lastWidth === null) return null;
            expandRight += (viewBox.width - lastWidth);
            expandLeft += viewBox.minX;
            var wrapper, canvas;
            if (redraw) {
                wrapper = node;
                canvas = node.firstChild;
            } else {
                wrapper = fabric.document.createElement('span');
                wrapper.className = 'cufon cufon-canvas';
                wrapper.alt = text;
                canvas = fabric.document.createElement('canvas');
                wrapper.appendChild(canvas);
                if (options.printable) {
                    var print = fabric.document.createElement('span');
                    print.className = 'cufon-alt';
                    print.appendChild(fabric.document.createTextNode(text));
                    wrapper.appendChild(print);
                }
            }
            var wStyle = wrapper.style;
            var cStyle = canvas.style || {};
            var height = size.convert(viewBox.height - expandTop + expandBottom);
            var roundedHeight = Math.ceil(height);
            var roundingFactor = roundedHeight / height;
            canvas.width = Math.ceil(size.convert(width + expandRight - expandLeft) * roundingFactor);
            canvas.height = roundedHeight;
            expandTop += viewBox.minY;
            cStyle.top = Math.round(size.convert(expandTop - font.ascent)) + 'px';
            cStyle.left = Math.round(size.convert(expandLeft)) + 'px';
            var _width = Math.ceil(size.convert(width * roundingFactor));
            var wrapperWidth = _width + 'px';
            var _height = size.convert(font.height);
            var totalLineHeight = (options.lineHeight - 1) * size.convert(-font.ascent / 5) * (lines - 1);
            Cufon.textOptions.width = _width;
            Cufon.textOptions.height = (_height * lines) + totalLineHeight;
            Cufon.textOptions.lines = lines;
            Cufon.textOptions.totalLineHeight = totalLineHeight;
            if (HAS_INLINE_BLOCK) {
                wStyle.width = wrapperWidth;
                wStyle.height = _height + 'px';
            } else {
                wStyle.paddingLeft = wrapperWidth;
                wStyle.paddingBottom = (_height - 1) + 'px';
            }
            var g = Cufon.textOptions.context || canvas.getContext('2d'),
                scale = roundedHeight / viewBox.height;
            Cufon.textOptions.fontAscent = font.ascent * scale;
            Cufon.textOptions.boundaries = null;
            for (var offsets = Cufon.textOptions.shadowOffsets, i = shadowOffsets.length; i--;) {
                offsets[i] = [shadowOffsets[i][0] * scale, shadowOffsets[i][1] * scale];
            }
            g.save();
            g.scale(scale, scale);
            g.translate(-expandLeft - ((1 / scale * canvas.width) / 2) + (Cufon.fonts[font.family].offsetLeft || 0), -expandTop - ((Cufon.textOptions.height / scale) / 2) + (Cufon.fonts[font.family].offsetTop || 0));
            g.lineWidth = font.face['underline-thickness'];
            g.save();

            function line(y, color) {
                g.strokeStyle = color;
                g.beginPath();
                g.moveTo(0, y);
                g.lineTo(width, y);
                g.stroke();
            }
            var textDecoration = Cufon.getTextDecoration(options),
                isItalic = options.fontStyle === 'italic';

            function renderBackground() {
                g.save();
                var left = 0,
                    lineNum = 0,
                    boundaries = [{
                        left: 0
                    }];
                if (options.backgroundColor) {
                    g.save();
                    g.fillStyle = options.backgroundColor;
                    g.translate(0, font.ascent);
                    g.fillRect(0, 0, width + 10, (-font.ascent + font.descent) * lines);
                    g.restore();
                }
                if (options.textAlign === 'right') {
                    g.translate(lineOffsets[lineNum], 0);
                    boundaries[0].left = lineOffsets[lineNum] * scale;
                } else if (options.textAlign === 'center') {
                    g.translate(lineOffsets[lineNum] / 2, 0);
                    boundaries[0].left = lineOffsets[lineNum] / 2 * scale;
                }
                for (var i = 0, l = chars.length; i < l; ++i) {
                    if (chars[i] === '\n') {
                        lineNum++;
                        var topOffset = -font.ascent - ((font.ascent / 5) * options.lineHeight);
                        var boundary = boundaries[boundaries.length - 1];
                        var nextBoundary = {
                            left: 0
                        };
                        boundary.width = left * scale;
                        boundary.height = (-font.ascent + font.descent) * scale;
                        if (options.textAlign === 'right') {
                            g.translate(-width, topOffset);
                            g.translate(lineOffsets[lineNum], 0);
                            nextBoundary.left = lineOffsets[lineNum] * scale;
                        } else if (options.textAlign === 'center') {
                            g.translate(-left - (lineOffsets[lineNum - 1] / 2), topOffset);
                            g.translate(lineOffsets[lineNum] / 2, 0);
                            nextBoundary.left = lineOffsets[lineNum] / 2 * scale;
                        } else {
                            g.translate(-left, topOffset);
                        }
                        boundaries.push(nextBoundary);
                        left = 0;
                        continue;
                    }
                    var glyph = font.glyphs[chars[i]] || font.missingGlyph;
                    if (!glyph) continue;
                    var charWidth = Number(glyph.w || font.w) + letterSpacing;
                    if (options.textBackgroundColor) {
                        g.save();
                        g.fillStyle = options.textBackgroundColor;
                        g.translate(0, font.ascent);
                        g.fillRect(0, 0, charWidth + 10, -font.ascent + font.descent);
                        g.restore();
                    }
                    g.translate(charWidth, 0);
                    left += charWidth;
                    if (i == l - 1) {
                        boundaries[boundaries.length - 1].width = left * scale;
                        boundaries[boundaries.length - 1].height = (-font.ascent + font.descent) * scale;
                    }
                }
                g.restore();
                Cufon.textOptions.boundaries = boundaries;
            }

            function renderText(color) {
                g.fillStyle = color || Cufon.textOptions.color || style.get('color');
                var left = 0,
                    lineNum = 0;
                if (options.textAlign === 'right') {
                    g.translate(lineOffsets[lineNum], 0);
                } else if (options.textAlign === 'center') {
                    g.translate(lineOffsets[lineNum] / 2, 0);
                }
                for (var i = 0, l = chars.length; i < l; ++i) {
                    if (chars[i] === '\n') {
                        lineNum++;
                        var topOffset = -font.ascent - ((font.ascent / 5) * options.lineHeight);
                        if (options.textAlign === 'right') {
                            g.translate(-width, topOffset);
                            g.translate(lineOffsets[lineNum], 0);
                        } else if (options.textAlign === 'center') {
                            g.translate(-left - (lineOffsets[lineNum - 1] / 2), topOffset);
                            g.translate(lineOffsets[lineNum] / 2, 0);
                        } else {
                            g.translate(-left, topOffset);
                        }
                        left = 0;
                        continue;
                    }
                    var glyph = font.glyphs[chars[i]] || font.missingGlyph;
                    if (!glyph) continue;
                    var charWidth = Number(glyph.w || font.w) + letterSpacing;
                    if (textDecoration) {
                        g.save();
                        g.strokeStyle = g.fillStyle;
                        g.lineWidth += g.lineWidth;
                        g.beginPath();
                        if (textDecoration.underline) {
                            g.moveTo(0, -font.face['underline-position'] + 0.5);
                            g.lineTo(charWidth, -font.face['underline-position'] + 0.5);
                        }
                        if (textDecoration.overline) {
                            g.moveTo(0, font.ascent + 0.5);
                            g.lineTo(charWidth, font.ascent + 0.5);
                        }
                        if (textDecoration['line-through']) {
                            g.moveTo(0, -font.descent + 0.5);
                            g.lineTo(charWidth, -font.descent + 0.5);
                        }
                        g.stroke();
                        g.restore();
                    }
                    if (isItalic) {
                        g.save();
                        g.transform(1, 0, -0.25, 1, 0, 0);
                    }
                    g.beginPath();
                    if (glyph.d) {
                        if (glyph.code) interpret(glyph.code, g);
                        else glyph.code = generateFromVML('m' + glyph.d, g);
                    }
                    g.fill();
                    if (options.strokeStyle) {
                        g.closePath();
                        g.save();
                        g.lineWidth = options.strokeWidth;
                        g.strokeStyle = options.strokeStyle;
                        g.stroke();
                        g.restore();
                    }
                    if (isItalic) {
                        g.restore();
                    }
                    g.translate(charWidth, 0);
                    left += charWidth;
                }
            }
            g.save();
            renderBackground();
            if (shadows) {
                for (var i = 0, l = shadows.length; i < l; ++i) {
                    var shadow = shadows[i];
                    g.save();
                    g.translate.apply(g, shadowOffsets[i]);
                    renderText(shadow.color);
                    g.restore();
                }
            }
            renderText();
            g.restore();
            g.restore();
            g.restore();
            return wrapper;
        };
    })());
    Cufon.registerEngine('vml', (function() {
        if (!fabric.document.namespaces) return;
        var canvasEl = fabric.document.createElement('canvas');
        if (canvasEl && canvasEl.getContext && canvasEl.getContext.apply) return;
        if (fabric.document.namespaces.cvml == null) {
            fabric.document.namespaces.add('cvml', 'urn:schemas-microsoft-com:vml');
        }
        var check = fabric.document.createElement('cvml:shape');
        check.style.behavior = 'url(#default#VML)';
        if (!check.coordsize) return;
        check = null;
        fabric.document.write('<style type="text/css">' + '.cufon-vml-canvas{text-indent:0}' + '@media screen{' + 'cvml\\:shape,cvml\\:shadow{behavior:url(#default#VML);display:block;antialias:true;position:absolute}' + '.cufon-vml-canvas{position:absolute;text-align:left}' + '.cufon-vml{display:inline-block;position:relative;vertical-align:middle}' + '.cufon-vml .cufon-alt{position:absolute;left:-10000in;font-size:1px}' + 'a .cufon-vml{cursor:pointer}' + '}' + '@media print{' + '.cufon-vml *{display:none}' + '.cufon-vml .cufon-alt{display:inline}' + '}' + '</style>');

        function getFontSizeInPixels(el, value) {
            return getSizeInPixels(el, /(?:em|ex|%)$/i.test(value) ? '1em' : value);
        }

        function getSizeInPixels(el, value) {
            if (/px$/i.test(value)) return parseFloat(value);
            var style = el.style.left,
                runtimeStyle = el.runtimeStyle.left;
            el.runtimeStyle.left = el.currentStyle.left;
            el.style.left = value;
            var result = el.style.pixelLeft;
            el.style.left = style;
            el.runtimeStyle.left = runtimeStyle;
            return result;
        }
        return function(font, text, style, options, node, el, hasNext) {
            var redraw = (text === null);
            if (redraw) text = node.alt;
            var viewBox = font.viewBox;
            var size = style.computedFontSize || (style.computedFontSize = new Cufon.CSS.Size(getFontSizeInPixels(el, style.get('fontSize')) + 'px', font.baseSize));
            var letterSpacing = style.computedLSpacing;
            if (letterSpacing == undefined) {
                letterSpacing = style.get('letterSpacing');
                style.computedLSpacing = letterSpacing = (letterSpacing == 'normal') ? 0 : ~~size.convertFrom(getSizeInPixels(el, letterSpacing));
            }
            var wrapper, canvas;
            if (redraw) {
                wrapper = node;
                canvas = node.firstChild;
            } else {
                wrapper = fabric.document.createElement('span');
                wrapper.className = 'cufon cufon-vml';
                wrapper.alt = text;
                canvas = fabric.document.createElement('span');
                canvas.className = 'cufon-vml-canvas';
                wrapper.appendChild(canvas);
                if (options.printable) {
                    var print = fabric.document.createElement('span');
                    print.className = 'cufon-alt';
                    print.appendChild(fabric.document.createTextNode(text));
                    wrapper.appendChild(print);
                }
                if (!hasNext) wrapper.appendChild(fabric.document.createElement('cvml:shape'));
            }
            var wStyle = wrapper.style;
            var cStyle = canvas.style;
            var height = size.convert(viewBox.height),
                roundedHeight = Math.ceil(height);
            var roundingFactor = roundedHeight / height;
            var minX = viewBox.minX,
                minY = viewBox.minY;
            cStyle.height = roundedHeight;
            cStyle.top = Math.round(size.convert(minY - font.ascent));
            cStyle.left = Math.round(size.convert(minX));
            wStyle.height = size.convert(font.height) + 'px';
            var textDecoration = Cufon.getTextDecoration(options);
            var color = style.get('color');
            var chars = Cufon.CSS.textTransform(text, style).split('');
            var width = 0,
                offsetX = 0,
                advance = null;
            var glyph, shape, shadows = options.textShadow;
            for (var i = 0, k = 0, l = chars.length; i < l; ++i) {
                glyph = font.glyphs[chars[i]] || font.missingGlyph;
                if (glyph) width += advance = ~~(glyph.w || font.w) + letterSpacing;
            }
            if (advance === null) return null;
            var fullWidth = -minX + width + (viewBox.width - advance);
            var shapeWidth = size.convert(fullWidth * roundingFactor),
                roundedShapeWidth = Math.round(shapeWidth);
            var coordSize = fullWidth + ',' + viewBox.height,
                coordOrigin;
            var stretch = 'r' + coordSize + 'nsnf';
            for (i = 0; i < l; ++i) {
                glyph = font.glyphs[chars[i]] || font.missingGlyph;
                if (!glyph) continue;
                if (redraw) {
                    shape = canvas.childNodes[k];
                    if (shape.firstChild) shape.removeChild(shape.firstChild);
                } else {
                    shape = fabric.document.createElement('cvml:shape');
                    canvas.appendChild(shape);
                }
                shape.stroked = 'f';
                shape.coordsize = coordSize;
                shape.coordorigin = coordOrigin = (minX - offsetX) + ',' + minY;
                shape.path = (glyph.d ? 'm' + glyph.d + 'xe' : '') + 'm' + coordOrigin + stretch;
                shape.fillcolor = color;
                var sStyle = shape.style;
                sStyle.width = roundedShapeWidth;
                sStyle.height = roundedHeight;
                if (shadows) {
                    var shadow1 = shadows[0],
                        shadow2 = shadows[1];
                    var color1 = Cufon.CSS.color(shadow1.color),
                        color2;
                    var shadow = fabric.document.createElement('cvml:shadow');
                    shadow.on = 't';
                    shadow.color = color1.color;
                    shadow.offset = shadow1.offX + ',' + shadow1.offY;
                    if (shadow2) {
                        color2 = Cufon.CSS.color(shadow2.color);
                        shadow.type = 'double';
                        shadow.color2 = color2.color;
                        shadow.offset2 = shadow2.offX + ',' + shadow2.offY;
                    }
                    shadow.opacity = color1.opacity || (color2 && color2.opacity) || 1;
                    shape.appendChild(shadow);
                }
                offsetX += ~~(glyph.w || font.w) + letterSpacing;
                ++k;
            }
            wStyle.width = Math.max(Math.ceil(size.convert(width * roundingFactor)), 0);
            return wrapper;
        };
    })());
    Cufon.getTextDecoration = function(options) {
        return {
            underline: options.textDecoration === 'underline',
            overline: options.textDecoration === 'overline',
            'line-through': options.textDecoration === 'line-through'
        };
    };
    if (typeof exports != 'undefined') {
        exports.Cufon = Cufon;
    }
    if (typeof JSON !== 'object') {
        JSON = {};
    }
    (function() {
        'use strict';

        function f(n) {
            return n < 10 ? '0' + n : n;
        }
        if (typeof Date.prototype.toJSON !== 'function') {
            Date.prototype.toJSON = function() {
                return isFinite(this.valueOf()) ? this.getUTCFullYear() + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate()) + 'T' +
                    f(this.getUTCHours()) + ':' +
                    f(this.getUTCMinutes()) + ':' +
                    f(this.getUTCSeconds()) + 'Z' : null;
            };
            String.prototype.toJSON = Number.prototype.toJSON = Boolean.prototype.toJSON = function() {
                return this.valueOf();
            };
        }
        var cx, escapable, gap, indent, meta, rep;

        function quote(string) {
            escapable.lastIndex = 0;
            return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
                var c = meta[a];
                return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' : '"' + string + '"';
        }

        function str(key, holder) {
            var i, k, v, length, mind = gap,
                partial, value = holder[key];
            if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
                value = value.toJSON(key);
            }
            if (typeof rep === 'function') {
                value = rep.call(holder, key, value);
            }
            switch (typeof value) {
                case 'string':
                    return quote(value);
                case 'number':
                    return isFinite(value) ? String(value) : 'null';
                case 'boolean':
                case 'null':
                    return String(value);
                case 'object':
                    if (!value) {
                        return 'null';
                    }
                    gap += indent;
                    partial = [];
                    if (Object.prototype.toString.apply(value) === '[object Array]') {
                        length = value.length;
                        for (i = 0; i < length; i += 1) {
                            partial[i] = str(i, value) || 'null';
                        }
                        v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
                        gap = mind;
                        return v;
                    }
                    if (rep && typeof rep === 'object') {
                        length = rep.length;
                        for (i = 0; i < length; i += 1) {
                            if (typeof rep[i] === 'string') {
                                k = rep[i];
                                v = str(k, value);
                                if (v) {
                                    partial.push(quote(k) + (gap ? ': ' : ':') + v);
                                }
                            }
                        }
                    } else {
                        for (k in value) {
                            if (Object.prototype.hasOwnProperty.call(value, k)) {
                                v = str(k, value);
                                if (v) {
                                    partial.push(quote(k) + (gap ? ': ' : ':') + v);
                                }
                            }
                        }
                    }
                    v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
                    gap = mind;
                    return v;
            }
        }
        if (typeof JSON.stringify !== 'function') {
            escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
            meta = {
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '"': '\\"',
                '\\': '\\\\'
            };
            JSON.stringify = function(value, replacer, space) {
                var i;
                gap = '';
                indent = '';
                if (typeof space === 'number') {
                    for (i = 0; i < space; i += 1) {
                        indent += ' ';
                    }
                } else if (typeof space === 'string') {
                    indent = space;
                }
                rep = replacer;
                if (replacer && typeof replacer !== 'function' && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
                    throw new Error('JSON.stringify');
                }
                return str('', {
                    '': value
                });
            };
        }
        if (typeof JSON.parse !== 'function') {
            cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
            JSON.parse = function(text, reviver) {
                var j;

                function walk(holder, key) {
                    var k, v, value = holder[key];
                    if (value && typeof value === 'object') {
                        for (k in value) {
                            if (Object.prototype.hasOwnProperty.call(value, k)) {
                                v = walk(value, k);
                                if (v !== undefined) {
                                    value[k] = v;
                                } else {
                                    delete value[k];
                                }
                            }
                        }
                    }
                    return reviver.call(holder, key, value);
                }
                text = String(text);
                cx.lastIndex = 0;
                if (cx.test(text)) {
                    text = text.replace(cx, function(a) {
                        return '\\u' +
                            ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                    });
                }
                if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {
                    j = eval('(' + text + ')');
                    return typeof reviver === 'function' ? walk({
                        '': j
                    }, '') : j;
                }
                throw new SyntaxError('JSON.parse');
            };
        }
    }());
    (function() {
        function _removeEventListener(eventName, handler) {
            if (!this.__eventListeners[eventName]) {
                return;
            }
            if (handler) {
                fabric.util.removeFromArray(this.__eventListeners[eventName], handler);
            } else {
                this.__eventListeners[eventName].length = 0;
            }
        }

        function observe(eventName, handler) {
            if (!this.__eventListeners) {
                this.__eventListeners = {};
            }
            if (arguments.length === 1) {
                for (var prop in eventName) {
                    this.on(prop, eventName[prop]);
                }
            } else {
                if (!this.__eventListeners[eventName]) {
                    this.__eventListeners[eventName] = [];
                }
                this.__eventListeners[eventName].push(handler);
            }
            return this;
        }

        function stopObserving(eventName, handler) {
            if (!this.__eventListeners) {
                return;
            }
            if (arguments.length === 0) {
                this.__eventListeners = {};
            } else if (arguments.length === 1 && typeof arguments[0] === 'object') {
                for (var prop in eventName) {
                    _removeEventListener.call(this, prop, eventName[prop]);
                }
            } else {
                _removeEventListener.call(this, eventName, handler);
            }
            return this;
        }

        function fire(eventName, options) {
            if (!this.__eventListeners) {
                return;
            }
            var listenersForEvent = this.__eventListeners[eventName];
            if (!listenersForEvent) {
                return;
            }
            for (var i = 0, len = listenersForEvent.length; i < len; i++) {
                listenersForEvent[i].call(this, options || {});
            }
            return this;
        }
        fabric.Observable = {
            observe: observe,
            stopObserving: stopObserving,
            fire: fire,
            on: observe,
            off: stopObserving,
            trigger: fire
        };
    })();
    fabric.Collection = {
        add: function() {
            this._objects.push.apply(this._objects, arguments);
            for (var i = 0, length = arguments.length; i < length; i++) {
                this._onObjectAdded(arguments[i]);
            }
            this.renderOnAddRemove && this.renderAll();
            return this;
        },
        insertAt: function(object, index, nonSplicing) {
            var objects = this.getObjects();
            if (nonSplicing) {
                objects[index] = object;
            } else {
                objects.splice(index, 0, object);
            }
            this._onObjectAdded(object);
            this.renderOnAddRemove && this.renderAll();
            return this;
        },
        remove: function() {
            var objects = this.getObjects(),
                index;
            for (var i = 0, length = arguments.length; i < length; i++) {
                index = objects.indexOf(arguments[i]);
                if (index !== -1) {
                    objects.splice(index, 1);
                    this._onObjectRemoved(arguments[i]);
                }
            }
            this.renderOnAddRemove && this.renderAll();
            return this;
        },
        forEachObject: function(callback, context) {
            var objects = this.getObjects(),
                i = objects.length;
            while (i--) {
                callback.call(context, objects[i], i, objects);
            }
            return this;
        },
        getObjects: function(type) {
            if (typeof type === 'undefined') {
                return this._objects;
            }
            return this._objects.filter(function(o) {
                return o.type === type;
            });
        },
        item: function(index) {
            return this.getObjects()[index];
        },
        isEmpty: function() {
            return this.getObjects().length === 0;
        },
        size: function() {
            return this.getObjects().length;
        },
        contains: function(object) {
            return this.getObjects().indexOf(object) > -1;
        },
        complexity: function() {
            return this.getObjects().reduce(function(memo, current) {
                memo += current.complexity ? current.complexity() : 0;
                return memo;
            }, 0);
        }
    };
    (function(global) {
        var sqrt = Math.sqrt,
            atan2 = Math.atan2,
            PiBy180 = Math.PI / 180;
        fabric.util = {
            removeFromArray: function(array, value) {
                var idx = array.indexOf(value);
                if (idx !== -1) {
                    array.splice(idx, 1);
                }
                return array;
            },
            getRandomInt: function(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            },
            degreesToRadians: function(degrees) {
                return degrees * PiBy180;
            },
            radiansToDegrees: function(radians) {
                return radians / PiBy180;
            },
            rotatePoint: function(point, origin, radians) {
                var sin = Math.sin(radians),
                    cos = Math.cos(radians);
                point.subtractEquals(origin);
                var rx = point.x * cos - point.y * sin,
                    ry = point.x * sin + point.y * cos;
                return new fabric.Point(rx, ry).addEquals(origin);
            },
            transformPoint: function(p, t, ignoreOffset) {
                if (ignoreOffset) {
                    return new fabric.Point(t[0] * p.x + t[1] * p.y, t[2] * p.x + t[3] * p.y);
                }
                return new fabric.Point(t[0] * p.x + t[1] * p.y + t[4], t[2] * p.x + t[3] * p.y + t[5]);
            },
            invertTransform: function(t) {
                var r = t.slice(),
                    a = 1 / (t[0] * t[3] - t[1] * t[2]);
                r = [a * t[3], -a * t[1], -a * t[2], a * t[0], 0, 0];
                var o = fabric.util.transformPoint({
                    x: t[4],
                    y: t[5]
                }, r);
                r[4] = -o.x;
                r[5] = -o.y;
                return r;
            },
            toFixed: function(number, fractionDigits) {
                return parseFloat(Number(number).toFixed(fractionDigits));
            },
            parseUnit: function(value) {
                var unit = /\D{0,2}$/.exec(value),
                    number = parseFloat(value);
                switch (unit[0]) {
                    case 'mm':
                        return number * fabric.DPI / 25.4;
                    case 'cm':
                        return number * fabric.DPI / 2.54;
                    case 'in':
                        return number * fabric.DPI;
                    case 'pt':
                        return number * fabric.DPI / 72;
                    case 'pc':
                        return number * fabric.DPI / 72 * 12;
                    default:
                        return number;
                }
            },
            falseFunction: function() {
                return false;
            },
            getKlass: function(type, namespace) {
                type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
                return fabric.util.resolveNamespace(namespace)[type];
            },
            resolveNamespace: function(namespace) {
                if (!namespace) {
                    return fabric;
                }
                var parts = namespace.split('.'),
                    len = parts.length,
                    obj = global || fabric.window;
                for (var i = 0; i < len; ++i) {
                    obj = obj[parts[i]];
                }
                return obj;
            },
            loadImage: function(url, callback, context, crossOrigin) {
                if (!url) {
                    callback && callback.call(context, url);
                    return;
                }
                var img = fabric.util.createImage();
                img.onload = function() {
                    callback && callback.call(context, img);
                    img = img.onload = img.onerror = null;
                };
                img.onerror = function() {
                    fabric.log('Error loading ' + img.src);
                    callback && callback.call(context, null, true);
                    img = img.onload = img.onerror = null;
                };
                if (url.indexOf('data') !== 0 && typeof crossOrigin !== 'undefined') {
                    img.crossOrigin = crossOrigin;
                }
                img.src = url;
            },
            enlivenObjects: function(objects, callback, namespace, reviver) {
                objects = objects || [];

                function onLoaded() {
                    if (++numLoadedObjects === numTotalObjects) {
                        callback && callback(enlivenedObjects);
                    }
                }
                var enlivenedObjects = [],
                    numLoadedObjects = 0,
                    numTotalObjects = objects.length;
                if (!numTotalObjects) {
                    callback && callback(enlivenedObjects);
                    return;
                }
                objects.forEach(function(o, index) {
                    if (!o || !o.type) {
                        onLoaded();
                        return;
                    }
                    var klass = fabric.util.getKlass(o.type, namespace);
                    if (klass.async) {
                        klass.fromObject(o, function(obj, error) {
                            if (!error) {
                                enlivenedObjects[index] = obj;
                                reviver && reviver(o, enlivenedObjects[index]);
                            }
                            onLoaded();
                        });
                    } else {
                        enlivenedObjects[index] = klass.fromObject(o);
                        reviver && reviver(o, enlivenedObjects[index]);
                        onLoaded();
                    }
                });
            },
            groupSVGElements: function(elements, options, path) {
                var object;
                object = new fabric.PathGroup(elements, options);
                if (typeof path !== 'undefined') {
                    object.setSourcePath(path);
                }
                return object;
            },
            populateWithProperties: function(source, destination, properties) {
                if (properties && Object.prototype.toString.call(properties) === '[object Array]') {
                    for (var i = 0, len = properties.length; i < len; i++) {
                        if (properties[i] in source) {
                            destination[properties[i]] = source[properties[i]];
                        }
                    }
                }
            },
            drawDashedLine: function(ctx, x, y, x2, y2, da) {
                var dx = x2 - x,
                    dy = y2 - y,
                    len = sqrt(dx * dx + dy * dy),
                    rot = atan2(dy, dx),
                    dc = da.length,
                    di = 0,
                    draw = true;
                ctx.save();
                ctx.translate(x, y);
                ctx.moveTo(0, 0);
                ctx.rotate(rot);
                x = 0;
                while (len > x) {
                    x += da[di++ % dc];
                    if (x > len) {
                        x = len;
                    }
                    ctx[draw ? 'lineTo' : 'moveTo'](x, 0);
                    draw = !draw;
                }
                ctx.restore();
            },
            createCanvasElement: function(canvasEl) {
                canvasEl || (canvasEl = fabric.document.createElement('canvas'));
                if (!canvasEl.getContext && typeof G_vmlCanvasManager !== 'undefined') {
                    G_vmlCanvasManager.initElement(canvasEl);
                }
                return canvasEl;
            },
            createImage: function() {
                return fabric.isLikelyNode ? new(require('canvas').Image)() : fabric.document.createElement('img');
            },
            createAccessors: function(klass) {
                var proto = klass.prototype;
                for (var i = proto.stateProperties.length; i--;) {
                    var propName = proto.stateProperties[i],
                        capitalizedPropName = propName.charAt(0).toUpperCase() + propName.slice(1),
                        setterName = 'set' + capitalizedPropName,
                        getterName = 'get' + capitalizedPropName;
                    if (!proto[getterName]) {
                        proto[getterName] = (function(property) {
                            return new Function('return this.get("' + property + '")');
                        })(propName);
                    }
                    if (!proto[setterName]) {
                        proto[setterName] = (function(property) {
                            return new Function('value', 'return this.set("' + property + '", value)');
                        })(propName);
                    }
                }
            },
            clipContext: function(receiver, ctx) {
                ctx.save();
                ctx.beginPath();
                receiver.clipTo(ctx);
                ctx.clip();
            },
            multiplyTransformMatrices: function(matrixA, matrixB) {
                var a = [
                        [matrixA[0], matrixA[2], matrixA[4]],
                        [matrixA[1], matrixA[3], matrixA[5]],
                        [0, 0, 1]
                    ],
                    b = [
                        [matrixB[0], matrixB[2], matrixB[4]],
                        [matrixB[1], matrixB[3], matrixB[5]],
                        [0, 0, 1]
                    ],
                    result = [];
                for (var r = 0; r < 3; r++) {
                    result[r] = [];
                    for (var c = 0; c < 3; c++) {
                        var sum = 0;
                        for (var k = 0; k < 3; k++) {
                            sum += a[r][k] * b[k][c];
                        }
                        result[r][c] = sum;
                    }
                }
                return [result[0][0], result[1][0], result[0][1], result[1][1], result[0][2], result[1][2]];
            },
            getFunctionBody: function(fn) {
                return (String(fn).match(/function[^{]*\{([\s\S]*)\}/) || {})[1];
            },
            isTransparent: function(ctx, x, y, tolerance) {
                if (tolerance > 0) {
                    if (x > tolerance) {
                        x -= tolerance;
                    } else {
                        x = 0;
                    }
                    if (y > tolerance) {
                        y -= tolerance;
                    } else {
                        y = 0;
                    }
                }
                var _isTransparent = true,
                    imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1);
                for (var i = 3, l = imageData.data.length; i < l; i += 4) {
                    var temp = imageData.data[i];
                    _isTransparent = temp <= 0;
                    if (_isTransparent === false) {
                        break;
                    }
                }
                imageData = null;
                return _isTransparent;
            }
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function() {
        var arcToSegmentsCache = {},
            segmentToBezierCache = {},
            _join = Array.prototype.join;

        function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
            var argsString = _join.call(arguments);
            if (arcToSegmentsCache[argsString]) {
                return arcToSegmentsCache[argsString];
            }
            var PI = Math.PI,
                th = rotateX * (PI / 180),
                sinTh = Math.sin(th),
                cosTh = Math.cos(th),
                fromX = 0,
                fromY = 0;
            rx = Math.abs(rx);
            ry = Math.abs(ry);
            var px = -cosTh * toX - sinTh * toY,
                py = -cosTh * toY + sinTh * toX,
                rx2 = rx * rx,
                ry2 = ry * ry,
                py2 = py * py,
                px2 = px * px,
                pl = 4 * rx2 * ry2 - rx2 * py2 - ry2 * px2,
                root = 0;
            if (pl < 0) {
                var s = Math.sqrt(1 - 0.25 * pl / (rx2 * ry2));
                rx *= s;
                ry *= s;
            } else {
                root = (large === sweep ? -0.5 : 0.5) * Math.sqrt(pl / (rx2 * py2 + ry2 * px2));
            }
            var cx = root * rx * py / ry,
                cy = -root * ry * px / rx,
                cx1 = cosTh * cx - sinTh * cy + toX / 2,
                cy1 = sinTh * cx + cosTh * cy + toY / 2,
                mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
                dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);
            if (sweep === 0 && dtheta > 0) {
                dtheta -= 2 * PI;
            } else if (sweep === 1 && dtheta < 0) {
                dtheta += 2 * PI;
            }
            var segments = Math.ceil(Math.abs(dtheta / (PI * 0.5))),
                result = [],
                mDelta = dtheta / segments,
                mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
                th3 = mTheta + mDelta;
            for (var i = 0; i < segments; i++) {
                result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
                fromX = result[i][4];
                fromY = result[i][5];
                mTheta += mDelta;
                th3 += mDelta;
            }
            arcToSegmentsCache[argsString] = result;
            return result;
        }

        function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
            var argsString2 = _join.call(arguments);
            if (segmentToBezierCache[argsString2]) {
                return segmentToBezierCache[argsString2];
            }
            var costh2 = Math.cos(th2),
                sinth2 = Math.sin(th2),
                costh3 = Math.cos(th3),
                sinth3 = Math.sin(th3),
                toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
                toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
                cp1X = fromX + mT * (-cosTh * rx * sinth2 - sinTh * ry * costh2),
                cp1Y = fromY + mT * (-sinTh * rx * sinth2 + cosTh * ry * costh2),
                cp2X = toX + mT * (cosTh * rx * sinth3 + sinTh * ry * costh3),
                cp2Y = toY + mT * (sinTh * rx * sinth3 - cosTh * ry * costh3);
            segmentToBezierCache[argsString2] = [cp1X, cp1Y, cp2X, cp2Y, toX, toY];
            return segmentToBezierCache[argsString2];
        }

        function calcVectorAngle(ux, uy, vx, vy) {
            var ta = Math.atan2(uy, ux),
                tb = Math.atan2(vy, vx);
            if (tb >= ta) {
                return tb - ta;
            } else {
                return 2 * Math.PI - (ta - tb);
            }
        }
        fabric.util.drawArc = function(ctx, fx, fy, coords) {
            var rx = coords[0],
                ry = coords[1],
                rot = coords[2],
                large = coords[3],
                sweep = coords[4],
                tx = coords[5],
                ty = coords[6],
                segs = [
                    [],
                    [],
                    [],
                    []
                ],
                segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
            for (var i = 0, len = segsNorm.length; i < len; i++) {
                segs[i][0] = segsNorm[i][0] + fx;
                segs[i][1] = segsNorm[i][1] + fy;
                segs[i][2] = segsNorm[i][2] + fx;
                segs[i][3] = segsNorm[i][3] + fy;
                segs[i][4] = segsNorm[i][4] + fx;
                segs[i][5] = segsNorm[i][5] + fy;
                ctx.bezierCurveTo.apply(ctx, segs[i]);
            }
        };
    })();
    (function() {
        var slice = Array.prototype.slice;

        function invoke(array, method) {
            var args = slice.call(arguments, 2),
                result = [];
            for (var i = 0, len = array.length; i < len; i++) {
                result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
            }
            return result;
        }

        function max(array, byProperty) {
            return find(array, byProperty, function(value1, value2) {
                return value1 >= value2;
            });
        }

        function min(array, byProperty) {
            return find(array, byProperty, function(value1, value2) {
                return value1 < value2;
            });
        }

        function find(array, byProperty, condition) {
            if (!array || array.length === 0) {
                return;
            }
            var i = array.length - 1,
                result = byProperty ? array[i][byProperty] : array[i];
            if (byProperty) {
                while (i--) {
                    if (condition(array[i][byProperty], result)) {
                        result = array[i][byProperty];
                    }
                }
            } else {
                while (i--) {
                    if (condition(array[i], result)) {
                        result = array[i];
                    }
                }
            }
            return result;
        }
        fabric.util.array = {
            invoke: invoke,
            min: min,
            max: max
        };
    })();
    (function() {
        function extend(destination, source) {
            for (var property in source) {
                destination[property] = source[property];
            }
            return destination;
        }

        function clone(object) {
            return extend({}, object);
        }
        fabric.util.object = {
            extend: extend,
            clone: clone
        };
    })();
    (function() {
        function camelize(string) {
            return string.replace(/-+(.)?/g, function(match, character) {
                return character ? character.toUpperCase() : '';
            });
        }

        function capitalize(string, firstLetterOnly) {
            return string.charAt(0).toUpperCase() +
                (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
        }

        function escapeXml(string) {
            return string.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&apos;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        }
        fabric.util.string = {
            camelize: camelize,
            capitalize: capitalize,
            escapeXml: escapeXml
        };
    }());
    (function() {
        var slice = Array.prototype.slice,
            emptyFunction = function() {},
            IS_DONTENUM_BUGGY = (function() {
                for (var p in {
                        toString: 1
                    }) {
                    if (p === 'toString') {
                        return false;
                    }
                }
                return true;
            })(),
            addMethods = function(klass, source, parent) {
                for (var property in source) {
                    if (property in klass.prototype && typeof klass.prototype[property] === 'function' && (source[property] + '').indexOf('callSuper') > -1) {
                        klass.prototype[property] = (function(property) {
                            return function() {
                                var superclass = this.constructor.superclass;
                                this.constructor.superclass = parent;
                                var returnValue = source[property].apply(this, arguments);
                                this.constructor.superclass = superclass;
                                if (property !== 'initialize') {
                                    return returnValue;
                                }
                            };
                        })(property);
                    } else {
                        klass.prototype[property] = source[property];
                    }
                    if (IS_DONTENUM_BUGGY) {
                        if (source.toString !== Object.prototype.toString) {
                            klass.prototype.toString = source.toString;
                        }
                        if (source.valueOf !== Object.prototype.valueOf) {
                            klass.prototype.valueOf = source.valueOf;
                        }
                    }
                }
            };

        function Subclass() {}

        function callSuper(methodName) {
            var fn = this.constructor.superclass.prototype[methodName];
            return (arguments.length > 1) ? fn.apply(this, slice.call(arguments, 1)) : fn.call(this);
        }

        function createClass() {
            var parent = null,
                properties = slice.call(arguments, 0);
            if (typeof properties[0] === 'function') {
                parent = properties.shift();
            }

            function klass() {
                this.initialize.apply(this, arguments);
            }
            klass.superclass = parent;
            klass.subclasses = [];
            if (parent) {
                Subclass.prototype = parent.prototype;
                klass.prototype = new Subclass();
                parent.subclasses.push(klass);
            }
            for (var i = 0, length = properties.length; i < length; i++) {
                addMethods(klass, properties[i], parent);
            }
            if (!klass.prototype.initialize) {
                klass.prototype.initialize = emptyFunction;
            }
            klass.prototype.constructor = klass;
            klass.prototype.callSuper = callSuper;
            return klass;
        }
        fabric.util.createClass = createClass;
    })();
    (function() {
        var unknown = 'unknown';

        function areHostMethods(object) {
            var methodNames = Array.prototype.slice.call(arguments, 1),
                t, i, len = methodNames.length;
            for (i = 0; i < len; i++) {
                t = typeof object[methodNames[i]];
                if (!(/^(?:function|object|unknown)$/).test(t)) {
                    return false;
                }
            }
            return true;
        }
        var getElement, setElement, getUniqueId = (function() {
            var uid = 0;
            return function(element) {
                return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);
            };
        })();
        (function() {
            var elements = {};
            getElement = function(uid) {
                return elements[uid];
            };
            setElement = function(uid, element) {
                elements[uid] = element;
            };
        })();

        function createListener(uid, handler) {
            return {
                handler: handler,
                wrappedHandler: createWrappedHandler(uid, handler)
            };
        }

        function createWrappedHandler(uid, handler) {
            return function(e) {
                handler.call(getElement(uid), e || fabric.window.event);
            };
        }

        function createDispatcher(uid, eventName) {
            return function(e) {
                if (handlers[uid] && handlers[uid][eventName]) {
                    var handlersForEvent = handlers[uid][eventName];
                    for (var i = 0, len = handlersForEvent.length; i < len; i++) {
                        handlersForEvent[i].call(this, e || fabric.window.event);
                    }
                }
            };
        }
        var shouldUseAddListenerRemoveListener = (areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') && areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),
            shouldUseAttachEventDetachEvent = (areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') && areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),
            listeners = {},
            handlers = {},
            addListener, removeListener;
        if (shouldUseAddListenerRemoveListener) {
            addListener = function(element, eventName, handler) {
                element.addEventListener(eventName, handler, false);
            };
            removeListener = function(element, eventName, handler) {
                element.removeEventListener(eventName, handler, false);
            };
        } else if (shouldUseAttachEventDetachEvent) {
            addListener = function(element, eventName, handler) {
                var uid = getUniqueId(element);
                setElement(uid, element);
                if (!listeners[uid]) {
                    listeners[uid] = {};
                }
                if (!listeners[uid][eventName]) {
                    listeners[uid][eventName] = [];
                }
                var listener = createListener(uid, handler);
                listeners[uid][eventName].push(listener);
                element.attachEvent('on' + eventName, listener.wrappedHandler);
            };
            removeListener = function(element, eventName, handler) {
                var uid = getUniqueId(element),
                    listener;
                if (listeners[uid] && listeners[uid][eventName]) {
                    for (var i = 0, len = listeners[uid][eventName].length; i < len; i++) {
                        listener = listeners[uid][eventName][i];
                        if (listener && listener.handler === handler) {
                            element.detachEvent('on' + eventName, listener.wrappedHandler);
                            listeners[uid][eventName][i] = null;
                        }
                    }
                }
            };
        } else {
            addListener = function(element, eventName, handler) {
                var uid = getUniqueId(element);
                if (!handlers[uid]) {
                    handlers[uid] = {};
                }
                if (!handlers[uid][eventName]) {
                    handlers[uid][eventName] = [];
                    var existingHandler = element['on' + eventName];
                    if (existingHandler) {
                        handlers[uid][eventName].push(existingHandler);
                    }
                    element['on' + eventName] = createDispatcher(uid, eventName);
                }
                handlers[uid][eventName].push(handler);
            };
            removeListener = function(element, eventName, handler) {
                var uid = getUniqueId(element);
                if (handlers[uid] && handlers[uid][eventName]) {
                    var handlersForEvent = handlers[uid][eventName];
                    for (var i = 0, len = handlersForEvent.length; i < len; i++) {
                        if (handlersForEvent[i] === handler) {
                            handlersForEvent.splice(i, 1);
                        }
                    }
                }
            };
        }
        fabric.util.addListener = addListener;
        fabric.util.removeListener = removeListener;

        function getPointer(event, upperCanvasEl) {
            event || (event = fabric.window.event);
            var element = event.target || (typeof event.srcElement !== unknown ? event.srcElement : null),
                scroll = fabric.util.getScrollLeftTop(element, upperCanvasEl);
            return {
                x: pointerX(event) + scroll.left,
                y: pointerY(event) + scroll.top
            };
        }
        var pointerX = function(event) {
                return (typeof event.clientX !== unknown ? event.clientX : 0);
            },
            pointerY = function(event) {
                return (typeof event.clientY !== unknown ? event.clientY : 0);
            };

        function _getPointer(event, pageProp, clientProp) {
            var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';
            return (event[touchProp] && event[touchProp][0] ? (event[touchProp][0][pageProp] - (event[touchProp][0][pageProp] - event[touchProp][0][clientProp])) || event[clientProp] : event[clientProp]);
        }
        if (fabric.isTouchSupported) {
            pointerX = function(event) {
                return _getPointer(event, 'pageX', 'clientX');
            };
            pointerY = function(event) {
                return _getPointer(event, 'pageY', 'clientY');
            };
        }
        fabric.util.getPointer = getPointer;
        fabric.util.object.extend(fabric.util, fabric.Observable);
    })();
    (function() {
        function setStyle(element, styles) {
            var elementStyle = element.style;
            if (!elementStyle) {
                return element;
            }
            if (typeof styles === 'string') {
                element.style.cssText += ';' + styles;
                return styles.indexOf('opacity') > -1 ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1]) : element;
            }
            for (var property in styles) {
                if (property === 'opacity') {
                    setOpacity(element, styles[property]);
                } else {
                    var normalizedProperty = (property === 'float' || property === 'cssFloat') ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat') : property;
                    elementStyle[normalizedProperty] = styles[property];
                }
            }
            return element;
        }
        var parseEl = fabric.document.createElement('div'),
            supportsOpacity = typeof parseEl.style.opacity === 'string',
            supportsFilters = typeof parseEl.style.filter === 'string',
            reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,
            setOpacity = function(element) {
                return element;
            };
        if (supportsOpacity) {
            setOpacity = function(element, value) {
                element.style.opacity = value;
                return element;
            };
        } else if (supportsFilters) {
            setOpacity = function(element, value) {
                var es = element.style;
                if (element.currentStyle && !element.currentStyle.hasLayout) {
                    es.zoom = 1;
                }
                if (reOpacity.test(es.filter)) {
                    value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
                    es.filter = es.filter.replace(reOpacity, value);
                } else {
                    es.filter += ' alpha(opacity=' + (value * 100) + ')';
                }
                return element;
            };
        }
        fabric.util.setStyle = setStyle;
    })();
    (function() {
        var _slice = Array.prototype.slice;

        function getById(id) {
            return typeof id === 'string' ? fabric.document.getElementById(id) : id;
        }
        var sliceCanConvertNodelists, toArray = function(arrayLike) {
            return _slice.call(arrayLike, 0);
        };
        try {
            sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
        } catch (err) {}
        if (!sliceCanConvertNodelists) {
            toArray = function(arrayLike) {
                var arr = new Array(arrayLike.length),
                    i = arrayLike.length;
                while (i--) {
                    arr[i] = arrayLike[i];
                }
                return arr;
            };
        }

        function makeElement(tagName, attributes) {
            var el = fabric.document.createElement(tagName);
            for (var prop in attributes) {
                if (prop === 'class') {
                    el.className = attributes[prop];
                } else if (prop === 'for') {
                    el.htmlFor = attributes[prop];
                } else {
                    el.setAttribute(prop, attributes[prop]);
                }
            }
            return el;
        }

        function addClass(element, className) {
            if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
                element.className += (element.className ? ' ' : '') + className;
            }
        }

        function wrapElement(element, wrapper, attributes) {
            if (typeof wrapper === 'string') {
                wrapper = makeElement(wrapper, attributes);
            }
            if (element.parentNode) {
                element.parentNode.replaceChild(wrapper, element);
            }
            wrapper.appendChild(element);
            return wrapper;
        }

        function getScrollLeftTop(element, upperCanvasEl) {
            var firstFixedAncestor, origElement, left = 0,
                top = 0,
                docElement = fabric.document.documentElement,
                body = fabric.document.body || {
                    scrollLeft: 0,
                    scrollTop: 0
                };
            origElement = element;
            while (element && element.parentNode && !firstFixedAncestor) {
                element = element.parentNode;
                if (element !== fabric.document && fabric.util.getElementStyle(element, 'position') === 'fixed') {
                    firstFixedAncestor = element;
                }
                if (element !== fabric.document && origElement !== upperCanvasEl && fabric.util.getElementStyle(element, 'position') === 'absolute') {
                    left = 0;
                    top = 0;
                } else if (element === fabric.document) {
                    left = body.scrollLeft || docElement.scrollLeft || 0;
                    top = body.scrollTop || docElement.scrollTop || 0;
                } else {
                    left += element.scrollLeft || 0;
                    top += element.scrollTop || 0;
                }
            }
            return {
                left: left,
                top: top
            };
        }

        function getElementOffset(element) {
            var docElem, doc = element && element.ownerDocument,
                box = {
                    left: 0,
                    top: 0
                },
                offset = {
                    left: 0,
                    top: 0
                },
                scrollLeftTop, offsetAttributes = {
                    borderLeftWidth: 'left',
                    borderTopWidth: 'top',
                    paddingLeft: 'left',
                    paddingTop: 'top'
                };
            if (!doc) {
                return {
                    left: 0,
                    top: 0
                };
            }
            for (var attr in offsetAttributes) {
                offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
            }
            docElem = doc.documentElement;
            if (typeof element.getBoundingClientRect !== 'undefined') {
                box = element.getBoundingClientRect();
            }
            scrollLeftTop = fabric.util.getScrollLeftTop(element, null);
            return {
                left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
                top: box.top + scrollLeftTop.top - (docElem.clientTop || 0) + offset.top
            };
        }
        var getElementStyle;
        if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
            getElementStyle = function(element, attr) {
                return fabric.document.defaultView.getComputedStyle(element, null)[attr];
            };
        } else {
            getElementStyle = function(element, attr) {
                var value = element.style[attr];
                if (!value && element.currentStyle) {
                    value = element.currentStyle[attr];
                }
                return value;
            };
        }
        (function() {
            var style = fabric.document.documentElement.style,
                selectProp = 'userSelect' in style ? 'userSelect' : 'MozUserSelect' in style ? 'MozUserSelect' : 'WebkitUserSelect' in style ? 'WebkitUserSelect' : 'KhtmlUserSelect' in style ? 'KhtmlUserSelect' : '';

            function makeElementUnselectable(element) {
                if (typeof element.onselectstart !== 'undefined') {
                    element.onselectstart = fabric.util.falseFunction;
                }
                if (selectProp) {
                    element.style[selectProp] = 'none';
                } else if (typeof element.unselectable === 'string') {
                    element.unselectable = 'on';
                }
                return element;
            }

            function makeElementSelectable(element) {
                if (typeof element.onselectstart !== 'undefined') {
                    element.onselectstart = null;
                }
                if (selectProp) {
                    element.style[selectProp] = '';
                } else if (typeof element.unselectable === 'string') {
                    element.unselectable = '';
                }
                return element;
            }
            fabric.util.makeElementUnselectable = makeElementUnselectable;
            fabric.util.makeElementSelectable = makeElementSelectable;
        })();
        (function() {
            function getScript(url, callback) {
                var headEl = fabric.document.getElementsByTagName('head')[0],
                    scriptEl = fabric.document.createElement('script'),
                    loading = true;
                scriptEl.onload = scriptEl.onreadystatechange = function(e) {
                    if (loading) {
                        if (typeof this.readyState === 'string' && this.readyState !== 'loaded' && this.readyState !== 'complete') {
                            return;
                        }
                        loading = false;
                        callback(e || fabric.window.event);
                        scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;
                    }
                };
                scriptEl.src = url;
                headEl.appendChild(scriptEl);
            }
            fabric.util.getScript = getScript;
        })();
        fabric.util.getById = getById;
        fabric.util.toArray = toArray;
        fabric.util.makeElement = makeElement;
        fabric.util.addClass = addClass;
        fabric.util.wrapElement = wrapElement;
        fabric.util.getScrollLeftTop = getScrollLeftTop;
        fabric.util.getElementOffset = getElementOffset;
        fabric.util.getElementStyle = getElementStyle;
    })();
    (function() {
        function addParamToUrl(url, param) {
            return url + (/\?/.test(url) ? '&' : '?') + param;
        }
        var makeXHR = (function() {
            var factories = [function() {
                return new ActiveXObject('Microsoft.XMLHTTP');
            }, function() {
                return new ActiveXObject('Msxml2.XMLHTTP');
            }, function() {
                return new ActiveXObject('Msxml2.XMLHTTP.3.0');
            }, function() {
                return new XMLHttpRequest();
            }];
            for (var i = factories.length; i--;) {
                try {
                    var req = factories[i]();
                    if (req) {
                        return factories[i];
                    }
                } catch (err) {}
            }
        })();

        function emptyFn() {}

        function request(url, options) {
            options || (options = {});
            var method = options.method ? options.method.toUpperCase() : 'GET',
                onComplete = options.onComplete || function() {},
                xhr = makeXHR(),
                body;
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    onComplete(xhr);
                    xhr.onreadystatechange = emptyFn;
                }
            };
            if (method === 'GET') {
                body = null;
                if (typeof options.parameters === 'string') {
                    url = addParamToUrl(url, options.parameters);
                }
            }
            xhr.open(method, url, true);
            if (method === 'POST' || method === 'PUT') {
                xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
            }
            xhr.send(body);
            return xhr;
        }
        fabric.util.request = request;
    })();
    fabric.log = function() {};
    fabric.warn = function() {};
    if (typeof console !== 'undefined') {
        ['log', 'warn'].forEach(function(methodName) {
            if (typeof console[methodName] !== 'undefined' && console[methodName].apply) {
                fabric[methodName] = function() {
                    return console[methodName].apply(console, arguments);
                };
            }
        });
    }
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend,
            capitalize = fabric.util.string.capitalize,
            clone = fabric.util.object.clone,
            toFixed = fabric.util.toFixed,
            parseUnit = fabric.util.parseUnit,
            multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,
            attributesMap = {
                cx: 'left',
                x: 'left',
                r: 'radius',
                cy: 'top',
                y: 'top',
                display: 'visible',
                visibility: 'visible',
                transform: 'transformMatrix',
                'fill-opacity': 'fillOpacity',
                'fill-rule': 'fillRule',
                'font-family': 'fontFamily',
                'font-size': 'fontSize',
                'font-style': 'fontStyle',
                'font-weight': 'fontWeight',
                'stroke-dasharray': 'strokeDashArray',
                'stroke-linecap': 'strokeLineCap',
                'stroke-linejoin': 'strokeLineJoin',
                'stroke-miterlimit': 'strokeMiterLimit',
                'stroke-opacity': 'strokeOpacity',
                'stroke-width': 'strokeWidth',
                'text-decoration': 'textDecoration',
                'text-anchor': 'originX'
            },
            colorAttributes = {
                stroke: 'strokeOpacity',
                fill: 'fillOpacity'
            };

        function normalizeAttr(attr) {
            if (attr in attributesMap) {
                return attributesMap[attr];
            }
            return attr;
        }

        function normalizeValue(attr, value, parentAttributes) {
            var isArray = Object.prototype.toString.call(value) === '[object Array]',
                parsed;
            if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
                value = '';
            } else if (attr === 'fillRule') {
                value = (value === 'evenodd') ? 'destination-over' : value;
            } else if (attr === 'strokeDashArray') {
                value = value.replace(/,/g, ' ').split(/\s+/).map(function(n) {
                    return parseInt(n);
                });
            } else if (attr === 'transformMatrix') {
                if (parentAttributes && parentAttributes.transformMatrix) {
                    value = multiplyTransformMatrices(parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
                } else {
                    value = fabric.parseTransformAttribute(value);
                }
            } else if (attr === 'visible') {
                value = (value === 'none' || value === 'hidden') ? false : true;
                if (parentAttributes && parentAttributes.visible === false) {
                    value = false;
                }
            } else if (attr === 'originX') {
                value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
            } else {
                parsed = isArray ? value.map(parseUnit) : parseUnit(value);
            }
            return (!isArray && isNaN(parsed) ? value : parsed);
        }

        function _setStrokeFillOpacity(attributes) {
            for (var attr in colorAttributes) {
                if (!attributes[attr] || typeof attributes[colorAttributes[attr]] === 'undefined') {
                    continue;
                }
                if (attributes[attr].indexOf('url(') === 0) {
                    continue;
                }
                var color = new fabric.Color(attributes[attr]);
                attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
            }
            return attributes;
        }
        fabric.parseTransformAttribute = (function() {
            function rotateMatrix(matrix, args) {
                var angle = args[0];
                matrix[0] = Math.cos(angle);
                matrix[1] = Math.sin(angle);
                matrix[2] = -Math.sin(angle);
                matrix[3] = Math.cos(angle);
            }

            function scaleMatrix(matrix, args) {
                var multiplierX = args[0],
                    multiplierY = (args.length === 2) ? args[1] : args[0];
                matrix[0] = multiplierX;
                matrix[3] = multiplierY;
            }

            function skewXMatrix(matrix, args) {
                matrix[2] = args[0];
            }

            function skewYMatrix(matrix, args) {
                matrix[1] = args[0];
            }

            function translateMatrix(matrix, args) {
                matrix[4] = args[0];
                if (args.length === 2) {
                    matrix[5] = args[1];
                }
            }
            var iMatrix = [1, 0, 0, 1, 0, 0],
                number = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)',
                commaWsp = '(?:\\s+,?\\s*|,\\s*)',
                skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',
                skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',
                rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
                commaWsp + '(' + number + ')' +
                commaWsp + '(' + number + '))?\\s*\\))',
                scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
                commaWsp + '(' + number + '))?\\s*\\))',
                translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
                commaWsp + '(' + number + '))?\\s*\\))',
                matrix = '(?:(matrix)\\s*\\(\\s*' + '(' + number + ')' + commaWsp + '(' + number + ')' + commaWsp + '(' + number + ')' + commaWsp + '(' + number + ')' + commaWsp + '(' + number + ')' + commaWsp + '(' + number + ')' + '\\s*\\))',
                transform = '(?:' +
                matrix + '|' +
                translate + '|' +
                scale + '|' +
                rotate + '|' +
                skewX + '|' +
                skewY + ')',
                transforms = '(?:' + transform + '(?:' + commaWsp + transform + ')*' + ')',
                transformList = '^\\s*(?:' + transforms + '?)\\s*$',
                reTransformList = new RegExp(transformList),
                reTransform = new RegExp(transform, 'g');
            return function(attributeValue) {
                var matrix = iMatrix.concat(),
                    matrices = [];
                if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
                    return matrix;
                }
                attributeValue.replace(reTransform, function(match) {
                    var m = new RegExp(transform).exec(match).filter(function(match) {
                            return (match !== '' && match != null);
                        }),
                        operation = m[1],
                        args = m.slice(2).map(parseFloat);
                    switch (operation) {
                        case 'translate':
                            translateMatrix(matrix, args);
                            break;
                        case 'rotate':
                            args[0] = fabric.util.degreesToRadians(args[0]);
                            rotateMatrix(matrix, args);
                            break;
                        case 'scale':
                            scaleMatrix(matrix, args);
                            break;
                        case 'skewX':
                            skewXMatrix(matrix, args);
                            break;
                        case 'skewY':
                            skewYMatrix(matrix, args);
                            break;
                        case 'matrix':
                            matrix = args;
                            break;
                    }
                    matrices.push(matrix.concat());
                    matrix = iMatrix.concat();
                });
                var combinedMatrix = matrices[0];
                while (matrices.length > 1) {
                    matrices.shift();
                    combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
                }
                return combinedMatrix;
            };
        })();

        function parseFontDeclaration(value, oStyle) {
            var match = value.match(/(normal|italic)?\s*(normal|small-caps)?\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\s*(\d+)px(?:\/(normal|[\d\.]+))?\s+(.*)/);
            if (!match) {
                return;
            }
            var fontStyle = match[1],
                fontWeight = match[3],
                fontSize = match[4],
                lineHeight = match[5],
                fontFamily = match[6];
            if (fontStyle) {
                oStyle.fontStyle = fontStyle;
            }
            if (fontWeight) {
                oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
            }
            if (fontSize) {
                oStyle.fontSize = parseFloat(fontSize);
            }
            if (fontFamily) {
                oStyle.fontFamily = fontFamily;
            }
            if (lineHeight) {
                oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
            }
        }

        function parseStyleString(style, oStyle) {
            var attr, value;
            style.replace(/;$/, '').split(';').forEach(function(chunk) {
                var pair = chunk.split(':');
                attr = normalizeAttr(pair[0].trim().toLowerCase());
                value = normalizeValue(attr, pair[1].trim());
                if (attr === 'font') {
                    parseFontDeclaration(value, oStyle);
                } else {
                    oStyle[attr] = value;
                }
            });
        }

        function parseStyleObject(style, oStyle) {
            var attr, value;
            for (var prop in style) {
                if (typeof style[prop] === 'undefined') {
                    continue;
                }
                attr = normalizeAttr(prop.toLowerCase());
                value = normalizeValue(attr, style[prop]);
                if (attr === 'font') {
                    parseFontDeclaration(value, oStyle);
                } else {
                    oStyle[attr] = value;
                }
            }
        }

        function getGlobalStylesForElement(element) {
            var styles = {};
            for (var rule in fabric.cssRules) {
                if (elementMatchesRule(element, rule.split(' '))) {
                    for (var property in fabric.cssRules[rule]) {
                        styles[property] = fabric.cssRules[rule][property];
                    }
                }
            }
            return styles;
        }

        function elementMatchesRule(element, selectors) {
            var firstMatching, parentMatching = true;
            firstMatching = selectorMatches(element, selectors.pop());
            if (firstMatching && selectors.length) {
                parentMatching = doesSomeParentMatch(element, selectors);
            }
            return firstMatching && parentMatching && (selectors.length === 0);
        }

        function doesSomeParentMatch(element, selectors) {
            var selector, parentMatching = true;
            while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
                if (parentMatching) {
                    selector = selectors.pop();
                }
                element = element.parentNode;
                parentMatching = selectorMatches(element, selector);
            }
            return selectors.length === 0;
        }

        function selectorMatches(element, selector) {
            var nodeName = element.nodeName,
                classNames = element.getAttribute('class'),
                id = element.getAttribute('id'),
                matcher;
            matcher = new RegExp('^' + nodeName, 'i');
            selector = selector.replace(matcher, '');
            if (id && selector.length) {
                matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
                selector = selector.replace(matcher, '');
            }
            if (classNames && selector.length) {
                classNames = classNames.split(' ');
                for (var i = classNames.length; i--;) {
                    matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
                    selector = selector.replace(matcher, '');
                }
            }
            return selector.length === 0;
        }

        function parseUseDirectives(doc) {
            var nodelist = doc.getElementsByTagName('use');
            while (nodelist.length) {
                var el = nodelist[0],
                    xlink = el.getAttribute('xlink:href').substr(1),
                    x = el.getAttribute('x') || 0,
                    y = el.getAttribute('y') || 0,
                    el2 = doc.getElementById(xlink).cloneNode(true),
                    currentTrans = (el.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
                    parentNode;
                for (var j = 0, attrs = el.attributes, l = attrs.length; j < l; j++) {
                    var attr = attrs.item(j);
                    if (attr.nodeName === 'x' || attr.nodeName === 'y' || attr.nodeName === 'xlink:href') {
                        continue;
                    }
                    if (attr.nodeName === 'transform') {
                        currentTrans = currentTrans + ' ' + attr.nodeValue;
                    } else {
                        el2.setAttribute(attr.nodeName, attr.nodeValue);
                    }
                }
                el2.setAttribute('transform', currentTrans);
                el2.removeAttribute('id');
                parentNode = el.parentNode;
                parentNode.replaceChild(el2, el);
            }
        }

        function addSvgTransform(doc, matrix) {
            matrix[3] = matrix[0] = (matrix[0] > matrix[3] ? matrix[3] : matrix[0]);
            if (!(matrix[0] !== 1 || matrix[3] !== 1 || matrix[4] !== 0 || matrix[5] !== 0)) {
                return;
            }
            var el = doc.ownerDocument.createElement('g');
            while (doc.firstChild != null) {
                el.appendChild(doc.firstChild);
            }
            el.setAttribute('transform', 'matrix(' + matrix[0] + ' ' + matrix[1] + ' ' + matrix[2] + ' ' + matrix[3] + ' ' + matrix[4] + ' ' + matrix[5] + ')');
            doc.appendChild(el);
        }
        fabric.parseSVGDocument = (function() {
            var reAllowedSVGTagNames = /^(path|circle|polygon|polyline|ellipse|rect|line|image|text)$/,
                reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)',
                reViewBoxAttrValue = new RegExp('^' + '\\s*(' + reNum + '+)\\s*,?' + '\\s*(' + reNum + '+)\\s*,?' + '\\s*(' + reNum + '+)\\s*,?' + '\\s*(' + reNum + '+)\\s*' + '$');

            function hasAncestorWithNodeName(element, nodeName) {
                while (element && (element = element.parentNode)) {
                    if (nodeName.test(element.nodeName)) {
                        return true;
                    }
                }
                return false;
            }
            return function(doc, callback, reviver) {
                if (!doc) {
                    return;
                }
                var startTime = new Date();
                parseUseDirectives(doc);
                var viewBoxAttr = doc.getAttribute('viewBox'),
                    widthAttr = parseUnit(doc.getAttribute('width') || '100%'),
                    heightAttr = parseUnit(doc.getAttribute('height') || '100%'),
                    viewBoxWidth, viewBoxHeight;
                if (viewBoxAttr && (viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))) {
                    var minX = parseFloat(viewBoxAttr[1]),
                        minY = parseFloat(viewBoxAttr[2]),
                        scaleX = 1,
                        scaleY = 1;
                    viewBoxWidth = parseFloat(viewBoxAttr[3]);
                    viewBoxHeight = parseFloat(viewBoxAttr[4]);
                    if (widthAttr && widthAttr !== viewBoxWidth) {
                        scaleX = widthAttr / viewBoxWidth;
                    }
                    if (heightAttr && heightAttr !== viewBoxHeight) {
                        scaleY = heightAttr / viewBoxHeight;
                    }
                    addSvgTransform(doc, [scaleX, 0, 0, scaleY, scaleX * -minX, scaleY * -minY]);
                }
                var descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
                if (descendants.length === 0 && fabric.isLikelyNode) {
                    descendants = doc.selectNodes('//*[name(.)!="svg"]');
                    var arr = [];
                    for (var i = 0, len = descendants.length; i < len; i++) {
                        arr[i] = descendants[i];
                    }
                    descendants = arr;
                }
                var elements = descendants.filter(function(el) {
                    return reAllowedSVGTagNames.test(el.tagName) && !hasAncestorWithNodeName(el, /^(?:pattern|defs)$/);
                });
                if (!elements || (elements && !elements.length)) {
                    callback && callback([], {});
                    return;
                }
                var options = {
                    width: widthAttr ? widthAttr : viewBoxWidth,
                    height: heightAttr ? heightAttr : viewBoxHeight,
                    widthAttr: widthAttr,
                    heightAttr: heightAttr
                };
                fabric.gradientDefs = fabric.getGradientDefs(doc);
                fabric.cssRules = fabric.getCSSRules(doc);
                fabric.parseElements(elements, function(instances) {
                    fabric.documentParsingTime = new Date() - startTime;
                    if (callback) {
                        callback(instances, options);
                    }
                }, clone(options), reviver);
            };
        })();
        var svgCache = {
            has: function(name, callback) {
                callback(false);
            },
            get: function() {},
            set: function() {}
        };

        function _enlivenCachedObject(cachedObject) {
            var objects = cachedObject.objects,
                options = cachedObject.options;
            objects = objects.map(function(o) {
                return fabric[capitalize(o.type)].fromObject(o);
            });
            return ({
                objects: objects,
                options: options
            });
        }

        function _createSVGPattern(markup, canvas, property) {
            if (canvas[property] && canvas[property].toSVG) {
                markup.push('<pattern x="0" y="0" id="', property, 'Pattern" ', 'width="', canvas[property].source.width, '" height="', canvas[property].source.height, '" patternUnits="userSpaceOnUse">', '<image x="0" y="0" ', 'width="', canvas[property].source.width, '" height="', canvas[property].source.height, '" xlink:href="', canvas[property].source.src, '"></image></pattern>');
            }
        }
        extend(fabric, {
            getGradientDefs: function(doc) {
                var linearGradientEls = doc.getElementsByTagName('linearGradient'),
                    radialGradientEls = doc.getElementsByTagName('radialGradient'),
                    el, i, j = 0,
                    id, xlink, elList = [],
                    gradientDefs = {},
                    idsToXlinkMap = {};
                elList.length = linearGradientEls.length + radialGradientEls.length;
                i = linearGradientEls.length;
                while (i--) {
                    elList[j++] = linearGradientEls[i];
                }
                i = radialGradientEls.length;
                while (i--) {
                    elList[j++] = radialGradientEls[i];
                }
                while (j--) {
                    el = elList[j];
                    xlink = el.getAttribute('xlink:href');
                    id = el.getAttribute('id');
                    if (xlink) {
                        idsToXlinkMap[id] = xlink.substr(1);
                    }
                    gradientDefs[id] = el;
                }
                for (id in idsToXlinkMap) {
                    var el2 = gradientDefs[idsToXlinkMap[id]].cloneNode(true);
                    el = gradientDefs[id];
                    while (el2.firstChild) {
                        el.appendChild(el2.firstChild);
                    }
                }
                return gradientDefs;
            },
            parseAttributes: function(element, attributes) {
                if (!element) {
                    return;
                }
                var value, parentAttributes = {};
                if (element.parentNode && /^symbol|[g|a]$/i.test(element.parentNode.nodeName)) {
                    parentAttributes = fabric.parseAttributes(element.parentNode, attributes);
                }
                var ownAttributes = attributes.reduce(function(memo, attr) {
                    value = element.getAttribute(attr);
                    if (value) {
                        attr = normalizeAttr(attr);
                        value = normalizeValue(attr, value, parentAttributes);
                        memo[attr] = value;
                    }
                    return memo;
                }, {});
                ownAttributes = extend(ownAttributes, extend(getGlobalStylesForElement(element), fabric.parseStyleAttribute(element)));
                return _setStrokeFillOpacity(extend(parentAttributes, ownAttributes));
            },
            parseElements: function(elements, callback, options, reviver) {
                new fabric.ElementsParser(elements, callback, options, reviver).parse();
            },
            parseStyleAttribute: function(element) {
                var oStyle = {},
                    style = element.getAttribute('style');
                if (!style) {
                    return oStyle;
                }
                if (typeof style === 'string') {
                    parseStyleString(style, oStyle);
                } else {
                    parseStyleObject(style, oStyle);
                }
                return oStyle;
            },
            parsePointsAttribute: function(points) {
                if (!points) {
                    return null;
                }
                points = points.replace(/,/g, ' ').trim();
                points = points.split(/\s+/);
                var parsedPoints = [],
                    i, len;
                i = 0;
                len = points.length;
                for (; i < len; i += 2) {
                    parsedPoints.push({
                        x: parseFloat(points[i]),
                        y: parseFloat(points[i + 1])
                    });
                }
                return parsedPoints;
            },
            getCSSRules: function(doc) {
                var styles = doc.getElementsByTagName('style'),
                    allRules = {},
                    rules;
                for (var i = 0, len = styles.length; i < len; i++) {
                    var styleContents = styles[0].textContent;
                    styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
                    rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
                    rules = rules.map(function(rule) {
                        return rule.trim();
                    });
                    rules.forEach(function(rule) {
                        var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
                            ruleObj = {},
                            declaration = match[2].trim(),
                            propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);
                        for (var i = 0, len = propertyValuePairs.length; i < len; i++) {
                            var pair = propertyValuePairs[i].split(/\s*:\s*/),
                                property = normalizeAttr(pair[0]),
                                value = normalizeValue(property, pair[1], pair[0]);
                            ruleObj[property] = value;
                        }
                        rule = match[1];
                        rule.split(',').forEach(function(_rule) {
                            allRules[_rule.trim()] = fabric.util.object.clone(ruleObj);
                        });
                    });
                }
                return allRules;
            },
            loadSVGFromURL: function(url, callback, reviver) {
                url = url.replace(/^\n\s*/, '').trim();
                svgCache.has(url, function(hasUrl) {
                    if (hasUrl) {
                        svgCache.get(url, function(value) {
                            var enlivedRecord = _enlivenCachedObject(value);
                            callback(enlivedRecord.objects, enlivedRecord.options);
                        });
                    } else {
                        new fabric.util.request(url, {
                            method: 'get',
                            onComplete: onComplete
                        });
                    }
                });

                function onComplete(r) {
                    var xml = r.responseXML;
                    if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {
                        xml = new ActiveXObject('Microsoft.XMLDOM');
                        xml.async = 'false';
                        xml.loadXML(r.responseText.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
                    }
                    if (!xml || !xml.documentElement) {
                        return;
                    }
                    fabric.parseSVGDocument(xml.documentElement, function(results, options) {
                        svgCache.set(url, {
                            objects: fabric.util.array.invoke(results, 'toObject'),
                            options: options
                        });
                        callback(results, options);
                    }, reviver);
                }
            },
            loadSVGFromString: function(string, callback, reviver) {
                string = string.trim();
                var doc;
                if (typeof DOMParser !== 'undefined') {
                    var parser = new DOMParser();
                    if (parser && parser.parseFromString) {
                        doc = parser.parseFromString(string, 'text/xml');
                    }
                } else if (fabric.window.ActiveXObject) {
                    doc = new ActiveXObject('Microsoft.XMLDOM');
                    doc.async = 'false';
                    doc.loadXML(string.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
                }
                fabric.parseSVGDocument(doc.documentElement, function(results, options) {
                    callback(results, options);
                }, reviver);
            },
            createSVGFontFacesMarkup: function(objects) {
                var markup = '';
                for (var i = 0, len = objects.length; i < len; i++) {
                    if (objects[i].type !== 'text' || !objects[i].path) {
                        continue;
                    }
                    markup += ['@font-face {', 'font-family: ', objects[i].fontFamily, '; ', 'src: url(\'', objects[i].path, '\')', '}'].join('');
                }
                if (markup) {
                    markup = ['<style type="text/css">', '<![CDATA[', markup, ']]>', '</style>'].join('');
                }
                return markup;
            },
            createSVGRefElementsMarkup: function(canvas) {
                var markup = [];
                _createSVGPattern(markup, canvas, 'backgroundColor');
                _createSVGPattern(markup, canvas, 'overlayColor');
                return markup.join('');
            }
        });
    })(typeof exports !== 'undefined' ? exports : this);
    fabric.ElementsParser = function(elements, callback, options, reviver) {
        this.elements = elements;
        this.callback = callback;
        this.options = options;
        this.reviver = reviver;
    };
    fabric.ElementsParser.prototype.parse = function() {
        this.instances = new Array(this.elements.length);
        this.numElements = this.elements.length;
        this.createObjects();
    };
    fabric.ElementsParser.prototype.createObjects = function() {
        for (var i = 0, len = this.elements.length; i < len; i++) {
            (function(_this, i) {
                setTimeout(function() {
                    _this.createObject(_this.elements[i], i);
                }, 0);
            })(this, i);
        }
    };
    fabric.ElementsParser.prototype.createObject = function(el, index) {
        var klass = fabric[fabric.util.string.capitalize(el.tagName)];
        if (klass && klass.fromElement) {
            try {
                this._createObject(klass, el, index);
            } catch (err) {
                fabric.log(err);
            }
        } else {
            this.checkIfDone();
        }
    };
    fabric.ElementsParser.prototype._createObject = function(klass, el, index) {
        if (klass.async) {
            klass.fromElement(el, this.createCallback(index, el), this.options);
        } else {
            var obj = klass.fromElement(el, this.options);
            this.resolveGradient(obj, 'fill');
            this.resolveGradient(obj, 'stroke');
            this.reviver && this.reviver(el, obj);
            this.instances[index] = obj;
            this.checkIfDone();
        }
    };
    fabric.ElementsParser.prototype.createCallback = function(index, el) {
        var _this = this;
        return function(obj) {
            _this.resolveGradient(obj, 'fill');
            _this.resolveGradient(obj, 'stroke');
            _this.reviver && _this.reviver(el, obj);
            _this.instances[index] = obj;
            _this.checkIfDone();
        };
    };
    fabric.ElementsParser.prototype.resolveGradient = function(obj, property) {
        var instanceFillValue = obj.get(property);
        if (!(/^url\(/).test(instanceFillValue)) {
            return;
        }
        var gradientId = instanceFillValue.slice(5, instanceFillValue.length - 1);
        if (fabric.gradientDefs[gradientId]) {
            obj.set(property, fabric.Gradient.fromElement(fabric.gradientDefs[gradientId], obj));
        }
    };
    fabric.ElementsParser.prototype.checkIfDone = function() {
        if (--this.numElements === 0) {
            this.instances = this.instances.filter(function(el) {
                return el != null;
            });
            this.callback(this.instances);
        }
    };
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {});
        if (fabric.Point) {
            fabric.warn('fabric.Point is already defined');
            return;
        }
        fabric.Point = Point;

        function Point(x, y) {
            this.x = x;
            this.y = y;
        }
        Point.prototype = {
            constructor: Point,
            add: function(that) {
                return new Point(this.x + that.x, this.y + that.y);
            },
            addEquals: function(that) {
                this.x += that.x;
                this.y += that.y;
                return this;
            },
            scalarAdd: function(scalar) {
                return new Point(this.x + scalar, this.y + scalar);
            },
            scalarAddEquals: function(scalar) {
                this.x += scalar;
                this.y += scalar;
                return this;
            },
            subtract: function(that) {
                return new Point(this.x - that.x, this.y - that.y);
            },
            subtractEquals: function(that) {
                this.x -= that.x;
                this.y -= that.y;
                return this;
            },
            scalarSubtract: function(scalar) {
                return new Point(this.x - scalar, this.y - scalar);
            },
            scalarSubtractEquals: function(scalar) {
                this.x -= scalar;
                this.y -= scalar;
                return this;
            },
            multiply: function(scalar) {
                return new Point(this.x * scalar, this.y * scalar);
            },
            multiplyEquals: function(scalar) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
            },
            divide: function(scalar) {
                return new Point(this.x / scalar, this.y / scalar);
            },
            divideEquals: function(scalar) {
                this.x /= scalar;
                this.y /= scalar;
                return this;
            },
            eq: function(that) {
                return (this.x === that.x && this.y === that.y);
            },
            lt: function(that) {
                return (this.x < that.x && this.y < that.y);
            },
            lte: function(that) {
                return (this.x <= that.x && this.y <= that.y);
            },
            gt: function(that) {
                return (this.x > that.x && this.y > that.y);
            },
            gte: function(that) {
                return (this.x >= that.x && this.y >= that.y);
            },
            lerp: function(that, t) {
                return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
            },
            distanceFrom: function(that) {
                var dx = this.x - that.x,
                    dy = this.y - that.y;
                return Math.sqrt(dx * dx + dy * dy);
            },
            midPointFrom: function(that) {
                return new Point(this.x + (that.x - this.x) / 2, this.y + (that.y - this.y) / 2);
            },
            min: function(that) {
                return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
            },
            max: function(that) {
                return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
            },
            toString: function() {
                return this.x + ',' + this.y;
            },
            setXY: function(x, y) {
                this.x = x;
                this.y = y;
            },
            setFromPoint: function(that) {
                this.x = that.x;
                this.y = that.y;
            },
            swap: function(that) {
                var x = this.x,
                    y = this.y;
                this.x = that.x;
                this.y = that.y;
                that.x = x;
                that.y = y;
            }
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {});
        if (fabric.Intersection) {
            fabric.warn('fabric.Intersection is already defined');
            return;
        }

        function Intersection(status) {
            this.status = status;
            this.points = [];
        }
        fabric.Intersection = Intersection;
        fabric.Intersection.prototype = {
            appendPoint: function(point) {
                this.points.push(point);
            },
            appendPoints: function(points) {
                this.points = this.points.concat(points);
            }
        };
        fabric.Intersection.intersectLineLine = function(a1, a2, b1, b2) {
            var result, uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
                ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
                uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
            if (uB !== 0) {
                var ua = uaT / uB,
                    ub = ubT / uB;
                if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
                    result = new Intersection('Intersection');
                    result.points.push(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
                } else {
                    result = new Intersection();
                }
            } else {
                if (uaT === 0 || ubT === 0) {
                    result = new Intersection('Coincident');
                } else {
                    result = new Intersection('Parallel');
                }
            }
            return result;
        };
        fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
            var result = new Intersection(),
                length = points.length;
            for (var i = 0; i < length; i++) {
                var b1 = points[i],
                    b2 = points[(i + 1) % length],
                    inter = Intersection.intersectLineLine(a1, a2, b1, b2);
                result.appendPoints(inter.points);
            }
            if (result.points.length > 0) {
                result.status = 'Intersection';
            }
            return result;
        };
        fabric.Intersection.intersectPolygonPolygon = function(points1, points2) {
            var result = new Intersection(),
                length = points1.length;
            for (var i = 0; i < length; i++) {
                var a1 = points1[i],
                    a2 = points1[(i + 1) % length],
                    inter = Intersection.intersectLinePolygon(a1, a2, points2);
                result.appendPoints(inter.points);
            }
            if (result.points.length > 0) {
                result.status = 'Intersection';
            }
            return result;
        };
        fabric.Intersection.intersectPolygonRectangle = function(points, r1, r2) {
            var min = r1.min(r2),
                max = r1.max(r2),
                topRight = new fabric.Point(max.x, min.y),
                bottomLeft = new fabric.Point(min.x, max.y),
                inter1 = Intersection.intersectLinePolygon(min, topRight, points),
                inter2 = Intersection.intersectLinePolygon(topRight, max, points),
                inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
                inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
                result = new Intersection();
            result.appendPoints(inter1.points);
            result.appendPoints(inter2.points);
            result.appendPoints(inter3.points);
            result.appendPoints(inter4.points);
            if (result.points.length > 0) {
                result.status = 'Intersection';
            }
            return result;
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {});
        if (fabric.Color) {
            fabric.warn('fabric.Color is already defined.');
            return;
        }

        function Color(color) {
            if (!color) {
                this.setSource([0, 0, 0, 1]);
            } else {
                this._tryParsingColor(color);
            }
        }
        fabric.Color = Color;
        fabric.Color.prototype = {
            _tryParsingColor: function(color) {
                var source;
                if (color in Color.colorNameMap) {
                    color = Color.colorNameMap[color];
                }
                if (color === 'transparent') {
                    this.setSource([255, 255, 255, 0]);
                    return;
                }
                source = Color.sourceFromHex(color);
                if (!source) {
                    source = Color.sourceFromRgb(color);
                }
                if (!source) {
                    source = Color.sourceFromHsl(color);
                }
                if (source) {
                    this.setSource(source);
                }
            },
            _rgbToHsl: function(r, g, b) {
                r /= 255, g /= 255, b /= 255;
                var h, s, l, max = fabric.util.array.max([r, g, b]),
                    min = fabric.util.array.min([r, g, b]);
                l = (max + min) / 2;
                if (max === min) {
                    h = s = 0;
                } else {
                    var d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h /= 6;
                }
                return [Math.round(h * 360), Math.round(s * 100), Math.round(l * 100)];
            },
            getSource: function() {
                return this._source;
            },
            setSource: function(source) {
                this._source = source;
            },
            toRgb: function() {
                var source = this.getSource();
                return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
            },
            toRgba: function() {
                var source = this.getSource();
                return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
            },
            toHsl: function() {
                var source = this.getSource(),
                    hsl = this._rgbToHsl(source[0], source[1], source[2]);
                return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
            },
            toHsla: function() {
                var source = this.getSource(),
                    hsl = this._rgbToHsl(source[0], source[1], source[2]);
                return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
            },
            toHex: function() {
                var source = this.getSource(),
                    r, g, b;
                r = source[0].toString(16);
                r = (r.length === 1) ? ('0' + r) : r;
                g = source[1].toString(16);
                g = (g.length === 1) ? ('0' + g) : g;
                b = source[2].toString(16);
                b = (b.length === 1) ? ('0' + b) : b;
                return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
            },
            getAlpha: function() {
                return this.getSource()[3];
            },
            setAlpha: function(alpha) {
                var source = this.getSource();
                source[3] = alpha;
                this.setSource(source);
                return this;
            },
            toGrayscale: function() {
                var source = this.getSource(),
                    average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
                    currentAlpha = source[3];
                this.setSource([average, average, average, currentAlpha]);
                return this;
            },
            toBlackWhite: function(threshold) {
                var source = this.getSource(),
                    average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
                    currentAlpha = source[3];
                threshold = threshold || 127;
                average = (Number(average) < Number(threshold)) ? 0 : 255;
                this.setSource([average, average, average, currentAlpha]);
                return this;
            },
            overlayWith: function(otherColor) {
                if (!(otherColor instanceof Color)) {
                    otherColor = new Color(otherColor);
                }
                var result = [],
                    alpha = this.getAlpha(),
                    otherAlpha = 0.5,
                    source = this.getSource(),
                    otherSource = otherColor.getSource();
                for (var i = 0; i < 3; i++) {
                    result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
                }
                result[3] = alpha;
                this.setSource(result);
                return this;
            }
        };
        fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/;
        fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/;
        fabric.Color.reHex = /^#?([0-9a-f]{6}|[0-9a-f]{3})$/i;
        fabric.Color.colorNameMap = {
            aqua: '#00FFFF',
            black: '#000000',
            blue: '#0000FF',
            fuchsia: '#FF00FF',
            gray: '#808080',
            green: '#008000',
            lime: '#00FF00',
            maroon: '#800000',
            navy: '#000080',
            olive: '#808000',
            orange: '#FFA500',
            purple: '#800080',
            red: '#FF0000',
            silver: '#C0C0C0',
            teal: '#008080',
            white: '#FFFFFF',
            yellow: '#FFFF00'
        };

        function hue2rgb(p, q, t) {
            if (t < 0) {
                t += 1;
            }
            if (t > 1) {
                t -= 1;
            }
            if (t < 1 / 6) {
                return p + (q - p) * 6 * t;
            }
            if (t < 1 / 2) {
                return q;
            }
            if (t < 2 / 3) {
                return p + (q - p) * (2 / 3 - t) * 6;
            }
            return p;
        }
        fabric.Color.fromRgb = function(color) {
            return Color.fromSource(Color.sourceFromRgb(color));
        };
        fabric.Color.sourceFromRgb = function(color) {
            var match = color.match(Color.reRGBa);
            if (match) {
                var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
                    g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
                    b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);
                return [parseInt(r, 10), parseInt(g, 10), parseInt(b, 10), match[4] ? parseFloat(match[4]) : 1];
            }
        };
        fabric.Color.fromRgba = Color.fromRgb;
        fabric.Color.fromHsl = function(color) {
            return Color.fromSource(Color.sourceFromHsl(color));
        };
        fabric.Color.sourceFromHsl = function(color) {
            var match = color.match(Color.reHSLa);
            if (!match) {
                return;
            }
            var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
                s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
                l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
                r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
                    p = l * 2 - q;
                r = hue2rgb(p, q, h + 1 / 3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1 / 3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), match[4] ? parseFloat(match[4]) : 1];
        };
        fabric.Color.fromHsla = Color.fromHsl;
        fabric.Color.fromHex = function(color) {
            return Color.fromSource(Color.sourceFromHex(color));
        };
        fabric.Color.sourceFromHex = function(color) {
            if (color.match(Color.reHex)) {
                var value = color.slice(color.indexOf('#') + 1),
                    isShortNotation = (value.length === 3),
                    r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
                    g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
                    b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6);
                return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1];
            }
        };
        fabric.Color.fromSource = function(source) {
            var oColor = new Color();
            oColor.setSource(source);
            return oColor;
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function() {
        function getColorStop(el) {
            var style = el.getAttribute('style'),
                offset = el.getAttribute('offset'),
                color, colorAlpha, opacity;
            offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
            offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
            if (style) {
                var keyValuePairs = style.split(/\s*;\s*/);
                if (keyValuePairs[keyValuePairs.length - 1] === '') {
                    keyValuePairs.pop();
                }
                for (var i = keyValuePairs.length; i--;) {
                    var split = keyValuePairs[i].split(/\s*:\s*/),
                        key = split[0].trim(),
                        value = split[1].trim();
                    if (key === 'stop-color') {
                        color = value;
                    } else if (key === 'stop-opacity') {
                        opacity = value;
                    }
                }
            }
            if (!color) {
                color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
            }
            if (!opacity) {
                opacity = el.getAttribute('stop-opacity');
            }
            color = new fabric.Color(color);
            colorAlpha = color.getAlpha();
            opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
            opacity *= colorAlpha;
            return {
                offset: offset,
                color: color.toRgb(),
                opacity: opacity
            };
        }

        function getLinearCoords(el) {
            return {
                x1: el.getAttribute('x1') || 0,
                y1: el.getAttribute('y1') || 0,
                x2: el.getAttribute('x2') || '100%',
                y2: el.getAttribute('y2') || 0
            };
        }

        function getRadialCoords(el) {
            return {
                x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
                y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
                r1: 0,
                x2: el.getAttribute('cx') || '50%',
                y2: el.getAttribute('cy') || '50%',
                r2: el.getAttribute('r') || '50%'
            };
        }
        fabric.Gradient = fabric.util.createClass({
            offsetX: 0,
            offsetY: 0,
            initialize: function(options) {
                options || (options = {});
                var coords = {};
                this.id = fabric.Object.__uid++;
                this.type = options.type || 'linear';
                coords = {
                    x1: options.coords.x1 || 0,
                    y1: options.coords.y1 || 0,
                    x2: options.coords.x2 || 0,
                    y2: options.coords.y2 || 0
                };
                if (this.type === 'radial') {
                    coords.r1 = options.coords.r1 || 0;
                    coords.r2 = options.coords.r2 || 0;
                }
                this.coords = coords;
                this.colorStops = options.colorStops.slice();
                if (options.gradientTransform) {
                    this.gradientTransform = options.gradientTransform;
                }
                this.offsetX = options.offsetX || this.offsetX;
                this.offsetY = options.offsetY || this.offsetY;
            },
            addColorStop: function(colorStop) {
                for (var position in colorStop) {
                    var color = new fabric.Color(colorStop[position]);
                    this.colorStops.push({
                        offset: position,
                        color: color.toRgb(),
                        opacity: color.getAlpha()
                    });
                }
                return this;
            },
            toObject: function() {
                return {
                    type: this.type,
                    coords: this.coords,
                    colorStops: this.colorStops,
                    offsetX: this.offsetX,
                    offsetY: this.offsetY
                };
            },
            toSVG: function(object) {
                var coords = fabric.util.object.clone(this.coords),
                    markup, commonAttributes;
                this.colorStops.sort(function(a, b) {
                    return a.offset - b.offset;
                });
                if (!(object.group && object.group.type === 'path-group')) {
                    for (var prop in coords) {
                        if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
                            coords[prop] += this.offsetX - object.width / 2;
                        } else if (prop === 'y1' || prop === 'y2') {
                            coords[prop] += this.offsetY - object.height / 2;
                        }
                    }
                }
                commonAttributes = 'id="SVGID_' + this.id + '" gradientUnits="userSpaceOnUse"';
                if (this.gradientTransform) {
                    commonAttributes += ' gradientTransform="matrix(' + this.gradientTransform.join(' ') + ')" ';
                }
                if (this.type === 'linear') {
                    markup = ['<linearGradient ', commonAttributes, ' x1="', coords.x1, '" y1="', coords.y1, '" x2="', coords.x2, '" y2="', coords.y2, '">\n'];
                } else if (this.type === 'radial') {
                    markup = ['<radialGradient ', commonAttributes, ' cx="', coords.x2, '" cy="', coords.y2, '" r="', coords.r2, '" fx="', coords.x1, '" fy="', coords.y1, '">\n'];
                }
                for (var i = 0; i < this.colorStops.length; i++) {
                    markup.push('<stop ', 'offset="', (this.colorStops[i].offset * 100) + '%', '" style="stop-color:', this.colorStops[i].color, (this.colorStops[i].opacity != null ? ';stop-opacity: ' + this.colorStops[i].opacity : ';'), '"/>\n');
                }
                markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));
                return markup.join('');
            },
            toLive: function(ctx) {
                var gradient;
                if (!this.type) {
                    return;
                }
                if (this.type === 'linear') {
                    gradient = ctx.createLinearGradient(this.coords.x1, this.coords.y1, this.coords.x2, this.coords.y2);
                } else if (this.type === 'radial') {
                    gradient = ctx.createRadialGradient(this.coords.x1, this.coords.y1, this.coords.r1, this.coords.x2, this.coords.y2, this.coords.r2);
                }
                for (var i = 0, len = this.colorStops.length; i < len; i++) {
                    var color = this.colorStops[i].color,
                        opacity = this.colorStops[i].opacity,
                        offset = this.colorStops[i].offset;
                    if (typeof opacity !== 'undefined') {
                        color = new fabric.Color(color).setAlpha(opacity).toRgba();
                    }
                    gradient.addColorStop(parseFloat(offset), color);
                }
                return gradient;
            }
        });
        fabric.util.object.extend(fabric.Gradient, {
            fromElement: function(el, instance) {
                var colorStopEls = el.getElementsByTagName('stop'),
                    type = (el.nodeName === 'linearGradient' ? 'linear' : 'radial'),
                    gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',
                    gradientTransform = el.getAttribute('gradientTransform'),
                    colorStops = [],
                    coords = {},
                    ellipseMatrix;
                if (type === 'linear') {
                    coords = getLinearCoords(el);
                } else if (type === 'radial') {
                    coords = getRadialCoords(el);
                }
                for (var i = colorStopEls.length; i--;) {
                    colorStops.push(getColorStop(colorStopEls[i]));
                }
                ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);
                var gradient = new fabric.Gradient({
                    type: type,
                    coords: coords,
                    colorStops: colorStops,
                    offsetX: -instance.left,
                    offsetY: -instance.top
                });
                if (gradientTransform || ellipseMatrix !== '') {
                    gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);
                }
                return gradient;
            },
            forObject: function(obj, options) {
                options || (options = {});
                _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');
                return new fabric.Gradient(options);
            }
        });

        function _convertPercentUnitsToValues(object, options, gradientUnits) {
            var propValue, addFactor = 0,
                multFactor = 1,
                ellipseMatrix = '';
            for (var prop in options) {
                propValue = parseFloat(options[prop], 10);
                if (typeof options[prop] === 'string' && /^\d+%$/.test(options[prop])) {
                    multFactor = 0.01;
                } else {
                    multFactor = 1;
                }
                if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
                    multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;
                    addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;
                } else if (prop === 'y1' || prop === 'y2') {
                    multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;
                    addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;
                }
                options[prop] = propValue * multFactor + addFactor;
            }
            if (object.type === 'ellipse' && options.r2 !== null && gradientUnits === 'objectBoundingBox' && object.rx !== object.ry) {
                var scaleFactor = object.ry / object.rx;
                ellipseMatrix = ' scale(1, ' + scaleFactor + ')';
                if (options.y1) {
                    options.y1 /= scaleFactor;
                }
                if (options.y2) {
                    options.y2 /= scaleFactor;
                }
            }
            return ellipseMatrix;
        }
    })();
    fabric.Pattern = fabric.util.createClass({
        repeat: 'repeat',
        offsetX: 0,
        offsetY: 0,
        initialize: function(options) {
            options || (options = {});
            this.id = fabric.Object.__uid++;
            if (options.source) {
                if (typeof options.source === 'string') {
                    if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {
                        this.source = new Function(fabric.util.getFunctionBody(options.source));
                    } else {
                        var _this = this;
                        this.source = fabric.util.createImage();
                        fabric.util.loadImage(options.source, function(img) {
                            _this.source = img;
                        });
                    }
                } else {
                    this.source = options.source;
                }
            }
            if (options.repeat) {
                this.repeat = options.repeat;
            }
            if (options.offsetX) {
                this.offsetX = options.offsetX;
            }
            if (options.offsetY) {
                this.offsetY = options.offsetY;
            }
        },
        toObject: function() {
            var source;
            if (typeof this.source === 'function') {
                source = String(this.source);
            } else if (typeof this.source.src === 'string') {
                source = this.source.src;
            }
            return {
                source: source,
                repeat: this.repeat,
                offsetX: this.offsetX,
                offsetY: this.offsetY
            };
        },
        toSVG: function(object) {
            var patternSource = typeof this.source === 'function' ? this.source() : this.source,
                patternWidth = patternSource.width / object.getWidth(),
                patternHeight = patternSource.height / object.getHeight(),
                patternImgSrc = '';
            if (patternSource.src) {
                patternImgSrc = patternSource.src;
            } else if (patternSource.toDataURL) {
                patternImgSrc = patternSource.toDataURL();
            }
            return '<pattern id="SVGID_' + this.id + '" x="' + this.offsetX + '" y="' + this.offsetY + '" width="' + patternWidth + '" height="' + patternHeight + '">' + '<image x="0" y="0"' + ' width="' + patternSource.width + '" height="' + patternSource.height + '" xlink:href="' + patternImgSrc + '"></image>' + '</pattern>';
        },
        toLive: function(ctx) {
            var source = typeof this.source === 'function' ? this.source() : this.source;
            if (!source) {
                return '';
            }
            if (typeof source.src !== 'undefined') {
                if (!source.complete) {
                    return '';
                }
                if (source.naturalWidth === 0 || source.naturalHeight === 0) {
                    return '';
                }
            }
            return ctx.createPattern(source, this.repeat);
        }
    });
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {});
        if (fabric.Shadow) {
            fabric.warn('fabric.Shadow is already defined.');
            return;
        }
        fabric.Shadow = fabric.util.createClass({
            color: 'rgb(0,0,0)',
            blur: 0,
            offsetX: 0,
            offsetY: 0,
            affectStroke: false,
            includeDefaultValues: true,
            initialize: function(options) {
                if (typeof options === 'string') {
                    options = this._parseShadow(options);
                }
                for (var prop in options) {
                    this[prop] = options[prop];
                }
                this.id = fabric.Object.__uid++;
            },
            _parseShadow: function(shadow) {
                var shadowStr = shadow.trim(),
                    offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],
                    color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';
                return {
                    color: color.trim(),
                    offsetX: parseInt(offsetsAndBlur[1], 10) || 0,
                    offsetY: parseInt(offsetsAndBlur[2], 10) || 0,
                    blur: parseInt(offsetsAndBlur[3], 10) || 0
                };
            },
            toString: function() {
                return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
            },
            toSVG: function(object) {
                var mode = 'SourceAlpha';
                if (object && (object.fill === this.color || object.stroke === this.color)) {
                    mode = 'SourceGraphic';
                }
                return ('<filter id="SVGID_' + this.id + '" y="-40%" height="180%">' + '<feGaussianBlur in="' + mode + '" stdDeviation="' +
                    (this.blur ? this.blur / 3 : 0) + '"></feGaussianBlur>' + '<feOffset dx="' + this.offsetX + '" dy="' + this.offsetY + '"></feOffset>' + '<feMerge>' + '<feMergeNode></feMergeNode>' + '<feMergeNode in="SourceGraphic"></feMergeNode>' + '</feMerge>' + '</filter>');
            },
            toObject: function() {
                if (this.includeDefaultValues) {
                    return {
                        color: this.color,
                        blur: this.blur,
                        offsetX: this.offsetX,
                        offsetY: this.offsetY
                    };
                }
                var obj = {},
                    proto = fabric.Shadow.prototype;
                if (this.color !== proto.color) {
                    obj.color = this.color;
                }
                if (this.blur !== proto.blur) {
                    obj.blur = this.blur;
                }
                if (this.offsetX !== proto.offsetX) {
                    obj.offsetX = this.offsetX;
                }
                if (this.offsetY !== proto.offsetY) {
                    obj.offsetY = this.offsetY;
                }
                return obj;
            }
        });
        fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;
    })(typeof exports !== 'undefined' ? exports : this);
    (function() {
        'use strict';
        if (fabric.StaticCanvas) {
            fabric.warn('fabric.StaticCanvas is already defined.');
            return;
        }
        var extend = fabric.util.object.extend,
            getElementOffset = fabric.util.getElementOffset,
            removeFromArray = fabric.util.removeFromArray,
            CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');
        fabric.StaticCanvas = fabric.util.createClass({
            initialize: function(el, options) {
                options || (options = {});
                this._initStatic(el, options);
                fabric.StaticCanvas.activeInstance = this;
            },
            backgroundColor: '',
            backgroundImage: null,
            overlayColor: '',
            overlayImage: null,
            includeDefaultValues: true,
            stateful: true,
            renderOnAddRemove: true,
            clipTo: null,
            controlsAboveOverlay: false,
            allowTouchScrolling: false,
            imageSmoothingEnabled: true,
            viewportTransform: [1, 0, 0, 1, 0, 0],
            onBeforeScaleRotate: function() {},
            _initStatic: function(el, options) {
                this._objects = [];
                this._createLowerCanvas(el);
                this._initOptions(options);
                this._setImageSmoothing();
                if (options.overlayImage) {
                    this.setOverlayImage(options.overlayImage, this.renderAll.bind(this));
                }
                if (options.backgroundImage) {
                    this.setBackgroundImage(options.backgroundImage, this.renderAll.bind(this));
                }
                if (options.backgroundColor) {
                    this.setBackgroundColor(options.backgroundColor, this.renderAll.bind(this));
                }
                if (options.overlayColor) {
                    this.setOverlayColor(options.overlayColor, this.renderAll.bind(this));
                }
                this.calcOffset();
            },
            calcOffset: function() {
                this._offset = getElementOffset(this.lowerCanvasEl);
                return this;
            },
            setOverlayImage: function(image, callback, options) {
                return this.__setBgOverlayImage('overlayImage', image, callback, options);
            },
            setBackgroundImage: function(image, callback, options) {
                return this.__setBgOverlayImage('backgroundImage', image, callback, options);
            },
            setOverlayColor: function(overlayColor, callback) {
                return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
            },
            setBackgroundColor: function(backgroundColor, callback) {
                return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
            },
            _setImageSmoothing: function() {
                var ctx = this.getContext();
                ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;
                ctx.webkitImageSmoothingEnabled = this.imageSmoothingEnabled;
                ctx.mozImageSmoothingEnabled = this.imageSmoothingEnabled;
                ctx.msImageSmoothingEnabled = this.imageSmoothingEnabled;
                ctx.oImageSmoothingEnabled = this.imageSmoothingEnabled;
            },
            __setBgOverlayImage: function(property, image, callback, options) {
                if (typeof image === 'string') {
                    fabric.util.loadImage(image, function(img) {
                        this[property] = new fabric.Image(img, options);
                        callback && callback();
                    }, this);
                } else {
                    this[property] = image;
                    callback && callback();
                }
                return this;
            },
            __setBgOverlayColor: function(property, color, callback) {
                if (color && color.source) {
                    var _this = this;
                    fabric.util.loadImage(color.source, function(img) {
                        _this[property] = new fabric.Pattern({
                            source: img,
                            repeat: color.repeat,
                            offsetX: color.offsetX,
                            offsetY: color.offsetY
                        });
                        callback && callback();
                    });
                } else {
                    this[property] = color;
                    callback && callback();
                }
                return this;
            },
            _createCanvasElement: function() {
                var element = fabric.document.createElement('canvas');
                if (!element.style) {
                    element.style = {};
                }
                if (!element) {
                    throw CANVAS_INIT_ERROR;
                }
                this._initCanvasElement(element);
                return element;
            },
            _initCanvasElement: function(element) {
                fabric.util.createCanvasElement(element);
                if (typeof element.getContext === 'undefined') {
                    throw CANVAS_INIT_ERROR;
                }
            },
            _initOptions: function(options) {
                for (var prop in options) {
                    this[prop] = options[prop];
                }
                this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0;
                this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0;
                if (!this.lowerCanvasEl.style) {
                    return;
                }
                this.lowerCanvasEl.width = this.width;
                this.lowerCanvasEl.height = this.height;
                this.lowerCanvasEl.style.width = this.width + 'px';
                this.lowerCanvasEl.style.height = this.height + 'px';
                this.viewportTransform = this.viewportTransform.slice();
            },
            _createLowerCanvas: function(canvasEl) {
                this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();
                this._initCanvasElement(this.lowerCanvasEl);
                fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');
                if (this.interactive) {
                    this._applyCanvasStyle(this.lowerCanvasEl);
                }
                this.contextContainer = this.lowerCanvasEl.getContext('2d');
            },
            getWidth: function() {
                return this.width;
            },
            getHeight: function() {
                return this.height;
            },
            setWidth: function(value, options) {
                return this.setDimensions({
                    width: value
                }, options);
            },
            setHeight: function(value, options) {
                return this.setDimensions({
                    height: value
                }, options);
            },
            setDimensions: function(dimensions, options) {
                var cssValue;
                options = options || {};
                for (var prop in dimensions) {
                    cssValue = dimensions[prop];
                    if (!options.cssOnly) {
                        this._setBackstoreDimension(prop, dimensions[prop]);
                        cssValue += 'px';
                    }
                    if (!options.backstoreOnly) {
                        this._setCssDimension(prop, cssValue);
                    }
                }
                if (!options.cssOnly) {
                    this.renderAll();
                }
                this.calcOffset();
                return this;
            },
            _setBackstoreDimension: function(prop, value) {
                this.lowerCanvasEl[prop] = value;
                if (this.upperCanvasEl) {
                    this.upperCanvasEl[prop] = value;
                }
                if (this.cacheCanvasEl) {
                    this.cacheCanvasEl[prop] = value;
                }
                this[prop] = value;
                return this;
            },
            _setCssDimension: function(prop, value) {
                this.lowerCanvasEl.style[prop] = value;
                if (this.upperCanvasEl) {
                    this.upperCanvasEl.style[prop] = value;
                }
                if (this.wrapperEl) {
                    this.wrapperEl.style[prop] = value;
                }
                return this;
            },
            getZoom: function() {
                return Math.sqrt(this.viewportTransform[0] * this.viewportTransform[3]);
            },
            setViewportTransform: function(vpt) {
                this.viewportTransform = vpt;
                this.renderAll();
                for (var i = 0, len = this._objects.length; i < len; i++) {
                    this._objects[i].setCoords();
                }
                return this;
            },
            zoomToPoint: function(point, value) {
                var before = point;
                point = fabric.util.transformPoint(point, fabric.util.invertTransform(this.viewportTransform));
                this.viewportTransform[0] = value;
                this.viewportTransform[3] = value;
                var after = fabric.util.transformPoint(point, this.viewportTransform);
                this.viewportTransform[4] += before.x - after.x;
                this.viewportTransform[5] += before.y - after.y;
                this.renderAll();
                for (var i = 0, len = this._objects.length; i < len; i++) {
                    this._objects[i].setCoords();
                }
                return this;
            },
            setZoom: function(value) {
                this.zoomToPoint(new fabric.Point(0, 0), value);
                return this;
            },
            absolutePan: function(point) {
                this.viewportTransform[4] = -point.x;
                this.viewportTransform[5] = -point.y;
                this.renderAll();
                for (var i = 0, len = this._objects.length; i < len; i++) {
                    this._objects[i].setCoords();
                }
                return this;
            },
            relativePan: function(point) {
                return this.absolutePan(new fabric.Point(-point.x - this.viewportTransform[4], -point.y - this.viewportTransform[5]));
            },
            getElement: function() {
                return this.lowerCanvasEl;
            },
            getActiveObject: function() {
                return null;
            },
            getActiveGroup: function() {
                return null;
            },
            _draw: function(ctx, object) {
                if (!object) {
                    return;
                }
                ctx.save();
                var v = this.viewportTransform;
                ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
                object.render(ctx);
                ctx.restore();
                if (!this.controlsAboveOverlay) {
                    object._renderControls(ctx);
                }
            },
            _onObjectAdded: function(obj) {
                this.stateful && obj.setupState();
                obj.canvas = this;
                obj.setCoords();
                this.fire('object:added', {
                    target: obj
                });
                obj.fire('added');
            },
            _onObjectRemoved: function(obj) {
                if (this.getActiveObject() === obj) {
                    this.fire('before:selection:cleared', {
                        target: obj
                    });
                    this._discardActiveObject();
                    this.fire('selection:cleared');
                }
                this.fire('object:removed', {
                    target: obj
                });
                obj.fire('removed');
            },
            clearContext: function(ctx) {
                ctx.clearRect(0, 0, this.width, this.height);
                return this;
            },
            getContext: function() {
                return this.contextContainer;
            },
            clear: function() {
                this._objects.length = 0;
                if (this.discardActiveGroup) {
                    this.discardActiveGroup();
                }
                if (this.discardActiveObject) {
                    this.discardActiveObject();
                }
                this.clearContext(this.contextContainer);
                if (this.contextTop) {
                    this.clearContext(this.contextTop);
                }
                this.fire('canvas:cleared');
                this.renderAll();
                return this;
            },
            renderAll: function(allOnTop) {
                var canvasToDrawOn = this[(allOnTop === true && this.interactive) ? 'contextTop' : 'contextContainer'],
                    activeGroup = this.getActiveGroup();
                if (this.contextTop && this.selection && !this._groupSelector) {
                    this.clearContext(this.contextTop);
                }
                if (!allOnTop) {
                    this.clearContext(canvasToDrawOn);
                }
                this.fire('before:render');
                if (this.clipTo) {
                    fabric.util.clipContext(this, canvasToDrawOn);
                }
                this._renderBackground(canvasToDrawOn);
                this._renderObjects(canvasToDrawOn, activeGroup);
                this._renderActiveGroup(canvasToDrawOn, activeGroup);
                if (this.clipTo) {
                    canvasToDrawOn.restore();
                }
                this._renderOverlay(canvasToDrawOn);
                if (this.controlsAboveOverlay && this.interactive) {
                    this.drawControls(canvasToDrawOn);
                }
                this.fire('after:render');
                return this;
            },
            _renderObjects: function(ctx, activeGroup) {
                var i, length;
                if (!activeGroup) {
                    for (i = 0, length = this._objects.length; i < length; ++i) {
                        this._draw(ctx, this._objects[i]);
                    }
                } else {
                    for (i = 0, length = this._objects.length; i < length; ++i) {
                        if (this._objects[i] && !activeGroup.contains(this._objects[i])) {
                            this._draw(ctx, this._objects[i]);
                        }
                    }
                }
            },
            _renderActiveGroup: function(ctx, activeGroup) {
                if (activeGroup) {
                    var sortedObjects = [];
                    this.forEachObject(function(object) {
                        if (activeGroup.contains(object)) {
                            sortedObjects.push(object);
                        }
                    });
                    activeGroup._set('objects', sortedObjects);
                    this._draw(ctx, activeGroup);
                }
            },
            _renderBackground: function(ctx) {
                if (this.backgroundColor) {
                    ctx.fillStyle = this.backgroundColor.toLive ? this.backgroundColor.toLive(ctx) : this.backgroundColor;
                    ctx.fillRect(this.backgroundColor.offsetX || 0, this.backgroundColor.offsetY || 0, this.width, this.height);
                }
                if (this.backgroundImage) {
                    this._draw(ctx, this.backgroundImage);
                }
            },
            _renderOverlay: function(ctx) {
                if (this.overlayColor) {
                    ctx.fillStyle = this.overlayColor.toLive ? this.overlayColor.toLive(ctx) : this.overlayColor;
                    ctx.fillRect(this.overlayColor.offsetX || 0, this.overlayColor.offsetY || 0, this.width, this.height);
                }
                if (this.overlayImage) {
                    this._draw(ctx, this.overlayImage);
                }
            },
            renderTop: function() {
                var ctx = this.contextTop || this.contextContainer;
                this.clearContext(ctx);
                if (this.selection && this._groupSelector) {
                    this._drawSelection();
                }
                var activeGroup = this.getActiveGroup();
                if (activeGroup) {
                    activeGroup.render(ctx);
                }
                this._renderOverlay(ctx);
                this.fire('after:render');
                return this;
            },
            getCenter: function() {
                return {
                    top: this.getHeight() / 2,
                    left: this.getWidth() / 2
                };
            },
            centerObjectH: function(object) {
                this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
                this.renderAll();
                return this;
            },
            centerObjectV: function(object) {
                this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
                this.renderAll();
                return this;
            },
            centerObject: function(object) {
                var center = this.getCenter();
                this._centerObject(object, new fabric.Point(center.left, center.top));
                this.renderAll();
                return this;
            },
            _centerObject: function(object, center) {
                object.setPositionByOrigin(center, 'center', 'center');
                return this;
            },
            toDatalessJSON: function(propertiesToInclude) {
                return this.toDatalessObject(propertiesToInclude);
            },
            toObject: function(propertiesToInclude) {
                return this._toObjectMethod('toObject', propertiesToInclude);
            },
            toDatalessObject: function(propertiesToInclude) {
                return this._toObjectMethod('toDatalessObject', propertiesToInclude);
            },
            _toObjectMethod: function(methodName, propertiesToInclude) {
                var activeGroup = this.getActiveGroup();
                if (activeGroup) {
                    this.discardActiveGroup();
                }
                var data = {
                    objects: this._toObjects(methodName, propertiesToInclude)
                };
                extend(data, this.__serializeBgOverlay());
                fabric.util.populateWithProperties(this, data, propertiesToInclude);
                if (activeGroup) {
                    this.setActiveGroup(new fabric.Group(activeGroup.getObjects(), {
                        originX: 'center',
                        originY: 'center'
                    }));
                    activeGroup.forEachObject(function(o) {
                        o.set('active', true);
                    });
                    if (this._currentTransform) {
                        this._currentTransform.target = this.getActiveGroup();
                    }
                }
                return data;
            },
            _toObjects: function(methodName, propertiesToInclude) {
                return this.getObjects().map(function(instance) {
                    return this._toObject(instance, methodName, propertiesToInclude);
                }, this);
            },
            _toObject: function(instance, methodName, propertiesToInclude) {
                var originalValue;
                if (!this.includeDefaultValues) {
                    originalValue = instance.includeDefaultValues;
                    instance.includeDefaultValues = false;
                }
                var object = instance[methodName](propertiesToInclude);
                if (!this.includeDefaultValues) {
                    instance.includeDefaultValues = originalValue;
                }
                return object;
            },
            __serializeBgOverlay: function() {
                var data = {
                    background: (this.backgroundColor && this.backgroundColor.toObject) ? this.backgroundColor.toObject() : this.backgroundColor
                };
                if (this.overlayColor) {
                    data.overlay = this.overlayColor.toObject ? this.overlayColor.toObject() : this.overlayColor;
                }
                if (this.backgroundImage) {
                    data.backgroundImage = this.backgroundImage.toObject();
                }
                if (this.overlayImage) {
                    data.overlayImage = this.overlayImage.toObject();
                }
                return data;
            },
            svgViewportTransformation: true,
            toSVG: function(options, reviver) {
                options || (options = {});
                var markup = [];
                this._setSVGPreamble(markup, options);
                this._setSVGHeader(markup, options);
                this._setSVGBgOverlayColor(markup, 'backgroundColor');
                this._setSVGBgOverlayImage(markup, 'backgroundImage');
                this._setSVGObjects(markup, reviver);
                this._setSVGBgOverlayColor(markup, 'overlayColor');
                this._setSVGBgOverlayImage(markup, 'overlayImage');
                markup.push('</svg>');
                return markup.join('');
            },
            _setSVGPreamble: function(markup, options) {
                if (!options.suppressPreamble) {
                    markup.push('<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>', '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n');
                }
            },
            _setSVGHeader: function(markup, options) {
                var width, height, vpt;
                if (options.viewBox) {
                    width = options.viewBox.width;
                    height = options.viewBox.height;
                } else {
                    width = this.width;
                    height = this.height;
                    if (!this.svgViewportTransformation) {
                        vpt = this.viewportTransform;
                        width /= vpt[0];
                        height /= vpt[3];
                    }
                }
                markup.push('<svg ', 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', width, '" ', 'height="', height, '" ', (this.backgroundColor && !this.backgroundColor.toLive ? 'style="background-color: ' + this.backgroundColor + '" ' : null), (options.viewBox ? 'viewBox="' +
                    options.viewBox.x + ' ' +
                    options.viewBox.y + ' ' +
                    options.viewBox.width + ' ' +
                    options.viewBox.height + '" ' : null), 'xml:space="preserve">', '<desc>Created with Fabric.js ', fabric.version, '</desc>', '<defs>', fabric.createSVGFontFacesMarkup(this.getObjects()), fabric.createSVGRefElementsMarkup(this), '</defs>');
            },
            _setSVGObjects: function(markup, reviver) {
                var activeGroup = this.getActiveGroup();
                if (activeGroup) {
                    this.discardActiveGroup();
                }
                for (var i = 0, objects = this.getObjects(), len = objects.length; i < len; i++) {
                    markup.push(objects[i].toSVG(reviver));
                }
                if (activeGroup) {
                    this.setActiveGroup(new fabric.Group(activeGroup.getObjects()));
                    activeGroup.forEachObject(function(o) {
                        o.set('active', true);
                    });
                }
            },
            _setSVGBgOverlayImage: function(markup, property) {
                if (this[property] && this[property].toSVG) {
                    markup.push(this[property].toSVG());
                }
            },
            _setSVGBgOverlayColor: function(markup, property) {
                if (this[property] && this[property].source) {
                    markup.push('<rect x="', this[property].offsetX, '" y="', this[property].offsetY, '" ', 'width="', (this[property].repeat === 'repeat-y' || this[property].repeat === 'no-repeat' ? this[property].source.width : this.width), '" height="', (this[property].repeat === 'repeat-x' || this[property].repeat === 'no-repeat' ? this[property].source.height : this.height), '" fill="url(#' + property + 'Pattern)"', '></rect>');
                } else if (this[property] && property === 'overlayColor') {
                    markup.push('<rect x="0" y="0" ', 'width="', this.width, '" height="', this.height, '" fill="', this[property], '"', '></rect>');
                }
            },
            sendToBack: function(object) {
                removeFromArray(this._objects, object);
                this._objects.unshift(object);
                return this.renderAll && this.renderAll();
            },
            bringToFront: function(object) {
                removeFromArray(this._objects, object);
                this._objects.push(object);
                return this.renderAll && this.renderAll();
            },
            sendBackwards: function(object, intersecting) {
                var idx = this._objects.indexOf(object);
                if (idx !== 0) {
                    var newIdx = this._findNewLowerIndex(object, idx, intersecting);
                    removeFromArray(this._objects, object);
                    this._objects.splice(newIdx, 0, object);
                    this.renderAll && this.renderAll();
                }
                return this;
            },
            _findNewLowerIndex: function(object, idx, intersecting) {
                var newIdx;
                if (intersecting) {
                    newIdx = idx;
                    for (var i = idx - 1; i >= 0; --i) {
                        var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);
                        if (isIntersecting) {
                            newIdx = i;
                            break;
                        }
                    }
                } else {
                    newIdx = idx - 1;
                }
                return newIdx;
            },
            bringForward: function(object, intersecting) {
                var idx = this._objects.indexOf(object);
                if (idx !== this._objects.length - 1) {
                    var newIdx = this._findNewUpperIndex(object, idx, intersecting);
                    removeFromArray(this._objects, object);
                    this._objects.splice(newIdx, 0, object);
                    this.renderAll && this.renderAll();
                }
                return this;
            },
            _findNewUpperIndex: function(object, idx, intersecting) {
                var newIdx;
                if (intersecting) {
                    newIdx = idx;
                    for (var i = idx + 1; i < this._objects.length; ++i) {
                        var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);
                        if (isIntersecting) {
                            newIdx = i;
                            break;
                        }
                    }
                } else {
                    newIdx = idx + 1;
                }
                return newIdx;
            },
            moveTo: function(object, index) {
                removeFromArray(this._objects, object);
                this._objects.splice(index, 0, object);
                return this.renderAll && this.renderAll();
            },
            dispose: function() {
                this.clear();
                this.interactive && this.removeListeners();
                return this;
            },
            toString: function() {
                return '#<fabric.Canvas (' + this.complexity() + '): ' + '{ objects: ' + this.getObjects().length + ' }>';
            }
        });
        extend(fabric.StaticCanvas.prototype, fabric.Observable);
        extend(fabric.StaticCanvas.prototype, fabric.Collection);
        extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);
        extend(fabric.StaticCanvas, {
            EMPTY_JSON: '{"objects": [], "background": "white"}',
            supports: function(methodName) {
                var el = fabric.util.createCanvasElement();
                if (!el || !el.getContext) {
                    return null;
                }
                var ctx = el.getContext('2d');
                if (!ctx) {
                    return null;
                }
                switch (methodName) {
                    case 'getImageData':
                        return typeof ctx.getImageData !== 'undefined';
                    case 'setLineDash':
                        return typeof ctx.setLineDash !== 'undefined';
                    case 'toDataURL':
                        return typeof el.toDataURL !== 'undefined';
                    case 'toDataURLWithQuality':
                        try {
                            el.toDataURL('image/jpeg', 0);
                            return true;
                        } catch (e) {}
                        return false;
                    default:
                        return null;
                }
            }
        });
        fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;
    })();
    fabric.BaseBrush = fabric.util.createClass({
        color: 'rgb(0, 0, 0)',
        width: 1,
        shadow: null,
        strokeLineCap: 'round',
        strokeLineJoin: 'round',
        setShadow: function(options) {
            this.shadow = new fabric.Shadow(options);
            return this;
        },
        _setBrushStyles: function() {
            var ctx = this.canvas.contextTop;
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.width;
            ctx.lineCap = this.strokeLineCap;
            ctx.lineJoin = this.strokeLineJoin;
        },
        _setShadow: function() {
            if (!this.shadow) {
                return;
            }
            var ctx = this.canvas.contextTop;
            ctx.shadowColor = this.shadow.color;
            ctx.shadowBlur = this.shadow.blur;
            ctx.shadowOffsetX = this.shadow.offsetX;
            ctx.shadowOffsetY = this.shadow.offsetY;
        },
        _resetShadow: function() {
            var ctx = this.canvas.contextTop;
            ctx.shadowColor = '';
            ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
        }
    });
    (function() {
        var utilMin = fabric.util.array.min,
            utilMax = fabric.util.array.max;
        fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, {
            initialize: function(canvas) {
                this.canvas = canvas;
                this._points = [];
            },
            onMouseDown: function(pointer) {
                this._prepareForDrawing(pointer);
                this._captureDrawingPath(pointer);
                this._render();
            },
            onMouseMove: function(pointer) {
                this._captureDrawingPath(pointer);
                this.canvas.clearContext(this.canvas.contextTop);
                this._render();
            },
            onMouseUp: function() {
                this._finalizeAndAddPath();
            },
            _prepareForDrawing: function(pointer) {
                var p = new fabric.Point(pointer.x, pointer.y);
                this._reset();
                this._addPoint(p);
                this.canvas.contextTop.moveTo(p.x, p.y);
            },
            _addPoint: function(point) {
                this._points.push(point);
            },
            _reset: function() {
                this._points.length = 0;
                this._setBrushStyles();
                this._setShadow();
            },
            _captureDrawingPath: function(pointer) {
                var pointerPoint = new fabric.Point(pointer.x, pointer.y);
                this._addPoint(pointerPoint);
            },
            _render: function() {
                var ctx = this.canvas.contextTop,
                    v = this.canvas.viewportTransform,
                    p1 = this._points[0],
                    p2 = this._points[1];
                ctx.save();
                ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
                ctx.beginPath();
                if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
                    p1.x -= 0.5;
                    p2.x += 0.5;
                }
                ctx.moveTo(p1.x, p1.y);
                for (var i = 1, len = this._points.length; i < len; i++) {
                    var midPoint = p1.midPointFrom(p2);
                    ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
                    p1 = this._points[i];
                    p2 = this._points[i + 1];
                }
                ctx.lineTo(p1.x, p1.y);
                ctx.stroke();
                ctx.restore();
            },
            _getSVGPathData: function() {
                this.box = this.getPathBoundingBox(this._points);
                return this.convertPointsToSVGPath(this._points, this.box.minX, this.box.minY);
            },
            getPathBoundingBox: function(points) {
                var xBounds = [],
                    yBounds = [],
                    p1 = points[0],
                    p2 = points[1],
                    startPoint = p1;
                for (var i = 1, len = points.length; i < len; i++) {
                    var midPoint = p1.midPointFrom(p2);
                    xBounds.push(startPoint.x);
                    xBounds.push(midPoint.x);
                    yBounds.push(startPoint.y);
                    yBounds.push(midPoint.y);
                    p1 = points[i];
                    p2 = points[i + 1];
                    startPoint = midPoint;
                }
                xBounds.push(p1.x);
                yBounds.push(p1.y);
                return {
                    minX: utilMin(xBounds),
                    minY: utilMin(yBounds),
                    maxX: utilMax(xBounds),
                    maxY: utilMax(yBounds)
                };
            },
            convertPointsToSVGPath: function(points, minX, minY) {
                var path = [],
                    p1 = new fabric.Point(points[0].x - minX, points[0].y - minY),
                    p2 = new fabric.Point(points[1].x - minX, points[1].y - minY);
                path.push('M ', points[0].x - minX, ' ', points[0].y - minY, ' ');
                for (var i = 1, len = points.length; i < len; i++) {
                    var midPoint = p1.midPointFrom(p2);
                    path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
                    p1 = new fabric.Point(points[i].x - minX, points[i].y - minY);
                    if ((i + 1) < points.length) {
                        p2 = new fabric.Point(points[i + 1].x - minX, points[i + 1].y - minY);
                    }
                }
                path.push('L ', p1.x, ' ', p1.y, ' ');
                return path;
            },
            createPath: function(pathData) {
                var path = new fabric.Path(pathData);
                path.fill = null;
                path.stroke = this.color;
                path.strokeWidth = this.width;
                path.strokeLineCap = this.strokeLineCap;
                path.strokeLineJoin = this.strokeLineJoin;
                if (this.shadow) {
                    this.shadow.affectStroke = true;
                    path.setShadow(this.shadow);
                }
                return path;
            },
            _finalizeAndAddPath: function() {
                var ctx = this.canvas.contextTop;
                ctx.closePath();
                var pathData = this._getSVGPathData().join('');
                if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
                    this.canvas.renderAll();
                    return;
                }
                var originLeft = this.box.minX + (this.box.maxX - this.box.minX) / 2,
                    originTop = this.box.minY + (this.box.maxY - this.box.minY) / 2;
                this.canvas.contextTop.arc(originLeft, originTop, 3, 0, Math.PI * 2, false);
                var path = this.createPath(pathData);
                path.set({
                    left: originLeft,
                    top: originTop,
                    originX: 'center',
                    originY: 'center'
                });
                this.canvas.add(path);
                path.setCoords();
                this.canvas.clearContext(this.canvas.contextTop);
                this._resetShadow();
                this.canvas.renderAll();
                this.canvas.fire('path:created', {
                    path: path
                });
            }
        });
    })();
    fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, {
        width: 10,
        initialize: function(canvas) {
            this.canvas = canvas;
            this.points = [];
        },
        drawDot: function(pointer) {
            var point = this.addPoint(pointer),
                ctx = this.canvas.contextTop,
                v = this.canvas.viewportTransform;
            ctx.save();
            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
            ctx.fillStyle = point.fill;
            ctx.beginPath();
            ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        },
        onMouseDown: function(pointer) {
            this.points.length = 0;
            this.canvas.clearContext(this.canvas.contextTop);
            this._setShadow();
            this.drawDot(pointer);
        },
        onMouseMove: function(pointer) {
            this.drawDot(pointer);
        },
        onMouseUp: function() {
            var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
            this.canvas.renderOnAddRemove = false;
            var circles = [];
            for (var i = 0, len = this.points.length; i < len; i++) {
                var point = this.points[i],
                    circle = new fabric.Circle({
                        radius: point.radius,
                        left: point.x,
                        top: point.y,
                        originX: 'center',
                        originY: 'center',
                        fill: point.fill
                    });
                this.shadow && circle.setShadow(this.shadow);
                circles.push(circle);
            }
            var group = new fabric.Group(circles, {
                originX: 'center',
                originY: 'center'
            });
            group.canvas = this.canvas;
            this.canvas.add(group);
            this.canvas.fire('path:created', {
                path: group
            });
            this.canvas.clearContext(this.canvas.contextTop);
            this._resetShadow();
            this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
            this.canvas.renderAll();
        },
        addPoint: function(pointer) {
            var pointerPoint = new fabric.Point(pointer.x, pointer.y),
                circleRadius = fabric.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2,
                circleColor = new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0, 100) / 100).toRgba();
            pointerPoint.radius = circleRadius;
            pointerPoint.fill = circleColor;
            this.points.push(pointerPoint);
            return pointerPoint;
        }
    });
    fabric.SprayBrush = fabric.util.createClass(fabric.BaseBrush, {
        width: 10,
        density: 20,
        dotWidth: 1,
        dotWidthVariance: 1,
        randomOpacity: false,
        optimizeOverlapping: true,
        initialize: function(canvas) {
            this.canvas = canvas;
            this.sprayChunks = [];
        },
        onMouseDown: function(pointer) {
            this.sprayChunks.length = 0;
            this.canvas.clearContext(this.canvas.contextTop);
            this._setShadow();
            this.addSprayChunk(pointer);
            this.render();
        },
        onMouseMove: function(pointer) {
            this.addSprayChunk(pointer);
            this.render();
        },
        onMouseUp: function() {
            var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
            this.canvas.renderOnAddRemove = false;
            var rects = [];
            for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
                var sprayChunk = this.sprayChunks[i];
                for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {
                    var rect = new fabric.Rect({
                        width: sprayChunk[j].width,
                        height: sprayChunk[j].width,
                        left: sprayChunk[j].x + 1,
                        top: sprayChunk[j].y + 1,
                        originX: 'center',
                        originY: 'center',
                        fill: this.color
                    });
                    this.shadow && rect.setShadow(this.shadow);
                    rects.push(rect);
                }
            }
            if (this.optimizeOverlapping) {
                rects = this._getOptimizedRects(rects);
            }
            var group = new fabric.Group(rects, {
                originX: 'center',
                originY: 'center'
            });
            group.canvas = this.canvas;
            this.canvas.add(group);
            this.canvas.fire('path:created', {
                path: group
            });
            this.canvas.clearContext(this.canvas.contextTop);
            this._resetShadow();
            this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
            this.canvas.renderAll();
        },
        _getOptimizedRects: function(rects) {
            var uniqueRects = {},
                key;
            for (var i = 0, len = rects.length; i < len; i++) {
                key = rects[i].left + '' + rects[i].top;
                if (!uniqueRects[key]) {
                    uniqueRects[key] = rects[i];
                }
            }
            var uniqueRectsArray = [];
            for (key in uniqueRects) {
                uniqueRectsArray.push(uniqueRects[key]);
            }
            return uniqueRectsArray;
        },
        render: function() {
            var ctx = this.canvas.contextTop;
            ctx.fillStyle = this.color;
            var v = this.canvas.viewportTransform;
            ctx.save();
            ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
            for (var i = 0, len = this.sprayChunkPoints.length; i < len; i++) {
                var point = this.sprayChunkPoints[i];
                if (typeof point.opacity !== 'undefined') {
                    ctx.globalAlpha = point.opacity;
                }
                ctx.fillRect(point.x, point.y, point.width, point.width);
            }
            ctx.restore();
        },
        addSprayChunk: function(pointer) {
            this.sprayChunkPoints = [];
            var x, y, width, radius = this.width / 2;
            for (var i = 0; i < this.density; i++) {
                x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
                y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);
                if (this.dotWidthVariance) {
                    width = fabric.util.getRandomInt(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance);
                } else {
                    width = this.dotWidth;
                }
                var point = new fabric.Point(x, y);
                point.width = width;
                if (this.randomOpacity) {
                    point.opacity = fabric.util.getRandomInt(0, 100) / 100;
                }
                this.sprayChunkPoints.push(point);
            }
            this.sprayChunks.push(this.sprayChunkPoints);
        }
    });
    fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, {
        getPatternSrc: function() {
            var dotWidth = 20,
                dotDistance = 5,
                patternCanvas = fabric.document.createElement('canvas'),
                patternCtx = patternCanvas.getContext('2d');
            patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;
            patternCtx.fillStyle = this.color;
            patternCtx.beginPath();
            patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
            patternCtx.closePath();
            patternCtx.fill();
            return patternCanvas;
        },
        getPatternSrcFunction: function() {
            return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
        },
        getPattern: function() {
            return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');
        },
        _setBrushStyles: function() {
            this.callSuper('_setBrushStyles');
            this.canvas.contextTop.strokeStyle = this.getPattern();
        },
        createPath: function(pathData) {
            var path = this.callSuper('createPath', pathData);
            path.stroke = new fabric.Pattern({
                source: this.source || this.getPatternSrcFunction()
            });
            return path;
        }
    });
    fabric.util.object.extend(fabric.StaticCanvas.prototype, {
        toDataURL: function(options) {
            options || (options = {});
            var format = options.format || 'png',
                quality = options.quality || 1,
                multiplier = options.multiplier || 1,
                cropping = {
                    left: options.left,
                    top: options.top,
                    width: options.width,
                    height: options.height
                };
            if (multiplier !== 1) {
                return this.__toDataURLWithMultiplier(format, quality, cropping, multiplier);
            } else {
                return this.__toDataURL(format, quality, cropping);
            }
        },
        __toDataURL: function(format, quality, cropping) {
            this.renderAll(true);
            var canvasEl = this.upperCanvasEl || this.lowerCanvasEl,
                croppedCanvasEl = this.__getCroppedCanvas(canvasEl, cropping);
            if (format === 'jpg') {
                format = 'jpeg';
            }
            var data = (fabric.StaticCanvas.supports('toDataURLWithQuality')) ? (croppedCanvasEl || canvasEl).toDataURL('image/' + format, quality) : (croppedCanvasEl || canvasEl).toDataURL('image/' + format);
            this.contextTop && this.clearContext(this.contextTop);
            this.renderAll();
            if (croppedCanvasEl) {
                croppedCanvasEl = null;
            }
            return data;
        },
        __getCroppedCanvas: function(canvasEl, cropping) {
            var croppedCanvasEl, croppedCtx, shouldCrop = 'left' in cropping || 'top' in cropping || 'width' in cropping || 'height' in cropping;
            if (shouldCrop) {
                croppedCanvasEl = fabric.util.createCanvasElement();
                croppedCtx = croppedCanvasEl.getContext('2d');
                croppedCanvasEl.width = cropping.width || this.width;
                croppedCanvasEl.height = cropping.height || this.height;
                croppedCtx.drawImage(canvasEl, -cropping.left || 0, -cropping.top || 0);
            }
            return croppedCanvasEl;
        },
        __toDataURLWithMultiplier: function(format, quality, cropping, multiplier) {
            var origWidth = this.getWidth(),
                origHeight = this.getHeight(),
                scaledWidth = origWidth * multiplier,
                scaledHeight = origHeight * multiplier,
                activeObject = this.getActiveObject(),
                activeGroup = this.getActiveGroup(),
                ctx = this.contextTop || this.contextContainer;
            if (multiplier > 1) {
                this.setWidth(scaledWidth).setHeight(scaledHeight);
            }
            ctx.scale(multiplier, multiplier);
            if (cropping.left) {
                cropping.left *= multiplier;
            }
            if (cropping.top) {
                cropping.top *= multiplier;
            }
            if (cropping.width) {
                cropping.width *= multiplier;
            } else if (multiplier < 1) {
                cropping.width = scaledWidth;
            }
            if (cropping.height) {
                cropping.height *= multiplier;
            } else if (multiplier < 1) {
                cropping.height = scaledHeight;
            }
            if (activeGroup) {
                this._tempRemoveBordersControlsFromGroup(activeGroup);
            } else if (activeObject && this.deactivateAll) {
                this.deactivateAll();
            }
            this.renderAll(true);
            var data = this.__toDataURL(format, quality, cropping);
            this.width = origWidth;
            this.height = origHeight;
            ctx.scale(1 / multiplier, 1 / multiplier);
            this.setWidth(origWidth).setHeight(origHeight);
            if (activeGroup) {
                this._restoreBordersControlsOnGroup(activeGroup);
            } else if (activeObject && this.setActiveObject) {
                this.setActiveObject(activeObject);
            }
            this.contextTop && this.clearContext(this.contextTop);
            this.renderAll();
            return data;
        },
        toDataURLWithMultiplier: function(format, multiplier, quality) {
            return this.toDataURL({
                format: format,
                multiplier: multiplier,
                quality: quality
            });
        },
        _tempRemoveBordersControlsFromGroup: function(group) {
            group.origHasControls = group.hasControls;
            group.origBorderColor = group.borderColor;
            group.hasControls = true;
            group.borderColor = 'rgba(0,0,0,0)';
            group.forEachObject(function(o) {
                o.origBorderColor = o.borderColor;
                o.borderColor = 'rgba(0,0,0,0)';
            });
        },
        _restoreBordersControlsOnGroup: function(group) {
            group.hideControls = group.origHideControls;
            group.borderColor = group.origBorderColor;
            group.forEachObject(function(o) {
                o.borderColor = o.origBorderColor;
                delete o.origBorderColor;
            });
        }
    });
    fabric.util.object.extend(fabric.StaticCanvas.prototype, {
        loadFromDatalessJSON: function(json, callback, reviver) {
            return this.loadFromJSON(json, callback, reviver);
        },
        loadFromJSON: function(json, callback, reviver) {
            if (!json) {
                return;
            }
            var serialized = (typeof json === 'string') ? JSON.parse(json) : json;
            this.clear();
            var _this = this;
            this._enlivenObjects(serialized.objects, function() {
                _this._setBgOverlay(serialized, callback);
            }, reviver);
            return this;
        },
        _setBgOverlay: function(serialized, callback) {
            var _this = this,
                loaded = {
                    backgroundColor: false,
                    overlayColor: false,
                    backgroundImage: false,
                    overlayImage: false
                };
            if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
                callback && callback();
                return;
            }
            var cbIfLoaded = function() {
                if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
                    _this.renderAll();
                    callback && callback();
                }
            };
            this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
            this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
            this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
            this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
            cbIfLoaded();
        },
        __setBgOverlay: function(property, value, loaded, callback) {
            var _this = this;
            if (!value) {
                loaded[property] = true;
                return;
            }
            if (property === 'backgroundImage' || property === 'overlayImage') {
                fabric.Image.fromObject(value, function(img) {
                    _this[property] = img;
                    loaded[property] = true;
                    callback && callback();
                });
            } else {
                this['set' + fabric.util.string.capitalize(property, true)](value, function() {
                    loaded[property] = true;
                    callback && callback();
                });
            }
        },
        _enlivenObjects: function(objects, callback, reviver) {
            var _this = this;
            if (!objects || objects.length === 0) {
                callback && callback();
                return;
            }
            var renderOnAddRemove = this.renderOnAddRemove;
            this.renderOnAddRemove = false;
            fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
                enlivenedObjects.forEach(function(obj, index) {
                    _this.insertAt(obj, index, true);
                });
                _this.renderOnAddRemove = renderOnAddRemove;
                callback && callback();
            }, null, reviver);
        },
        _toDataURL: function(format, callback) {
            this.clone(function(clone) {
                callback(clone.toDataURL(format));
            });
        },
        _toDataURLWithMultiplier: function(format, multiplier, callback) {
            this.clone(function(clone) {
                callback(clone.toDataURLWithMultiplier(format, multiplier));
            });
        },
        clone: function(callback, properties) {
            var data = JSON.stringify(this.toJSON(properties));
            this.cloneWithoutData(function(clone) {
                clone.loadFromJSON(data, function() {
                    callback && callback(clone);
                });
            });
        },
        cloneWithoutData: function(callback) {
            var el = fabric.document.createElement('canvas');
            el.width = this.getWidth();
            el.height = this.getHeight();
            var clone = new fabric.Canvas(el);
            clone.clipTo = this.clipTo;
            if (this.backgroundImage) {
                clone.setBackgroundImage(this.backgroundImage.src, function() {
                    clone.renderAll();
                    callback && callback(clone);
                });
                clone.backgroundImageOpacity = this.backgroundImageOpacity;
                clone.backgroundImageStretch = this.backgroundImageStretch;
            } else {
                callback && callback(clone);
            }
        }
    });
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend,
            toFixed = fabric.util.toFixed,
            capitalize = fabric.util.string.capitalize,
            degreesToRadians = fabric.util.degreesToRadians,
            supportsLineDash = fabric.StaticCanvas.supports('setLineDash');
        if (fabric.Object) {
            return;
        }
        fabric.Object = fabric.util.createClass({
            type: 'object',
            originX: 'left',
            originY: 'top',
            top: 0,
            left: 0,
            width: 0,
            height: 0,
            scaleX: 1,
            scaleY: 1,
            flipX: false,
            flipY: false,
            opacity: 1,
            angle: 0,
            cornerSize: 12,
            transparentCorners: true,
            hoverCursor: null,
            padding: 0,
            borderColor: 'rgba(102,153,255,0.75)',
            cornerColor: 'rgba(102,153,255,0.5)',
            centeredScaling: false,
            centeredRotation: true,
            fill: 'rgb(0,0,0)',
            fillRule: 'source-over',
            backgroundColor: '',
            stroke: null,
            strokeWidth: 1,
            strokeDashArray: null,
            strokeLineCap: 'butt',
            strokeLineJoin: 'miter',
            strokeMiterLimit: 10,
            shadow: null,
            borderOpacityWhenMoving: 0.4,
            borderScaleFactor: 1,
            transformMatrix: null,
            minScaleLimit: 0.01,
            selectable: true,
            evented: true,
            visible: true,
            hasControls: true,
            hasBorders: true,
            hasRotatingPoint: true,
            rotatingPointOffset: 40,
            perPixelTargetFind: false,
            includeDefaultValues: true,
            clipTo: null,
            lockMovementX: false,
            lockMovementY: false,
            lockRotation: false,
            lockScalingX: false,
            lockScalingY: false,
            lockUniScaling: false,
            lockScalingFlip: false,
            stateProperties: ('top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' + 'stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit ' + 'angle opacity fill fillRule shadow clipTo visible backgroundColor').split(' '),
            initialize: function(options) {
                if (options) {
                    this.setOptions(options);
                }
            },
            _initGradient: function(options) {
                if (options.fill && options.fill.colorStops && !(options.fill instanceof fabric.Gradient)) {
                    this.set('fill', new fabric.Gradient(options.fill));
                }
            },
            _initPattern: function(options) {
                if (options.fill && options.fill.source && !(options.fill instanceof fabric.Pattern)) {
                    this.set('fill', new fabric.Pattern(options.fill));
                }
                if (options.stroke && options.stroke.source && !(options.stroke instanceof fabric.Pattern)) {
                    this.set('stroke', new fabric.Pattern(options.stroke));
                }
            },
            _initClipping: function(options) {
                if (!options.clipTo || typeof options.clipTo !== 'string') {
                    return;
                }
                var functionBody = fabric.util.getFunctionBody(options.clipTo);
                if (typeof functionBody !== 'undefined') {
                    this.clipTo = new Function('ctx', functionBody);
                }
            },
            setOptions: function(options) {
                for (var prop in options) {
                    this.set(prop, options[prop]);
                }
                this._initGradient(options);
                this._initPattern(options);
                this._initClipping(options);
            },
            transform: function(ctx, fromLeft) {
                if (this.group) {
                    this.group.transform(ctx, fromLeft);
                }
                ctx.globalAlpha = this.opacity;
                var center = fromLeft ? this._getLeftTopCoords() : this.getCenterPoint();
                ctx.translate(center.x, center.y);
                ctx.rotate(degreesToRadians(this.angle));
                ctx.scale(this.scaleX * (this.flipX ? -1 : 1), this.scaleY * (this.flipY ? -1 : 1));
            },
            toObject: function(propertiesToInclude) {
                var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
                    object = {
                        type: this.type,
                        originX: this.originX,
                        originY: this.originY,
                        left: toFixed(this.left, NUM_FRACTION_DIGITS),
                        top: toFixed(this.top, NUM_FRACTION_DIGITS),
                        width: toFixed(this.width, NUM_FRACTION_DIGITS),
                        height: toFixed(this.height, NUM_FRACTION_DIGITS),
                        fill: (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
                        stroke: (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
                        strokeWidth: toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
                        strokeDashArray: this.strokeDashArray,
                        strokeLineCap: this.strokeLineCap,
                        strokeLineJoin: this.strokeLineJoin,
                        strokeMiterLimit: toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
                        scaleX: toFixed(this.scaleX, NUM_FRACTION_DIGITS),
                        scaleY: toFixed(this.scaleY, NUM_FRACTION_DIGITS),
                        angle: toFixed(this.getAngle(), NUM_FRACTION_DIGITS),
                        flipX: this.flipX,
                        flipY: this.flipY,
                        opacity: toFixed(this.opacity, NUM_FRACTION_DIGITS),
                        shadow: (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
                        visible: this.visible,
                        clipTo: this.clipTo && String(this.clipTo),
                        backgroundColor: this.backgroundColor
                    };
                if (!this.includeDefaultValues) {
                    object = this._removeDefaultValues(object);
                }
                fabric.util.populateWithProperties(this, object, propertiesToInclude);
                return object;
            },
            toDatalessObject: function(propertiesToInclude) {
                return this.toObject(propertiesToInclude);
            },
            _removeDefaultValues: function(object) {
                var prototype = fabric.util.getKlass(object.type).prototype,
                    stateProperties = prototype.stateProperties;
                stateProperties.forEach(function(prop) {
                    if (object[prop] === prototype[prop]) {
                        delete object[prop];
                    }
                });
                return object;
            },
            toString: function() {
                return '#<fabric.' + capitalize(this.type) + '>';
            },
            get: function(property) {
                return this[property];
            },
            _setObject: function(obj) {
                for (var prop in obj) {
                    this._set(prop, obj[prop]);
                }
            },
            set: function(key, value) {
                if (typeof key === 'object') {
                    this._setObject(key);
                } else {
                    if (typeof value === 'function' && key !== 'clipTo') {
                        this._set(key, value(this.get(key)));
                    } else {
                        this._set(key, value);
                    }
                }
                return this;
            },
            _set: function(key, value) {
                var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY');
                if (shouldConstrainValue) {
                    value = this._constrainScale(value);
                }
                if (key === 'scaleX' && value < 0) {
                    this.flipX = !this.flipX;
                    value *= -1;
                } else if (key === 'scaleY' && value < 0) {
                    this.flipY = !this.flipY;
                    value *= -1;
                } else if (key === 'width' || key === 'height') {
                    this.minScaleLimit = toFixed(Math.min(0.1, 1 / Math.max(this.width, this.height)), 2);
                } else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
                    value = new fabric.Shadow(value);
                }
                this[key] = value;
                return this;
            },
            toggle: function(property) {
                var value = this.get(property);
                if (typeof value === 'boolean') {
                    this.set(property, !value);
                }
                return this;
            },
            setSourcePath: function(value) {
                this.sourcePath = value;
                return this;
            },
            getViewportTransform: function() {
                if (this.canvas && this.canvas.viewportTransform) {
                    return this.canvas.viewportTransform;
                }
                return [1, 0, 0, 1, 0, 0];
            },
            render: function(ctx, noTransform) {
                if (this.width === 0 || this.height === 0 || !this.visible) {
                    return;
                }
                ctx.save();
                this._setupFillRule(ctx);
                this._transform(ctx, noTransform);
                this._setStrokeStyles(ctx);
                this._setFillStyles(ctx);
                if (this.group && this.group.type === 'path-group') {
                    ctx.translate(-this.group.width / 2, -this.group.height / 2);
                    var m = this.transformMatrix;
                    if (m) {
                        ctx.transform.apply(ctx, m);
                    }
                }
                ctx.globalAlpha = this.group ? (ctx.globalAlpha * this.opacity) : this.opacity;
                this._setShadow(ctx);
                this.clipTo && fabric.util.clipContext(this, ctx);
                this._render(ctx, noTransform);
                this.clipTo && ctx.restore();
                this._removeShadow(ctx);
                this._restoreFillRule(ctx);
                ctx.restore();
            },
            _transform: function(ctx, noTransform) {
                var m = this.transformMatrix;
                if (m && !this.group) {
                    ctx.setTransform.apply(ctx, m);
                }
                if (!noTransform) {
                    this.transform(ctx);
                }
            },
            _setStrokeStyles: function(ctx) {
                if (this.stroke) {
                    ctx.lineWidth = this.strokeWidth;
                    ctx.lineCap = this.strokeLineCap;
                    ctx.lineJoin = this.strokeLineJoin;
                    ctx.miterLimit = this.strokeMiterLimit;
                    ctx.strokeStyle = this.stroke.toLive ? this.stroke.toLive(ctx) : this.stroke;
                }
            },
            _setFillStyles: function(ctx) {
                if (this.fill) {
                    ctx.fillStyle = this.fill.toLive ? this.fill.toLive(ctx) : this.fill;
                }
            },
            _renderControls: function(ctx, noTransform) {
                var vpt = this.getViewportTransform();
                ctx.save();
                if (this.active && !noTransform) {
                    var center;
                    if (this.group) {
                        center = fabric.util.transformPoint(this.group.getCenterPoint(), vpt);
                        ctx.translate(center.x, center.y);
                        ctx.rotate(degreesToRadians(this.group.angle));
                    }
                    center = fabric.util.transformPoint(this.getCenterPoint(), vpt, null != this.group);
                    if (this.group) {
                        center.x *= this.group.scaleX;
                        center.y *= this.group.scaleY;
                    }
                    ctx.translate(center.x, center.y);
                    ctx.rotate(degreesToRadians(this.angle));
                    this.drawBorders(ctx);
                    this.drawControls(ctx);
                }
                ctx.restore();
            },
            _setShadow: function(ctx) {
                if (!this.shadow) {
                    return;
                }
                ctx.shadowColor = this.shadow.color;
                ctx.shadowBlur = this.shadow.blur;
                ctx.shadowOffsetX = this.shadow.offsetX;
                ctx.shadowOffsetY = this.shadow.offsetY;
            },
            _removeShadow: function(ctx) {
                if (!this.shadow) {
                    return;
                }
                ctx.shadowColor = '';
                ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
            },
            _renderFill: function(ctx) {
                if (!this.fill) {
                    return;
                }
                ctx.save();
                if (this.fill.toLive) {
                    ctx.translate(-this.width / 2 + this.fill.offsetX || 0, -this.height / 2 + this.fill.offsetY || 0);
                }
                if (this.fill.gradientTransform) {
                    var g = this.fill.gradientTransform;
                    ctx.transform.apply(ctx, g);
                }
                if (this.fillRule === 'destination-over') {
                    ctx.fill('evenodd');
                } else {
                    ctx.fill();
                }
                ctx.restore();
                if (this.shadow && !this.shadow.affectStroke) {
                    this._removeShadow(ctx);
                }
            },
            _renderStroke: function(ctx) {
                if (!this.stroke || this.strokeWidth === 0) {
                    return;
                }
                ctx.save();
                if (this.strokeDashArray) {
                    if (1 & this.strokeDashArray.length) {
                        this.strokeDashArray.push.apply(this.strokeDashArray, this.strokeDashArray);
                    }
                    if (supportsLineDash) {
                        ctx.setLineDash(this.strokeDashArray);
                        this._stroke && this._stroke(ctx);
                    } else {
                        this._renderDashedStroke && this._renderDashedStroke(ctx);
                    }
                    ctx.stroke();
                } else {
                    if (this.stroke.gradientTransform) {
                        var g = this.stroke.gradientTransform;
                        ctx.transform.apply(ctx, g);
                    }
                    this._stroke ? this._stroke(ctx) : ctx.stroke();
                }
                this._removeShadow(ctx);
                ctx.restore();
            },
            clone: function(callback, propertiesToInclude) {
                if (this.constructor.fromObject) {
                    return this.constructor.fromObject(this.toObject(propertiesToInclude), callback);
                }
                return new fabric.Object(this.toObject(propertiesToInclude));
            },
            cloneAsImage: function(callback) {
                var dataUrl = this.toDataURL();
                fabric.util.loadImage(dataUrl, function(img) {
                    if (callback) {
                        callback(new fabric.Image(img));
                    }
                });
                return this;
            },
            toDataURL: function(options) {
                options || (options = {});
                var el = fabric.util.createCanvasElement(),
                    boundingRect = this.getBoundingRect();
                el.width = boundingRect.width;
                el.height = boundingRect.height;
                fabric.util.wrapElement(el, 'div');
                var canvas = new fabric.Canvas(el);
                if (options.format === 'jpg') {
                    options.format = 'jpeg';
                }
                if (options.format === 'jpeg') {
                    canvas.backgroundColor = '#fff';
                }
                var origParams = {
                    active: this.get('active'),
                    left: this.getLeft(),
                    top: this.getTop()
                };
                this.set('active', false);
                this.setPositionByOrigin(new fabric.Point(el.width / 2, el.height / 2), 'center', 'center');
                var originalCanvas = this.canvas;
                canvas.add(this);
                var data = canvas.toDataURL(options);
                this.set(origParams).setCoords();
                this.canvas = originalCanvas;
                canvas.dispose();
                canvas = null;
                return data;
            },
            isType: function(type) {
                return this.type === type;
            },
            complexity: function() {
                return 0;
            },
            toJSON: function(propertiesToInclude) {
                return this.toObject(propertiesToInclude);
            },
            setGradient: function(property, options) {
                options || (options = {});
                var gradient = {
                    colorStops: []
                };
                gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');
                gradient.coords = {
                    x1: options.x1,
                    y1: options.y1,
                    x2: options.x2,
                    y2: options.y2
                };
                if (options.r1 || options.r2) {
                    gradient.coords.r1 = options.r1;
                    gradient.coords.r2 = options.r2;
                }
                for (var position in options.colorStops) {
                    var color = new fabric.Color(options.colorStops[position]);
                    gradient.colorStops.push({
                        offset: position,
                        color: color.toRgb(),
                        opacity: color.getAlpha()
                    });
                }
                return this.set(property, fabric.Gradient.forObject(this, gradient));
            },
            setPatternFill: function(options) {
                return this.set('fill', new fabric.Pattern(options));
            },
            setShadow: function(options) {
                return this.set('shadow', options ? new fabric.Shadow(options) : null);
            },
            setColor: function(color) {
                this.set('fill', color);
                return this;
            },
            setAngle: function(angle) {
                var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;
                if (shouldCenterOrigin) {
                    this._setOriginToCenter();
                }
                this.set('angle', angle);
                if (shouldCenterOrigin) {
                    this._resetOrigin();
                }
                return this;
            },
            centerH: function() {
                this.canvas.centerObjectH(this);
                return this;
            },
            centerV: function() {
                this.canvas.centerObjectV(this);
                return this;
            },
            center: function() {
                this.canvas.centerObject(this);
                return this;
            },
            remove: function() {
                this.canvas.remove(this);
                return this;
            },
            getLocalPointer: function(e, pointer) {
                pointer = pointer || this.canvas.getPointer(e);
                var objectLeftTop = this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
                return {
                    x: pointer.x - objectLeftTop.x,
                    y: pointer.y - objectLeftTop.y
                };
            },
            _setupFillRule: function(ctx) {
                if (this.fillRule) {
                    this._prevFillRule = ctx.globalCompositeOperation;
                    ctx.globalCompositeOperation = this.fillRule;
                }
            },
            _restoreFillRule: function(ctx) {
                if (this.fillRule && this._prevFillRule) {
                    ctx.globalCompositeOperation = this._prevFillRule;
                }
            }
        });
        fabric.util.createAccessors(fabric.Object);
        fabric.Object.prototype.rotate = fabric.Object.prototype.setAngle;
        extend(fabric.Object.prototype, fabric.Observable);
        fabric.Object.NUM_FRACTION_DIGITS = 2;
        fabric.Object.__uid = 0;
    })(typeof exports !== 'undefined' ? exports : this);
    (function() {
        var degreesToRadians = fabric.util.degreesToRadians;
        fabric.util.object.extend(fabric.Object.prototype, {
            translateToCenterPoint: function(point, originX, originY) {
                var cx = point.x,
                    cy = point.y,
                    strokeWidth = this.stroke ? this.strokeWidth : 0;
                if (originX === 'left') {
                    cx = point.x + (this.getWidth() + strokeWidth * this.scaleX) / 2;
                } else if (originX === 'right') {
                    cx = point.x - (this.getWidth() + strokeWidth * this.scaleX) / 2;
                }
                if (originY === 'top') {
                    cy = point.y + (this.getHeight() + strokeWidth * this.scaleY) / 2;
                } else if (originY === 'bottom') {
                    cy = point.y - (this.getHeight() + strokeWidth * this.scaleY) / 2;
                }
                return fabric.util.rotatePoint(new fabric.Point(cx, cy), point, degreesToRadians(this.angle));
            },
            translateToOriginPoint: function(center, originX, originY) {
                var x = center.x,
                    y = center.y,
                    strokeWidth = this.stroke ? this.strokeWidth : 0;
                if (originX === 'left') {
                    x = center.x - (this.getWidth() + strokeWidth * this.scaleX) / 2;
                } else if (originX === 'right') {
                    x = center.x + (this.getWidth() + strokeWidth * this.scaleX) / 2;
                }
                if (originY === 'top') {
                    y = center.y - (this.getHeight() + strokeWidth * this.scaleY) / 2;
                } else if (originY === 'bottom') {
                    y = center.y + (this.getHeight() + strokeWidth * this.scaleY) / 2;
                }
                return fabric.util.rotatePoint(new fabric.Point(x, y), center, degreesToRadians(this.angle));
            },
            getCenterPoint: function() {
                var leftTop = new fabric.Point(this.left, this.top);
                return this.translateToCenterPoint(leftTop, this.originX, this.originY);
            },
            getPointByOrigin: function(originX, originY) {
                var center = this.getCenterPoint();
                return this.translateToOriginPoint(center, originX, originY);
            },
            toLocalPoint: function(point, originX, originY) {
                var center = this.getCenterPoint(),
                    strokeWidth = this.stroke ? this.strokeWidth : 0,
                    x, y;
                if (originX && originY) {
                    if (originX === 'left') {
                        x = center.x - (this.getWidth() + strokeWidth * this.scaleX) / 2;
                    } else if (originX === 'right') {
                        x = center.x + (this.getWidth() + strokeWidth * this.scaleX) / 2;
                    } else {
                        x = center.x;
                    }
                    if (originY === 'top') {
                        y = center.y - (this.getHeight() + strokeWidth * this.scaleY) / 2;
                    } else if (originY === 'bottom') {
                        y = center.y + (this.getHeight() + strokeWidth * this.scaleY) / 2;
                    } else {
                        y = center.y;
                    }
                } else {
                    x = this.left;
                    y = this.top;
                }
                return fabric.util.rotatePoint(new fabric.Point(point.x, point.y), center, -degreesToRadians(this.angle)).subtractEquals(new fabric.Point(x, y));
            },
            setPositionByOrigin: function(pos, originX, originY) {
                var center = this.translateToCenterPoint(pos, originX, originY),
                    position = this.translateToOriginPoint(center, this.originX, this.originY);
                this.set('left', position.x);
                this.set('top', position.y);
            },
            adjustPosition: function(to) {
                var angle = degreesToRadians(this.angle),
                    hypotHalf = this.getWidth() / 2,
                    xHalf = Math.cos(angle) * hypotHalf,
                    yHalf = Math.sin(angle) * hypotHalf,
                    hypotFull = this.getWidth(),
                    xFull = Math.cos(angle) * hypotFull,
                    yFull = Math.sin(angle) * hypotFull;
                if (this.originX === 'center' && to === 'left' || this.originX === 'right' && to === 'center') {
                    this.left -= xHalf;
                    this.top -= yHalf;
                } else if (this.originX === 'left' && to === 'center' || this.originX === 'center' && to === 'right') {
                    this.left += xHalf;
                    this.top += yHalf;
                } else if (this.originX === 'left' && to === 'right') {
                    this.left += xFull;
                    this.top += yFull;
                } else if (this.originX === 'right' && to === 'left') {
                    this.left -= xFull;
                    this.top -= yFull;
                }
                this.setCoords();
                this.originX = to;
            },
            _setOriginToCenter: function() {
                this._originalOriginX = this.originX;
                this._originalOriginY = this.originY;
                var center = this.getCenterPoint();
                this.originX = 'center';
                this.originY = 'center';
                this.left = center.x;
                this.top = center.y;
            },
            _resetOrigin: function() {
                var originPoint = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY);
                this.originX = this._originalOriginX;
                this.originY = this._originalOriginY;
                this.left = originPoint.x;
                this.top = originPoint.y;
                this._originalOriginX = null;
                this._originalOriginY = null;
            },
            _getLeftTopCoords: function() {
                return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'center');
            }
        });
    })();
    (function() {
        var degreesToRadians = fabric.util.degreesToRadians;
        fabric.util.object.extend(fabric.Object.prototype, {
            oCoords: null,
            intersectsWithRect: function(pointTL, pointBR) {
                var oCoords = this.oCoords,
                    tl = new fabric.Point(oCoords.tl.x, oCoords.tl.y),
                    tr = new fabric.Point(oCoords.tr.x, oCoords.tr.y),
                    bl = new fabric.Point(oCoords.bl.x, oCoords.bl.y),
                    br = new fabric.Point(oCoords.br.x, oCoords.br.y),
                    intersection = fabric.Intersection.intersectPolygonRectangle([tl, tr, br, bl], pointTL, pointBR);
                return intersection.status === 'Intersection';
            },
            intersectsWithObject: function(other) {
                function getCoords(oCoords) {
                    return {
                        tl: new fabric.Point(oCoords.tl.x, oCoords.tl.y),
                        tr: new fabric.Point(oCoords.tr.x, oCoords.tr.y),
                        bl: new fabric.Point(oCoords.bl.x, oCoords.bl.y),
                        br: new fabric.Point(oCoords.br.x, oCoords.br.y)
                    };
                }
                var thisCoords = getCoords(this.oCoords),
                    otherCoords = getCoords(other.oCoords),
                    intersection = fabric.Intersection.intersectPolygonPolygon([thisCoords.tl, thisCoords.tr, thisCoords.br, thisCoords.bl], [otherCoords.tl, otherCoords.tr, otherCoords.br, otherCoords.bl]);
                return intersection.status === 'Intersection';
            },
            isContainedWithinObject: function(other) {
                var boundingRect = other.getBoundingRect(),
                    point1 = new fabric.Point(boundingRect.left, boundingRect.top),
                    point2 = new fabric.Point(boundingRect.left + boundingRect.width, boundingRect.top + boundingRect.height);
                return this.isContainedWithinRect(point1, point2);
            },
            isContainedWithinRect: function(pointTL, pointBR) {
                var boundingRect = this.getBoundingRect();
                return (boundingRect.left >= pointTL.x && boundingRect.left + boundingRect.width <= pointBR.x && boundingRect.top >= pointTL.y && boundingRect.top + boundingRect.height <= pointBR.y);
            },
            containsPoint: function(point) {
                var lines = this._getImageLines(this.oCoords),
                    xPoints = this._findCrossPoints(point, lines);
                return (xPoints !== 0 && xPoints % 2 === 1);
            },
            _getImageLines: function(oCoords) {
                return {
                    topline: {
                        o: oCoords.tl,
                        d: oCoords.tr
                    },
                    rightline: {
                        o: oCoords.tr,
                        d: oCoords.br
                    },
                    bottomline: {
                        o: oCoords.br,
                        d: oCoords.bl
                    },
                    leftline: {
                        o: oCoords.bl,
                        d: oCoords.tl
                    }
                };
            },
            _findCrossPoints: function(point, oCoords) {
                var b1, b2, a1, a2, xi, yi, xcount = 0,
                    iLine;
                for (var lineKey in oCoords) {
                    iLine = oCoords[lineKey];
                    if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
                        continue;
                    }
                    if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
                        continue;
                    }
                    if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
                        xi = iLine.o.x;
                        yi = point.y;
                    } else {
                        b1 = 0;
                        b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
                        a1 = point.y - b1 * point.x;
                        a2 = iLine.o.y - b2 * iLine.o.x;
                        xi = -(a1 - a2) / (b1 - b2);
                        yi = a1 + b1 * xi;
                    }
                    if (xi >= point.x) {
                        xcount += 1;
                    }
                    if (xcount === 2) {
                        break;
                    }
                }
                return xcount;
            },
            getBoundingRectWidth: function() {
                return this.getBoundingRect().width;
            },
            getBoundingRectHeight: function() {
                return this.getBoundingRect().height;
            },
            getBoundingRect: function() {
                this.oCoords || this.setCoords();
                var xCoords = [this.oCoords.tl.x, this.oCoords.tr.x, this.oCoords.br.x, this.oCoords.bl.x],
                    minX = fabric.util.array.min(xCoords),
                    maxX = fabric.util.array.max(xCoords),
                    width = Math.abs(minX - maxX),
                    yCoords = [this.oCoords.tl.y, this.oCoords.tr.y, this.oCoords.br.y, this.oCoords.bl.y],
                    minY = fabric.util.array.min(yCoords),
                    maxY = fabric.util.array.max(yCoords),
                    height = Math.abs(minY - maxY);
                return {
                    left: minX,
                    top: minY,
                    width: width,
                    height: height
                };
            },
            getWidth: function() {
                return this.width * this.scaleX;
            },
            getHeight: function() {
                return this.height * this.scaleY;
            },
            _constrainScale: function(value) {
                if (Math.abs(value) < this.minScaleLimit) {
                    if (value < 0) {
                        return -this.minScaleLimit;
                    } else {
                        return this.minScaleLimit;
                    }
                }
                return value;
            },
            scale: function(value) {
                value = this._constrainScale(value);
                if (value < 0) {
                    this.flipX = !this.flipX;
                    this.flipY = !this.flipY;
                    value *= -1;
                }
                this.scaleX = value;
                this.scaleY = value;
                this.setCoords();
                return this;
            },
            scaleToWidth: function(value) {
                var boundingRectFactor = this.getBoundingRectWidth() / this.getWidth();
                return this.scale(value / this.width / boundingRectFactor);
            },
            scaleToHeight: function(value) {
                var boundingRectFactor = this.getBoundingRectHeight() / this.getHeight();
                return this.scale(value / this.height / boundingRectFactor);
            },
            setCoords: function() {
                var strokeWidth = this.strokeWidth > 1 ? this.strokeWidth : 0,
                    theta = degreesToRadians(this.angle),
                    vpt = this.getViewportTransform(),
                    f = function(p) {
                        return fabric.util.transformPoint(p, vpt);
                    },
                    w = this.width,
                    h = this.height,
                    capped = this.strokeLineCap === 'round' || this.strokeLineCap === 'square',
                    vLine = this.type === 'line' && this.width === 1,
                    hLine = this.type === 'line' && this.height === 1,
                    strokeW = (capped && hLine) || this.type !== 'line',
                    strokeH = (capped && vLine) || this.type !== 'line';
                if (vLine) {
                    w = strokeWidth;
                } else if (hLine) {
                    h = strokeWidth;
                }
                if (strokeW) {
                    w += strokeWidth;
                }
                if (strokeH) {
                    h += strokeWidth;
                }
                this.currentWidth = w * this.scaleX;
                this.currentHeight = h * this.scaleY;
                if (this.currentWidth < 0) {
                    this.currentWidth = Math.abs(this.currentWidth);
                }
                var _hypotenuse = Math.sqrt(Math.pow(this.currentWidth / 2, 2) +
                        Math.pow(this.currentHeight / 2, 2)),
                    _angle = Math.atan(isFinite(this.currentHeight / this.currentWidth) ? this.currentHeight / this.currentWidth : 0),
                    offsetX = Math.cos(_angle + theta) * _hypotenuse,
                    offsetY = Math.sin(_angle + theta) * _hypotenuse,
                    sinTh = Math.sin(theta),
                    cosTh = Math.cos(theta),
                    coords = this.getCenterPoint(),
                    wh = new fabric.Point(this.currentWidth, this.currentHeight),
                    _tl = new fabric.Point(coords.x - offsetX, coords.y - offsetY),
                    _tr = new fabric.Point(_tl.x + (wh.x * cosTh), _tl.y + (wh.x * sinTh)),
                    _bl = new fabric.Point(_tl.x - (wh.y * sinTh), _tl.y + (wh.y * cosTh)),
                    _mt = new fabric.Point(_tl.x + (wh.x / 2 * cosTh), _tl.y + (wh.x / 2 * sinTh)),
                    tl = f(_tl),
                    tr = f(_tr),
                    br = f(new fabric.Point(_tr.x - (wh.y * sinTh), _tr.y + (wh.y * cosTh))),
                    bl = f(_bl),
                    ml = f(new fabric.Point(_tl.x - (wh.y / 2 * sinTh), _tl.y + (wh.y / 2 * cosTh))),
                    mt = f(_mt),
                    mr = f(new fabric.Point(_tr.x - (wh.y / 2 * sinTh), _tr.y + (wh.y / 2 * cosTh))),
                    mb = f(new fabric.Point(_bl.x + (wh.x / 2 * cosTh), _bl.y + (wh.x / 2 * sinTh))),
                    mtr = f(new fabric.Point(_mt.x, _mt.y)),
                    padX = Math.cos(_angle + theta) * this.padding * Math.sqrt(2),
                    padY = Math.sin(_angle + theta) * this.padding * Math.sqrt(2);
                tl = tl.add(new fabric.Point(-padX, -padY));
                tr = tr.add(new fabric.Point(padY, -padX));
                br = br.add(new fabric.Point(padX, padY));
                bl = bl.add(new fabric.Point(-padY, padX));
                ml = ml.add(new fabric.Point((-padX - padY) / 2, (-padY + padX) / 2));
                mt = mt.add(new fabric.Point((padY - padX) / 2, -(padY + padX) / 2));
                mr = mr.add(new fabric.Point((padY + padX) / 2, (padY - padX) / 2));
                mb = mb.add(new fabric.Point((padX - padY) / 2, (padX + padY) / 2));
                mtr = mtr.add(new fabric.Point((padY - padX) / 2, -(padY + padX) / 2));
                this.oCoords = {
                    tl: tl,
                    tr: tr,
                    br: br,
                    bl: bl,
                    ml: ml,
                    mt: mt,
                    mr: mr,
                    mb: mb,
                    mtr: mtr
                };
                this._setCornerCoords && this._setCornerCoords();
                return this;
            }
        });
    })();
    fabric.util.object.extend(fabric.Object.prototype, {
        sendToBack: function() {
            if (this.group) {
                fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
            } else {
                this.canvas.sendToBack(this);
            }
            return this;
        },
        bringToFront: function() {
            if (this.group) {
                fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
            } else {
                this.canvas.bringToFront(this);
            }
            return this;
        },
        sendBackwards: function(intersecting) {
            if (this.group) {
                fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
            } else {
                this.canvas.sendBackwards(this, intersecting);
            }
            return this;
        },
        bringForward: function(intersecting) {
            if (this.group) {
                fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
            } else {
                this.canvas.bringForward(this, intersecting);
            }
            return this;
        },
        moveTo: function(index) {
            if (this.group) {
                fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
            } else {
                this.canvas.moveTo(this, index);
            }
            return this;
        }
    });
    fabric.util.object.extend(fabric.Object.prototype, {
        getSvgStyles: function() {
            var fill = this.fill ? (this.fill.toLive ? 'url(#SVGID_' + this.fill.id + ')' : this.fill) : 'none',
                fillRule = (this.fillRule === 'destination-over' ? 'evenodd' : this.fillRule),
                stroke = this.stroke ? (this.stroke.toLive ? 'url(#SVGID_' + this.stroke.id + ')' : this.stroke) : 'none',
                strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
                strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : '',
                strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
                strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
                strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
                opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
                visibility = this.visible ? '' : ' visibility: hidden;',
                filter = this.shadow && this.type !== 'text' ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
            return ['stroke: ', stroke, '; ', 'stroke-width: ', strokeWidth, '; ', 'stroke-dasharray: ', strokeDashArray, '; ', 'stroke-linecap: ', strokeLineCap, '; ', 'stroke-linejoin: ', strokeLineJoin, '; ', 'stroke-miterlimit: ', strokeMiterLimit, '; ', 'fill: ', fill, '; ', 'fill-rule: ', fillRule, '; ', 'opacity: ', opacity, ';', filter, visibility].join('');
        },
        getSvgTransform: function() {
            if (this.group) {
                return '';
            }
            var toFixed = fabric.util.toFixed,
                angle = this.getAngle(),
                vpt = !this.canvas || this.canvas.svgViewportTransformation ? this.getViewportTransform() : [1, 0, 0, 1, 0, 0],
                center = fabric.util.transformPoint(this.getCenterPoint(), vpt),
                NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
                translatePart = this.type === 'path-group' ? '' : 'translate(' +
                toFixed(center.x, NUM_FRACTION_DIGITS) + ' ' +
                toFixed(center.y, NUM_FRACTION_DIGITS) + ')',
                anglePart = angle !== 0 ? (' rotate(' + toFixed(angle, NUM_FRACTION_DIGITS) + ')') : '',
                scalePart = (this.scaleX === 1 && this.scaleY === 1 && vpt[0] === 1 && vpt[3] === 1) ? '' : (' scale(' +
                    toFixed(this.scaleX * vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                    toFixed(this.scaleY * vpt[3], NUM_FRACTION_DIGITS) + ')'),
                addTranslateX = this.type === 'path-group' ? this.width * vpt[0] : 0,
                flipXPart = this.flipX ? ' matrix(-1 0 0 1 ' + addTranslateX + ' 0) ' : '',
                addTranslateY = this.type === 'path-group' ? this.height * vpt[3] : 0,
                flipYPart = this.flipY ? ' matrix(1 0 0 -1 0 ' + addTranslateY + ')' : '';
            return [translatePart, anglePart, scalePart, flipXPart, flipYPart].join('');
        },
        getSvgTransformMatrix: function() {
            return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ')' : '';
        },
        _createBaseSVGMarkup: function() {
            var markup = [];
            if (this.fill && this.fill.toLive) {
                markup.push(this.fill.toSVG(this, false));
            }
            if (this.stroke && this.stroke.toLive) {
                markup.push(this.stroke.toSVG(this, false));
            }
            if (this.shadow) {
                markup.push(this.shadow.toSVG(this));
            }
            return markup;
        }
    });
    fabric.util.object.extend(fabric.Object.prototype, {
        hasStateChanged: function() {
            return this.stateProperties.some(function(prop) {
                return this.get(prop) !== this.originalState[prop];
            }, this);
        },
        saveState: function(options) {
            this.stateProperties.forEach(function(prop) {
                this.originalState[prop] = this.get(prop);
            }, this);
            if (options && options.stateProperties) {
                options.stateProperties.forEach(function(prop) {
                    this.originalState[prop] = this.get(prop);
                }, this);
            }
            return this;
        },
        setupState: function() {
            this.originalState = {};
            this.saveState();
            return this;
        }
    });
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend,
            coordProps = {
                x1: 1,
                x2: 1,
                y1: 1,
                y2: 1
            },
            supportsLineDash = fabric.StaticCanvas.supports('setLineDash');
        if (fabric.Line) {
            fabric.warn('fabric.Line is already defined');
            return;
        }
        fabric.Line = fabric.util.createClass(fabric.Object, {
            type: 'line',
            x1: 0,
            y1: 0,
            x2: 0,
            y2: 0,
            initialize: function(points, options) {
                options = options || {};
                if (!points) {
                    points = [0, 0, 0, 0];
                }
                this.callSuper('initialize', options);
                this.set('x1', points[0]);
                this.set('y1', points[1]);
                this.set('x2', points[2]);
                this.set('y2', points[3]);
                this._setWidthHeight(options);
            },
            _setWidthHeight: function(options) {
                options || (options = {});
                this.width = Math.abs(this.x2 - this.x1) || 1;
                this.height = Math.abs(this.y2 - this.y1) || 1;
                this.left = 'left' in options ? options.left : this._getLeftToOriginX();
                this.top = 'top' in options ? options.top : this._getTopToOriginY();
            },
            _set: function(key, value) {
                this[key] = value;
                if (typeof coordProps[key] !== 'undefined') {
                    this._setWidthHeight();
                }
                return this;
            },
            _getLeftToOriginX: makeEdgeToOriginGetter({
                origin: 'originX',
                axis1: 'x1',
                axis2: 'x2',
                dimension: 'width'
            }, {
                nearest: 'left',
                center: 'center',
                farthest: 'right'
            }),
            _getTopToOriginY: makeEdgeToOriginGetter({
                origin: 'originY',
                axis1: 'y1',
                axis2: 'y2',
                dimension: 'height'
            }, {
                nearest: 'top',
                center: 'center',
                farthest: 'bottom'
            }),
            _render: function(ctx, noTransform) {
                ctx.beginPath();
                if (noTransform) {
                    var cp = this.getCenterPoint();
                    ctx.translate(cp.x, cp.y);
                }
                if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {
                    var xMult = this.x1 <= this.x2 ? -1 : 1,
                        yMult = this.y1 <= this.y2 ? -1 : 1;
                    ctx.moveTo(this.width === 1 ? 0 : (xMult * this.width / 2), this.height === 1 ? 0 : (yMult * this.height / 2));
                    ctx.lineTo(this.width === 1 ? 0 : (xMult * -1 * this.width / 2), this.height === 1 ? 0 : (yMult * -1 * this.height / 2));
                }
                ctx.lineWidth = this.strokeWidth;
                var origStrokeStyle = ctx.strokeStyle;
                ctx.strokeStyle = this.stroke || ctx.fillStyle;
                this.stroke && this._renderStroke(ctx);
                ctx.strokeStyle = origStrokeStyle;
            },
            _renderDashedStroke: function(ctx) {
                var
                    xMult = this.x1 <= this.x2 ? -1 : 1,
                    yMult = this.y1 <= this.y2 ? -1 : 1,
                    x = this.width === 1 ? 0 : xMult * this.width / 2,
                    y = this.height === 1 ? 0 : yMult * this.height / 2;
                ctx.beginPath();
                fabric.util.drawDashedLine(ctx, x, y, -x, -y, this.strokeDashArray);
                ctx.closePath();
            },
            toObject: function(propertiesToInclude) {
                return extend(this.callSuper('toObject', propertiesToInclude), {
                    x1: this.get('x1'),
                    y1: this.get('y1'),
                    x2: this.get('x2'),
                    y2: this.get('y2')
                });
            },
            toSVG: function(reviver) {
                var markup = this._createBaseSVGMarkup(),
                    addTranslate = '';
                if (!this.group) {
                    var x = -this.width / 2 - (this.x1 > this.x2 ? this.x2 : this.x1),
                        y = -this.height / 2 - (this.y1 > this.y2 ? this.y2 : this.y1);
                    addTranslate = 'translate(' + x + ', ' + y + ') ';
                }
                markup.push('<line ', 'x1="', this.x1, '" y1="', this.y1, '" x2="', this.x2, '" y2="', this.y2, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), addTranslate, this.getSvgTransformMatrix(), '"/>\n');
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            complexity: function() {
                return 1;
            }
        });
        fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));
        fabric.Line.fromElement = function(element, options) {
            var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
                points = [parsedAttributes.x1 || 0, parsedAttributes.y1 || 0, parsedAttributes.x2 || 0, parsedAttributes.y2 || 0];
            return new fabric.Line(points, extend(parsedAttributes, options));
        };
        fabric.Line.fromObject = function(object) {
            var points = [object.x1, object.y1, object.x2, object.y2];
            return new fabric.Line(points, object);
        };

        function makeEdgeToOriginGetter(propertyNames, originValues) {
            var origin = propertyNames.origin,
                axis1 = propertyNames.axis1,
                axis2 = propertyNames.axis2,
                dimension = propertyNames.dimension,
                nearest = originValues.nearest,
                center = originValues.center,
                farthest = originValues.farthest;
            return function() {
                switch (this.get(origin)) {
                    case nearest:
                        return Math.min(this.get(axis1), this.get(axis2));
                    case center:
                        return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
                    case farthest:
                        return Math.max(this.get(axis1), this.get(axis2));
                }
            };
        }
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            piBy2 = Math.PI * 2,
            extend = fabric.util.object.extend;
        if (fabric.Circle) {
            fabric.warn('fabric.Circle is already defined.');
            return;
        }
        fabric.Circle = fabric.util.createClass(fabric.Object, {
            type: 'circle',
            radius: 0,
            initialize: function(options) {
                options = options || {};
                this.callSuper('initialize', options);
                this.set('radius', options.radius || 0);
            },
            _set: function(key, value) {
                this.callSuper('_set', key, value);
                if (key === 'radius') {
                    this.setRadius(value);
                }
                return this;
            },
            toObject: function(propertiesToInclude) {
                return extend(this.callSuper('toObject', propertiesToInclude), {
                    radius: this.get('radius')
                });
            },
            toSVG: function(reviver) {
                var markup = this._createBaseSVGMarkup(),
                    x = 0,
                    y = 0;
                if (this.group) {
                    x = this.left + this.radius;
                    y = this.top + this.radius;
                }
                markup.push('<circle ', 'cx="' + x + '" cy="' + y + '" ', 'r="', this.radius, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), ' ', this.getSvgTransformMatrix(), '"/>\n');
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            _render: function(ctx, noTransform) {
                ctx.beginPath();
                ctx.arc(noTransform ? this.left + this.radius : 0, noTransform ? this.top + this.radius : 0, this.radius, 0, piBy2, false);
                this._renderFill(ctx);
                this._renderStroke(ctx);
            },
            getRadiusX: function() {
                return this.get('radius') * this.get('scaleX');
            },
            getRadiusY: function() {
                return this.get('radius') * this.get('scaleY');
            },
            setRadius: function(value) {
                this.radius = value;
                this.set('width', value * 2).set('height', value * 2);
            },
            complexity: function() {
                return 1;
            }
        });
        fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));
        fabric.Circle.fromElement = function(element, options) {
            options || (options = {});
            var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);
            if (!isValidRadius(parsedAttributes)) {
                throw new Error('value of `r` attribute is required and can not be negative');
            }
            parsedAttributes.left = parsedAttributes.left || 0;
            parsedAttributes.top = parsedAttributes.top || 0;
            var obj = new fabric.Circle(extend(parsedAttributes, options));
            obj.left -= obj.radius;
            obj.top -= obj.radius;
            return obj;
        };

        function isValidRadius(attributes) {
            return (('radius' in attributes) && (attributes.radius > 0));
        }
        fabric.Circle.fromObject = function(object) {
            return new fabric.Circle(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {});
        if (fabric.Triangle) {
            fabric.warn('fabric.Triangle is already defined');
            return;
        }
        fabric.Triangle = fabric.util.createClass(fabric.Object, {
            type: 'triangle',
            initialize: function(options) {
                options = options || {};
                this.callSuper('initialize', options);
                this.set('width', options.width || 100).set('height', options.height || 100);
            },
            _render: function(ctx) {
                var widthBy2 = this.width / 2,
                    heightBy2 = this.height / 2;
                ctx.beginPath();
                ctx.moveTo(-widthBy2, heightBy2);
                ctx.lineTo(0, -heightBy2);
                ctx.lineTo(widthBy2, heightBy2);
                ctx.closePath();
                this._renderFill(ctx);
                this._renderStroke(ctx);
            },
            _renderDashedStroke: function(ctx) {
                var widthBy2 = this.width / 2,
                    heightBy2 = this.height / 2;
                ctx.beginPath();
                fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);
                fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);
                fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);
                ctx.closePath();
            },
            toSVG: function(reviver) {
                var markup = this._createBaseSVGMarkup(),
                    widthBy2 = this.width / 2,
                    heightBy2 = this.height / 2,
                    points = [-widthBy2 + ' ' + heightBy2, '0 ' + -heightBy2, widthBy2 + ' ' + heightBy2].join(',');
                markup.push('<polygon ', 'points="', points, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), '"/>');
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            complexity: function() {
                return 1;
            }
        });
        fabric.Triangle.fromObject = function(object) {
            return new fabric.Triangle(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            piBy2 = Math.PI * 2,
            extend = fabric.util.object.extend;
        if (fabric.Ellipse) {
            fabric.warn('fabric.Ellipse is already defined.');
            return;
        }
        fabric.Ellipse = fabric.util.createClass(fabric.Object, {
            type: 'ellipse',
            rx: 0,
            ry: 0,
            initialize: function(options) {
                options = options || {};
                this.callSuper('initialize', options);
                this.set('rx', options.rx || 0);
                this.set('ry', options.ry || 0);
                this.set('width', this.get('rx') * 2);
                this.set('height', this.get('ry') * 2);
            },
            toObject: function(propertiesToInclude) {
                return extend(this.callSuper('toObject', propertiesToInclude), {
                    rx: this.get('rx'),
                    ry: this.get('ry')
                });
            },
            toSVG: function(reviver) {
                var markup = this._createBaseSVGMarkup(),
                    x = 0,
                    y = 0;
                if (this.group) {
                    x = this.left + this.rx;
                    y = this.top + this.ry;
                }
                markup.push('<ellipse ', 'cx="', x, '" cy="', y, '" ', 'rx="', this.rx, '" ry="', this.ry, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"/>\n');
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            _render: function(ctx, noTransform) {
                ctx.beginPath();
                ctx.save();
                ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
                ctx.arc(noTransform ? this.left + this.rx : 0, noTransform ? (this.top + this.ry) * this.rx / this.ry : 0, this.rx, 0, piBy2, false);
                ctx.restore();
                this._renderFill(ctx);
                this._renderStroke(ctx);
            },
            complexity: function() {
                return 1;
            }
        });
        fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));
        fabric.Ellipse.fromElement = function(element, options) {
            options || (options = {});
            var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);
            parsedAttributes.left = parsedAttributes.left || 0;
            parsedAttributes.top = parsedAttributes.top || 0;
            var ellipse = new fabric.Ellipse(extend(parsedAttributes, options));
            ellipse.top -= ellipse.ry;
            ellipse.left -= ellipse.rx;
            return ellipse;
        };
        fabric.Ellipse.fromObject = function(object) {
            return new fabric.Ellipse(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend;
        if (fabric.Rect) {
            console.warn('fabric.Rect is already defined');
            return;
        }
        var stateProperties = fabric.Object.prototype.stateProperties.concat();
        stateProperties.push('rx', 'ry', 'x', 'y');
        fabric.Rect = fabric.util.createClass(fabric.Object, {
            stateProperties: stateProperties,
            type: 'rect',
            rx: 0,
            ry: 0,
            strokeDashArray: null,
            initialize: function(options) {
                options = options || {};
                this.callSuper('initialize', options);
                this._initRxRy();
            },
            _initRxRy: function() {
                if (this.rx && !this.ry) {
                    this.ry = this.rx;
                } else if (this.ry && !this.rx) {
                    this.rx = this.ry;
                }
            },
            _render: function(ctx, noTransform) {
                if (this.width === 1 && this.height === 1) {
                    ctx.fillRect(0, 0, 1, 1);
                    return;
                }
                var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
                    ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
                    w = this.width,
                    h = this.height,
                    x = noTransform ? this.left : -this.width / 2,
                    y = noTransform ? this.top : -this.height / 2,
                    isRounded = rx !== 0 || ry !== 0,
                    k = 1 - 0.5522847498;
                ctx.beginPath();
                ctx.moveTo(x + rx, y);
                ctx.lineTo(x + w - rx, y);
                isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);
                ctx.lineTo(x + w, y + h - ry);
                isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);
                ctx.lineTo(x + rx, y + h);
                isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);
                ctx.lineTo(x, y + ry);
                isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);
                ctx.closePath();
                this._renderFill(ctx);
                this._renderStroke(ctx);
            },
            _renderDashedStroke: function(ctx) {
                var x = -this.width / 2,
                    y = -this.height / 2,
                    w = this.width,
                    h = this.height;
                ctx.beginPath();
                fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
                fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
                fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
                fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
                ctx.closePath();
            },
            toObject: function(propertiesToInclude) {
                var object = extend(this.callSuper('toObject', propertiesToInclude), {
                    rx: this.get('rx') || 0,
                    ry: this.get('ry') || 0
                });
                if (!this.includeDefaultValues) {
                    this._removeDefaultValues(object);
                }
                return object;
            },
            toSVG: function(reviver) {
                var markup = this._createBaseSVGMarkup(),
                    x = this.left,
                    y = this.top;
                if (!this.group) {
                    x = -this.width / 2;
                    y = -this.height / 2;
                }
                markup.push('<rect ', 'x="', x, '" y="', y, '" rx="', this.get('rx'), '" ry="', this.get('ry'), '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"/>\n');
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            complexity: function() {
                return 1;
            }
        });
        fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));
        fabric.Rect.fromElement = function(element, options) {
            if (!element) {
                return null;
            }
            options = options || {};
            var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);
            parsedAttributes.left = parsedAttributes.left || 0;
            parsedAttributes.top = parsedAttributes.top || 0;
            return new fabric.Rect(extend((options ? fabric.util.object.clone(options) : {}), parsedAttributes));
        };
        fabric.Rect.fromObject = function(object) {
            return new fabric.Rect(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            toFixed = fabric.util.toFixed;
        if (fabric.Polyline) {
            fabric.warn('fabric.Polyline is already defined');
            return;
        }
        fabric.Polyline = fabric.util.createClass(fabric.Object, {
            type: 'polyline',
            points: null,
            initialize: function(points, options) {
                options = options || {};
                this.set('points', points);
                this.callSuper('initialize', options);
                this._calcDimensions();
            },
            _calcDimensions: function() {
                return fabric.Polygon.prototype._calcDimensions.call(this);
            },
            _applyPointOffset: function() {
                return fabric.Polygon.prototype._applyPointOffset.call(this);
            },
            toObject: function(propertiesToInclude) {
                return fabric.Polygon.prototype.toObject.call(this, propertiesToInclude);
            },
            toSVG: function(reviver) {
                var points = [],
                    markup = this._createBaseSVGMarkup();
                for (var i = 0, len = this.points.length; i < len; i++) {
                    points.push(toFixed(this.points[i].x, 2), ',', toFixed(this.points[i].y, 2), ' ');
                }
                markup.push('<polyline ', 'points="', points.join(''), '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), ' ', this.getSvgTransformMatrix(), '"/>\n');
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            _render: function(ctx) {
                var point;
                ctx.beginPath();
                if (this._applyPointOffset) {
                    if (!(this.group && this.group.type === 'path-group')) {
                        this._applyPointOffset();
                    }
                    this._applyPointOffset = null;
                }
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (var i = 0, len = this.points.length; i < len; i++) {
                    point = this.points[i];
                    ctx.lineTo(point.x, point.y);
                }
                this._renderFill(ctx);
                this._renderStroke(ctx);
            },
            _renderDashedStroke: function(ctx) {
                var p1, p2;
                ctx.beginPath();
                for (var i = 0, len = this.points.length; i < len; i++) {
                    p1 = this.points[i];
                    p2 = this.points[i + 1] || p1;
                    fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
                }
            },
            complexity: function() {
                return this.get('points').length;
            }
        });
        fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
        fabric.Polyline.fromElement = function(element, options) {
            if (!element) {
                return null;
            }
            options || (options = {});
            var points = fabric.parsePointsAttribute(element.getAttribute('points')),
                parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);
            if (points === null) {
                return null;
            }
            return new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options));
        };
        fabric.Polyline.fromObject = function(object) {
            var points = object.points;
            return new fabric.Polyline(points, object, true);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend,
            min = fabric.util.array.min,
            max = fabric.util.array.max,
            toFixed = fabric.util.toFixed;
        if (fabric.Polygon) {
            fabric.warn('fabric.Polygon is already defined');
            return;
        }
        fabric.Polygon = fabric.util.createClass(fabric.Object, {
            type: 'polygon',
            points: null,
            initialize: function(points, options) {
                options = options || {};
                this.points = points;
                this.callSuper('initialize', options);
                this._calcDimensions();
            },
            _calcDimensions: function() {
                var points = this.points,
                    minX = min(points, 'x'),
                    minY = min(points, 'y'),
                    maxX = max(points, 'x'),
                    maxY = max(points, 'y');
                this.width = (maxX - minX) || 1;
                this.height = (maxY - minY) || 1;
                this.left = minX, this.top = minY;
            },
            _applyPointOffset: function() {
                this.points.forEach(function(p) {
                    p.x -= (this.left + this.width / 2);
                    p.y -= (this.top + this.height / 2);
                }, this);
            },
            toObject: function(propertiesToInclude) {
                return extend(this.callSuper('toObject', propertiesToInclude), {
                    points: this.points.concat()
                });
            },
            toSVG: function(reviver) {
                var points = [],
                    markup = this._createBaseSVGMarkup();
                for (var i = 0, len = this.points.length; i < len; i++) {
                    points.push(toFixed(this.points[i].x, 2), ',', toFixed(this.points[i].y, 2), ' ');
                }
                markup.push('<polygon ', 'points="', points.join(''), '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), ' ', this.getSvgTransformMatrix(), '"/>\n');
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            _render: function(ctx) {
                var point;
                ctx.beginPath();
                if (this._applyPointOffset) {
                    if (!(this.group && this.group.type === 'path-group')) {
                        this._applyPointOffset();
                    }
                    this._applyPointOffset = null;
                }
                ctx.moveTo(this.points[0].x, this.points[0].y);
                for (var i = 0, len = this.points.length; i < len; i++) {
                    point = this.points[i];
                    ctx.lineTo(point.x, point.y);
                }
                this._renderFill(ctx);
                if (this.stroke || this.strokeDashArray) {
                    ctx.closePath();
                    this._renderStroke(ctx);
                }
            },
            _renderDashedStroke: function(ctx) {
                var p1, p2;
                ctx.beginPath();
                for (var i = 0, len = this.points.length; i < len; i++) {
                    p1 = this.points[i];
                    p2 = this.points[i + 1] || this.points[0];
                    fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
                }
                ctx.closePath();
            },
            complexity: function() {
                return this.points.length;
            }
        });
        fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();
        fabric.Polygon.fromElement = function(element, options) {
            if (!element) {
                return null;
            }
            options || (options = {});
            var points = fabric.parsePointsAttribute(element.getAttribute('points')),
                parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);
            if (points === null) {
                return null;
            }
            return new fabric.Polygon(points, extend(parsedAttributes, options));
        };
        fabric.Polygon.fromObject = function(object) {
            return new fabric.Polygon(object.points, object, true);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            min = fabric.util.array.min,
            max = fabric.util.array.max,
            extend = fabric.util.object.extend,
            _toString = Object.prototype.toString,
            drawArc = fabric.util.drawArc,
            commandLengths = {
                m: 2,
                l: 2,
                h: 1,
                v: 1,
                c: 6,
                s: 4,
                q: 4,
                t: 2,
                a: 7
            },
            repeatedCommands = {
                m: 'l',
                M: 'L'
            };
        if (fabric.Path) {
            fabric.warn('fabric.Path is already defined');
            return;
        }

        function getX(item) {
            if (item[0] === 'H') {
                return item[1];
            }
            return item[item.length - 2];
        }

        function getY(item) {
            if (item[0] === 'V') {
                return item[1];
            }
            return item[item.length - 1];
        }
        fabric.Path = fabric.util.createClass(fabric.Object, {
            type: 'path',
            path: null,
            initialize: function(path, options) {
                options = options || {};
                this.setOptions(options);
                if (!path) {
                    throw new Error('`path` argument is required');
                }
                var fromArray = _toString.call(path) === '[object Array]';
                this.path = fromArray ? path : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
                if (!this.path) {
                    return;
                }
                if (!fromArray) {
                    this.path = this._parsePath();
                }
                this._initializePath(options);
                if (options.sourcePath) {
                    this.setSourcePath(options.sourcePath);
                }
            },
            _initializePath: function(options) {
                var isWidthSet = 'width' in options && options.width != null,
                    isHeightSet = 'height' in options && options.width != null,
                    isLeftSet = 'left' in options,
                    isTopSet = 'top' in options,
                    origLeft = isLeftSet ? this.left : 0,
                    origTop = isTopSet ? this.top : 0;
                if (!isWidthSet || !isHeightSet) {
                    extend(this, this._parseDimensions());
                    if (isWidthSet) {
                        this.width = options.width;
                    }
                    if (isHeightSet) {
                        this.height = options.height;
                    }
                } else {
                    if (!isTopSet) {
                        this.top = this.height / 2;
                    }
                    if (!isLeftSet) {
                        this.left = this.width / 2;
                    }
                }
                this.pathOffset = this.pathOffset || this._calculatePathOffset(origLeft, origTop);
            },
            _calculatePathOffset: function(origLeft, origTop) {
                return {
                    x: this.left - origLeft - (this.width / 2),
                    y: this.top - origTop - (this.height / 2)
                };
            },
            _render: function(ctx, noTransform) {
                var current, previous = null,
                    subpathStartX = 0,
                    subpathStartY = 0,
                    x = 0,
                    y = 0,
                    controlX = 0,
                    controlY = 0,
                    tempX, tempY, tempControlX, tempControlY, l = -((this.width / 2) + this.pathOffset.x),
                    t = -((this.height / 2) + this.pathOffset.y);
                if (noTransform) {
                    l += this.width / 2;
                    t += this.height / 2;
                }
                for (var i = 0, len = this.path.length; i < len; ++i) {
                    current = this.path[i];
                    switch (current[0]) {
                        case 'l':
                            x += current[1];
                            y += current[2];
                            ctx.lineTo(x + l, y + t);
                            break;
                        case 'L':
                            x = current[1];
                            y = current[2];
                            ctx.lineTo(x + l, y + t);
                            break;
                        case 'h':
                            x += current[1];
                            ctx.lineTo(x + l, y + t);
                            break;
                        case 'H':
                            x = current[1];
                            ctx.lineTo(x + l, y + t);
                            break;
                        case 'v':
                            y += current[1];
                            ctx.lineTo(x + l, y + t);
                            break;
                        case 'V':
                            y = current[1];
                            ctx.lineTo(x + l, y + t);
                            break;
                        case 'm':
                            x += current[1];
                            y += current[2];
                            subpathStartX = x;
                            subpathStartY = y;
                            ctx.moveTo(x + l, y + t);
                            break;
                        case 'M':
                            x = current[1];
                            y = current[2];
                            subpathStartX = x;
                            subpathStartY = y;
                            ctx.moveTo(x + l, y + t);
                            break;
                        case 'c':
                            tempX = x + current[5];
                            tempY = y + current[6];
                            controlX = x + current[3];
                            controlY = y + current[4];
                            ctx.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t);
                            x = tempX;
                            y = tempY;
                            break;
                        case 'C':
                            x = current[5];
                            y = current[6];
                            controlX = current[3];
                            controlY = current[4];
                            ctx.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
                            break;
                        case 's':
                            tempX = x + current[3];
                            tempY = y + current[4];
                            controlX = controlX ? (2 * x - controlX) : x;
                            controlY = controlY ? (2 * y - controlY) : y;
                            ctx.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t);
                            controlX = x + current[1];
                            controlY = y + current[2];
                            x = tempX;
                            y = tempY;
                            break;
                        case 'S':
                            tempX = current[3];
                            tempY = current[4];
                            controlX = 2 * x - controlX;
                            controlY = 2 * y - controlY;
                            ctx.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);
                            x = tempX;
                            y = tempY;
                            controlX = current[1];
                            controlY = current[2];
                            break;
                        case 'q':
                            tempX = x + current[3];
                            tempY = y + current[4];
                            controlX = x + current[1];
                            controlY = y + current[2];
                            ctx.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                            x = tempX;
                            y = tempY;
                            break;
                        case 'Q':
                            tempX = current[3];
                            tempY = current[4];
                            ctx.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
                            x = tempX;
                            y = tempY;
                            controlX = current[1];
                            controlY = current[2];
                            break;
                        case 't':
                            tempX = x + current[1];
                            tempY = y + current[2];
                            if (previous[0].match(/[QqTt]/) === null) {
                                controlX = x;
                                controlY = y;
                            } else if (previous[0] === 't') {
                                controlX = 2 * x - tempControlX;
                                controlY = 2 * y - tempControlY;
                            } else if (previous[0] === 'q') {
                                controlX = 2 * x - controlX;
                                controlY = 2 * y - controlY;
                            }
                            tempControlX = controlX;
                            tempControlY = controlY;
                            ctx.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                            x = tempX;
                            y = tempY;
                            controlX = x + current[1];
                            controlY = y + current[2];
                            break;
                        case 'T':
                            tempX = current[1];
                            tempY = current[2];
                            controlX = 2 * x - controlX;
                            controlY = 2 * y - controlY;
                            ctx.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                            x = tempX;
                            y = tempY;
                            break;
                        case 'a':
                            drawArc(ctx, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);
                            x += current[6];
                            y += current[7];
                            break;
                        case 'A':
                            drawArc(ctx, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);
                            x = current[6];
                            y = current[7];
                            break;
                        case 'z':
                        case 'Z':
                            x = subpathStartX;
                            y = subpathStartY;
                            ctx.closePath();
                            break;
                    }
                    previous = current;
                }
            },
            render: function(ctx, noTransform) {
                if (!this.visible) {
                    return;
                }
                ctx.save();
                if (noTransform) {
                    ctx.translate(-this.width / 2, -this.height / 2);
                }
                var m = this.transformMatrix;
                if (m) {
                    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
                if (!noTransform) {
                    this.transform(ctx);
                }
                this._setStrokeStyles(ctx);
                this._setFillStyles(ctx);
                this._setShadow(ctx);
                this.clipTo && fabric.util.clipContext(this, ctx);
                ctx.beginPath();
                ctx.globalAlpha = this.group ? (ctx.globalAlpha * this.opacity) : this.opacity;
                this._render(ctx, noTransform);
                this._renderFill(ctx);
                this._renderStroke(ctx);
                this.clipTo && ctx.restore();
                this._removeShadow(ctx);
                ctx.restore();
            },
            toString: function() {
                return '#<fabric.Path (' + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
            },
            toObject: function(propertiesToInclude) {
                var o = extend(this.callSuper('toObject', propertiesToInclude), {
                    path: this.path.map(function(item) {
                        return item.slice()
                    }),
                    pathOffset: this.pathOffset
                });
                if (this.sourcePath) {
                    o.sourcePath = this.sourcePath;
                }
                if (this.transformMatrix) {
                    o.transformMatrix = this.transformMatrix;
                }
                return o;
            },
            toDatalessObject: function(propertiesToInclude) {
                var o = this.toObject(propertiesToInclude);
                if (this.sourcePath) {
                    o.path = this.sourcePath;
                }
                delete o.sourcePath;
                return o;
            },
            toSVG: function(reviver) {
                var chunks = [],
                    markup = this._createBaseSVGMarkup();
                for (var i = 0, len = this.path.length; i < len; i++) {
                    chunks.push(this.path[i].join(' '));
                }
                var path = chunks.join(' ');
                markup.push('<path ', 'd="', path, '" style="', this.getSvgStyles(), '" transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '" stroke-linecap="round" ', '/>\n');
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            complexity: function() {
                return this.path.length;
            },
            _parsePath: function() {
                var result = [],
                    coords = [],
                    currentPath, parsed, re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/ig,
                    match, coordsStr;
                for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {
                    currentPath = this.path[i];
                    coordsStr = currentPath.slice(1).trim();
                    coords.length = 0;
                    while ((match = re.exec(coordsStr))) {
                        coords.push(match[0]);
                    }
                    coordsParsed = [currentPath.charAt(0)];
                    for (var j = 0, jlen = coords.length; j < jlen; j++) {
                        parsed = parseFloat(coords[j]);
                        if (!isNaN(parsed)) {
                            coordsParsed.push(parsed);
                        }
                    }
                    var command = coordsParsed[0],
                        commandLength = commandLengths[command.toLowerCase()],
                        repeatedCommand = repeatedCommands[command] || command;
                    if (coordsParsed.length - 1 > commandLength) {
                        for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
                            result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
                            command = repeatedCommand;
                        }
                    } else {
                        result.push(coordsParsed);
                    }
                }
                return result;
            },
            _parseDimensions: function() {
                var aX = [],
                    aY = [],
                    previous = {};
                this.path.forEach(function(item, i) {
                    this._getCoordsFromCommand(item, i, aX, aY, previous);
                }, this);
                var minX = min(aX),
                    minY = min(aY),
                    maxX = max(aX),
                    maxY = max(aY),
                    deltaX = maxX - minX,
                    deltaY = maxY - minY,
                    o = {
                        left: this.left + (minX + deltaX / 2),
                        top: this.top + (minY + deltaY / 2),
                        width: deltaX,
                        height: deltaY
                    };
                return o;
            },
            _getCoordsFromCommand: function(item, i, aX, aY, previous) {
                var isLowerCase = false;
                if (item[0] !== 'H') {
                    previous.x = (i === 0) ? getX(item) : getX(this.path[i - 1]);
                }
                if (item[0] !== 'V') {
                    previous.y = (i === 0) ? getY(item) : getY(this.path[i - 1]);
                }
                if (item[0] === item[0].toLowerCase()) {
                    isLowerCase = true;
                }
                var xy = this._getXY(item, isLowerCase, previous),
                    val;
                val = parseInt(xy.x, 10);
                if (!isNaN(val)) {
                    aX.push(val);
                }
                val = parseInt(xy.y, 10);
                if (!isNaN(val)) {
                    aY.push(val);
                }
            },
            _getXY: function(item, isLowerCase, previous) {
                var x = isLowerCase ? previous.x + getX(item) : item[0] === 'V' ? previous.x : getX(item),
                    y = isLowerCase ? previous.y + getY(item) : item[0] === 'H' ? previous.y : getY(item);
                return {
                    x: x,
                    y: y
                };
            }
        });
        fabric.Path.fromObject = function(object, callback) {
            if (typeof object.path === 'string') {
                fabric.loadSVGFromURL(object.path, function(elements) {
                    var path = elements[0],
                        pathUrl = object.path;
                    delete object.path;
                    fabric.util.object.extend(path, object);
                    path.setSourcePath(pathUrl);
                    callback(path);
                });
            } else {
                callback(new fabric.Path(object.path, object));
            }
        };
        fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);
        fabric.Path.fromElement = function(element, callback, options) {
            var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
            callback && callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
        };
        fabric.Path.async = true;
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend,
            invoke = fabric.util.array.invoke,
            parentToObject = fabric.Object.prototype.toObject;
        if (fabric.PathGroup) {
            fabric.warn('fabric.PathGroup is already defined');
            return;
        }
        fabric.PathGroup = fabric.util.createClass(fabric.Path, {
            type: 'path-group',
            fill: '',
            initialize: function(paths, options) {
                options = options || {};
                this.paths = paths || [];
                for (var i = this.paths.length; i--;) {
                    this.paths[i].group = this;
                }
                this.setOptions(options);
                if (options.widthAttr) {
                    this.scaleX = options.widthAttr / options.width;
                }
                if (options.heightAttr) {
                    this.scaleY = options.heightAttr / options.height;
                }
                this.setCoords();
                if (options.sourcePath) {
                    this.setSourcePath(options.sourcePath);
                }
            },
            render: function(ctx) {
                if (!this.visible) {
                    return;
                }
                ctx.save();
                var m = this.transformMatrix;
                if (m) {
                    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
                this.transform(ctx);
                this._setShadow(ctx);
                this.clipTo && fabric.util.clipContext(this, ctx);
                for (var i = 0, l = this.paths.length; i < l; ++i) {
                    this.paths[i].render(ctx, true);
                }
                this.clipTo && ctx.restore();
                this._removeShadow(ctx);
                ctx.restore();
            },
            _set: function(prop, value) {
                if (prop === 'fill' && value && this.isSameColor()) {
                    var i = this.paths.length;
                    while (i--) {
                        this.paths[i]._set(prop, value);
                    }
                }
                return this.callSuper('_set', prop, value);
            },
            toObject: function(propertiesToInclude) {
                var o = extend(parentToObject.call(this, propertiesToInclude), {
                    paths: invoke(this.getObjects(), 'toObject', propertiesToInclude)
                });
                if (this.sourcePath) {
                    o.sourcePath = this.sourcePath;
                }
                return o;
            },
            toDatalessObject: function(propertiesToInclude) {
                var o = this.toObject(propertiesToInclude);
                if (this.sourcePath) {
                    o.paths = this.sourcePath;
                }
                return o;
            },
            toSVG: function(reviver) {
                var objects = this.getObjects(),
                    translatePart = 'translate(' + this.left + ' ' + this.top + ')',
                    markup = ['<g ', 'style="', this.getSvgStyles(), '" ', 'transform="', translatePart, this.getSvgTransform(), '" ', '>\n'];
                for (var i = 0, len = objects.length; i < len; i++) {
                    markup.push(objects[i].toSVG(reviver));
                }
                markup.push('</g>\n');
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            toString: function() {
                return '#<fabric.PathGroup (' + this.complexity() + '): { top: ' + this.top + ', left: ' + this.left + ' }>';
            },
            isSameColor: function() {
                var firstPathFill = (this.getObjects()[0].get('fill') || '').toLowerCase();
                return this.getObjects().every(function(path) {
                    return (path.get('fill') || '').toLowerCase() === firstPathFill;
                });
            },
            complexity: function() {
                return this.paths.reduce(function(total, path) {
                    return total + ((path && path.complexity) ? path.complexity() : 0);
                }, 0);
            },
            getObjects: function() {
                return this.paths;
            }
        });
        fabric.PathGroup.fromObject = function(object, callback) {
            if (typeof object.paths === 'string') {
                fabric.loadSVGFromURL(object.paths, function(elements) {
                    var pathUrl = object.paths;
                    delete object.paths;
                    var pathGroup = fabric.util.groupSVGElements(elements, object, pathUrl);
                    callback(pathGroup);
                });
            } else {
                fabric.util.enlivenObjects(object.paths, function(enlivenedObjects) {
                    delete object.paths;
                    callback(new fabric.PathGroup(enlivenedObjects, object));
                });
            }
        };
        fabric.PathGroup.async = true;
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend,
            min = fabric.util.array.min,
            max = fabric.util.array.max,
            invoke = fabric.util.array.invoke;
        if (fabric.Group) {
            return;
        }
        var _lockProperties = {
            lockMovementX: true,
            lockMovementY: true,
            lockRotation: true,
            lockScalingX: true,
            lockScalingY: true,
            lockUniScaling: true
        };
        fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, {
            type: 'group',
            initialize: function(objects, options) {
                options = options || {};
                this._objects = objects || [];
                for (var i = this._objects.length; i--;) {
                    this._objects[i].group = this;
                }
                this.originalState = {};
                this.callSuper('initialize');
                this._calcBounds();
                this._updateObjectsCoords();
                if (options) {
                    extend(this, options);
                }
                this._setOpacityIfSame();
                this.setCoords();
                this.saveCoords();
            },
            _updateObjectsCoords: function() {
                this.forEachObject(this._updateObjectCoords, this);
            },
            _updateObjectCoords: function(object) {
                var objectLeft = object.getLeft(),
                    objectTop = object.getTop();
                object.set({
                    originalLeft: objectLeft,
                    originalTop: objectTop,
                    left: objectLeft - this.left,
                    top: objectTop - this.top
                });
                object.setCoords();
                object.__origHasControls = object.hasControls;
                object.hasControls = false;
            },
            toString: function() {
                return '#<fabric.Group: (' + this.complexity() + ')>';
            },
            addWithUpdate: function(object) {
                this._restoreObjectsState();
                if (object) {
                    this._objects.push(object);
                    object.group = this;
                }
                this.forEachObject(this._setObjectActive, this);
                this._calcBounds();
                this._updateObjectsCoords();
                return this;
            },
            _setObjectActive: function(object) {
                object.set('active', true);
                object.group = this;
            },
            removeWithUpdate: function(object) {
                this._moveFlippedObject(object);
                this._restoreObjectsState();
                this.forEachObject(this._setObjectActive, this);
                this.remove(object);
                this._calcBounds();
                this._updateObjectsCoords();
                return this;
            },
            _onObjectAdded: function(object) {
                object.group = this;
            },
            _onObjectRemoved: function(object) {
                delete object.group;
                object.set('active', false);
            },
            delegatedProperties: {
                fill: true,
                opacity: true,
                fontFamily: true,
                fontWeight: true,
                fontSize: true,
                fontStyle: true,
                lineHeight: true,
                textDecoration: true,
                textAlign: true,
                backgroundColor: true
            },
            _set: function(key, value) {
                if (key in this.delegatedProperties) {
                    var i = this._objects.length;
                    this[key] = value;
                    while (i--) {
                        this._objects[i].set(key, value);
                    }
                } else {
                    this[key] = value;
                }
            },
            toObject: function(propertiesToInclude) {
                return extend(this.callSuper('toObject', propertiesToInclude), {
                    objects: invoke(this._objects, 'toObject', propertiesToInclude)
                });
            },
            render: function(ctx) {
                if (!this.visible) {
                    return;
                }
                ctx.save();
                this.clipTo && fabric.util.clipContext(this, ctx);
                for (var i = 0, len = this._objects.length; i < len; i++) {
                    this._renderObject(this._objects[i], ctx);
                }
                this.clipTo && ctx.restore();
                ctx.restore();
            },
            _renderControls: function(ctx, noTransform) {
                this.callSuper('_renderControls', ctx, noTransform);
                for (var i = 0, len = this._objects.length; i < len; i++) {
                    this._objects[i]._renderControls(ctx);
                }
            },
            _renderObject: function(object, ctx) {
                var originalHasRotatingPoint = object.hasRotatingPoint;
                if (!object.visible) {
                    return;
                }
                object.hasRotatingPoint = false;
                object.render(ctx);
                object.hasRotatingPoint = originalHasRotatingPoint;
            },
            _restoreObjectsState: function() {
                this._objects.forEach(this._restoreObjectState, this);
                return this;
            },
            _moveFlippedObject: function(object) {
                var oldOriginX = object.get('originX'),
                    oldOriginY = object.get('originY'),
                    center = object.getCenterPoint();
                object.set({
                    originX: 'center',
                    originY: 'center',
                    left: center.x,
                    top: center.y
                });
                this._toggleFlipping(object);
                var newOrigin = object.getPointByOrigin(oldOriginX, oldOriginY);
                object.set({
                    originX: oldOriginX,
                    originY: oldOriginY,
                    left: newOrigin.x,
                    top: newOrigin.y
                });
                return this;
            },
            _toggleFlipping: function(object) {
                if (this.flipX) {
                    object.toggle('flipX');
                    object.set('left', -object.get('left'));
                    object.setAngle(-object.getAngle());
                }
                if (this.flipY) {
                    object.toggle('flipY');
                    object.set('top', -object.get('top'));
                    object.setAngle(-object.getAngle());
                }
            },
            _restoreObjectState: function(object) {
                this._setObjectPosition(object);
                object.setCoords();
                object.hasControls = object.__origHasControls;
                delete object.__origHasControls;
                object.set('active', false);
                object.setCoords();
                delete object.group;
                return this;
            },
            _setObjectPosition: function(object) {
                var groupLeft = this.getLeft(),
                    groupTop = this.getTop(),
                    rotated = this._getRotatedLeftTop(object);
                object.set({
                    angle: object.getAngle() + this.getAngle(),
                    left: groupLeft + rotated.left,
                    top: groupTop + rotated.top,
                    scaleX: object.get('scaleX') * this.get('scaleX'),
                    scaleY: object.get('scaleY') * this.get('scaleY')
                });
            },
            _getRotatedLeftTop: function(object) {
                var groupAngle = this.getAngle() * (Math.PI / 180);
                return {
                    left: (-Math.sin(groupAngle) * object.getTop() * this.get('scaleY') +
                        Math.cos(groupAngle) * object.getLeft() * this.get('scaleX')),
                    top: (Math.cos(groupAngle) * object.getTop() * this.get('scaleY') +
                        Math.sin(groupAngle) * object.getLeft() * this.get('scaleX'))
                };
            },
            destroy: function() {
                this._objects.forEach(this._moveFlippedObject, this);
                return this._restoreObjectsState();
            },
            saveCoords: function() {
                this._originalLeft = this.get('left');
                this._originalTop = this.get('top');
                return this;
            },
            hasMoved: function() {
                return this._originalLeft !== this.get('left') || this._originalTop !== this.get('top');
            },
            setObjectsCoords: function() {
                this.forEachObject(function(object) {
                    object.setCoords();
                });
                return this;
            },
            _setOpacityIfSame: function() {
                var objects = this.getObjects(),
                    firstValue = objects[0] ? objects[0].get('opacity') : 1,
                    isSameOpacity = objects.every(function(o) {
                        return o.get('opacity') === firstValue;
                    });
                if (isSameOpacity) {
                    this.opacity = firstValue;
                }
            },
            _calcBounds: function(onlyWidthHeight) {
                var aX = [],
                    aY = [],
                    o;
                for (var i = 0, len = this._objects.length; i < len; ++i) {
                    o = this._objects[i];
                    o.setCoords();
                    for (var prop in o.oCoords) {
                        aX.push(o.oCoords[prop].x);
                        aY.push(o.oCoords[prop].y);
                    }
                }
                this.set(this._getBounds(aX, aY, onlyWidthHeight));
            },
            _getBounds: function(aX, aY, onlyWidthHeight) {
                var ivt = fabric.util.invertTransform(this.getViewportTransform()),
                    minXY = fabric.util.transformPoint(new fabric.Point(min(aX), min(aY)), ivt),
                    maxXY = fabric.util.transformPoint(new fabric.Point(max(aX), max(aY)), ivt),
                    obj = {
                        width: (maxXY.x - minXY.x) || 0,
                        height: (maxXY.y - minXY.y) || 0
                    };
                if (!onlyWidthHeight) {
                    obj.left = (minXY.x + maxXY.x) / 2 || 0;
                    obj.top = (minXY.y + maxXY.y) / 2 || 0;
                }
                return obj;
            },
            toSVG: function(reviver) {
                var markup = ['<g ', 'transform="', this.getSvgTransform(), '">\n'];
                for (var i = 0, len = this._objects.length; i < len; i++) {
                    markup.push(this._objects[i].toSVG(reviver));
                }
                markup.push('</g>\n');
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            get: function(prop) {
                if (prop in _lockProperties) {
                    if (this[prop]) {
                        return this[prop];
                    } else {
                        for (var i = 0, len = this._objects.length; i < len; i++) {
                            if (this._objects[i][prop]) {
                                return true;
                            }
                        }
                        return false;
                    }
                } else {
                    if (prop in this.delegatedProperties) {
                        return this._objects[0] && this._objects[0].get(prop);
                    }
                    return this[prop];
                }
            }
        });
        fabric.Group.fromObject = function(object, callback) {
            fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
                delete object.objects;
                callback && callback(new fabric.Group(enlivenedObjects, object));
            });
        };
        fabric.Group.async = true;
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var extend = fabric.util.object.extend;
        if (!global.fabric) {
            global.fabric = {};
        }
        if (global.fabric.Image) {
            fabric.warn('fabric.Image is already defined.');
            return;
        }
        fabric.Image = fabric.util.createClass(fabric.Object, {
            type: 'image',
            crossOrigin: '',
            initialize: function(element, options) {
                options || (options = {});
                this.filters = [];
                this.callSuper('initialize', options);
                this._initElement(element, options);
                this._initConfig(options);
                if (options.filters) {
                    this.filters = options.filters;
                    this.applyFilters();
                }
            },
            getElement: function() {
                return this._element;
            },
            setElement: function(element, callback) {
                this._element = element;
                this._originalElement = element;
                this._initConfig();
                if (this.filters.length !== 0) {
                    this.applyFilters(callback);
                }
                return this;
            },
            setCrossOrigin: function(value) {
                this.crossOrigin = value;
                this._element.crossOrigin = value;
                return this;
            },
            getOriginalSize: function() {
                var element = this.getElement();
                return {
                    width: element.width,
                    height: element.height
                };
            },
            _stroke: function(ctx) {
                ctx.save();
                this._setStrokeStyles(ctx);
                ctx.beginPath();
                ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.closePath();
                ctx.restore();
            },
            _renderDashedStroke: function(ctx) {
                var x = -this.width / 2,
                    y = -this.height / 2,
                    w = this.width,
                    h = this.height;
                ctx.save();
                this._setStrokeStyles(ctx);
                ctx.beginPath();
                fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
                fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
                fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
                fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
                ctx.closePath();
                ctx.restore();
            },
            toObject: function(propertiesToInclude) {
                return extend(this.callSuper('toObject', propertiesToInclude), {
                    src: this._originalElement.src || this._originalElement._src,
                    filters: this.filters.map(function(filterObj) {
                        return filterObj && filterObj.toObject();
                    }),
                    crossOrigin: this.crossOrigin
                });
            },
            toSVG: function(reviver) {
                var markup = [],
                    x = -this.width / 2,
                    y = -this.height / 2;
                if (this.group) {
                    x = this.left;
                    y = this.top;
                }
                markup.push('<g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '">\n', '<image xlink:href="', this.getSvgSrc(), '" x="', x, '" y="', y, '" style="', this.getSvgStyles(), '" width="', this.width, '" height="', this.height, '" preserveAspectRatio="none"', '></image>\n');
                if (this.stroke || this.strokeDashArray) {
                    var origFill = this.fill;
                    this.fill = null;
                    markup.push('<rect ', 'x="', x, '" y="', y, '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), '"/>\n');
                    this.fill = origFill;
                }
                markup.push('</g>\n');
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            getSrc: function() {
                if (this.getElement()) {
                    return this.getElement().src || this.getElement()._src;
                }
            },
            toString: function() {
                return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
            },
            clone: function(callback, propertiesToInclude) {
                this.constructor.fromObject(this.toObject(propertiesToInclude), callback);
            },
            applyFilters: function(callback) {
                if (!this._originalElement) {
                    return;
                }
                if (this.filters.length === 0) {
                    this._element = this._originalElement;
                    callback && callback();
                    return;
                }
                var imgEl = this._originalElement,
                    canvasEl = fabric.util.createCanvasElement(),
                    replacement = fabric.util.createImage(),
                    _this = this;
                canvasEl.width = imgEl.width;
                canvasEl.height = imgEl.height;
                canvasEl.getContext('2d').drawImage(imgEl, 0, 0, imgEl.width, imgEl.height);
                this.filters.forEach(function(filter) {
                    filter && filter.applyTo(canvasEl);
                });
                replacement.width = imgEl.width;
                replacement.height = imgEl.height;
                if (fabric.isLikelyNode) {
                    replacement.src = canvasEl.toBuffer(undefined, fabric.Image.pngCompression);
                    _this._element = replacement;
                    callback && callback();
                } else {
                    replacement.onload = function() {
                        _this._element = replacement;
                        callback && callback();
                        replacement.onload = canvasEl = imgEl = null;
                    };
                    replacement.src = canvasEl.toDataURL('image/png');
                }
                return this;
            },
            _render: function(ctx, noTransform) {
                this._element && ctx.drawImage(this._element, noTransform ? this.left : -this.width / 2, noTransform ? this.top : -this.height / 2, this.width, this.height);
                this._renderStroke(ctx);
            },
            _resetWidthHeight: function() {
                var element = this.getElement();
                this.set('width', element.width);
                this.set('height', element.height);
            },
            _initElement: function(element) {
                this.setElement(fabric.util.getById(element));
                fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
            },
            _initConfig: function(options) {
                options || (options = {});
                this.setOptions(options);
                this._setWidthHeight(options);
                if (this._element && this.crossOrigin) {
                    this._element.crossOrigin = this.crossOrigin;
                }
            },
            _initFilters: function(object, callback) {
                if (object.filters && object.filters.length) {
                    fabric.util.enlivenObjects(object.filters, function(enlivenedObjects) {
                        callback && callback(enlivenedObjects);
                    }, 'fabric.Image.filters');
                } else {
                    callback && callback();
                }
            },
            _setWidthHeight: function(options) {
                this.width = 'width' in options ? options.width : (this.getElement() ? this.getElement().width || 0 : 0);
                this.height = 'height' in options ? options.height : (this.getElement() ? this.getElement().height || 0 : 0);
            },
            complexity: function() {
                return 1;
            }
        });
        fabric.Image.CSS_CANVAS = 'canvas-img';
        fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;
        fabric.Image.fromObject = function(object, callback) {
            fabric.util.loadImage(object.src, function(img) {
                fabric.Image.prototype._initFilters.call(object, object, function(filters) {
                    object.filters = filters || [];
                    var instance = new fabric.Image(img, object);
                    callback && callback(instance);
                });
            }, null, object.crossOrigin);
        };
        fabric.Image.fromURL = function(url, callback, imgOptions) {
            fabric.util.loadImage(url, function(img) {
                callback(new fabric.Image(img, imgOptions));
            }, null, imgOptions && imgOptions.crossOrigin);
        };
        fabric.Image.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y width height xlink:href'.split(' '));
        fabric.Image.fromElement = function(element, callback, options) {
            var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);
            fabric.Image.fromURL(parsedAttributes['xlink:href'], callback, extend((options ? fabric.util.object.clone(options) : {}), parsedAttributes));
        };
        fabric.Image.async = true;
        fabric.Image.pngCompression = 1;
    })(typeof exports !== 'undefined' ? exports : this);
    fabric.Image.filters = fabric.Image.filters || {};
    fabric.Image.filters.BaseFilter = fabric.util.createClass({
        type: 'BaseFilter',
        toObject: function() {
            return {
                type: this.type
            };
        },
        toJSON: function() {
            return this.toObject();
        }
    });
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend;
        fabric.Image.filters.Brightness = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'Brightness',
            initialize: function(options) {
                options = options || {};
                this.brightness = options.brightness || 0;
            },
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    brightness = this.brightness;
                for (var i = 0, len = data.length; i < len; i += 4) {
                    data[i] += brightness;
                    data[i + 1] += brightness;
                    data[i + 2] += brightness;
                }
                context.putImageData(imageData, 0, 0);
            },
            toObject: function() {
                return extend(this.callSuper('toObject'), {
                    brightness: this.brightness
                });
            }
        });
        fabric.Image.filters.Brightness.fromObject = function(object) {
            return new fabric.Image.filters.Brightness(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend;
        fabric.Image.filters.Convolute = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'Convolute',
            initialize: function(options) {
                options = options || {};
                this.opaque = options.opaque;
                this.matrix = options.matrix || [0, 0, 0, 0, 1, 0, 0, 0, 0];
                var canvasEl = fabric.util.createCanvasElement();
                this.tmpCtx = canvasEl.getContext('2d');
            },
            _createImageData: function(w, h) {
                return this.tmpCtx.createImageData(w, h);
            },
            applyTo: function(canvasEl) {
                var weights = this.matrix,
                    context = canvasEl.getContext('2d'),
                    pixels = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    side = Math.round(Math.sqrt(weights.length)),
                    halfSide = Math.floor(side / 2),
                    src = pixels.data,
                    sw = pixels.width,
                    sh = pixels.height,
                    w = sw,
                    h = sh,
                    output = this._createImageData(w, h),
                    dst = output.data,
                    alphaFac = this.opaque ? 1 : 0;
                for (var y = 0; y < h; y++) {
                    for (var x = 0; x < w; x++) {
                        var sy = y,
                            sx = x,
                            dstOff = (y * w + x) * 4,
                            r = 0,
                            g = 0,
                            b = 0,
                            a = 0;
                        for (var cy = 0; cy < side; cy++) {
                            for (var cx = 0; cx < side; cx++) {
                                var scy = sy + cy - halfSide,
                                    scx = sx + cx - halfSide;
                                if (scy < 0 || scy > sh || scx < 0 || scx > sw) {
                                    continue;
                                }
                                var srcOff = (scy * sw + scx) * 4,
                                    wt = weights[cy * side + cx];
                                r += src[srcOff] * wt;
                                g += src[srcOff + 1] * wt;
                                b += src[srcOff + 2] * wt;
                                a += src[srcOff + 3] * wt;
                            }
                        }
                        dst[dstOff] = r;
                        dst[dstOff + 1] = g;
                        dst[dstOff + 2] = b;
                        dst[dstOff + 3] = a + alphaFac * (255 - a);
                    }
                }
                context.putImageData(output, 0, 0);
            },
            toObject: function() {
                return extend(this.callSuper('toObject'), {
                    opaque: this.opaque,
                    matrix: this.matrix
                });
            }
        });
        fabric.Image.filters.Convolute.fromObject = function(object) {
            return new fabric.Image.filters.Convolute(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend;
        fabric.Image.filters.GradientTransparency = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'GradientTransparency',
            initialize: function(options) {
                options = options || {};
                this.threshold = options.threshold || 100;
            },
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    threshold = this.threshold,
                    total = data.length;
                for (var i = 0, len = data.length; i < len; i += 4) {
                    data[i + 3] = threshold + 255 * (total - i) / total;
                }
                context.putImageData(imageData, 0, 0);
            },
            toObject: function() {
                return extend(this.callSuper('toObject'), {
                    threshold: this.threshold
                });
            }
        });
        fabric.Image.filters.GradientTransparency.fromObject = function(object) {
            return new fabric.Image.filters.GradientTransparency(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {});
        fabric.Image.filters.Grayscale = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'Grayscale',
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    len = imageData.width * imageData.height * 4,
                    index = 0,
                    average;
                while (index < len) {
                    average = (data[index] + data[index + 1] + data[index + 2]) / 3;
                    data[index] = average;
                    data[index + 1] = average;
                    data[index + 2] = average;
                    index += 4;
                }
                context.putImageData(imageData, 0, 0);
            }
        });
        fabric.Image.filters.Grayscale.fromObject = function() {
            return new fabric.Image.filters.Grayscale();
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {});
        fabric.Image.filters.Invert = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'Invert',
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    iLen = data.length,
                    i;
                for (i = 0; i < iLen; i += 4) {
                    data[i] = 255 - data[i];
                    data[i + 1] = 255 - data[i + 1];
                    data[i + 2] = 255 - data[i + 2];
                }
                context.putImageData(imageData, 0, 0);
            }
        });
        fabric.Image.filters.Invert.fromObject = function() {
            return new fabric.Image.filters.Invert();
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend;
        fabric.Image.filters.Mask = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'Mask',
            initialize: function(options) {
                options = options || {};
                this.mask = options.mask;
                this.channel = [0, 1, 2, 3].indexOf(options.channel) > -1 ? options.channel : 0;
            },
            applyTo: function(canvasEl) {
                if (!this.mask) {
                    return;
                }
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    maskEl = this.mask.getElement(),
                    maskCanvasEl = fabric.util.createCanvasElement(),
                    channel = this.channel,
                    i, iLen = imageData.width * imageData.height * 4;
                maskCanvasEl.width = maskEl.width;
                maskCanvasEl.height = maskEl.height;
                maskCanvasEl.getContext('2d').drawImage(maskEl, 0, 0, maskEl.width, maskEl.height);
                var maskImageData = maskCanvasEl.getContext('2d').getImageData(0, 0, maskEl.width, maskEl.height),
                    maskData = maskImageData.data;
                for (i = 0; i < iLen; i += 4) {
                    data[i + 3] = maskData[i + channel];
                }
                context.putImageData(imageData, 0, 0);
            },
            toObject: function() {
                return extend(this.callSuper('toObject'), {
                    mask: this.mask.toObject(),
                    channel: this.channel
                });
            }
        });
        fabric.Image.filters.Mask.fromObject = function(object, callback) {
            fabric.util.loadImage(object.mask.src, function(img) {
                object.mask = new fabric.Image(img, object.mask);
                callback && callback(new fabric.Image.filters.Mask(object));
            });
        };
        fabric.Image.filters.Mask.async = true;
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend;
        fabric.Image.filters.Noise = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'Noise',
            initialize: function(options) {
                options = options || {};
                this.noise = options.noise || 0;
            },
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    noise = this.noise,
                    rand;
                for (var i = 0, len = data.length; i < len; i += 4) {
                    rand = (0.5 - Math.random()) * noise;
                    data[i] += rand;
                    data[i + 1] += rand;
                    data[i + 2] += rand;
                }
                context.putImageData(imageData, 0, 0);
            },
            toObject: function() {
                return extend(this.callSuper('toObject'), {
                    noise: this.noise
                });
            }
        });
        fabric.Image.filters.Noise.fromObject = function(object) {
            return new fabric.Image.filters.Noise(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend;
        fabric.Image.filters.Pixelate = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'Pixelate',
            initialize: function(options) {
                options = options || {};
                this.blocksize = options.blocksize || 4;
            },
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    iLen = imageData.height,
                    jLen = imageData.width,
                    index, i, j, r, g, b, a;
                for (i = 0; i < iLen; i += this.blocksize) {
                    for (j = 0; j < jLen; j += this.blocksize) {
                        index = (i * 4) * jLen + (j * 4);
                        r = data[index];
                        g = data[index + 1];
                        b = data[index + 2];
                        a = data[index + 3];
                        for (var _i = i, _ilen = i + this.blocksize; _i < _ilen; _i++) {
                            for (var _j = j, _jlen = j + this.blocksize; _j < _jlen; _j++) {
                                index = (_i * 4) * jLen + (_j * 4);
                                data[index] = r;
                                data[index + 1] = g;
                                data[index + 2] = b;
                                data[index + 3] = a;
                            }
                        }
                    }
                }
                context.putImageData(imageData, 0, 0);
            },
            toObject: function() {
                return extend(this.callSuper('toObject'), {
                    blocksize: this.blocksize
                });
            }
        });
        fabric.Image.filters.Pixelate.fromObject = function(object) {
            return new fabric.Image.filters.Pixelate(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend;
        fabric.Image.filters.RemoveWhite = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'RemoveWhite',
            initialize: function(options) {
                options = options || {};
                this.threshold = options.threshold || 30;
                this.distance = options.distance || 20;
            },
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    threshold = this.threshold,
                    distance = this.distance,
                    limit = 255 - threshold,
                    abs = Math.abs,
                    r, g, b;
                for (var i = 0, len = data.length; i < len; i += 4) {
                    r = data[i];
                    g = data[i + 1];
                    b = data[i + 2];
                    if (r > limit && g > limit && b > limit && abs(r - g) < distance && abs(r - b) < distance && abs(g - b) < distance) {
                        data[i + 3] = 1;
                    }
                }
                context.putImageData(imageData, 0, 0);
            },
            toObject: function() {
                return extend(this.callSuper('toObject'), {
                    threshold: this.threshold,
                    distance: this.distance
                });
            }
        });
        fabric.Image.filters.RemoveWhite.fromObject = function(object) {
            return new fabric.Image.filters.RemoveWhite(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {});
        fabric.Image.filters.Sepia = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'Sepia',
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    iLen = data.length,
                    i, avg;
                for (i = 0; i < iLen; i += 4) {
                    avg = 0.3 * data[i] + 0.59 * data[i + 1] + 0.11 * data[i + 2];
                    data[i] = avg + 100;
                    data[i + 1] = avg + 50;
                    data[i + 2] = avg + 255;
                }
                context.putImageData(imageData, 0, 0);
            }
        });
        fabric.Image.filters.Sepia.fromObject = function() {
            return new fabric.Image.filters.Sepia();
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {});
        fabric.Image.filters.Sepia2 = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'Sepia2',
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    iLen = data.length,
                    i, r, g, b;
                for (i = 0; i < iLen; i += 4) {
                    r = data[i];
                    g = data[i + 1];
                    b = data[i + 2];
                    data[i] = (r * 0.393 + g * 0.769 + b * 0.189) / 1.351;
                    data[i + 1] = (r * 0.349 + g * 0.686 + b * 0.168) / 1.203;
                    data[i + 2] = (r * 0.272 + g * 0.534 + b * 0.131) / 2.140;
                }
                context.putImageData(imageData, 0, 0);
            }
        });
        fabric.Image.filters.Sepia2.fromObject = function() {
            return new fabric.Image.filters.Sepia2();
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend;
        fabric.Image.filters.Tint = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'Tint',
            initialize: function(options) {
                options = options || {};
                this.color = options.color || '#000000';
                this.opacity = typeof options.opacity !== 'undefined' ? options.opacity : new fabric.Color(this.color).getAlpha();
            },
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    iLen = data.length,
                    i, tintR, tintG, tintB, r, g, b, alpha1, source;
                source = new fabric.Color(this.color).getSource();
                tintR = source[0] * this.opacity;
                tintG = source[1] * this.opacity;
                tintB = source[2] * this.opacity;
                alpha1 = 1 - this.opacity;
                for (i = 0; i < iLen; i += 4) {
                    r = data[i];
                    g = data[i + 1];
                    b = data[i + 2];
                    data[i] = tintR + r * alpha1;
                    data[i + 1] = tintG + g * alpha1;
                    data[i + 2] = tintB + b * alpha1;
                }
                context.putImageData(imageData, 0, 0);
            },
            toObject: function() {
                return extend(this.callSuper('toObject'), {
                    color: this.color,
                    opacity: this.opacity
                });
            }
        });
        fabric.Image.filters.Tint.fromObject = function(object) {
            return new fabric.Image.filters.Tint(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend;
        fabric.Image.filters.Multiply = fabric.util.createClass(fabric.Image.filters.BaseFilter, {
            type: 'Multiply',
            initialize: function(options) {
                options = options || {};
                this.color = options.color || '#000000';
            },
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    iLen = data.length,
                    i, source;
                source = new fabric.Color(this.color).getSource();
                for (i = 0; i < iLen; i += 4) {
                    data[i] *= source[0] / 255;
                    data[i + 1] *= source[1] / 255;
                    data[i + 2] *= source[2] / 255;
                }
                context.putImageData(imageData, 0, 0);
            },
            toObject: function() {
                return extend(this.callSuper('toObject'), {
                    color: this.color
                });
            }
        });
        fabric.Image.filters.Multiply.fromObject = function(object) {
            return new fabric.Image.filters.Multiply(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric;
        fabric.Image.filters.Blend = fabric.util.createClass({
            type: 'Blend',
            initialize: function(options) {
                options = options || {};
                this.color = options.color || '#000';
                this.image = options.image || false;
                this.mode = options.mode || 'multiply';
                this.alpha = options.alpha || 1;
            },
            applyTo: function(canvasEl) {
                var context = canvasEl.getContext('2d'),
                    imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height),
                    data = imageData.data,
                    tr, tg, tb, r, g, b, source, isImage = false;
                if (this.image) {
                    isImage = true;
                    var _el = fabric.util.createCanvasElement();
                    _el.width = this.image.width;
                    _el.height = this.image.height;
                    var tmpCanvas = new fabric.StaticCanvas(_el);
                    tmpCanvas.add(this.image);
                    var context2 = tmpCanvas.getContext('2d');
                    source = context2.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height).data;
                } else {
                    source = new fabric.Color(this.color).getSource();
                    tr = source[0] * this.alpha;
                    tg = source[1] * this.alpha;
                    tb = source[2] * this.alpha;
                }
                for (var i = 0, len = data.length; i < len; i += 4) {
                    r = data[i];
                    g = data[i + 1];
                    b = data[i + 2];
                    if (isImage) {
                        tr = source[i] * this.alpha;
                        tg = source[i + 1] * this.alpha;
                        tb = source[i + 2] * this.alpha;
                    }
                    switch (this.mode) {
                        case 'multiply':
                            data[i] = r * tr / 255;
                            data[i + 1] = g * tg / 255;
                            data[i + 2] = b * tb / 255;
                            break;
                        case 'screen':
                            data[i] = 1 - (1 - r) * (1 - tr);
                            data[i + 1] = 1 - (1 - g) * (1 - tg);
                            data[i + 2] = 1 - (1 - b) * (1 - tb);
                            break;
                        case 'add':
                            data[i] = Math.min(255, r + tr);
                            data[i + 1] = Math.min(255, g + tg);
                            data[i + 2] = Math.min(255, b + tb);
                            break;
                        case 'diff':
                        case 'difference':
                            data[i] = Math.abs(r - tr);
                            data[i + 1] = Math.abs(g - tg);
                            data[i + 2] = Math.abs(b - tb);
                            break;
                        case 'subtract':
                            var _r = r - tr,
                                _g = g - tg,
                                _b = b - tb;
                            data[i] = (_r < 0) ? 0 : _r;
                            data[i + 1] = (_g < 0) ? 0 : _g;
                            data[i + 2] = (_b < 0) ? 0 : _b;
                            break;
                        case 'darken':
                            data[i] = Math.min(r, tr);
                            data[i + 1] = Math.min(g, tg);
                            data[i + 2] = Math.min(b, tb);
                            break;
                        case 'lighten':
                            data[i] = Math.max(r, tr);
                            data[i + 1] = Math.max(g, tg);
                            data[i + 2] = Math.max(b, tb);
                            break;
                    }
                }
                context.putImageData(imageData, 0, 0);
            }
        });
        fabric.Image.filters.Blend.fromObject = function(object) {
            return new fabric.Image.filters.Blend(object);
        };
    })(typeof exports !== 'undefined' ? exports : this);
    (function(global) {
        'use strict';
        var fabric = global.fabric || (global.fabric = {}),
            extend = fabric.util.object.extend,
            clone = fabric.util.object.clone,
            toFixed = fabric.util.toFixed,
            supportsLineDash = fabric.StaticCanvas.supports('setLineDash');
        if (fabric.Text) {
            fabric.warn('fabric.Text is already defined');
            return;
        }
        var stateProperties = fabric.Object.prototype.stateProperties.concat();
        stateProperties.push('fontFamily', 'fontWeight', 'fontSize', 'text', 'textDecoration', 'textAlign', 'fontStyle', 'lineHeight', 'textBackgroundColor', 'useNative', 'path');
        fabric.Text = fabric.util.createClass(fabric.Object, {
            _dimensionAffectingProps: {
                fontSize: true,
                fontWeight: true,
                fontFamily: true,
                textDecoration: true,
                fontStyle: true,
                lineHeight: true,
                stroke: true,
                strokeWidth: true,
                text: true
            },
            _reNewline: /\r?\n/,
            type: 'text',
            fontSize: 40,
            fontWeight: 'normal',
            fontFamily: 'Times New Roman',
            textDecoration: '',
            textAlign: 'left',
            fontStyle: '',
            lineHeight: 1.3,
            textBackgroundColor: '',
            path: null,
            useNative: true,
            stateProperties: stateProperties,
            stroke: null,
            shadow: null,
            initialize: function(text, options) {
                options = options || {};
                this.text = text;
                this.__skipDimension = true;
                this.setOptions(options);
                this.__skipDimension = false;
                this._initDimensions();
            },
            _initDimensions: function() {
                if (this.__skipDimension) {
                    return;
                }
                var canvasEl = fabric.util.createCanvasElement();
                this._render(canvasEl.getContext('2d'));
            },
            toString: function() {
                return '#<fabric.Text (' + this.complexity() + '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
            },
            _render: function(ctx) {
                if (typeof Cufon === 'undefined' || this.useNative === true) {
                    this._renderViaNative(ctx);
                } else {
                    this._renderViaCufon(ctx);
                }
            },
            _renderViaNative: function(ctx) {
                var textLines = this.text.split(this._reNewline);
                this._setTextStyles(ctx);
                this.width = this._getTextWidth(ctx, textLines);
                this.height = this._getTextHeight(ctx, textLines);
                this.clipTo && fabric.util.clipContext(this, ctx);
                this._renderTextBackground(ctx, textLines);
                this._translateForTextAlign(ctx);
                this._renderText(ctx, textLines);
                if (this.textAlign !== 'left' && this.textAlign !== 'justify') {
                    ctx.restore();
                }
                this._renderTextDecoration(ctx, textLines);
                this.clipTo && ctx.restore();
                this._setBoundaries(ctx, textLines);
                this._totalLineHeight = 0;
            },
            _renderText: function(ctx, textLines) {
                ctx.save();
                this._setShadow(ctx);
                this._setupFillRule(ctx);
                this._renderTextFill(ctx, textLines);
                this._renderTextStroke(ctx, textLines);
                this._restoreFillRule(ctx);
                this._removeShadow(ctx);
                ctx.restore();
            },
            _translateForTextAlign: function(ctx) {
                if (this.textAlign !== 'left' && this.textAlign !== 'justify') {
                    ctx.save();
                    ctx.translate(this.textAlign === 'center' ? (this.width / 2) : this.width, 0);
                }
            },
            _setBoundaries: function(ctx, textLines) {
                this._boundaries = [];
                for (var i = 0, len = textLines.length; i < len; i++) {
                    var lineWidth = this._getLineWidth(ctx, textLines[i]),
                        lineLeftOffset = this._getLineLeftOffset(lineWidth);
                    this._boundaries.push({
                        height: this.fontSize * this.lineHeight,
                        width: lineWidth,
                        left: lineLeftOffset
                    });
                }
            },
            _setTextStyles: function(ctx) {
                this._setFillStyles(ctx);
                this._setStrokeStyles(ctx);
                ctx.textBaseline = 'alphabetic';
                if (!this.skipTextAlign) {
                    ctx.textAlign = this.textAlign;
                }
                ctx.font = this._getFontDeclaration();
            },
            _getTextHeight: function(ctx, textLines) {
                return this.fontSize * textLines.length * this.lineHeight;
            },
            _getTextWidth: function(ctx, textLines) {
                var maxWidth = ctx.measureText(textLines[0] || '|').width;
                for (var i = 1, len = textLines.length; i < len; i++) {
                    var currentLineWidth = ctx.measureText(textLines[i]).width;
                    if (currentLineWidth > maxWidth) {
                        maxWidth = currentLineWidth;
                    }
                }
                return maxWidth;
            },
            _renderChars: function(method, ctx, chars, left, top) {
                ctx[method](chars, left, top);
            },
            _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
                top -= this.fontSize / 4;
                if (this.textAlign !== 'justify') {
                    this._renderChars(method, ctx, line, left, top, lineIndex);
                    return;
                }
                var lineWidth = ctx.measureText(line).width,
                    totalWidth = this.width;
                if (totalWidth > lineWidth) {
                    var words = line.split(/\s+/),
                        wordsWidth = ctx.measureText(line.replace(/\s+/g, '')).width,
                        widthDiff = totalWidth - wordsWidth,
                        numSpaces = words.length - 1,
                        spaceWidth = widthDiff / numSpaces,
                        leftOffset = 0;
                    for (var i = 0, len = words.length; i < len; i++) {
                        this._renderChars(method, ctx, words[i], left + leftOffset, top, lineIndex);
                        leftOffset += ctx.measureText(words[i]).width + spaceWidth;
                    }
                } else {
                    this._renderChars(method, ctx, line, left, top, lineIndex);
                }
            },
            _getLeftOffset: function() {
                if (fabric.isLikelyNode) {
                    return 0;
                }
                return -this.width / 2;
            },
            _getTopOffset: function() {
                return -this.height / 2;
            },
            _renderTextFill: function(ctx, textLines) {
                if (!this.fill && !this._skipFillStrokeCheck) {
                    return;
                }
                this._boundaries = [];
                var lineHeights = 0;
                for (var i = 0, len = textLines.length; i < len; i++) {
                    var heightOfLine = this._getHeightOfLine(ctx, i, textLines);
                    lineHeights += heightOfLine;
                    this._renderTextLine('fillText', ctx, textLines[i], this._getLeftOffset(), this._getTopOffset() + lineHeights, i);
                }
            },
            _renderTextStroke: function(ctx, textLines) {
                if ((!this.stroke || this.strokeWidth === 0) && !this._skipFillStrokeCheck) {
                    return;
                }
                var lineHeights = 0;
                ctx.save();
                if (this.strokeDashArray) {
                    if (1 & this.strokeDashArray.length) {
                        this.strokeDashArray.push.apply(this.strokeDashArray, this.strokeDashArray);
                    }
                    supportsLineDash && ctx.setLineDash(this.strokeDashArray);
                }
                ctx.beginPath();
                for (var i = 0, len = textLines.length; i < len; i++) {
                    var heightOfLine = this._getHeightOfLine(ctx, i, textLines);
                    lineHeights += heightOfLine;
                    this._renderTextLine('strokeText', ctx, textLines[i], this._getLeftOffset(), this._getTopOffset() + lineHeights, i);
                }
                ctx.closePath();
                ctx.restore();
            },
            _getHeightOfLine: function() {
                return this.fontSize * this.lineHeight;
            },
            _renderTextBackground: function(ctx, textLines) {
                this._renderTextBoxBackground(ctx);
                this._renderTextLinesBackground(ctx, textLines);
            },
            _renderTextBoxBackground: function(ctx) {
                if (!this.backgroundColor) {
                    return;
                }
                ctx.save();
                ctx.fillStyle = this.backgroundColor;
                ctx.fillRect(this._getLeftOffset(), this._getTopOffset(), this.width, this.height);
                ctx.restore();
            },
            _renderTextLinesBackground: function(ctx, textLines) {
                if (!this.textBackgroundColor) {
                    return;
                }
                ctx.save();
                ctx.fillStyle = this.textBackgroundColor;
                for (var i = 0, len = textLines.length; i < len; i++) {
                    if (textLines[i] !== '') {
                        var lineWidth = this._getLineWidth(ctx, textLines[i]),
                            lineLeftOffset = this._getLineLeftOffset(lineWidth);
                        ctx.fillRect(this._getLeftOffset() + lineLeftOffset, this._getTopOffset() + (i * this.fontSize * this.lineHeight), lineWidth, this.fontSize * this.lineHeight);
                    }
                }
                ctx.restore();
            },
            _getLineLeftOffset: function(lineWidth) {
                if (this.textAlign === 'center') {
                    return (this.width - lineWidth) / 2;
                }
                if (this.textAlign === 'right') {
                    return this.width - lineWidth;
                }
                return 0;
            },
            _getLineWidth: function(ctx, line) {
                return this.textAlign === 'justify' ? this.width : ctx.measureText(line).width;
            },
            _renderTextDecoration: function(ctx, textLines) {
                if (!this.textDecoration) {
                    return;
                }
                var halfOfVerticalBox = this._getTextHeight(ctx, textLines) / 2,
                    _this = this;

                function renderLinesAtOffset(offset) {
                    for (var i = 0, len = textLines.length; i < len; i++) {
                        var lineWidth = _this._getLineWidth(ctx, textLines[i]),
                            lineLeftOffset = _this._getLineLeftOffset(lineWidth);
                        ctx.fillRect(_this._getLeftOffset() + lineLeftOffset, ~~((offset + (i * _this._getHeightOfLine(ctx, i, textLines))) - halfOfVerticalBox), lineWidth, 1);
                    }
                }
                if (this.textDecoration.indexOf('underline') > -1) {
                    renderLinesAtOffset(this.fontSize * this.lineHeight);
                }
                if (this.textDecoration.indexOf('line-through') > -1) {
                    renderLinesAtOffset(this.fontSize * this.lineHeight - this.fontSize / 2);
                }
                if (this.textDecoration.indexOf('overline') > -1) {
                    renderLinesAtOffset(this.fontSize * this.lineHeight - this.fontSize);
                }
            },
            _getFontDeclaration: function() {
                return [(fabric.isLikelyNode ? this.fontWeight : this.fontStyle), (fabric.isLikelyNode ? this.fontStyle : this.fontWeight), this.fontSize + 'px', (fabric.isLikelyNode ? ('"' + this.fontFamily + '"') : this.fontFamily)].join(' ');
            },
            render: function(ctx, noTransform) {
                if (!this.visible) {
                    return;
                }
                ctx.save();
                this._transform(ctx, noTransform);
                var m = this.transformMatrix,
                    isInPathGroup = this.group && this.group.type === 'path-group';
                if (isInPathGroup) {
                    ctx.translate(-this.group.width / 2, -this.group.height / 2);
                }
                if (m) {
                    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
                if (isInPathGroup) {
                    ctx.translate(this.left, this.top);
                }
                this._render(ctx);
                ctx.restore();
            },
            toObject: function(propertiesToInclude) {
                var object = extend(this.callSuper('toObject', propertiesToInclude), {
                    text: this.text,
                    fontSize: this.fontSize,
                    fontWeight: this.fontWeight,
                    fontFamily: this.fontFamily,
                    fontStyle: this.fontStyle,
                    lineHeight: this.lineHeight,
                    textDecoration: this.textDecoration,
                    textAlign: this.textAlign,
                    path: this.path,
                    textBackgroundColor: this.textBackgroundColor,
                    useNative: this.useNative
                });
                if (!this.includeDefaultValues) {
                    this._removeDefaultValues(object);
                }
                return object;
            },
            toSVG: function(reviver) {
                var markup = [],
                    textLines = this.text.split(this._reNewline),
                    offsets = this._getSVGLeftTopOffsets(textLines),
                    textAndBg = this._getSVGTextAndBg(offsets.lineTop, offsets.textLeft, textLines),
                    shadowSpans = this._getSVGShadows(offsets.lineTop, textLines);
                offsets.textTop += (this._fontAscent ? ((this._fontAscent / 5) * this.lineHeight) : 0);
                this._wrapSVGTextAndBg(markup, textAndBg, shadowSpans, offsets);
                return reviver ? reviver(markup.join('')) : markup.join('');
            },
            _getSVGLeftTopOffsets: function(textLines) {
                var lineTop = this.useNative ? this.fontSize * this.lineHeight : (-this._fontAscent - ((this._fontAscent / 5) * this.lineHeight)),
                    textLeft = -(this.width / 2),
                    textTop = this.useNative ? this.fontSize - 1 : (this.height / 2) - (textLines.length * this.fontSize) - this._totalLineHeight;
                return {
                    textLeft: textLeft + (this.group && this.group.type === 'path-group' ? this.left : 0),
                    textTop: textTop + (this.group && this.group.type === 'path-group' ? this.top : 0),
                    lineTop: lineTop
                };
            },
            _wrapSVGTextAndBg: function(markup, textAndBg, shadowSpans, offsets) {
                markup.push('<g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '">\n', textAndBg.textBgRects.join(''), '<text ', (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''), (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''), (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''), (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''), (this.textDecoration ? 'text-decoration="' + this.textDecoration + '" ' : ''), 'style="', this.getSvgStyles(), '" ', 'transform="translate(', toFixed(offsets.textLeft, 2), ' ', toFixed(offsets.textTop, 2), ')">', shadowSpans.join(''), textAndBg.textSpans.join(''), '</text>\n', '</g>\n');
            },
            _getSVGShadows: function(lineHeight, textLines) {
                var shadowSpans = [],
                    i, len, lineTopOffsetMultiplier = 1;
                if (!this.shadow || !this._boundaries) {
                    return shadowSpans;
                }
                for (i = 0, len = textLines.length; i < len; i++) {
                    if (textLines[i] !== '') {
                        var lineLeftOffset = (this._boundaries && this._boundaries[i]) ? this._boundaries[i].left : 0;
                        shadowSpans.push('<tspan x="', toFixed((lineLeftOffset + lineTopOffsetMultiplier) + this.shadow.offsetX, 2), ((i === 0 || this.useNative) ? '" y' : '" dy'), '="', toFixed(this.useNative ? ((lineHeight * i) - this.height / 2 + this.shadow.offsetY) : (lineHeight + (i === 0 ? this.shadow.offsetY : 0)), 2), '" ', this._getFillAttributes(this.shadow.color), '>', fabric.util.string.escapeXml(textLines[i]), '</tspan>');
                        lineTopOffsetMultiplier = 1;
                    } else {
                        lineTopOffsetMultiplier++;
                    }
                }
                return shadowSpans;
            },
            _getSVGTextAndBg: function(lineHeight, textLeftOffset, textLines) {
                var textSpans = [],
                    textBgRects = [],
                    lineTopOffsetMultiplier = 1;
                this._setSVGBg(textBgRects);
                for (var i = 0, len = textLines.length; i < len; i++) {
                    if (textLines[i] !== '') {
                        this._setSVGTextLineText(textLines[i], i, textSpans, lineHeight, lineTopOffsetMultiplier, textBgRects);
                        lineTopOffsetMultiplier = 1;
                    } else {
                        lineTopOffsetMultiplier++;
                    }
                    if (!this.textBackgroundColor || !this._boundaries) {
                        continue;
                    }
                    this._setSVGTextLineBg(textBgRects, i, textLeftOffset, lineHeight);
                }
                return {
                    textSpans: textSpans,
                    textBgRects: textBgRects
                };
            },
            _setSVGTextLineText: function(textLine, i, textSpans, lineHeight, lineTopOffsetMultiplier) {
                var lineLeftOffset = (this._boundaries && this._boundaries[i]) ? toFixed(this._boundaries[i].left, 2) : 0;
                textSpans.push('<tspan x="', lineLeftOffset, '" ', (i === 0 || this.useNative ? 'y' : 'dy'), '="', toFixed(this.useNative ? ((lineHeight * i) - this.height / 2) : (lineHeight * lineTopOffsetMultiplier), 2), '" ', this._getFillAttributes(this.fill), '>', fabric.util.string.escapeXml(textLine), '</tspan>');
            },
            _setSVGTextLineBg: function(textBgRects, i, textLeftOffset, lineHeight) {
                textBgRects.push('<rect ', this._getFillAttributes(this.textBackgroundColor), ' x="', toFixed(textLeftOffset + this._boundaries[i].left, 2), '" y="', toFixed((lineHeight * i) - this.height / 2, 2), '" width="', toFixed(this._boundaries[i].width, 2), '" height="', toFixed(this._boundaries[i].height, 2), '"></rect>\n');
            },
            _setSVGBg: function(textBgRects) {
                if (this.backgroundColor && this._boundaries) {
                    textBgRects.push('<rect ', this._getFillAttributes(this.backgroundColor), ' x="', toFixed(-this.width / 2, 2), '" y="', toFixed(-this.height / 2, 2), '" width="', toFixed(this.width, 2), '" height="', toFixed(this.height, 2), '"></rect>');
                }
            },
            _getFillAttributes: function(value) {
                var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
                if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
                    return 'fill="' + value + '"';
                }
                return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
            },
            _set: function(key, value) {
                if (key === 'fontFamily' && this.path) {
                    this.path = this.path.replace(/(.*?)([^\/]*)(\.font\.js)/, '$1' + value + '$3');
                }
                this.callSuper('_set', key, value);
                if (key in this._dimensionAffectingProps) {
                    this._initDimensions();
                    this.setCoords();
                }
            },
            complexity: function() {
                return 1;
            }
        });
        fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y dx dy font-family font-style font-weight font-size text-decoration text-anchor'.split(' '));
        fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;
        fabric.Text.fromElement = function(element, options) {
            if (!element) {
                return null;
            }
            var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES);
            options = fabric.util.object.extend((options ? fabric.util.object.clone(options) : {}), parsedAttributes);
            if ('dx' in parsedAttributes) {
                options.left += parsedAttributes.dx;
            }
            if ('dy' in parsedAttributes) {
                options.top += parsedAttributes.dy;
            }
            if (!('fontSize' in options)) {
                options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
            }
            if (!options.originX) {
                options.originX = 'left';
            }
            var text = new fabric.Text(element.textContent, options),
                offX = 0;
            if (text.originX === 'left') {
                offX = text.getWidth() / 2;
            }
            if (text.originX === 'right') {
                offX = -text.getWidth() / 2;
            }
            text.set({
                left: text.getLeft() + offX,
                top: text.getTop() - text.getHeight() / 2
            });
            return text;
        };
        fabric.Text.fromObject = function(object) {
            return new fabric.Text(object.text, clone(object));
        };
        fabric.util.createAccessors(fabric.Text);
    })(typeof exports !== 'undefined' ? exports : this);
}).call({}, window, document, html2canvas);;
var Utilities = function($options) {
    'use strict';
    this.di = {};
    this.settings = {
        speed: 375
    };
    if ($options) {
        $.extend(this.settings, $options);
    }
    this.injectDI = function($di) {
        this.di = $di;
    };
};
var FunctionGenerate = function() {
    'use strict';
};
String.prototype.capitalize = function() {
    'use strict';
    return this.charAt(0).toUpperCase() + this.slice(1);
};
String.prototype.toTitleCase = function(deslug) {
    'use strict';
    var smallWords = /^(a|an|and|as|at|but|by|en|for|if|in|nor|of|on|or|per|the|to|vs?\.?|via)$/i;
    var titleCase;
    titleCase = this.replace(/[A-Za-z0-9\u00C0-\u00FF]+[^\s-]*/g, function(match, index, title) {
        if (index && index + match.length !== title.length && match.search(smallWords) > -1 && title.charAt(index - 2) !== ':' && (title.charAt(index + match.length) !== '-' || title.charAt(index - 1) === '-') && title.charAt(index - 1).search(/[^\s-]/) < 0) {
            return match.toLowerCase();
        }
        if (match.substr(1).search(/[A-Z]|\../) > -1) {
            return match;
        }
        return match.charAt(0).toUpperCase() + match.substr(1);
    });
    if (deslug) {
        titleCase = titleCase.replace('-', ' ');
    }
    return titleCase;
};
Object.create = function(options) {
    'use strict';
    FunctionGenerate.prototype = options;
    return new FunctionGenerate();
};
Object.size = function(obj) {
    'use strict';
    var size = 0;
    var key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) {
            size += 1;
        }
    }
    return size;
};
if (!Object.keys) {
    Object.keys = (function() {
        'use strict';
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var hasDontEnumBug = !({
            toString: null
        }).propertyIsEnumerable('toString');
        var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
        var dontEnumsLength = dontEnums.length;
        return function(obj) {
            if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
                throw new TypeError('Object.keys called on non-object');
            }
            var result = [],
                prop, i;
            for (prop in obj) {
                if (hasOwnProperty.call(obj, prop)) {
                    result.push(prop);
                }
            }
            if (hasDontEnumBug) {
                for (i = 0; i < dontEnumsLength; i++) {
                    if (hasOwnProperty.call(obj, dontEnums[i])) {
                        result.push(dontEnums[i]);
                    }
                }
            }
            return result;
        };
    }());
}
Array.prototype.clean = function(deleteValue) {
    'use strict';
    var i;
    for (i = 0; i < this.length; i += 1) {
        if (this[i] === deleteValue) {
            this.splice(i, 1);
            i -= 1;
        }
    }
    return this;
};
if (!Array.prototype.filter) {
    Array.prototype.filter = function(func) {
        'use strict';
        var t = Object(this);
        var i;
        var len = t.length >>> 0;
        var res = [];
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        var val;
        if (this === void 0 || this === null) {
            throw new TypeError();
        }
        if (typeof func !== 'function') {
            throw new TypeError();
        }
        for (i = 0; i < len; i++) {
            if (i in t) {
                val = t[i];
                if (func.call(thisArg, val, i, t)) {
                    res.push(val);
                }
            }
        }
        return res;
    };
}
Utilities.prototype = {
    lazyLoad: function(src, doneCallback, failCallback) {
        'use strict';
        var done = doneCallback || function() {},
            fail = failCallback || function() {};
        $.ajax({
            cache: true,
            dataType: 'script',
            url: src
        }).done(done).fail(fail);
        return this;
    },
    addCurrent: function($currentItems) {
        'use strict';
        $currentItems.addClass('current');
        return this;
    },
    removeCurrent: function($currentItems) {
        'use strict';
        $currentItems.removeClass('current');
        return this;
    },
    openDropdown: function($dropdown, position, speed, openClass) {
        'use strict';
        var animationSpeed = speed || this.settings.speed;
        var self = this;
        var addClass = openClass || 'open';
        if ($dropdown.length) {
            $dropdown.css('top', position).slideDown(animationSpeed).addClass(addClass);
        }
        if (!$dropdown.hasClass('options')) {
            $(document).on('click', this, function(e) {
                if (!$(e.target).parents('.dropdown').length) {
                    self.closeDropdown($dropdown, animationSpeed, addClass);
                    $(document).not($dropdown).off('click');
                }
            });
        }
        return this;
    },
    closeDropdown: function($dropdown, speed, openClass) {
        'use strict';
        var animationSpeed = speed || this.settings.speed;
        var removeClass = openClass || 'open';
        if ($dropdown.length) {
            $dropdown.slideUp(animationSpeed).removeClass(removeClass);
        }
        return this;
    },
    openAccordion: function($accordionTitle, $accordion, speed, openClass) {
        'use strict';
        var animationSpeed = speed || this.settings.speed;
        var addClass = openClass || 'open';
        if ($accordionTitle.length && $accordion.length) {
            $accordionTitle.addClass(addClass);
            $accordion.slideDown(animationSpeed);
        }
        return this;
    },
    closeAccordion: function($accordionTitle, $accordion, speed, openClass) {
        'use strict';
        var animationSpeed = speed || this.settings.speed;
        var removeClass = openClass || 'open';
        if ($accordionTitle.length && $accordion.length) {
            $accordionTitle.removeClass(removeClass);
            $accordion.slideUp(animationSpeed);
        }
        return this;
    },
    addScrollbar: function($items, resize) {
        'use strict';
        var autoResize = true;
        if (resize !== undefined && resize !== null) {
            autoResize = resize;
        }
        $items.scrollbar({
            autoScrollSize: autoResize,
            autoUpdate: true,
            disableBodyScroll: false,
            ignoreMobile: false,
            ignoreOverlay: false
        });
        return this;
    },
    removeScrollbar: function($items) {
        'use strict';
        if ($items.data('scrollbar') !== undefined && $items.data('scrollbar') !== null) {
            $items.scrollbar('destroy');
        }
        return this;
    },
    evenColumnHeight: function($columns) {
        'use strict';
        var i;
        var len = $columns.length;
        var colHeight;
        var maxHeight = 0;
        for (i = 0; i < len; i += 1) {
            colHeight = $($columns[i]).outerHeight(true);
            if (colHeight > maxHeight) {
                maxHeight = colHeight;
            }
        }
        $columns.height(maxHeight);
        return this;
    },
    shadeColour: function(color, percent) {
        'use strict';
        var f = parseInt(color.slice(1), 16);
        var t;
        var p;
        var r = f >> 16;
        var g = f >> 8 & 0x00FF;
        var b = f & 0x0000FF;
        var red;
        var green;
        var blue;
        var equation;
        if (percent < 0) {
            t = 0;
            p = percent * -1;
        } else {
            t = 255;
            p = percent;
        }
        red = 0x1000000 + (Math.round((t - r) * p) + r) * 0x10000;
        green = (Math.round((t - g) * p) + g) * 0x100;
        blue = (Math.round((t - b) * p) + b);
        equation = (red + green + blue);
        return '#' + equation.toString(16).slice(1);
    },
    getMonthNumber: function(month, abbreviation) {
        'use strict';
        var shortNames = abbreviation || true;
        var returnMonth = null;
        var shortMonthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        if (shortNames) {
            returnMonth = shortMonthNames.indexOf(month);
        } else {
            returnMonth = monthNames.indexOf(month);
        }
        return returnMonth;
    },
    getMonthName: function(month, abbreviation) {
        'use strict';
        var shortNames = abbreviation || true;
        var returnMonth = '';
        var shortMonthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
            monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        if (shortNames) {
            returnMonth = shortMonthNames[month - 1];
        } else {
            returnMonth = monthNames[month - 1];
        }
        return returnMonth;
    },
    numberFormat: function(number, decimals, decPoint, thousandsSep) {
        'use strict';
        var point = '.';
        var sep = ',';
        var dec = 2;
        var parts = number;
        var formattedNumber = '-';
        if (parts !== undefined && parts !== null && parts !== '' && parts !== '-') {
            if (dec !== undefined) {
                dec = decimals;
            }
            parts = parseFloat(parts);
            if (parts.toString().indexOf('.') > -1) {
                parts = parts.toFixed(dec);
            }
            parts = parts.toString().split('.');
            if (decPoint !== undefined) {
                point = decPoint;
            }
            if (thousandsSep !== undefined) {
                sep = thousandsSep;
            }
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, sep);
            formattedNumber = parts.join(point);
        }
        return formattedNumber;
    },
    getShortNumber: function(num) {
        'use strict';
        var shortenedNum = num || '-';
        if (num !== undefined && num !== null) {
            switch (true) {
                case (num >= 1000000000):
                    shortenedNum = (num / 1000000000).toFixed(2).replace(/\.0+$/, '').replace(/(\.\d)0+$/, '$1') + 'B';
                    break;
                case (num >= 1000000):
                    shortenedNum = (num / 1000000).toFixed(2).replace(/\.0+$/, '').replace(/(\.\d)0+$/, '$1') + 'M';
                    break;
                case (num >= 1000):
                    shortenedNum = (num / 1000).toFixed(2).replace(/\.0+$/, '').replace(/(\.\d)0+$/, '$1') + 'K';
                    break;
                default:
                    shortenedNum = num.toFixed(2).replace(/\.0+$/, '').replace(/(\.\d)0+$/, '$1');
            }
        }
        return shortenedNum;
    },
    numToWord: function(num) {
        'use strict';
        var thousands = ['', 'thousand', 'million', 'billion', 'trillion', 'quadrillion'];
        var singleNumber = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
        var tenPlus = ['ten', 'eleven', 'twelve', 'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen'];
        var tens = ['twenty', 'thirty', 'forty', 'fifty', 'sixty', 'seventy', 'eighty', 'ninety'];
        var str;
        var strLength;
        var numbers;
        var result;
        var skip;
        var i;
        var decimalStringLength;
        var numWord = '';
        if (num !== undefined && num !== null) {
            str = num.toString().replace(/[, ]/g, '');
            if (str === parseFloat(str).toString()) {
                strLength = str.indexOf('.');
                if (strLength === -1) {
                    strLength = str.length;
                }
                numbers = str.split('');
                result = '';
                skip = 0;
                for (i = 0; i < strLength; i += 1) {
                    if ((strLength - i) % 3 === 2) {
                        if (numbers[i] === '1') {
                            result += tenPlus[Number(numbers[i + 1])] + ' ';
                            i += 1;
                            skip = 1;
                        } else if (numbers[i] !== 0) {
                            result += tens[numbers[i] - 2] + ' ';
                            skip = 1;
                        }
                    } else if (numbers[i] !== 0) {
                        result += singleNumber[numbers[i]] + ' ';
                        if ((strLength - i) % 3 === 0) {
                            result += 'hundred ';
                        }
                        skip = 1;
                    }
                    if ((strLength - i) % 3 === 1) {
                        if (skip) {
                            result += thousands[(strLength - i - 1) / 3] + ' ';
                            skip = 0;
                        }
                    }
                }
                if (strLength !== str.length) {
                    decimalStringLength = str.length;
                    result += 'point ';
                    for (i = strLength + 1; i < decimalStringLength; i += 1) {
                        result += singleNumber[numbers[i]] + ' ';
                    }
                }
                numWord = result.replace(/\s+/g, ' ');
            }
        }
        return numWord.trim();
    },
    getColumn: function(matrix, col) {
        'use strict';
        var column = [];
        var i;
        var len = matrix.length;
        for (i = 0; i < len; i += 1) {
            column.push(matrix[i][col]);
        }
        return column;
    },
    supportsDownloadAttr: function() {
        'use strict';
        var a = document.createElement('a');
        var returnBool = false;
        if (typeof a.download != 'undefined') {
            returnBool = true;
        }
        return returnBool;
    },
    supportsLocalStorage: function() {
        'use strict';
        return !!(window.localStorage && localStorage.setItem);
    },
    setLocalStorage: function(key, data) {
        'use strict';
        if (this.di.utilities().supportsLocalStorage() && key && data) {
            localStorage.setItem(key, JSON.stringify(data));
        }
        return this;
    },
    unsetLocalStorage: function(key) {
        'use strict';
        localStorage.removeItem(key);
        return this;
    },
    clearLocalStorage: function(excludes) {
        'use strict';
        var keys = Object.keys(localStorage);
        var i = keys.length;
        while (i--) {
            if (excludes.indexOf(keys[i]) < 0) {
                this.unsetLocalStorage(keys[i]);
            }
        }
        return this;
    },
    getLocalStorage: function(key) {
        'use strict';
        return JSON.parse(localStorage.getItem(key));
    },
    addEvent: function(event, elem, func) {
        'use strict';
        if (elem.addEventListener) {
            elem.addEventListener(event, func, false);
        } else if (elem.attachEvent) {
            elem.attachEvent('on' + event, func);
        } else {
            elem[event] = func;
        }
        return this;
    },
    removeEvent: function(event, elem, func) {
        'use strict';
        if (elem.removeEventListener) {
            elem.removeEventListener(event, func, true);
        } else if (elem.detachEvent) {
            elem.detachEvent('on' + event, func);
        }
        return this;
    },
    createCustomEvent: function(eventName, callback) {
        'use strict';
        if (document.addEventListener) {
            document.addEventListener(eventName, callback, false);
        } else {
            document.documentElement.attachEvent('onpropertychange', function(e) {
                if (e.propertyName === eventName) {
                    callback();
                }
            });
        }
        return this;
    },
    triggerCustomEvent: function(eventName) {
        'use strict';
        var event;
        if (document.createEvent) {
            event = document.createEvent('Event');
            event.initEvent(eventName, true, true);
            document.dispatchEvent(event);
        } else {
            event = document.documentElement[eventName];
            event += 1;
        }
        return this;
    },
    removeCustomEvent: function(eventName, callback) {
        'use strict';
        if (document.removeEventListener) {
            document.removeEventListener(eventName, callback, false);
        } else {
            document.documentElement.detachEvent('onpropertychange', callback);
        }
        return this;
    },
    trackAnalyticEvent: function(category, action, label) {
        'use strict';
        if (typeof ga !== 'undefined') {
            ga('send', 'event', category, action, label, {
                'page': this.di.hashURLs().getGaPageUrl(),
                'nonInteraction': 1
            });
        }
        return this;
    }
};;
var Indicators = function($options) {
    'use strict';
    this.di = {};
    this.settings = {
        defaultIndicatorsListTitle: '',
        dropdown: null,
        indicators: null,
        indicatorsHeading: null,
        indicatorsList: null,
        speed: 375,
        themes: null
    };
    if ($options) {
        $.extend(this.settings, $options);
    }
    if (typeof this.settings.indicatorsHeading === 'string') {
        this.settings.indicatorsHeading = $(this.settings.indicatorsHeading);
    }
    if (typeof this.settings.indicatorsList === 'string') {
        this.settings.indicatorsList = $(this.settings.indicatorsList);
    }
    if (typeof this.settings.themes === 'string') {
        this.settings.themes = $(this.settings.themes);
    }
    if (typeof this.settings.indicators === 'string') {
        this.settings.indicators = $(this.settings.indicators);
    }
    if (typeof this.settings.dropdown === 'string') {
        this.settings.dropdown = $(this.settings.dropdown);
    }
    this.injectDI = function($di) {
        this.di = $di;
    };
};
Indicators.prototype = {
    addCounter: function($counterItems, count) {
        'use strict';
        if (count) {
            $counterItems.find('> .item').addClass('counted');
        }
        return this;
    },
    removeCounter: function($counterItems) {
        'use strict';
        $counterItems.find('> .item').removeClass('counted');
        return this;
    },
    updateListTitle: function(counter) {
        'use strict';
        var suffix = '';
        if (counter > 1) {
            suffix = '(s)';
        }
        this.settings.indicatorsHeading.find('.title').text('Indicator' + suffix + ' selected');
        return this;
    },
    resetListTitle: function() {
        'use strict';
        this.settings.indicatorsHeading.find('.title').text(this.settings.defaultIndicatorsListTitle);
        return this;
    },
    clearAll: function(e, noHash) {
        'use strict';
        var self = this;
        var $currentItems = this.settings.themes.find('.indicator.current');
        this.di.utilities().removeCurrent($currentItems);
        this.removeCounter(this.settings.themes);
        if (noHash) {
            this.di.utilities().removeScrollbar(this.settings.indicatorsList.find('.dropdown-list ul'));
            this.settings.indicatorsList.empty();
            this.addPrompt(false);
        } else {
            this.settings.indicatorsList.fadeOut(this.settings.speed, function() {
                self.di.utilities().removeScrollbar($(this).find('.dropdown-list ul'));
                $(this).empty().fadeIn(0);
                self.di.hashURLs().removeHashType('indicator');
                self.di.hashURLs().setHash();
                self.addPrompt(false);
            }).promise();
        }
        $currentItems.find('.radio[data-range="single"]').trigger('click');
        $currentItems.find('.start-date .selected').data('value', '').html('Select a date <span class="icon filter-icon dropdown"></span>');
        $currentItems.find('.end-date .selected').data('value', '').html('End date: <span class="icon filter-icon dropdown"></span>');
        this.di.utilities().removeCurrent($currentItems.find('.dates.filter .option.current'));
        $('.disabled-by-datatype').removeClass('disabled-by-datatype');
        this.di.graphs().removeGraphTitle();
        this.resetListTitle();
        this.di.chart().reset(false, true);
        return this;
    },
    removeSort: function($item) {
        'use strict';
        if ($item.prev('.sort').length) {
            $item.prev('.sort').remove();
        } else if ($item.next('.sort').length) {
            $item.next('.sort').remove();
        }
        return this;
    },
    getCurrentThemes: function() {
        'use strict';
        var $indicators = this.getIndicatorsList(false);
        var i;
        var len = $indicators.length;
        var $indicator;
        var $indicatorsList = [];
        for (i = 0; i < len; i += 1) {
            $indicator = $($indicators[i]);
            $indicatorsList.push($indicator.data('indicator'));
        }
        return $indicatorsList;
    },
    getCurrentIndicators: function() {
        'use strict';
        var $indicators = this.getIndicatorsList(false);
        var i;
        var len = $indicators.length;
        var $indicator;
        var $indicatorsList = [];
        for (i = 0; i < len; i += 1) {
            $indicator = $($indicators[i]);
            if (!$indicator.hasClass('selected-disabled-by-datatype')) {
                $indicatorsList.push($indicator.data('indicator'));
            }
        }
        return $indicatorsList;
    },
    getAllIndicators: function(slug) {
        var $indicators = this.settings.indicators;
        var len = $indicators.length;
        var i;
        var $indicator;
        var $indicatorSlugs = [];
        if (slug) {
            for (i = 0; i < len; i += 1) {
                $indicator = $($indicators[i]);
                $indicatorSlugs.push($indicator.data('indicator'));
            }
            if ($indicatorSlugs.length) {
                $indicators = $indicatorSlugs;
            }
        }
        return $indicators;
    },
    getIndicatorsList: function(ignoreRemoving) {
        'use strict';
        var ignore = ignoreRemoving || false;
        var $indicatorsList;
        if (ignore) {
            $indicatorsList = this.settings.indicatorsList.find('.selected-indicator');
        } else {
            $indicatorsList = this.settings.indicatorsList.find('.selected-indicator:not(.removing)');
        }
        return $indicatorsList;
    },
    getIndicatorBySlugAndIndex: function(slug, index, ignoreRemoving, $list) {
        'use strict';
        var $indicators = $list || [];
        var ignore = ignoreRemoving || false;
        if (!$indicators.length) {
            $indicators = this.getIndicatorsList(ignore);
        }
        return $indicators.filter(function() {
            return ($(this).data('indicator') === slug && ((index === undefined) || (index !== undefined && $(this).data('index') === index)));
        }).first();
    },
    removeExtraIndicators: function() {
        'use strict';
        var $indicators = this.getIndicatorsList(false);
        var maximum = this.di.graphs().maximumIndicators;
        if (maximum && $indicators.length > maximum) {
            $indicators.slice(($indicators.length - maximum) * -1).addClass('removing').find('.close').trigger('click', [true]);
        }
        return this;
    },
    checkIndicatorsForDates: function() {
        var $indicators = this.settings.indicators;
        var i;
        var len = $indicators.length;
        var $indicator;
        var type = this.di.chart().type;
        var $dates;
        var invalidated = false;
        for (i = 0; i < len; i += 1) {
            $indicator = $($indicators[i]);
            $dates = $indicator.find('.dropdown.start-date li');
            if (type === 'time' && $dates.length < 2) {
                $indicator.addClass('disabled');
            } else {
                $indicator.removeClass('disabled');
            }
            if ($dates.length === 1) {
                $indicator.find('.radio[data-range!="single"]').hide();
            } else {
                $indicator.find('.radio[data-range!="single"]').show();
            }
            if (($indicator.hasClass('open') || $indicator.hasClass('current')) && ($indicator.hasClass('disabled'))) {
                invalidated = this.addPrompt('invalid');
            }
        }
        if (!invalidated) {
            this.removePrompt('invalid');
        }
        return this;
    },
    close: function(e, noReset) {
        'use strict';
        var self = this;
        var $elem = $(e.currentTarget);
        var $indicator = $elem.parents('.selected-indicator');
        var theme;
        var indicator;
        var indicatorIndex;
        var indicatorCount;
        var $theme;
        var $themeIndicator;
        var $themeIndicatorStartDate;
        var $themeIndicatorEndDate;
        var count;
        e.stopPropagation();
        if (!$indicator.length) {
            $indicator = $elem.parents('.indicator');
            theme = $indicator.parents('.theme').data('theme');
            indicator = $indicator.data('indicator');
            $indicator = this.getIndicatorsList(false).filter(function() {
                return ($(this).data('theme') === theme && $(this).data('indicator') === indicator);
            });
        } else {
            theme = $indicator.data('theme');
            indicator = $indicator.data('indicator');
            indicatorIndex = $indicator.data('index');
        }
        count = this.getIndicatorsList(false).filter(function() {
            return ($(this).data('theme') === theme && $(this).data('indicator') === indicator);
        }).length;
        $themeIndicator = this.settings.themes.find('.indicator.current').filter(function() {
            return ($(this).parents('.theme').data('theme') === theme && $(this).data('indicator') === indicator);
        });
        $themeIndicatorStartDate = $themeIndicator.find('.start-date');
        $themeIndicatorEndDate = $themeIndicator.find('.end-date');
        if (!indicatorIndex || count < 2) {
            this.di.utilities().removeCurrent($themeIndicator);
            $themeIndicator.find('.radio[data-range="single"]').trigger('click');
            $themeIndicatorStartDate.find('.selected').data('value', '').html('Select a date <span class="icon filter-icon dropdown"></span>');
            this.di.utilities().removeCurrent($themeIndicatorStartDate.find('.option.current'));
            $themeIndicatorEndDate.find('.selected').data('value', '').html('End date: <span class="icon filter-icon dropdown"></span>');
            this.di.utilities().removeCurrent($themeIndicatorEndDate.find('.option.current'));
        }
        $theme = this.settings.themes.filter(function() {
            return ($(this).data('theme') === theme);
        });
        indicatorCount = $theme.find('.indicator.current').length;
        this.removeCounter($theme);
        this.resetListTitle();
        if (indicatorCount) {
            this.addCounter($theme, indicatorCount);
            this.updateListTitle(indicatorCount);
        }
        $indicator.filter(function() {
            return (!indicatorIndex || $indicator.data('index') === indicatorIndex);
        }).addClass('removing').fadeOut(this.settings.speed, function() {
            var classes = '.indicator';
            if (indicatorIndex) {
                classes += '[data-index="' + indicatorIndex + '"]';
            }
            self.di.utilities().removeScrollbar($(this).find('.dropdown-list ul'));
            self.removeSort($(this));
            $(this).remove();
            self.di.graphs().removeTextFromGraphTitle(classes, 'indicator', indicator);
            if (!self.getIndicatorsList(false).length) {
                self.settings.indicatorsList.find('.btn.clear-all').remove();
            }
            self.di.hashURLs().removeHashPart('indicator', indicator, self.di.hashURLs().getHashPart('indicator')[indicatorIndex - 1]);
            self.di.hashURLs().setHash();
            if (!noReset) {
                self.di.chart().reset(false, true);
            }
            if ($('.selected-indicator').length && $('.selected-indicator.selected-disabled-by-datatype').length) {
                if (!$('.selected-indicator.selected-disabled-by-datatype').filter(function() {
                        return $('.indicator.current[data-indicator="' + $(this).data('indicator') + '"').data('datatype') === undefined || !$('.indicator.current[data-indicator="' + $(this).data('indicator') + '"').data('datatype').length;
                    }).length || !$('.selected-indicator.selected-disabled-by-datatype').filter(function() {
                        return $('.indicator.current[data-indicator="' + $(this).data('indicator') + '"').data('datatype') === '%';
                    }).length) {
                    $('.prompt[data-type="datatype"]').remove();
                    $('.selected-indicator.selected-disabled-by-datatype').removeClass('selected-disabled-by-datatype');
                }
            }
            self.processIndicators();
            self.addPrompt(false);
        }).promise();
        if (!$('.indicator.current').length) {
            $('.disabled-by-datatype').removeClass('disabled-by-datatype');
        }
        return this;
    },
    editSelectedIndicator: function(e, stayOpen) {
        'use strict';
        var $elem = $(e.currentTarget).parents('.selected-indicator');
        e.stopPropagation();
        if ($elem.find('.options').hasClass('open') && !stayOpen) {
            $elem.removeClass('open');
            this.di.utilities().closeDropdown($elem.find('.options'));
        } else {
            $elem.addClass('open');
            if (this.di.chart().type === 'time') {
                $elem.find('.data-range').slideUp();
            }
            this.di.utilities().openDropdown($elem.find('.options'));
            this.di.utilities().addScrollbar($elem.find('.dropdown-list ul:not(.scroll-content)'));
        }
        return this;
    },
    dropdownSlide: function(e) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $dropdown = $elem.siblings('.dropdown-list');
        var filterHeight = $elem.parents('.filter').height();
        e.stopPropagation();
        if ($dropdown.hasClass('open')) {
            this.di.utilities().closeDropdown($dropdown);
        } else {
            this.di.utilities().closeDropdown($elem.parents('.indicator').find('.dropdown-list'));
            this.di.utilities().openDropdown($dropdown, filterHeight);
            $dropdown.find('.current').focus();
        }
        return this;
    },
    dropdownUpdate: function(e) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $dropdown = $elem.parents('.dropdown-list');
        var $filter = $elem.parents('.filter');
        var $selected = $dropdown.siblings('.selected');
        var $iconSpan = $selected.find('.filter-icon');
        var startDate = $elem.data('value');
        var endDate;
        var testStartDate;
        var testEndDate;
        e.stopPropagation();
        if (!$elem.hasClass('disabled') && !$elem.hasClass('disabled-by-graph') && !$elem.hasClass('disabled-by-datatype')) {
            this.di.utilities().removeCurrent($elem.siblings('.current')).addCurrent($elem);
            $selected.html($elem.text() + $iconSpan.clone().wrapAll('<div></div>').parent().html()).data('value', startDate).attr('data-value', startDate);
            this.di.utilities().closeDropdown($dropdown);
            if (!$filter.siblings('.data-range').is('visible') && this.di.chart().type !== 'time') {
                $filter.siblings('.data-range').slideDown(this.settings.speed);
            }
            if (!$filter.find('.dropdown.end-date .dropdown-list').length) {
                this.getEndDates($elem.parents('.filter'));
            } else {
                if ($elem.parents('.dropdown').hasClass('end-date')) {
                    endDate = startDate;
                    startDate = $filter.find('.dropdown.start-date .selected').data('value');
                } else {
                    endDate = $filter.find('.dropdown.end-date .selected').data('value');
                    this.getEndDates($filter);
                }
                testStartDate = startDate.toString().split('-');
                testEndDate = endDate.toString().split('-');
                if (testStartDate[0].length < 2 && testStartDate[0].length) {
                    testStartDate[0] = '0' + testStartDate[0];
                }
                if (testEndDate[0].length < 2 && testEndDate[0].length) {
                    testEndDate[0] = '0' + testEndDate[0];
                }
                testStartDate = testStartDate.reverse().join('');
                testEndDate = testEndDate.reverse().join('');
                if (endDate && parseInt(testStartDate, 10) > parseInt(testEndDate, 10)) {
                    this.di.utilities().removeCurrent($filter.find('.dropdown.end-date li'));
                    $filter.find('.dropdown.end-date .selected').data('value', '').html('End date: <span class="icon filter-icon dropdown"></span>');
                }
            }
        }
        return this;
    },
    radioSelect: function(e) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $datesFilter = $elem.parent().siblings('.dates');
        if (!$elem.hasClass('disabled') && !$elem.hasClass('disabled-by-graph') && !$elem.hasClass('disabled-by-datatype')) {
            $elem.siblings('.on').addClass('off').removeClass('on');
            $elem.addClass('on').removeClass('off');
            if ($elem.data('range') === 'actual' || $elem.data('range') === 'change') {
                $datesFilter.addClass('show-end');
                if (!$datesFilter.find('.dropdown.start-date .selected').data('value')) {
                    $datesFilter.find('.dropdown.start-date .selected').data('value', '').html('Start date: <span class="icon filter-icon dropdown"></span>');
                }
            } else {
                $datesFilter.removeClass('show-end');
                if (!$datesFilter.find('.dropdown.start-date .selected').data('value')) {
                    $datesFilter.find('.dropdown.start-date .selected').data('value', '').html('Select a date <span class="icon filter-icon dropdown"></span>');
                }
                this.di.utilities().removeCurrent($datesFilter.find('.dropdown.end-date li'));
                $datesFilter.find('.dropdown.end-date .selected').data('value', '').html('End date: <span class="icon filter-icon dropdown"></span>');
            }
        }
        return this;
    },
    themeSlide: function(e) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $theme = $elem.parents('.theme');
        var $indicators = $theme.find('.indicators');
        var $openThemes = $theme.parent().find('.theme.open');
        if ($theme.hasClass('open')) {
            this.di.utilities().closeAccordion($theme, $indicators);
        } else {
            this.di.utilities().closeAccordion($openThemes, $openThemes.find('.indicators'));
            this.di.utilities().openAccordion($theme, $indicators);
        }
        return this;
    },
    getDateString: function(startDate, endDate) {
        'use strict';
        var string;
        var start = [];
        var end = [];
        if (startDate) {
            start = startDate.toString().split('-');
        }
        if (endDate) {
            end = endDate.toString().split('-');
        }
        if (start[0] && start[1]) {
            start[0] = this.di.utilities().getMonthName(start[0]) + ' ';
        } else {
            start[1] = '';
        }
        if (end[0] && end[1]) {
            end[0] = this.di.utilities().getMonthName(end[0]) + ' ';
        } else {
            end[1] = '';
        }
        start = start[0] + start[1];
        end = end[0] + end[1];
        string = start;
        if (endDate) {
            string += '&ndash;' + end;
        }
        return string;
    },
    getDateValues: function($dates, current) {
        'use strict';
        var $date;
        var $dateValue;
        var dateObj;
        var $values = [];
        var i;
        var len = $dates.length;
        var currentDate = current || null;
        var currentDateObj = null;
        if (currentDate) {
            currentDateObj = this.createDateObject(currentDate);
        }
        for (i = 0; i < len; i += 1) {
            $date = $($dates[i]);
            $dateValue = $date.data('value');
            dateObj = this.createDateObject($dateValue);
            if (currentDateObj && dateObj > currentDateObj) {
                $values.push({
                    text: $date.text(),
                    value: $date.data('value')
                });
            }
        }
        return $values;
    },
    createDateObject: function(date) {
        'use strict';
        var dateArray;
        var dateObj;
        if (date.toString().indexOf('-') > -1) {
            dateArray = date.toString().split('-');
        } else {
            dateArray = [date];
        }
        if (dateArray.length === 1) {
            dateArray.unshift('1');
        }
        if (dateArray.length === 2) {
            dateArray.unshift('1');
        }
        dateObj = new Date(dateArray[2], dateArray[1], dateArray[0]);
        return dateObj;
    },
    getEndDates: function($indicator) {
        'use strict';
        var $start = $indicator.find('.dropdown.start-date');
        var $startDates = $start.find('ul li');
        var current = $start.find('.selected').data('value');
        var $startDateValues = this.getDateValues($startDates, current);
        var $end = $indicator.find('.dropdown.end-date');
        var $endDate;
        var endI;
        var endLen = $startDateValues.length;
        var currentEnd;
        var classes;
        if (!endLen) {
            $startDateValues.push({
                text: 'Select earlier start date',
                value: ''
            });
            endLen = $startDateValues.length;
        }
        if (current && $startDateValues) {
            currentEnd = $end.find('.selected').data('value');
            this.di.utilities().removeScrollbar($end.find('ul'));
            $end.find('ul').remove();
            $end.find('.dropdown-list-wrapper').append('<ul></ul>');
            $end = $end.find('.dropdown-list-wrapper ul');
            for (endI = 0; endI < endLen; endI += 1) {
                $endDate = $startDateValues[endI];
                classes = '';
                if ($endDate.value !== '' && $endDate.value === currentEnd) {
                    classes += ' current';
                }
                if ($endDate.value === '') {
                    classes += ' disabled';
                }
                $end.append('<li class="option' + classes + '" data-value="' + $endDate.value + '">' + $endDate.text + '</li>');
            }
            this.di.utilities().addScrollbar($indicator.find('.dropdown-list ul:not(.scroll-content)'));
        }
        return this;
    },
    addIndicator: function($indicator, theme, indicator, replacement) {
        'use strict';
        var $selectedIndicator;
        var dataType = $indicator.data('datatype');
        var range = $indicator.find('.radio.on').data('range');
        var startDate = $indicator.find('.start-date .selected').data('value');
        var endDate = $indicator.find('.end-date .selected').data('value');
        var dateText = this.getDateString(startDate, endDate);
        var dataRange = $indicator.find('.radio.on .name').text().replace(' over time', '');
        var index = this.getIndicatorsList().length + 1;
        var date;
        if (range !== 'single' && endDate === '') {
            range = 'single';
            $indicator.find('.radio.on').removeClass('on').addClass('off');
            $indicator.find('.radio[data-range="single"]').removeClass('off').addClass('on');
            dataRange = $indicator.find('.radio.on .name').text().replace(' over time', '');
        }
        if (range === 'single') {
            endDate = '';
            $indicator.find('.end-date .selected').attr('data-value', '').html('End date: <span class="icon filter-icon dropdown"></span>');
            this.di.utilities().removeCurrent($indicator.find('.end-date .option.current'));
            dateText = this.getDateString(startDate, endDate);
        }
        if (range === 'change') {
            dataType = '';
        }
        if (range === 'actual' && dataType === '%') {
            dataType = '';
        }
        if (dataType) {
            dataType = ' <span class="datatype">(' + dataType + ')</span>';
        }
        this.di.utilities().addCurrent($indicator);
        this.settings.indicatorsList.find('.btn.clear-all').remove();
        if (!replacement || replacement === 1) {
            $selectedIndicator = $('<div class="selected-indicator" data-theme="' + theme + '" data-indicator="' + indicator + '" data-index="' + index + '" data-datatype="' + $indicator.data('datatype') + '"/>');
            $selectedIndicator.append('<div class="indicator-info"><span class="title"><span class="name">' + $indicator.find('.title .name').text() + '</span>' + dataType + '</span></div>');
            if (dataRange.toLowerCase() !== 'single date') {
                $selectedIndicator.find('.indicator-info').append('<span class="data-range-text">' + dataRange + '</span>');
            }
            $selectedIndicator.find('.indicator-info').append('<span class="date-text">' + dateText + '</span>');
            $selectedIndicator.append('<div class="indicator-actions"><span class="icon indicator-icon close"><span></span></span><span class="btn edit">Edit</span></div>');
            $selectedIndicator.append('<div class="clear"></div>');
            $selectedIndicator = this.copyDataToIndicator($indicator, $selectedIndicator);
            if (this.getIndicatorsList(false).length && $selectedIndicator !== null) {
                this.settings.indicatorsList.append('<a class="icon indicator-icon sort"></a>');
            }
            this.settings.indicatorsList.append($selectedIndicator);
        } else if (replacement === 2) {
            $selectedIndicator = this.getIndicatorBySlugAndIndex(indicator, $indicator.data('index'), true, []);
            if (dataRange.toLowerCase() === 'single date') {
                $selectedIndicator.find('.data-range-text').remove();
            } else {
                if (!$selectedIndicator.find('.data-range-text').length) {
                    $selectedIndicator.find('.indicator-info .title').after('<span class="data-range-text">' + dataRange + '</span>');
                } else {
                    $selectedIndicator.find('.data-range-text').text(dataRange);
                }
            }
            $selectedIndicator.find('.date-text').html(dateText);
        }
        date = this.di.hashURLs().getIndicatorHashDate($indicator);
        if ($indicator.data('index') !== undefined) {
            this.di.hashURLs().replaceHashPartByIndex('indicator', $indicator.data('index') - 1, $selectedIndicator.data('indicator'), {
                date: date,
                range: range
            });
        } else {
            this.di.hashURLs().setHashPart('indicator', $selectedIndicator.data('indicator'), {
                date: date,
                range: range
            });
        }
        this.di.hashURLs().setHash();
        if (this.getIndicatorsList(false).length) {
            this.settings.indicatorsList.append('<a class="btn clear-all">Clear all</a>');
        }
        this.di.graphs().buildGraphTitle();
        if ($('.selected-indicator.selected-disabled-by-datatype').length && $('.selected-indicator').length > $('.selected-indicator.selected-disabled-by-datatype').length) {
            $('.selected-indicator.selected-disabled-by-datatype').find('.close').trigger('click');
        }
        return this;
    },
    copyDataToIndicator: function($selectedIndicator, $indicator) {
        'use strict';
        var $optionsToCopy = $selectedIndicator.find('.options');
        var $options;
        this.di.utilities().removeScrollbar($optionsToCopy.find('.dropdown-list ul'));
        $options = $optionsToCopy.clone(true, true).removeAttr('style').removeClass('open');
        $indicator.find('.options').remove();
        $indicator.append($options);
        if (this.di.chart().type === 'time') {
            $indicator.find('.data-range').slideUp();
        } else {
            $indicator.find('.data-range').slideDown();
        }
        return $indicator;
    },
    getGraphDataOpts: function() {
        'use strict';
        var $themeContainer = {};
        var $indicators = this.settings.indicatorsList.find('.selected-indicator:not(.removing)');
        var i;
        var len = $indicators.length;
        var $indicator;
        var theme;
        var endDate;
        var $cities = this.di.cities().getSelectedCities();
        var hasEndDates = false;
        var indicatorObj = {};
        for (i = 0; i < len; i += 1) {
            $indicator = $($indicators[i]);
            theme = $indicator.data('theme');
            endDate = $indicator.find('.end-date .selected').attr('data-value');
            if ($themeContainer[theme] === undefined) {
                $themeContainer[theme] = {};
            }
            if (!hasEndDates) {
                hasEndDates = (endDate !== undefined && endDate !== null && endDate !== '');
            }
            indicatorObj = {
                endDate: endDate,
                index: $indicator.attr('data-index'),
                range: $indicator.find('.radio.on').attr('data-range') || 'single',
                startDate: $indicator.find('.start-date .selected').attr('data-value')
            };
            if (!$themeContainer[$indicator.data('theme')][$indicator.data('indicator')]) {
                $themeContainer[$indicator.data('theme')][$indicator.data('indicator')] = [];
            }
            $themeContainer[$indicator.data('theme')][$indicator.data('indicator')].push(indicatorObj);
        }
        return {
            cities: $cities,
            hasEndDates: hasEndDates,
            themeContainer: $themeContainer
        };
    },
    processIndicators: function() {
        'use strict';
        this.di.graphs().addLoading();
        this.checkIndicatorsForDates();
        this.disableUnselectedIndicators($('.graph-tabs .current').data('graph'));
        this.disableDataTypeIndicators($('.graph-tabs .current').data('graph'));
        if (!$.isEmptyObject(this.di.chart()) && typeof this.di.chart().getGraphData === 'function') {
            this.di.chart().getGraphData(this.getGraphDataOpts());
        }
        return this;
    },
    indicatorLoad: function(e, setFromHash) {
        'use strict';
        var $selectedIndicator;
        var $indicator = $(e.currentTarget).parent().parent();
        var current = $indicator.hasClass('current');
        var theme = $indicator.parents('.theme').data('theme');
        var indicator = $indicator.data('indicator');
        var index = $indicator.data('index');
        var indicatorCount;
        var $theme;
        var $selectedIndicators = this.getIndicatorsList(false);
        var $removal = $selectedIndicators.filter(function() {
            return ($(this).data('indicator') !== indicator);
        }).slice(0, 1);
        var selectedList = false;
        var endDate = $indicator.find('.end-date .selected').data('value');
        if ($indicator.find('.start-date .selected').data('value') !== '') {
            if ($indicator.hasClass('selected-indicator')) {
                $selectedIndicator = $indicator;
                $indicator = this.settings.themes.find('.indicator[data-indicator="' + $selectedIndicator.data('indicator') + '"]');
                this.copyDataToIndicator($selectedIndicator, $indicator);
                selectedList = true;
                current = true;
                theme = $indicator.parents('.theme').data('theme');
                indicator = $indicator.data('indicator');
                $removal = $selectedIndicators.filter(function() {
                    return ($(this).data('indicator') === indicator && $(this).data('index') === index);
                }).slice(0, 1);
                endDate = $selectedIndicator.find('.end-date .selected').data('value');
            }
            if (current) {
                if (selectedList || (this.di.chart().maximumIndicators && $selectedIndicators.length >= this.di.chart().maximumIndicators)) {
                    if ($selectedIndicator !== undefined) {
                        this.addIndicator($selectedIndicator, theme, indicator, 2);
                    } else {
                        this.addIndicator($indicator, theme, indicator, 2);
                    }
                } else {
                    this.addIndicator($indicator, theme, indicator, false);
                }
                this.removePrompt('indicators');
            } else if (this.di.chart().maximumIndicators && $selectedIndicators.length >= this.di.chart().maximumIndicators) {
                $removal.find('.close').trigger('click', [true]);
                this.addIndicator($indicator, theme, indicator, 1);
                this.removePrompt('indicators');
            } else {
                this.addIndicator($indicator, theme, indicator, false);
                this.removePrompt('indicators');
            }
            $theme = this.settings.themes.filter(function() {
                return ($(this).data('theme') === theme);
            });
            indicatorCount = $theme.find('.indicators > .current').length;
            this.removeCounter(this.settings.themes);
            this.resetListTitle();
            if (indicatorCount) {
                this.addCounter($theme, indicatorCount);
                this.updateListTitle(indicatorCount);
            }
            if (selectedList) {
                $selectedIndicator.find('.edit').trigger('click', [false]);
            } else {
                $indicator.find('.title').trigger('click', [true]);
                this.di.utilities().closeAccordion($theme, $theme.find('.indicators'));
            }
            $indicator.find('.radio[data-range="single"]').trigger('click');
            $indicator.find('.start-date .selected').data('value', '').html('Select a date <span class="icon filter-icon dropdown"></span>');
            this.di.utilities().removeCurrent($indicator.find('.start-date .option.current'));
            $indicator.find('.end-date .selected').data('value', '').html('End date: <span class="icon filter-icon dropdown"></span>');
            if (endDate === '' && this.di.chart().type === 'time') {
                this.addPrompt('endDate');
            } else {
                this.removePrompt('endDate');
            }
            if (!setFromHash) {
                this.processIndicators();
            }
        }
        return this;
    },
    indicatorSelect: function(e, triggered) {
        'use strict';
        var $elem = $(e.currentTarget).parent('li');
        var chartType = this.di.chart().type;
        var $indicators = this.getAllIndicators();
        e.stopPropagation();
        if (chartType === 'stacked-bar') {
            $indicators.removeClass('disabled-by-datatype');
            if ($elem.data('datatype') === '%') {
                $indicators.filter(function() {
                    return $(this).data('datatype') === undefined || !$(this).data('datatype').length;
                }).addClass('disabled-by-datatype');
            } else if ($elem.data('datatype') === undefined || !$elem.data('datatype').length) {
                $indicators.filter(function() {
                    return $(this).data('datatype') === '%';
                }).addClass('disabled-by-datatype');
            }
        } else {
            $indicators.removeClass('disabled-by-datatype');
        }
        if ((!$elem.hasClass('disabled') && !$elem.hasClass('disabled-by-graph') && !$elem.hasClass('disabled-by-datatype')) || triggered) {
            if (!triggered) {
                $elem.siblings('.open').find('.title').trigger('click', [true]);
            }
            if ($elem.hasClass('open')) {
                $elem.find('.options').slideUp(this.settings.speed, function() {
                    $elem.removeClass('open');
                });
            } else {
                $elem.addClass('open').find('.options').slideDown(this.settings.speed);
                this.di.utilities().addScrollbar($elem.find('.dropdown-list ul:not(.scroll-content)'));
            }
        }
        return this;
    },
    indicatorSort: function(e) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $prev = $elem.prev('.selected-indicator');
        var $next = $elem.next('.selected-indicator');
        var nextIndex = $next.data('index') || 1;
        var prevIndex = $prev.data('index') || 1;
        var prevOpts = {
            date: this.di.hashURLs().getIndicatorHashDate($prev),
            range: $prev.find('.radio.on .name').text().replace(' over time', '').replace('Single date', 'single'),
            indicator: $prev.data('indicator')
        };
        var nextOpts = {
            date: this.di.hashURLs().getIndicatorHashDate($next),
            range: $next.find('.radio.on .name').text().replace(' over time', '').replace('Single date', 'single'),
            indicator: $next.data('indicator')
        };
        if ($prev.length && $next.length) {
            $prev.data('index', nextIndex).attr('data-index', nextIndex);
            $next.data('index', prevIndex).attr('data-index', prevIndex);
            $next.after($prev);
            $elem.before($next);
            this.di.hashURLs().switchHashParts('indicator', $prev.data('indicator'), $next.data('indicator'), prevOpts, nextOpts);
            this.di.hashURLs().setHash();
        } else {
            $elem.remove();
        }
        this.processIndicators();
        return this;
    },
    hoverInfo: function(e) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $tooltip = $elem.find('.info-tooltip');
        if (!$elem.hasClass('ignore')) {
            if (e.type === 'mouseover') {
                $tooltip.css('top', ($elem[0].offsetTop - 1) + $elem.outerHeight()).stop().fadeIn(this.settings.speed);
            } else {
                $tooltip.stop().fadeOut({
                    duration: this.settings.speed,
                    progress: function(anim, progress) {
                        if (progress > 0.89) {
                            $elem.addClass('ignore');
                        }
                    },
                    done: function() {
                        $elem.removeClass('ignore');
                    }
                });
            }
        }
        return this;
    },
    addPrompt: function(type) {
        'use strict';
        var currentCount = this.getIndicatorsList(false).length;
        var minCount = this.di.chart().minimumIndicators;
        var diffCount = minCount - currentCount;
        var message = '';
        var promptType = type || 'indicators';
        var response = false;
        if (promptType === 'datatype') {
            message = 'The selected indicators are not comparable for this chart type.<br/>Please select indicators within a single theme.';
        } else if (promptType === 'indicators') {
            switch (diffCount) {
                case 1:
                    if (currentCount === 1) {
                        message = 'Select a SECOND indicator<br/>to view data';
                    } else if (currentCount === 2) {
                        message = 'Select a THIRD indicator<br/>to view data';
                    } else {
                        message = 'Select an indicator<br/>to view data';
                    }
                    break;
                case 2:
                    if (currentCount === 0) {
                        message = 'Select a FIRST and SECOND indicator<br/>to view data';
                    } else {
                        message = 'Select a SECOND and THIRD indicator<br/>to view data';
                    }
                    break;
                case 3:
                    message = 'Select a FIRST, SECOND and THIRD indicator<br/>to view data';
                    break;
                default:
                    if (!diffCount && currentCount !== 0) {
                        response = false;
                    } else {
                        message = 'Select an indicator<br/>to view data';
                    }
            }
        } else if (promptType === 'date') {
            message = 'Select the date to filter date';
        } else if (promptType === 'invalid') {
            message = $('.graph-tabs .current span:last').text() + ' is not available for this indicator.<br/>Please clear the indicator and choose another.';
        } else if (promptType === 'endDate') {
            message = 'Select the end date to see data';
        } else if (promptType === 'percentage') {
            message = "THE SELECTED INDICATORS CAN'T BE USED <br/>AT THE SAME TIME ON A STACKED BAR";
        }
        if (message !== '' && (currentCount < minCount || promptType === 'invalid' || promptType === 'endDate') || promptType === 'datatype') {
            this.removePrompt('all');
            $('.prompt').remove();
            response = this.di.prompts().add(promptType, message);
        }
        return response;
    },
    removePrompt: function(type) {
        'use strict';
        var currentCount = this.getIndicatorsList(false).length;
        var minCount = this.di.chart().minimumIndicators;
        var diffCount = minCount - currentCount;
        var promptType = type || 'indicators';
        var response = false;
        if (promptType === 'indicators') {
            if (!diffCount && currentCount !== 0) {
                response = this.di.prompts().remove(promptType);
            } else {
                this.di.prompts().remove(promptType);
                response = this.addPrompt(promptType);
            }
        } else {
            response = this.di.prompts().remove(promptType);
        }
        return response;
    },
    setFromHash: function(indicators) {
        'use strict';
        var i = indicators.length;
        var indicatorOptions;
        var $indicator;
        var range;
        var date;
        this.clearAll({}, true);
        while (i > 0) {
            indicatorOptions = indicators.shift();
            $indicator = this.settings.themes.find('.indicator[data-indicator="' + indicatorOptions.indicator + '"]');
            range = indicatorOptions.range;
            date = indicatorOptions.date;
            if (date) {
                date = date.split(this.di.hashURLs().settings.dateSeparator);
            } else {
                date = [date];
            }
            if ($indicator.length > 0) {
                $indicator.find('.options .start-date .option[data-value="' + date[0] + '"]').trigger('click');
                if (date.length > 1) {
                    $indicator.find('.options .data-range .radio[data-range="' + range + '"]').trigger('click');
                    $indicator.find('.options .end-date .option[data-value="' + date[1] + '"]').trigger('click');
                }
                $indicator.find('> .title').trigger('click').delay(0);
                $indicator.find('.options .btn.apply').trigger('click', true);
            }
            i -= 1;
        }
        this.processIndicators();
        return this;
    },
    disableUnselectedIndicators: function(graphSlug) {
        'use strict';
        var $indicators = this.getAllIndicators();
        var len = $indicators.length;
        var i;
        var $indicatorGraphs;
        for (i = 0; i < len; i++) {
            $indicatorGraphs = $($indicators[i]).data('graphs');
            if (!$indicatorGraphs.hasOwnProperty(graphSlug)) {
                if ($($indicators[i]).hasClass('current')) {
                    $('.selected-indicator[data-indicator="' + $($indicators[i]).data('indicator') + '"').find('.indicator-icon.close').trigger('click');
                }
                $($indicators[i]).addClass('disabled-by-graph');
            } else {
                $($indicators[i]).removeClass('disabled-by-graph');
            }
        }
    },
    disableDataTypeIndicators: function(graphSlug) {
        'use strict';
        var $indicators = this.getAllIndicators();
        var $currentIndicators = $('.indicator.current');
        var $percentIndicators;
        var $actualIndicators;
        if (graphSlug === 'stacked-bar') {
            if ($currentIndicators.length) {
                $actualIndicators = $currentIndicators.filter(function() {
                    return $(this).data('datatype') === undefined || !$(this).data('datatype').length;
                });
                $percentIndicators = $currentIndicators.filter(function() {
                    return $(this).data('datatype') === '%';
                });
                if ($actualIndicators.length && $percentIndicators.length) {
                    this.addPrompt('datatype');
                    $('.selected-indicator').addClass('selected-disabled-by-datatype');
                    $('.disabled-by-datatype').removeClass('disabled-by-datatype');
                } else if ($actualIndicators.length) {
                    $indicators.filter(function() {
                        return $(this).data('datatype') === '%';
                    }).addClass('disabled-by-datatype');
                } else if ($percentIndicators.length) {
                    $indicators.filter(function() {
                        return $(this).data('datatype').undefined || !$(this).data('datatype').length;
                    }).addClass('disabled-by-datatype');
                }
            } else {
                $('.disabled-by-datatype').removeClass('disabled-by-datatype');
                $('.selected-disabled-by-datatype').removeClass('selected-disabled-by-datatype');
            }
        } else {
            $('.disabled-by-datatype').removeClass('disabled-by-datatype');
            $('.selected-disabled-by-datatype').removeClass('selected-disabled-by-datatype');
        }
    },
    runEvents: function() {
        'use strict';
        this.settings.indicatorsList.off('click', '.clear-all').on('click', '.clear-all', $.proxy(this.clearAll, this));
        this.settings.indicatorsList.off('click', '.indicator-icon.close').on('click', '.indicator-icon.close', $.proxy(this.close, this));
        this.settings.themes.off('click', '.indicator-icon.close').on('click', '.indicator-icon.close', $.proxy(this.close, this));
        this.settings.indicatorsList.off('click', '.edit').on('click', '.edit', $.proxy(this.editSelectedIndicator, this));
        this.settings.indicatorsList.off('click', '.dropdown .selected').on('click', '.dropdown .selected', $.proxy(this.dropdownSlide, this));
        this.settings.themes.off('click', '.dropdown .selected').on('click', '.dropdown .selected', $.proxy(this.dropdownSlide, this));
        this.settings.indicatorsList.off('click', '.dropdown-list li').on('click', '.dropdown-list li', $.proxy(this.dropdownUpdate, this));
        this.settings.themes.off('click', 'dropdown-list li').on('click', '.dropdown-list li', $.proxy(this.dropdownUpdate, this));
        this.settings.indicatorsList.off('click', '.data-range > .radio').on('click', '.data-range > .radio:not(.disabled)', $.proxy(this.radioSelect, this));
        this.settings.themes.off('click', '.data-range > .radio').on('click', '.data-range > .radio:not(.disabled)', $.proxy(this.radioSelect, this));
        this.settings.themes.off('click', 'h4').on('click', 'h4', $.proxy(this.themeSlide, this));
        this.settings.themes.off('click', '.indicator').on('click', '.indicator .title', $.proxy(this.indicatorSelect, this));
        this.settings.themes.off('click', '.icon.info').on('click', '.icon.info', function(e) {
            e.preventDefault();
            return false;
        });
        this.settings.themes.off('mouseover mouseout', '.icon.info').on('mouseover mouseout', '.icon.info:not(.ignore)', $.proxy(this.hoverInfo, this));
        this.settings.indicatorsList.off('click', '.btn.apply').on('click', '.btn.apply', $.proxy(this.indicatorLoad, this));
        this.settings.themes.off('click', '.btn.apply').on('click', '.btn.apply', $.proxy(this.indicatorLoad, this));
        this.settings.indicatorsList.off('click', '.indicator-icon.sort').on('click', '.indicator-icon.sort', $.proxy(this.indicatorSort, this));
        this.settings.defaultIndicatorsListTitle = this.settings.indicatorsHeading.find('.title').text();
        return this;
    }
};;
var Cities = function($options) {
    'use strict';
    this.di = {};
    this.disabled = false;
    this.averagesTooltips = true;
    this.settings = {
        averagesList: null,
        citiesList: null,
        container: null,
        filters: null,
        speed: 375
    };
    if ($options) {
        $.extend(this.settings, $options);
    }
    if (typeof this.settings.filters === 'string') {
        this.settings.filters = $(this.settings.filters);
    }
    if (typeof this.settings.citiesList === 'string') {
        this.settings.citiesList = $(this.settings.citiesList);
    }
    if (typeof this.settings.container === 'string') {
        this.settings.container = $(this.settings.container);
    }
    this.injectDI = function($di) {
        this.di = $di;
    };
};
Cities.prototype = {
    addDisabled: function($disabledItems) {
        'use strict';
        $disabledItems.addClass('disabled').parent('div,aside').addClass('disabled');
        return this;
    },
    removeDisabled: function($disabledItems) {
        'use strict';
        $disabledItems.removeClass('disabled').parent('div,aside').removeClass('disabled');
        return this;
    },
    enableAveragesTooltips: function() {
        'use strict';
        this.averagesTooltips = true;
        return this;
    },
    disableAveragesTooltips: function() {
        'use strict';
        this.averagesTooltips = false;
        return this;
    },
    averagesTooltipsEnabled: function($elem) {
        'use strict';
        return ((this.averagesTooltips && $elem.parents('.averages').length) || !$elem.parents('.averages').length);
    },
    getCitiesForData: function($cities) {
        'use strict';
        var citiesArr = [];
        var $city;
        var i;
        var len = $cities.length;
        for (i = 0; i < len; i += 1) {
            $city = $($cities[i]);
            citiesArr.push($city.data('city'));
        }
        return citiesArr;
    },
    getAveragesList: function() {
        'use strict';
        return this.settings.averagesList;
    },
    getAverages: function() {
        'use strict';
        return this.getAveragesList().find('a[data-city]');
    },
    getAveragesForData: function($averages) {
        'use strict';
        var averagesArr = [];
        var $averages;
        var i;
        var len = $averages.length;
        for (i = 0; i < len; i += 1) {
            $averages = $($averages[i]);
            averagesArr.push($averages.data('city'));
        }
        return averagesArr;
    },
    getCitiesList: function() {
        'use strict';
        return this.settings.citiesList;
    },
    getCities: function() {
        'use strict';
        return this.getCitiesList().find('a[data-city]');
    },
    getSelectedCities: function() {
        'use strict';
        return this.getCities().filter(function() {
            return ($(this).siblings('.ticked').length);
        });
    },
    getLockedCities: function() {
        'use strict';
        return this.getCities().filter(function() {
            return ($(this).parents('li.locked').length);
        });
    },
    getDeselectedCities: function() {
        'use strict';
        return this.getCities().filter(function() {
            return ($(this).siblings('.checkbox:not(.ticked)').length);
        });
    },
    getUnlockedCities: function() {
        'use strict';
        return this.getCities().filter(function() {
            return (!$(this).parents('li.locked').length);
        });
    },
    findCity: function(slug, $list) {
        'use strict';
        var $cityList = $list || this.getCitiesList();
        return $cityList.find('a[data-city="' + slug + '"]');
    },
    highlightCity: function(slug, blur) {
        'use strict';
        var $city = this.findCity(slug, false).parent().parent('li');
        if ($city.length && !blur && !$city.find('.disabled').length) {
            $city.addClass('hover');
        } else if ($city.length) {
            $city.removeClass('hover');
        }
        return this;
    },
    selectCity: function(slug, deselect, noLock) {
        'use strict';
        var $city = this.findCity(slug, false).parent().parent('li');
        if ($city.length && !deselect) {
            $city.addClass('current');
            if (!noLock) {
                $city.addClass('locked');
            }
        } else if ($city.length) {
            $city.removeClass('current').removeClass('locked');
        }
        return this;
    },
    addTicked: function($checkedItems) {
        'use strict';
        var slug;
        var i;
        var len = $checkedItems.length;
        var $checkedItem;
        for (i = 0; i < len; i += 1) {
            $checkedItem = $($checkedItems[i]);
            slug = $checkedItem.siblings('a[data-city]').data('city');
            if (slug) {
                this.findCity(slug, false).prev('.checkbox').addClass('ticked');
                this.di.graphs().removeHiddenGraphObject(slug);
            }
        }
        if (this.getDeselectedCities().length) {
            this.di.hashURLs().removeHashType('city').setHashParts('city', this.getCitiesForData(this.getSelectedCities()));
        } else {
            this.di.hashURLs().removeHashType('city').setHashPart('city', 'show-all', {
                city: 'show-all'
            });
        }
        this.di.hashURLs().setHash();
        this.addPrompt(false);
        return this;
    },
    removeTicked: function($checkedItems) {
        'use strict';
        var slug;
        var i;
        var len = $checkedItems.length;
        var $checkedItem;
        var $graphObject;
        for (i = 0; i < len; i += 1) {
            $checkedItem = $($checkedItems[i]);
            if ($checkedItem.data('city')) {
                slug = $checkedItem.data('city');
            } else {
                slug = $checkedItem.siblings('a[data-city]').data('city');
            }
            if (slug) {
                this.findCity(slug, false).prev('.checkbox').removeClass('ticked');
                this.di.chart().settings.container.find('.balloon[data-slug="' + slug + '"]').removeClass('visible').removeClass('selected');
                if (typeof this.di.chart().unlockTooltip === 'function' && this.di.chart().type !== 'time') {
                    $graphObject = this.di.chart().getGraphObject(slug);
                    this.di.chart().unlockTooltip($graphObject).removeTooltip($graphObject);
                }
                this.di.graphs().addHiddenGraphObject(slug);
            }
        }
        if (this.getSelectedCities().length) {
            this.di.hashURLs().removeHashType('city').setHashParts('city', this.getCitiesForData(this.getSelectedCities()));
        } else {
            this.di.hashURLs().removeHashType('city').setHashPart('city', 'hide-all', {
                city: 'hide-all'
            });
        }
        this.di.hashURLs().setHash();
        this.addPrompt(false);
        return this;
    },
    getValueObject: function(objectType, $usedCities) {
        'use strict';
        var $cities = $usedCities || this.getCities();
        var i;
        var len = $cities.length;
        var city;
        var $data;
        var object = [];
        var $currentIndicators = this.di.indicators().getCurrentIndicators();
        var chartType = this.di.chart().type;
        for (i = 0; i < len; i += 1) {
            city = this.di.chart().getMarker($($cities[i]).data('city'));
            $data = this.di.chart().getData(city).info;
            if ($data !== undefined && $data !== null) {
                if (chartType === 'stacked-bar') {
                    if (objectType === 'checkbox') {
                        object.push({
                            object: $($cities[i]).siblings('.checkbox').get(0),
                            value: $data[$currentIndicators[0]] === undefined ? 0 : $data[$currentIndicators[0]]
                        });
                    } else if (objectType === 'marker') {
                        object.push({
                            object: city,
                            value: $data[$currentIndicators[0]] === undefined ? 0 : $data[$currentIndicators[0]]
                        });
                    }
                } else {
                    if (objectType === 'checkbox') {
                        object.push({
                            object: $($cities[i]).siblings('.checkbox').get(0),
                            value: $data.value
                        });
                    } else if (objectType === 'marker') {
                        object.push({
                            object: city,
                            value: $data.value
                        });
                    }
                }
            }
        }
        return object;
    },
    findTop: function(count) {
        'use strict';
        var top = this.getValueObject('checkbox', false);
        top.sort(function($a, $b) {
            var aValue = -1;
            var bValue = -1;
            if ($a.value !== undefined) {
                aValue = $a.value.toString().replace(',', '');
            }
            if ($b.value !== undefined) {
                bValue = $b.value.toString().replace(',', '');
            }
            return (bValue - aValue);
        });
        top = top.slice(0, count);
        return this.di.utilities().getColumn(top, 'object');
    },
    findBottom: function(count) {
        'use strict';
        var bottom = this.getValueObject('checkbox', false);
        bottom.sort(function($a, $b) {
            var aValue = -1;
            var bValue = -1;
            if ($a.value !== undefined) {
                aValue = $a.value.toString().replace(',', '');
            }
            if ($b.value !== undefined) {
                bValue = $b.value.toString().replace(',', '');
            }
            return (aValue - bValue);
        });
        bottom = bottom.slice(0, count);
        return this.di.utilities().getColumn(bottom, 'object');
    },
    hoverFilter: function(e) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $type = $elem.data('filterType');
        var $list = this.getCitiesList();
        var i;
        var len = $list.length;
        var $item;
        if (!$elem.length) {
            $elem = $(e.target);
        }
        if (!$elem.parents('.disabled').length && !this.disabled && this.averagesTooltipsEnabled($elem)) {
            switch ($type) {
                case 'region':
                    $list = $list.find('li[data-region="' + $elem.data('region') + '"] a');
                    break;
                case 'top':
                    $list = $(this.findTop($elem.data('count'))).siblings('a');
                    break;
                case 'bottom':
                    $list = $(this.findBottom($elem.data('count'))).siblings('a');
                    break;
                default:
                    $elem = null;
            }
            len = $list.length;
            for (i = 0; i < len; i += 1) {
                $item = $($list[i]);
                if ($item.data('city')) {
                    this.selectCity($item.data('city'), (e.type !== 'mouseover'), true);
                }
            }
        }
        return this;
    },
    enactFilter: function(e) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $type = $elem.data('filterType');
        var $list = this.getCitiesList();
        if (!$elem.parents('.disabled').length && !this.disabled && this.averagesTooltipsEnabled($elem)) {
            switch ($type) {
                case 'select-all':
                    this.addTicked($list.find('.checkbox'));
                    break;
                case 'clear-all':
                    this.removeTicked($list.find('.checkbox'));
                    break;
                case 'region':
                    this.removeTicked($list.find('.ticked'));
                    this.addTicked($list.find('li[data-region="' + $elem.data('region') + '"]').find('.checkbox'));
                    break;
                case 'top':
                    this.removeTicked($list.find('.ticked'));
                    this.addTicked(this.findTop($elem.data('count')));
                    break;
                case 'bottom':
                    this.removeTicked($list.find('.ticked'));
                    this.addTicked(this.findBottom($elem.data('count')));
                    break;
                default:
                    $elem = null;
            }
            this.di.indicators().processIndicators();
        }
        return this;
    },
    cityHighlight: function(e) {
        'use strict';
        var $elem = $(e.currentTarget);
        var slug = $elem.find('a[data-city]').data('city');
        var $mapObject;
        e.stopPropagation();
        if (slug && $elem.find('.ticked').length && !this.disabled && !$elem.find('.disabled').length && this.averagesTooltipsEnabled($elem)) {
            $mapObject = this.di.chart().getGraphObject(slug);
            if ($mapObject) {
                this.di.chart().clickGraphObject($mapObject);
                this.di.graphs().storeTooltips();
            }
        }
        return this;
    },
    cityHover: function(e) {
        'use strict';
        var $elem = $(e.currentTarget);
        var slug = $elem.find('a[data-city]').data('city');
        var $mapObject;
        e.stopPropagation();
        if (!$elem.length) {
            $elem = $(e.target);
        }
        if (slug && $elem.find('.ticked').length && !this.disabled && !$elem.find('.disabled').length && typeof this.di.chart().getGraphObject === 'function' && this.averagesTooltipsEnabled($elem)) {
            $mapObject = this.di.chart().getGraphObject(slug);
            if ($mapObject) {
                if (e.type === 'mouseover') {
                    this.di.chart().rollOverGraphObject($mapObject);
                } else {
                    this.di.chart().rollOutGraphObject($mapObject);
                }
            }
        }
        return this;
    },
    citySelect: function(e) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $item = $elem.parent().parent();
        e.stopPropagation();
        if (!this.disabled && !$item.find('.disabled').length) {
            if ($item.find('.ticked').length) {
                this.di.utilities().removeCurrent($item);
                this.removeTicked($item.find('.ticked'));
                this.addPrompt(false);
            } else {
                this.addTicked($item.find('.checkbox'));
                this.di.prompts().remove('cities');
            }
            this.di.indicators().processIndicators();
        }
        return this;
    },
    getUnusedCities: function($allCities, $cities) {
        'use strict';
        var i;
        var len = $allCities.length;
        var $city;
        var $unusedCities = {};
        for (i = 0; i < len; i += 1) {
            $city = $($allCities[i]).get(0);
            if ($.inArray($city, $cities) === -1) {
                $unusedCities[i] = $allCities[i];
            }
        }
        return $unusedCities;
    },
    disableCities: function($citiesToDisable) {
        'use strict';
        var i;
        var len = $citiesToDisable.length;
        var $city;
        for (i = 0; i < len; i += 1) {
            $city = this.findCity($citiesToDisable[i].city, false);
            if ($city.length > 0) {
                this.addDisabled($city);
            }
        }
        return this;
    },
    disableUnusedCities: function($data) {
        'use strict';
        var i;
        var iTime;
        var len;
        var lenTime;
        var dTime;
        var $dataTime;
        var $d;
        var $cities = this.getCitiesForData(this.getCities());
        var $averages = this.getAveragesForData(this.getAverages());
        var $usedCities = [];
        var $unusedCities;
        var cityI;
        for (i in $data) {
            if ($data.hasOwnProperty(i)) {
                $d = $data[i];
                if (this.di.chart().type === 'time') {
                    $dataTime = $.grep(Object.keys($d), function(item) {
                        return item.indexOf('value_') !== -1;
                    });
                    lenTime = $dataTime.length;
                    for (iTime = 0; iTime < lenTime; iTime += 1) {
                        dTime = $dataTime[iTime].split('value_')[1];
                        cityI = $.inArray(dTime, $cities);
                        if (cityI !== -1 && $.inArray(dTime, $usedCities) === -1) {
                            $usedCities.push($cities[cityI]);
                        }
                    }
                } else {
                    cityI = $.inArray($d.city, $cities);
                    if (cityI !== -1) {
                        $usedCities.push($cities[cityI]);
                    }
                }
            }
        }
        $unusedCities = $($cities).not($usedCities);
        if (!this.di.graphs().averagesEnabled()) {
            $unusedCities = $unusedCities.add($averages);
        }
        $unusedCities = $unusedCities.get();
        len = $unusedCities.length;
        for (i = 0; i < len; i += 1) {
            var $city = this.findCity($unusedCities[i], false);
            if ($city.length > 0) {
                this.addDisabled($city);
            }
        }
        return this;
    },
    addPrompt: function(first) {
        'use strict';
        return first || true;
    },
    setFromHash: function(cities) {
        'use strict';
        var $citiesList = this.getCities();
        var listLen = $citiesList.length;
        var len = cities.length;
        var i;
        var self = this;
        if (len) {
            if (this.di.sharing().embedded) {
                if (self.disabled) {
                    self.disabled = false;
                    self.settings.container.removeClass('disabled');
                }
            }
            for (i = 0; i < listLen; i += 1) {
                $($citiesList[i]).prev('.checkbox').removeClass('ticked');
                self.di.graphs().addHiddenGraphObject($($citiesList[i]).data('city'));
            }
            for (i = 0; i < len; i += 1) {
                if (cities[i].city !== 'show-all' && cities[i].city !== 'hide-all') {
                    self.findCity(cities[i].city, false).prev('.checkbox').addClass('ticked');
                    self.di.graphs().removeHiddenGraphObject(cities[i].city);
                } else if (cities[i].city === 'show-all') {
                    for (i = 0; i < listLen; i += 1) {
                        $($citiesList[i]).prev('.checkbox').addClass('ticked');
                        self.di.graphs().removeHiddenGraphObject($($citiesList[i]).data('city'));
                    }
                }
            }
        }
        return this;
    },
    runEvents: function() {
        'use strict';
        this.settings.filters.off('click', 'a').on('click', 'a', $.proxy(this.enactFilter, this));
        this.settings.filters.off('mouseover mouseout', 'a').on('mouseover mouseout', 'a', $.proxy(this.hoverFilter, this));
        this.settings.citiesList.off('click', 'li').on('click', 'li', $.proxy(this.cityHighlight, this));
        this.settings.citiesList.off('mouseover mouseout', 'li').on('mouseover mouseout', 'li', $.proxy(this.cityHover, this));
        this.settings.citiesList.off('click', 'li .checkbox').on('click', 'li .checkbox', $.proxy(this.citySelect, this));
        return this;
    }
};;
var Graphs = function($options) {
    'use strict';
    this.di = {};
    this.disabled = false;
    this.chart = {};
    this.chartFn = {};
    this.hiddenGraphObjects = [];
    this.graphTitle = '';
    this.loading = 0;
    this.markers = [];
    this.notesAjax = null;
    this.minimumIndicators = 0;
    this.maximumIndicators = null;
    this.type = null;
    this.orientation = 'horz';
    this.tooltipsLoaded = false;
    this.loadingTooltips = false;
    this.settings = {
        container: null,
        embedded: false,
        graphWrapper: null,
        initialGraph: '',
        markerColour: '#868686',
        markerDisabledColour: '#868686',
        maximumToShow: 10,
        speed: 375,
        tooltipMaximum: 7
    };
    if ($options) {
        $.extend(this.settings, $options);
    }
    if (typeof this.settings.container === 'string') {
        this.settings.container = $(this.settings.container);
    }
    if (typeof this.settings.graphWrapper === 'string') {
        this.settings.graphWrapper = $(this.settings.graphWrapper);
    }
    if (this.settings.initialGraph === null) {
        this.settings.initialGraph = 'map';
    }
    this.injectDI = function($di) {
        this.di = $di;
    };
};
Graphs.prototype = {
    alterStamp: function() {
        'use strict';
        $('a:contains("by amCharts")').css({
            color: '#868686',
            opacity: '0.5',
            textTransform: 'lowercase'
        });
        return this;
    },
    isLoading: function() {
        'use strict';
        return (this.loading);
    },
    addLoading: function() {
        'use strict';
        var $loading = $('<div class="loading"><img alt="Loading graph" title="Loading graph" src="/data-tool/img/loading.gif" /></div>');
        if (!this.isLoading()) {
            this.settings.container.append($loading);
        }
        this.di.prompts().knockBack();
        this.loading += 1;
        return this;
    },
    removeLoading: function() {
        'use strict';
        if (this.isLoading()) {
            this.settings.container.find('.loading').remove();
            if (!Object.size(this.di.prompts().promptsList)) {
                this.di.prompts().knockForward();
            }
            this.loading -= 1;
        }
        return this;
    },
    averagesEnabled: function() {
        "use strict";
        return (parseInt($('.graph-tabs .current').data('enableAverages'), 10));
    },
    allowGraphTitle: function() {
        'use strict';
        return (this.di.chart().type !== 'table' && this.graphTitle !== '');
    },
    addGraphTitle: function() {
        'use strict';
        if (!$.isEmptyObject(this.di.chart()) && this.di.chart().type !== 'table' && !this.di.chart().settings.container.find('.graph-title').length) {
            this.di.chart().settings.container.prepend('<aside class="graph-title"></aside>');
            this.graphTitle = this.di.chart().settings.container.find('.graph-title');
        }
        return this;
    },
    emptyGraphTitle: function() {
        'use strict';
        if (this.graphTitle !== '') {
            this.graphTitle.empty();
        }
        return this;
    },
    removeGraphTitle: function() {
        'use strict';
        this.di.chart().settings.container.find('.graph-title').remove();
        this.graphTitle = '';
        return this;
    },
    addTextToGraphTitle: function($html) {
        'use strict';
        if (this.allowGraphTitle()) {
            if (this.graphTitle.find('span:not(.separator):last').hasClass('indicator')) {
                this.graphTitle.append('<span class="indicator separator"> / </span>');
            }
            this.graphTitle.append($html);
            this.removeExcessSeparatorsFromGraphTitle();
        }
        return this;
    },
    removeTextFromGraphTitle: function(spanClass, dataAttribute, dataValue) {
        'use strict';
        if (this.allowGraphTitle()) {
            if (dataAttribute) {
                this.graphTitle.find(spanClass + '[data-' + dataAttribute + '="' + dataValue + '"]').remove();
            } else {
                this.graphTitle.find(spanClass).remove();
            }
            this.removeExcessSeparatorsFromGraphTitle();
        }
        return this;
    },
    replaceTextInGraphTitle: function(textClass, $replaceHtml) {
        'use strict';
        var $existing;
        var $newHtml = $replaceHtml;
        if (this.allowGraphTitle()) {
            $existing = this.graphTitle.find(textClass);
            if (this.graphTitle.find('> span:not(.separator):last').hasClass('indicator')) {
                $newHtml = $($newHtml).prepend('<span class="indicator separator"> / </span>');
            }
            if ($existing.length) {
                $existing.first().after($newHtml);
                $existing.remove();
            } else {
                this.graphTitle.append($newHtml);
            }
            this.removeExcessSeparatorsFromGraphTitle();
        }
        return this;
    },
    removeExcessSeparatorsFromGraphTitle: function() {
        'use strict';
        var $indicators = this.graphTitle.find('> span.indicator:not(.separator)');
        var i;
        var len = $indicators.length;
        var $indicator;
        if (this.allowGraphTitle() && this.graphTitle.find('.separator').length) {
            this.graphTitle.find('.separator').remove();
        }
        if (this.allowGraphTitle()) {
            for (i = 0; i < len; i += 1) {
                $indicator = $($indicators[i]);
                if (len > 1 && i !== len - 1) {
                    $indicator.append('<span class="indicator separator"> / </span>');
                }
            }
        }
        return this;
    },
    buildGraphTitle: function(indicator) {
        'use strict';
        var indicators;
        var i;
        var len;
        var $indicator;
        var index;
        var dataType;
        var range;
        var startDate;
        var endDate;
        var dateText;
        var dataRange;
        var dataRangeTitleText;
        if (indicator) {
            indicators = [indicator];
        } else {
            indicators = this.di.indicators().getCurrentIndicators();
        }
        this.emptyGraphTitle();
        len = indicators.length;
        for (i = 0; i < len; i += 1) {
            index = i + 1;
            $indicator = this.di.indicators().settings.indicatorsList.find('.selected-indicator[data-indicator="' + indicators[i] + '"][data-index="' + index + '"]');
            if (!$indicator.find('.title .name').text().length) {
                $indicator = $('.selected-indicator[data-indicator="' + indicators[i] + '"]');
            }
            dataType = $indicator.data('datatype');
            range = $indicator.find('.radio.on').data('range');
            startDate = $indicator.find('.start-date .selected').data('value') || '';
            endDate = $indicator.find('.end-date .selected').data('value') || '';
            dateText = this.di.indicators().getDateString(startDate, endDate) || '';
            dataRange = $indicator.find('.radio.on .name').text().replace(' over time', '');
            if (range === 'actual' && dataType === '%') {
                dataRange = 'percentage point change';
                dataType = '';
            }
            dataRangeTitleText = '<span class="data-range">, ' + dataRange.toLowerCase() + '</span>';
            if (range === 'single') {
                endDate = '';
                dataType = '';
                dateText = this.di.indicators().getDateString(startDate, endDate);
            }
            if (range === 'change') {
                dataType = '';
            }
            if (dataType) {
                dataType = ' (' + dataType + ')';
            } else {
                dataType = '';
            }
            if (!dataRange) {
                dataRangeTitleText = '';
            }
            if (!dateText || dateText === undefined || dateText === 'undefined') {
                dateText = '';
            }
            if (dataRange.toLowerCase() === 'single date') {
                dataRangeTitleText = '';
            }
            this.addGraphTitle().replaceTextInGraphTitle('.indicator[data-indicator="' + indicators[i] + '"][data-index="' + index + '"]', '<span class="indicator" data-indicator="' + indicators[i] + '" data-index="' + index + '"><span class="name">' + $indicator.find('.title .name').text() + dataRangeTitleText + ' <span class="date" data-start-date="' + startDate + '" data-end-date="' + endDate + '">' + dateText + '</span> <span class="datatype">' + dataType + '</span></span></span>');
        }
        this.removeBubbleTitle();
        if (this.di.chart().type === 'bubble') {
            this.addBubbleTitle();
        }
        return this;
    },
    addBubbleTitle: function() {
        'use strict';
        var indicators = this.di.indicators().getCurrentIndicators();
        var $indicator;
        var index;
        var dataType;
        var range;
        var startDate;
        var endDate;
        var dateText;
        var dataRange;
        var dataRangeTitleText;
        if (indicators.length === this.di.chart().minimumIndicators) {
            $indicator = this.di.indicators().settings.indicatorsList.find('.selected-indicator[data-indicator="' + indicators[0] + '"][data-index="' + 1 + '"]');
            index = $indicator.data('index');
            dataType = $indicator.data('datatype');
            range = $indicator.find('.radio.on').data('range');
            startDate = $indicator.find('.start-date .selected').data('value');
            endDate = $indicator.find('.end-date .selected').data('value');
            dateText = this.di.indicators().getDateString(startDate, endDate);
            dataRange = $indicator.find('.radio.on .name').text().replace(' over time', '');
            dataRangeTitleText = '<span class="data-range">, ' + dataRange.toLowerCase() + '</span>';
            if (range === 'single') {
                endDate = '';
                dataType = '';
                dateText = this.di.indicators().getDateString(startDate, endDate);
            }
            if (range === 'change') {
                dataType = '';
            }
            if (range === 'actual' && dataType === '%') {
                dataType = '';
            }
            if (dataType) {
                dataType = ' (' + dataType + ')';
            } else {
                dataType = '';
            }
            if (dataRange.toLowerCase() === 'single date') {
                dataRangeTitleText = '';
            }
            this.settings.graphWrapper.before('<div class="bubble-title"><span class="indicator" data-indicator="' + indicators[0] + '" data-index="' + index + '"><span class="bubble-indicator"><br/>= </span><span class="name">' + $indicator.find('.title .name').text() + dataRangeTitleText + ' <span class="date" data-start-date="' + startDate + '" data-end-date="' + endDate + '">' + dateText + '</span> <span class="datatype">' + dataType + '</span></span></span></div>');
        }
        return this;
    },
    removeBubbleTitle: function() {
        'use strict';
        this.settings.container.find('.bubble-title').remove();
        return this;
    },
    addHiddenGraphObject: function(slug) {
        'use strict';
        if (slug && $.inArray(slug, this.hiddenGraphObjects) === -1) {
            this.hiddenGraphObjects.push(slug);
        }
        return this;
    },
    removeHiddenGraphObject: function(slug) {
        'use strict';
        var index;
        if (slug) {
            index = $.inArray(slug, this.hiddenGraphObjects);
            if (index > -1) {
                this.hiddenGraphObjects.splice(index, 1);
            }
        }
        return this;
    },
    getTooltipHoverArea: function() {
        'use strict';
        var $rangeLegend = this.settings.container.find('.range-legend');
        if (!this.settings.container.find('.tooltip-hover-area').length) {
            this.settings.container.append('<div class="tooltip-hover-area"></div>');
        }
        if ($rangeLegend.length || $rangeLegend.css('top') !== parseInt($rangeLegend.css('top'), 10) + $rangeLegend.outerHeight(true)) {
            this.settings.container.find('.tooltip-hover-area').css('top', parseInt($rangeLegend.css('top'), 10) + $rangeLegend.outerHeight(true));
        }
        return this.settings.container.find('.tooltip-hover-area');
    },
    getTooltipArea: function() {
        'use strict';
        if (!this.settings.container.find('.tooltip-area').length) {
            this.settings.container.append('<div class="tooltip-area"></div>');
        }
        return this.settings.container.find('.tooltip-area');
    },
    getTooltipSize: function($tooltip) {
        'use strict';
        var $testTooltip = $tooltip.clone();
        var size;
        $testTooltip.attr('id', 'test-tooltip').css({
            left: '-99999px',
            top: '-99999px'
        });
        this.getTooltipArea().append($testTooltip);
        size = {
            height: $testTooltip.height(),
            outerHeight: $testTooltip.outerHeight(),
            outerHeightFull: $testTooltip.outerHeight(true),
            width: $testTooltip.width(),
            outerWidth: $testTooltip.outerWidth(),
            outerWidthFull: $testTooltip.outerWidth(true)
        };
        $testTooltip.remove();
        return size;
    },
    closeTooltip: function(e, keepLocked, city) {
        'use strict';
        var slug;
        var $tooltip;
        if ($(e.currentTarget).hasClass('tooltip')) {
            slug = $(e.currentTarget).data('slug') || city;
        } else {
            slug = $(e.currentTarget).parents('.tooltip').data('slug') || city;
        }
        $tooltip = this.findTooltip(slug);
        if (!keepLocked && this.di.chart().isTooltipLocked($tooltip, true)) {
            this.di.chart().unlockTooltip($tooltip, true);
        }
        if ($tooltip.length && !$tooltip.hasClass('locked')) {
            $tooltip.remove();
            this.di.cities().selectCity(slug, true);
        } else if (!$tooltip.length) {
            this.di.cities().selectCity(slug, true);
        }
        if (typeof this.di.chart().removeHalo === 'function') {
            this.di.chart().removeHalo(this.di.chart().getMarker(slug)).markerHover({
                type: 'rollOutMapObject',
                mapObject: this.di.chart().getMarker(slug)
            });
        }
        if (typeof this.di.chart().selectObject === 'function') {
            this.di.chart().selectObject();
        }
        this.storeTooltips();
        return this;
    },
    removeCityByTooltip: function(e) {
        'use strict';
        var $tooltip = $(e.currentTarget).parents('.tooltip');
        var slug = $tooltip.data('slug');
        var $city = this.di.cities().findCity(slug);
        $city.siblings('.checkbox').trigger('click');
        $tooltip.find('.close').trigger('click');
        return this;
    },
    loadStoredTooltips: function() {
        'use strict';
        var $graphObject;
        var lockedCities = this.di.utilities().getLocalStorage('lockedCities');
        var i;
        var len = 0;
        var $tooltip;
        var self = this;
        if (lockedCities) {
            len = lockedCities.length;
        }
        if (len && !this.tooltipsLoaded) {
            self.loadingTooltips = true;
            self.tooltipsLoaded = true;
            setTimeout(function() {
                for (i = 0; i < len; i += 1) {
                    $tooltip = self.di.chart().findTooltip(lockedCities[i]);
                    $graphObject = self.di.chart().getGraphObjectForTooltip(lockedCities[i]);
                    if (!$tooltip.length) {
                        self.di.cities().findCity(lockedCities[i]).parent().parent('li').trigger('click');
                    }
                }
                if (typeof self.di.chart().scrollZoom === 'function') {
                    self.di.chart().scrollZoom();
                    self.loadingTooltips = false;
                } else if (self.di.chart().type === 'map') {
                    self.di.chart().chart.validateNow();
                    self.loadingTooltips = false;
                }
            }, 500);
        }
        return this;
    },
    storeTooltips: function() {
        'use strict';
        var $lockedCities = this.di.cities().getLockedCities();
        var $cities = [];
        var len = $lockedCities.length;
        var i;
        if (len && !this.loadingTooltips) {
            for (i = 0; i < len; i += 1) {
                $cities.push($($lockedCities[i]).data('city'));
            }
            if ($cities.length) {
                this.di.utilities().setLocalStorage('lockedCities', $cities);
            }
        }
    },
    addNotes: function($notes) {
        'use strict';
        var $note;
        var i;
        var len = $notes.length;
        var $notesContainer = $('<aside class="notes"></aside>');
        for (i = 0; i < len; i += 1) {
            $note = $notes[i];
            if (!$notesContainer.find('p:contains("' + $note.text + '")').length) {
                $notesContainer.append('<p data-indicator="' + $note.indicator + '" data-indicator-id="' + $note.indicatorId + '" data-date="' + $note.date + '" data-date-id="' + $note.dateId + '" data-name="' + $note.name + '" data-slug="' + $note.slug + '" data-source-type="' + $note.sourceType + '">' + $note.text + '</p>');
            }
            this.settings.container.append($notesContainer);
        }
        return this;
    },
    removeNotes: function(indicator) {
        'use strict';
        if (indicator) {
            this.settings.container.find('notes [data-indicator="' + indicator + '"]').remove();
        } else {
            this.settings.container.find('.notes').remove();
        }
        return this;
    },
    getNotes: function(indicators) {
        'use strict';
        var self = this;
        self.di.chart().removeNotes();
        if (indicators) {
            if (this.notesAjax !== null) {
                this.notesAjax.abort();
                this.notesAjax = null;
            }
            this.notesAjax = $.ajax({
                async: true,
                data: {
                    'indicators': indicators,
                    'dataset': $('.theme').data('dataset')
                },
                success: function(notes) {
                    self.di.chart().addNotes(notes);
                    $('.loading').remove();
                    return true;
                },
                type: 'POST',
                url: '/data-tool/ajax/get-notes'
            });
        }
        return this;
    },
    removeLegend: function() {
        'use strict';
        this.settings.container.find('.legend').remove();
        return this;
    },
    getAxisData: function() {
        'use strict';
        var len = this.di.chart().chart.valueAxes.length;
        var data = this.di.chart().chart.valueAxes[0].data;
        var i = 0;
        var activeAxis = ['x', 'y'];
        var datum;
        var indicator;
        var city;
        var axisData = {
            x: [],
            y: []
        };
        var valueName;
        for (datum in data) {
            if (data.hasOwnProperty(datum)) {
                for (indicator in data[datum].axes) {
                    if (data[datum].axes.hasOwnProperty(indicator)) {
                        for (city in data[datum].axes[indicator].graphs) {
                            if (data[datum].axes[indicator].graphs.hasOwnProperty(city)) {
                                valueName = 'value_' + city.split('_')[0] + '_' + indicator.replace('value-', '');
                                if (data[datum].axes[indicator].graphs[city].dataContext[valueName] !== undefined) {
                                    axisData[activeAxis[i]].push(data[datum].axes[indicator].graphs[city].dataContext[valueName]);
                                }
                            }
                        }
                    }
                    i += 1;
                    if (i === len) {
                        i = 0;
                    }
                }
            }
        }
        if (axisData.x.length !== axisData.y.length) {
            axisData.x = axisData.x.slice(0, axisData.y.length);
            axisData.y = axisData.y.slice(0, axisData.x.length);
        }
        return axisData;
    },
    getIndicatorDateParts: function($elem) {
        'use strict';
        var range;
        var startDate;
        var endDate;
        var startSplit;
        var endSplit;
        var dateParts = {
            'end_date': '',
            'end_month': '',
            'start_date': '',
            'start_month': ''
        };
        if ($elem.length === 1) {
            range = $elem.find('.radio.on').data('range');
            startDate = $elem.find('.start-date .selected').data('value').toString();
            endDate = $elem.find('.end-date .selected').data('value').toString();
            if (range === 'single') {
                endDate = '';
            }
            if (endDate !== '') {
                endSplit = endDate.split('-');
                dateParts.end_date = endSplit[0];
                if (endSplit.length > 1) {
                    dateParts.end_month = endSplit[1];
                }
            }
            startSplit = startDate.split('-');
            dateParts.start_date = startSplit[0];
            if (startSplit.length > 1) {
                dateParts.start_month = startSplit[1];
            }
        }
        return dateParts;
    },
    addArray: function(data) {
        'use strict';
        var len = data.length;
        var i;
        var total = 0;
        for (i = 0; i < len; i += 1) {
            total += data[i];
        }
        return total;
    },
    timesArray: function(axis) {
        'use strict';
        var len = axis.x.length;
        var i;
        var xy = [];
        for (i = 0; i < len; i += 1) {
            xy.push(axis.x[i] * axis.y[i]);
        }
        return xy;
    },
    powArray: function(axis, pow) {
        'use strict';
        var len = axis.length;
        var i;
        var axis2 = [];
        for (i = 0; i < len; i += 1) {
            axis2.push(Math.pow(axis[i], pow));
        }
        return axis2;
    },
    calculateBestFit: function() {
        'use strict';
        var axis = this.getAxisData();
        var xTotal = this.addArray(axis.x);
        var yTotal = this.addArray(axis.y);
        var timesArray = this.timesArray(axis);
        var xPow = this.powArray(axis.x, 2);
        var yPow = this.powArray(axis.y, 2);
        var slope = ((axis.x.length * this.addArray(timesArray)) - (xTotal * yTotal)) / ((axis.x.length * this.addArray(xPow)) - (Math.pow(xTotal, 2)));
        var yIntercept = (yTotal - (slope * xTotal)) / axis.x.length;
        return {
            axis: axis,
            xTotal: xTotal,
            yTotal: yTotal,
            timesArray: timesArray,
            xPow: xPow,
            yPow: yPow,
            slope: slope,
            yIntercept: yIntercept
        };
    },
    calculateBestFitY: function(calculations, dataPoint) {
        'use strict';
        return ((calculations.slope * dataPoint) + (calculations.yIntercept));
    },
    changeLabelStyle: function(value, valueText, valueAxis) {
        'use strict';
        if (value === 0 || value === 0.00) {
            valueAxis.boldLabels = true;
            valueAxis.dashLength = 0;
            valueAxis.gridThickness = 2;
        } else {
            valueAxis.boldLabels = false;
            valueAxis.dashLength = 3;
            valueAxis.gridThickness = 1;
        }
        return valueText;
    },
    changeCategoryLabelStyle: function(valueText, data, categoryAxis) {
        'use strict';
        categoryAxis.boldLabels = (valueText.toLowerCase().indexOf('average') > -1);
        if (valueText.length > 13) {
            valueText = valueText.replace(/\s/g, '\n');
        }
        return valueText;
    },
    resetFromTime: function(ranFromHash) {
        'use strict';
        var $indicators = this.di.indicators().getIndicatorsList();
        var $themes = this.di.indicators().settings.themes;
        $indicators.find('.filter.data-range').slideDown().removeAttr('style');
        $themes.find('.filter.data-range').slideDown().removeAttr('style');
        this.di.indicators().settings.indicatorsList.removeClass('hide-data-range');
        if ($indicators.length && !ranFromHash) {
            $indicators.find('.end-date .selected').filter(function() {
                return (!$(this).data('value') || $(this).data('value') === '');
            }).parents('.options').find('.radio[data-range="single"]').trigger('click').parents('.options').find('.btn.apply').trigger('click');
        }
        $themes.find('.end-date .selected').filter(function() {
            return (!$(this).data('value') || $(this).data('value') === '');
        }).parents('.options').find('.radio[data-range="single"]').trigger('click');
        if (this.type !== 'scatter') {
            this.di.cities().settings.filters.find('[data-filter-type="top"]').parents('.filter').removeClass('disabled');
        }
        return this;
    },
    resetToTime: function(ranFromHash) {
        'use strict';
        var $indicators = this.di.indicators().getIndicatorsList();
        var $themes = this.di.indicators().settings.themes;
        var $endDate;
        if (this.di.graphs().graphTitle !== '') {
            this.di.graphs().graphTitle.find('.bubble-indicator').remove();
        }
        this.di.indicators().settings.indicatorsList.addClass('hide-data-range');
        if ($indicators.length) {
            $indicators.find('.radio.on').removeClass('on').addClass('off').end().find('.radio[data-range="actual"]').trigger('click');
            $indicators.find('.filter.data-range').slideUp();
            $endDate = $indicators.find('.end-date .selected').filter(function() {
                return (!$(this).data('value') || $(this).data('value') === '');
            });
            if ($endDate.length) {
                $endDate.parents('.selected-indicator').find('.edit').trigger('click', [true]);
                this.di.indicators().addPrompt('endDate');
            }
        }
        $themes.find('.indicators .radio.on').removeClass('on').addClass('off');
        $themes.find('.indicator .radio[data-range="actual"]').trigger('click');
        $themes.find('.filter.data-range').slideUp();
        this.di.cities().settings.filters.find('[data-filter-type="top"]').parents('.filter').addClass('disabled');
        return this;
    },
    autoLoad: function() {
        'use strict';
        var $selectedIndicators = this.di.indicators().getIndicatorsList();
        var graph = $('.graph-tabs .current').data('graph');
        this.settings.container.attr('class', graph);
        if ($selectedIndicators.length) {
            this.di.indicators().removeExtraIndicators().checkIndicatorsForDates().processIndicators();
        } else {
            this.di.indicators().checkIndicatorsForDates();
            this.di.indicators().addPrompt();
            this.di.indicators().disableUnselectedIndicators(graph);
        }
        if (graph === 'bubble' || graph === 'scatter') {
            this.di.cities().disableAveragesTooltips();
        } else {
            this.di.cities().enableAveragesTooltips();
        }
        return this;
    },
    changeChart: function(e) {
        'use strict';
        var $tab = $(e.currentTarget);
        var graphClass = $tab.data('graph');
        e.preventDefault();
        $tab.addClass('current').parents('li').siblings('li').find('.current').removeClass('current');
        this.minimumIndicators = $tab.data('minimumIndicators');
        this.maximumIndicators = $tab.data('maximumIndicators');
        this.getChart(graphClass);
        this.settings.container.find('.prompt, .range-legend, .tooltip-area, .tooltip-hover-area, .controls').remove();
        this.di.prompts().promptsList = [];
        return this;
    },
    startCharts: function() {
        'use strict';
        var $graphTabs = $('.graph-tabs');
        $graphTabs.off('click', 'li a').on('click', 'li a', $.proxy(this.changeChart, this));
        if (this.di.hashURLs().hashKeyExists('graph')) {
            this.setFromHash(this.di.hashURLs().getHashPart('graph'));
        } else {
            $graphTabs.find('li .current').trigger('click');
        }
        return this;
    },
    getChart: function(type) {
        'use strict';
        var self = this;
        var interval;
        var typeClassPrefix = 'DT';
        var typeClass = typeClassPrefix + 'Map';
        this.settings.container.off('click', '.tooltip-area .tooltip');
        interval = setInterval(function() {
            if (AmCharts.isReady || type === 'table') {
                if (self.di.chart().chart !== undefined && typeof self.di.chart().chart.clear === 'function') {
                    self.di.chart().chart.clear();
                } else if (self.di.chart().chart !== undefined) {
                    self.di.chart().chart.remove();
                }
                typeClass = typeClassPrefix + type.toTitleCase(true).replace(' ', '');
                self.di.chart(self, true, typeClass, function($chart) {
                    self.chartFn = $chart;
                    self.autoLoad();
                });
                self.di.hashURLs().removeHashType('graph').setHashPart('graph', type, {
                    graph: type
                });
                self.di.hashURLs().setHash();
                clearInterval(interval);
            }
        }, 100);
        if (!this.di.sharing().settings.printView && !this.di.sharing().settings.exportView) {
            this.di.utilities().clearLocalStorage(['lockedCities']);
        }
        return this;
    },
    setFromHash: function(graph) {
        'use strict';
        if (graph.length && graph[0].hasOwnProperty('graph')) {
            if (graph[0].graph.toLowerCase() === 'stackedbar') {
                graph[0].graph = 'stacked-bar';
            }
            $('.graph-tabs [data-graph="' + graph[0].graph + '"]').trigger('click');
        }
        return this;
    },
    setOrientationFromHash: function(orient) {
        'use strict';
        var orientation = orient[0].orient;
        var setOrientation = this.orientation;
        if (orientation && setOrientation !== orientation) {
            this.settings.container.find('.orientation').trigger('click');
        }
        return this;
    },
    setTableOrderFromHash: function(order) {
        'use strict';
        var newOrder = [];
        if (order.length && order[0].order && $.isArray(order[0].order)) {
            newOrder = order[0].order;
        }
        return newOrder;
    },
    setSortFromHash: function(sort) {
        'use strict';
        var sortOrder = sort[0].sortOrder;
        if (sortOrder) {
            this.settings.container.find('.dropdown-list li[data-value="' + sortOrder + '"]').trigger('click');
        }
        return this;
    },
    setBestFitFromHash: function(bestFit, noValidate) {
        'use strict';
        var bestFitLine = (parseInt(bestFit[0].bestFit, 10) === 1);
        var disabledWait;
        var self = this;
        if (bestFitLine) {
            disabledWait = setInterval(function() {
                if (!self.di.chart().disabled) {
                    self.settings.container.find('.best-fit').trigger('click', [true, bestFitLine, (noValidate)]);
                    clearInterval(disabledWait);
                }
            }, 100);
        }
        return this;
    }
};;
var Prompts = function($options) {
    'use strict';
    this.di = {};
    this.promptsList = {};
    this.settings = {
        container: null,
        speed: 375
    };
    if ($options) {
        $.extend(this.settings, $options);
    }
    if (typeof this.settings.container === 'string') {
        this.settings.container = $(this.settings.container);
    }
    this.injectDI = function($di) {
        this.di = $di;
    };
};
Prompts.prototype = {
    knockForward: function() {
        'use strict';
        if (!$.isEmptyObject(this.di.cities())) {
            this.di.cities().disabled = false;
        }
        if (!$.isEmptyObject(this.di.chart())) {
            this.di.chart().disabled = false;
        }
        this.di.cities().settings.container.add(this.di.graphs().settings.container).removeClass('knock-back');
        return this;
    },
    knockBack: function() {
        'use strict';
        if (!$.isEmptyObject(this.di.cities())) {
            this.di.cities().disabled = true;
        }
        if (!$.isEmptyObject(this.di.chart())) {
            this.di.chart().disabled = true;
        }
        this.di.cities().settings.container.add(this.di.graphs().settings.container).addClass('knock-back');
        return this;
    },
    add: function(promptType, promptMessage) {
        'use strict';
        var type = promptType || 'indicator';
        var message = promptMessage || '';
        var $prompt;
        var classes = 'prompt';
        $prompt = $('<div class="" data-type="' + type + '"></div>');
        $prompt.addClass(classes).append('<span class="message">' + message + '</span><span class="arrow"></span>');
        this.remove(type);
        this.settings.container.append($prompt);
        this.promptsList[type] = $prompt[0];
        this.di.sharing().settings.toolOptions.filter(function() {
            return $(this).hasClass('tool-option--needs-chart');
        }).addClass('disabled');
        this.knockBack();
        return this;
    },
    close: function(e) {
        'use strict';
        var $prompt = $(e.currentTarget);
        var type = $prompt.data('type');
        this.remove(type);
        return this;
    },
    remove: function(type) {
        'use strict';
        var $prompt = this.find(type, false);
        if ($prompt.length) {
            if (this.promptsList[type]) {
                delete this.promptsList[type];
            } else if (type === 'all') {
                this.promptsList = {};
            }
            $prompt.remove();
            this.di.sharing().settings.toolOptions.filter(function() {
                return $(this).hasClass('tool-option--needs-chart');
            }).removeClass('disabled');
        }
        if (!Object.size(this.promptsList)) {
            this.knockForward();
        }
        return this;
    },
    find: function(type, byList) {
        'use strict';
        var useList = byList || false;
        var response;
        if (!useList && type === 'all') {
            response = $('.prompt');
        } else if (type === 'all') {
            response = this.promptsList;
        }
        if (useList) {
            response = this.promptsList[type];
        } else {
            response = $('.prompt[data-type="' + type + '"]');
        }
        return response;
    },
    getPromptWidth: function($prompt) {
        'use strict';
        var $p = $prompt.clone(false, false).css({
            left: '-99999px',
            top: '-99999px'
        }).addClass('prompt').attr('id', 'test-prompt');
        var width;
        this.settings.container.append($p);
        width = $p.outerWidth(true);
        $p.remove();
        return width;
    },
    getPromptHeight: function($prompt) {
        'use strict';
        var $p = $prompt.clone(false, false).css({
                left: '-99999px',
                top: '-99999px'
            }).addClass('prompt').attr('id', 'test-prompt'),
            height;
        this.settings.container.append($p);
        height = $p.outerHeight(true);
        $p.remove();
        return height;
    },
    runEvents: function() {
        'use strict';
        return this;
    }
};;
var HashURLs = function($options) {
    'use strict';
    this.di = {};
    this.settings = {
        dateSeparator: '--',
        optionsSeparator: '\\\\',
        pairSeparator: '&',
        valueSeparator: '='
    };
    this.hash = '';
    this.hashParts = {};
    this.supports = {
        historyAPI: false,
        onHashChange: false
    };
    if ($options) {
        $.extend(this.settings, $options);
    }
    this.injectDI = function($di) {
        this.di = $di;
    };
};
HashURLs.prototype = {
    hasHistoryAPI: function() {
        'use strict';
        return !!(window.history && history.pushState);
    },
    hasOnHashChange: function() {
        'use strict';
        return ('onhashchange' in window);
    },
    setSupport: function(option) {
        'use strict';
        var supportFn = this['has' + option.capitalize()];
        if (typeof supportFn === 'function') {
            this.supports[option] = supportFn();
        }
        return this;
    },
    getSupport: function(option) {
        'use strict';
        return (this.supports[option] !== undefined && this.supports[option]);
    },
    getGaPageUrl: function() {
        'use strict';
        var url = this.getWindowHash();
        if ($('body').hasClass('embedded')) {
            url = 'embed/' + url;
        }
        return '/data-tool/' + url;
    },
    hashKeyExists: function(key, allowEmpty) {
        'use strict';
        return (this.hashParts.hasOwnProperty(key) && (allowEmpty || (!allowEmpty && this.hashParts[key].length)));
    },
    optionsMatch: function(a, b) {
        'use strict';
        var aProps;
        var bProps;
        if (a === undefined || b === undefined || typeof a !== typeof b || a.constructor !== b.constructor) {
            return false;
        }
        if (a.constructor === Array) {
            aProps = a;
            bProps = b;
        } else {
            aProps = Object.getOwnPropertyNames(a);
            bProps = Object.getOwnPropertyNames(b);
        }
        if (aProps.length !== bProps.length) {
            return false;
        }
        for (var i = 0; i < aProps.length; i++) {
            var propName = aProps[i];
            if (!a.hasOwnProperty(propName) || !b.hasOwnProperty(propName)) {
                return false;
            } else if ((a[propName] === undefined && b[propName] !== undefined || a[propName] !== undefined && b[propName] === undefined) || (a[propName] === null && b[propName] !== null || a[propName] !== null && b[propName] === null)) {
                return true;
            } else if (a[propName].constructor === Array || typeof a[propName] === 'object') {
                return this.optionsMatch(a[propName], b[propName]);
            } else if (a[propName] !== b[propName]) {
                return false;
            }
        }
        return true;
    },
    getWindowHash: function() {
        'use strict';
        return decodeURI(window.location.hash.replace('#', ''));
    },
    setOgUrl: function(passedURL) {
        'use strict';
        var $ogUrl = $('meta[property="og\\:url"]');
        var url = passedURL || window.location.href;
        if (!$ogUrl.length) {
            $('<meta property="og:url" content="">').insertAfter('meta[property^="og\\:"]:last');
            $ogUrl = $('meta[property="og\\:url"]');
        }
        $ogUrl.attr('content', url);
        return this;
    },
    getDataset: function() {
        'use strict';
        var path = window.location.pathname;
        var dataset = '';
        var regex = new RegExp('(.*)dataset/(.*)');
        if (path.indexOf('dataset/') !== -1) {
            dataset = path.replace(regex, '$2');
            if (dataset.indexOf('/') === dataset.length - 1) {
                dataset = dataset.substring(0, dataset.length - 1);
            }
        }
        return dataset;
    },
    getDatasetUri: function() {
        'use strict';
        var path = window.location.pathname;
        var datasetUri = '';
        var regex = new RegExp('(.*)(dataset/)(.*)');
        if (path.indexOf('dataset/') !== -1) {
            datasetUri = path.replace(regex, '$2$3');
            if (datasetUri.lastIndexOf('/') !== datasetUri.length - 1) {
                datasetUri += '/';
            }
        }
        return datasetUri;
    },
    getIndicatorHashDate: function($elem) {
        'use strict';
        var range;
        var startDate;
        var endDate;
        var date = '';
        var regex = new RegExp(this.settings.dateSeparator + '$');
        if ($elem.length === 1) {
            range = $elem.find('.radio.on').attr('data-range');
            startDate = $elem.find('.start-date .selected').attr('data-value');
            endDate = $elem.find('.end-date .selected').attr('data-value');
            if (range === 'single') {
                endDate = '';
            }
            date = startDate + this.settings.dateSeparator + endDate;
            if (date) {
                date = date.replace(regex, '');
            }
        }
        return date;
    },
    getHashPartOptions: function(type, part) {
        'use strict';
        var options = {};
        var bits;
        var size;
        var i;
        var len;
        var newArr = [];
        if (part && part.length) {
            bits = part.split(this.settings.optionsSeparator);
            options[type] = bits[0];
            if (type === 'indicator') {
                options.range = bits[1];
                options.date = bits[2];
            }
            if (type === 'tableOrder') {
                options.order = $.map(bits[1].split(','), function(v) {
                    return (parseInt(v, 10));
                });
                size = 2;
                len = options.order.length;
                for (i = 0; i < len; i += size) {
                    newArr.push(options.order.slice(i, i + size));
                }
                options.order = newArr;
            }
        }
        return options;
    },
    getHashParts: function() {
        'use strict';
        var hash = this.hash;
        var hashParts = hash.split(this.settings.pairSeparator).clean('');
        var finalHashParts = {};
        var i;
        var len;
        var part;
        var options;
        if (!hashParts.length || hashParts === '') {
            hashParts = [hash].clean('');
        }
        len = hashParts.length;
        for (i = 0; i < len; i += 1) {
            part = hashParts[i].split(this.settings.valueSeparator);
            options = this.getHashPartOptions(part[0], part[1]);
            if (finalHashParts.hasOwnProperty(part[0])) {
                finalHashParts[part[0]].push(options);
            } else {
                finalHashParts[part[0]] = [options];
            }
        }
        return finalHashParts;
    },
    getHashPart: function(key) {
        'use strict';
        var part = [];
        if (this.hashParts.hasOwnProperty(key)) {
            part = this.hashParts[key];
        }
        return part;
    },
    cleanHashParts: function() {
        'use strict';
        var hashParts = this.hashParts;
        var cleanHashParts = {};
        var options = [];
        var type;
        var len;
        var optLen;
        var i;
        var optI;
        var noMatch = false;
        for (type in hashParts) {
            if (hashParts.hasOwnProperty(type)) {
                len = hashParts[type].length;
                for (i = 0; i < len; i += 1) {
                    optLen = options.length;
                    noMatch = true;
                    if (optLen) {
                        for (optI = 0; optI < optLen; optI += 1) {
                            if (this.optionsMatch(hashParts[type][i], options[optI])) {
                                noMatch = false;
                            }
                        }
                    }
                    if (noMatch && hashParts[type][i] !== undefined) {
                        if (!cleanHashParts.hasOwnProperty(type)) {
                            cleanHashParts[type] = [];
                        }
                        cleanHashParts[type][i] = hashParts[type][i];
                        options.push(hashParts[type][i]);
                        cleanHashParts[type] = cleanHashParts[type].clean('').clean(undefined);
                    }
                }
            }
        }
        this.hashParts = cleanHashParts;
        return this;
    },
    mergeHashPartOptions: function(type, options) {
        'use strict';
        var optionsString = [];
        if (options[type]) {
            optionsString.push(options[type]);
        }
        if (options.range) {
            optionsString.push(options.range);
        }
        if (options.date) {
            optionsString.push(options.date);
        }
        if (options.order) {
            optionsString.push(options.order);
        }
        optionsString = optionsString.join(this.settings.optionsSeparator);
        return optionsString;
    },
    mergeHashParts: function() {
        'use strict';
        var hashParts = '';
        var type;
        var len;
        var i;
        this.cleanHashParts();
        for (type in this.hashParts) {
            if (this.hashParts.hasOwnProperty(type)) {
                len = this.hashParts[type].length;
                for (i = 0; i < len; i += 1) {
                    if (hashParts !== '') {
                        hashParts += this.settings.pairSeparator;
                    }
                    hashParts += type + this.settings.valueSeparator + this.mergeHashPartOptions(type, this.hashParts[type][i]);
                }
            }
        }
        return hashParts;
    },
    setHash: function(hash) {
        'use strict';
        var newHash = hash || this.mergeHashParts();
        if (this.getSupport('historyAPI')) {
            if (newHash.indexOf('#') === -1) {
                newHash = '#' + newHash;
            }
            history.pushState({
                state: 'new'
            }, null, newHash);
        } else {
            window.location.hash = newHash;
        }
        if (typeof ga === 'function' || typeof ga === 'object') {
            if (newHash.indexOf('#') === -1) {
                newHash = '#' + newHash;
            }
            ga('send', 'pageview', {
                'page': this.getGaPageUrl()
            });
        }
        this.hash = newHash;
        if (this.di.sharing().gotHash || this.di.sharing().gotLink) {
            this.di.sharing().settings.toolOptions.filter(function() {
                return ($(this).hasClass('link') || $(this).hasClass('embed'));
            }).trigger('click', [true]);
        }
        this.di.utilities().unsetLocalStorage('PNG');
        this.di.utilities().unsetLocalStorage('PDF');
        this.setOgUrl();
        return this;
    },
    setHashParts: function(type, keys) {
        'use strict';
        var len = keys.length || Object.size(keys);
        var i;
        for (i = 0; i < len; i += 1) {
            if (typeof keys[i] === 'string') {
                this.setHashPart(type, keys[i], {
                    type: keys[i]
                });
            } else {
                this.setHashPart(type, keys[i][type], keys[i]);
            }
        }
        return this;
    },
    setHashPart: function(type, key, options) {
        'use strict';
        var len;
        var i;
        var part;
        var exists = false;
        options[type] = key;
        if (this.hashParts.hasOwnProperty(type)) {
            len = this.hashParts[type].length;
        } else {
            len = 0;
        }
        for (i = 0; i < len; i += 1) {
            part = this.hashParts[type][i];
            if (part[type] === key) {
                if (this.optionsMatch(this.hashParts[type][i], options) || type === 'tableOrder') {
                    this.hashParts[type][i] = options;
                    exists = true;
                }
                break;
            }
        }
        if (!exists && $.isArray(this.hashParts[type])) {
            this.hashParts[type].push(options);
        } else if (!exists) {
            this.hashParts[type] = [options];
        }
        return this;
    },
    removeHashPart: function(type, key, options) {
        'use strict';
        var len;
        var i;
        if (this.hashParts.hasOwnProperty(type)) {
            len = this.hashParts[type].length;
            for (i = 0; i < len; i += 1) {
                if (this.hashParts[type][i] === undefined || this.hashParts[type][i][type] === key) {
                    if (this.optionsMatch(this.hashParts[type][i], options)) {
                        this.hashParts[type].splice(i, 1);
                    } else if (!options) {
                        this.hashParts[type].splice(i, 1);
                    }
                }
            }
        }
        return this;
    },
    removeHashPartByIndex: function(type, index) {
        'use strict';
        if (this.hashParts[type] !== undefined && this.hashParts[type][index] !== undefined) {
            if (index === 0 && this.hashParts[type].length < 2) {
                this.hashParts[type] = [];
            } else {
                this.hashParts[type].splice(index, 1);
            }
        }
        return this;
    },
    replaceHashPartByIndex: function(type, index, key, options) {
        'use strict';
        if (this.hashParts[type] !== undefined && this.hashParts[type][index] !== undefined) {
            options[type] = key;
            this.hashParts[type][index] = options;
        }
        return this;
    },
    removeHashType: function(type) {
        'use strict';
        this.hashParts[type] = [];
        return this;
    },
    switchHashParts: function(type, key1, key2, options1, options2) {
        'use strict';
        var len;
        var i;
        var key1i;
        var key2i;
        var $part1;
        var $part2;
        if (this.hashParts.hasOwnProperty(type)) {
            len = this.hashParts[type].length;
            for (i = 0; i < len; i += 1) {
                if (this.hashParts[type][i][type] === key1) {
                    if (this.optionsMatch(this.hashParts[type][i], options1)) {
                        key1i = i;
                        $part1 = this.hashParts[type][i];
                    }
                }
                if (this.hashParts[type][i][type] === key2) {
                    if (this.optionsMatch(this.hashParts[type][i], options2)) {
                        key2i = i;
                        $part2 = this.hashParts[type][i];
                    }
                }
            }
            if ($part1 && $part2) {
                this.hashParts[type][key1i] = $part2;
                this.hashParts[type][key2i] = $part1;
            }
        }
        return this;
    },
    setHashVars: function() {
        'use strict';
        this.hash = this.getWindowHash();
        this.hashParts = this.getHashParts();
        return this;
    },
    init: function(e, reset) {
        'use strict';
        var self = this;
        var hashInterval;
        this.setOgUrl();
        if (e !== undefined || reset) {
            this.setHashVars();
        }
        hashInterval = setInterval(function() {
            if (!$.isEmptyObject(self.di.chart())) {
                if (self.hashKeyExists('city', false)) {
                    self.di.cities().setFromHash(self.getHashPart('city'));
                }
                if (self.hashKeyExists('indicator', false)) {
                    self.di.indicators().setFromHash(self.getHashPart('indicator'));
                }
                if (self.hashKeyExists('orient', false)) {
                    self.di.graphs().setOrientationFromHash(self.getHashPart('orient'));
                }
                if (self.hashKeyExists('sortOrder', false)) {
                    self.di.graphs().setSortFromHash(self.getHashPart('sortOrder'));
                }
                if (self.hashKeyExists('bestFit', false)) {
                    self.di.graphs().setBestFitFromHash(self.getHashPart('bestFit'));
                }
                if (self.di.cities().getDeselectedCities().length) {
                    self.removeHashType('city').setHashParts('city', self.di.cities().getCitiesForData(self.di.cities().getSelectedCities()));
                } else {
                    self.removeHashType('city').setHashPart('city', 'show-all', {
                        city: 'show-all'
                    });
                }
                if (self.di.chart().type === 'time') {
                    self.di.graphs().resetToTime(true);
                } else {
                    self.di.graphs().resetFromTime(true);
                }
                self.di.hashURLs().setHash();
                clearInterval(hashInterval);
            }
        }, 50);
        return this;
    },
    runEvents: function() {
        'use strict';
        var self = this;
        this.setSupport('historyAPI').setSupport('onHashChange');
        this.setHashVars();
        if (this.getSupport('historyAPI')) {
            window.onpopstate = $.proxy(this.init, this);
        }
        if (this.getSupport('onHashChange')) {
            window.onhashchange = $.proxy(this.init, this);
        }
        if (!this.getSupport('historyAPI') || !this.getSupport('onHashChange')) {
            setInterval(function() {
                if (self.getWindowHash().replace('embed/', '') !== self.hash.replace('#', '').replace('embed/', '')) {
                    self.init(null, true);
                }
            }, 200);
        }
        return this;
    }
};;
var Sharing = function($options) {
    'use strict';
    this.ajax = null;
    this.debug = false;
    this.di = {};
    this.gotHash = '';
    this.gotLink = '';
    this.notesCSVAjax = null;
    this.exportTimeout = null;
    this.settings = {
        exportView: false,
        printView: false,
        sharingNetworks: null,
        sharingOptions: null,
        speed: 375
    };
    if ($options) {
        $.extend(this.settings, $options);
    }
    if (typeof this.settings.sharingNetworks === 'string') {
        this.settings.sharingNetworks = $(this.settings.sharingNetworks);
    }
    if (typeof this.settings.sharingOptions === 'string') {
        this.settings.sharingOptions = $(this.settings.sharingOptions);
    }
    this.injectDI = function($di) {
        this.di = $di;
    };
};
Sharing.prototype = {
    getDownloadCSV: function($data, $notes, type, link) {
        'use strict';
        var $form = $('<form action="/data-tool/ajax/get-download-csv" method="POST" style="visibility: hidden"></form>');
        $form.append('<textarea name="data">' + JSON.stringify($data) + '</textarea>');
        if (type === 'chart') {
            $form.append('<textarea name="hash">' + JSON.stringify(this.di.hashURLs().getWindowHash()) + '</textarea>');
        }
        $form.append('<textarea name="notes">' + JSON.stringify($notes) + '</textarea>');
        $form.append('<input type="hidden" name="link" value="' + link + '" />');
        $form.append('<input type="hidden" name="filename" value="' + this.getGraphFilename(type) + '" />');
        this.settings.toolOptions.filter(function() {
            return ($(this).hasClass('download'));
        }).removeClass('open').next('.tool-option__sub').removeClass('open');
        this.di.utilities().trackAnalyticEvent('Download', 'CSV', '');
        $('body').append($form.css('display', 'none'));
        $form.submit().remove();
        return this;
    },
    getNotesForCSV: function($indicators, $data, type, link) {
        'use strict';
        var self = this;
        if ($indicators) {
            if (this.notesCSVAjax !== null) {
                this.notesCSVAjax.abort();
                this.notesCSVAjax = null;
            }
            this.notesCSVAjax = $.ajax({
                async: true,
                data: {
                    'indicators': $indicators,
                    'dataset': $('.theme').data('dataset')
                },
                success: function($notes) {
                    self.getDownloadCSV($data, $notes, type, link);
                    return true;
                },
                error: function(jqXHR, textStatus, errorThrown) {
                    console.log('Notes failed', jqXHR, textStatus, errorThrown);
                },
                type: 'POST',
                url: '/data-tool/ajax/get-notes'
            });
        }
        return this;
    },
    getDownloadData: function(type, $options) {
        'use strict';
        var self = this;
        var $passedCities = this.di.cities().getCitiesForData($options.cities || this.di.cities().getSelectedCities);
        if (this.ajax !== null) {
            this.ajax.abort();
            this.ajax = null;
        }
        if (Object.size($options.themeContainer) && type === 'chart') {
            this.ajax = $.ajax({
                async: true,
                data: {
                    'cities': $passedCities,
                    'graph_type': 'CSV',
                    'theme_container': $options.themeContainer,
                    'filename': this.getGraphFilename(type),
                    'dataset': $('.theme').data('dataset')
                },
                success: function($data) {
                    self.getSharingLink($.proxy(self.getNotesForCSV, self), false, self.di.indicators().getCurrentIndicators(), $data, type);
                },
                type: 'POST',
                url: '/data-tool/ajax/get-data'
            });
        } else {
            this.ajax = $.ajax({
                async: true,
                data: {
                    'cities': $passedCities,
                    'graph_type': 'CSV',
                    'dataset': $('.theme').data('dataset')
                },
                success: function($data) {
                    self.getSharingLink($.proxy(self.getNotesForCSV, self), false, self.di.indicators().getAllIndicators(true).sort(), $data, null);
                },
                type: 'POST',
                url: '/data-tool/ajax/get-full-data'
            });
            return this;
        }
    },
    getSharingLink: function(callback, isExport) {
        'use strict';
        var args = Array.prototype.slice.call(arguments, 0);
        var hash = '#' + this.di.hashURLs().getWindowHash();
        var dataset = this.di.hashURLs().getDatasetUri();
        var self = this;
        var url = '/data-tool/ajax/get-sharing-link';
        if (isExport) {
            url += '?export=1';
        }
        args = args.slice(2);
        hash = dataset + hash;
        if (hash === this.gotHash) {
            this.gotLink = this.gotLink.replace('?export=1', '');
            if (isExport) {
                this.gotLink += '?export=1';
            }
            this.di.hashURLs().setOgUrl(this.gotLink);
            if (typeof callback === 'function') {
                args.push(this.gotLink);
                callback.apply(this, args);
            }
        } else {
            if (this.ajax !== null) {
                this.ajax.abort();
                this.ajax = null;
            }
            this.ajax = $.ajax({
                async: true,
                data: {
                    'hash': hash
                },
                success: function(link) {
                    self.gotHash = hash;
                    self.gotLink = link;
                    self.di.hashURLs().setOgUrl(link);
                    if (typeof callback === 'function') {
                        args.push(link);
                        callback.apply(self, args);
                    }
                    if ($('body').hasClass('embedded') && link.length) {
                        $('.embedded-logos .short-link').attr('href', link).html(link);
                    }
                },
                type: 'POST',
                url: url
            });
        }
        return this;
    },
    showGeneratedLink: function($sub, $generatedLink, sharingLink) {
        'use strict';
        $generatedLink.val(sharingLink);
        if ($generatedLink.val() !== '') {
            $sub.addClass('open');
            $generatedLink.select();
            this.di.utilities().trackAnalyticEvent('Export', 'Share link', '');
        }
        return this;
    },
    toggleGeneratedLink: function(e, forceClose) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $sub = $elem.next('.tool-option__sub');
        var $generatedLink = $sub.find('.generated-link');
        e.preventDefault();
        if ($sub.hasClass('open') || forceClose) {
            $sub.removeClass('open');
            $generatedLink.val('');
        } else {
            this.getSharingLink($.proxy(this.showGeneratedLink, this), false, $sub, $generatedLink);
        }
        return this;
    },
    addImageToPage: function($graph, $image) {
        'use strict';
        $graph.find('#graph').empty();
        $graph.find('#graph').append($image);
        $('.embedded-logos').removeClass('show');
        return this;
    },
    exportAmCharts: function(type, $graph) {
        'use strict';
        var self = this;
        var exporting = new AmCharts.AmExport(this.di.chart().chart);
        if (this.debug === false) {
            exporting.init();
            exporting.output({
                output: 'datastring',
                format: type
            }, function(blob) {
                var image = new Image();
                image.src = blob;
                image.className = 'export-graph';
                $graph.find('#graph-wrapper').empty().append(image);
                self.exportPNG($graph);
            });
        }
        return this;
    },
    addGraphForExport: function($graph, width, height) {
        'use strict';
        $graph.append($('.embedded-logos').eq(0).clone(false, false));
        $graph.find('.embedded-logos').addClass('show');
        $graph.width(width).height(height);
        $graph.find('.controls').hide();
        return $graph;
    },
    exportPNG: function($graph) {
        'use strict';
        var exportPNG;
        var self = this;
        exportPNG = html2canvas($graph, {
            background: '#fff',
            allowTaint: true,
            logging: true,
            useCORS: true,
        }).then(function(canvas) {
            if (self.di.utilities().getLocalStorage('exportType') === 'pdf') {
                self.exportPDF(canvas);
            } else {
                var dataURL = canvas.toDataURL('image/png');
                self.addImageToPage($graph, $('<img class="export-graph" src="' + dataURL + '" />'));
                if (!/msie/.test(navigator.userAgent.toLowerCase())) {
                    self.di.utilities().setLocalStorage('PNG', dataURL);
                }
            }
        });
        return exportPNG;
    },
    exportPDF: function(canvas) {
        'use strict';
        var bodyHeight = canvas.height;
        var bodyWidth = canvas.width;
        var pdf = new jsPDF('p', 'px', 'a4');
        var pageHeight = pdf.internal.pageSize.height;
        var pageWidth = pdf.internal.pageSize.width;
        var self = this;
        var imagePNG = canvas.toDataURL('image/png');
        var imageWidth = pageWidth;
        var imageHeight = (imageWidth / bodyWidth) * bodyHeight;
        var currentPage = 0;
        var pages = Math.ceil(imageHeight / pageHeight);
        var yPos = 0;
        var name = this.getGraphFilename();
        if (bodyHeight < imageHeight) {
            imageHeight = bodyHeight;
        }
        while (currentPage < pages) {
            if (currentPage) {
                pdf.addPage();
                yPos -= pageHeight;
            }
            if (imageHeight < (pageHeight - 10) || currentPage === 0) {
                yPos = 10;
            }
            pdf.addImage(imagePNG, 'PNG', 0, yPos, imageWidth, imageHeight);
            currentPage += 1;
        }
        pdf.save(name + '.pdf');
        self.di.utilities().setLocalStorage('PDF', 'Saved via JsPDF');
        return pdf;
    },
    exportOptions: function(e, forceClose) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $exportOptions = $elem.siblings('.export-options');
        e.preventDefault();
        if ($exportOptions.is(':visible') || forceClose) {
            $exportOptions.hide();
        } else if (!$elem.hasClass('disabled')) {
            this.getSharingLink($.proxy(this.exportShow, this), true, $exportOptions);
        }
        return this;
    },
    exportShow: function($elem) {
        'use strict';
        $($elem).show();
        return this;
    },
    exportEvent: function() {
        'use strict';
        var self = this;
        if (this.exportTimeout) {
            clearTimeout(this.exportTimeout);
        }
        this.exportTimeout = setTimeout(function() {
            var $container = $('.container');
            var usesAmCharts = (self.di.chart().chart && self.di.chart().chart.chartDiv);
            if (usesAmCharts) {
                self.exportAmCharts('png', $container);
            } else {
                self.exportPNG($container);
            }
        }, 2000);
        return this;
    },
    buildGeneratedEmbedLink: function(sharingLink) {
        'use strict';
        var sharingCode = sharingLink.split('/').reverse()[0];
        var dataset = this.di.hashURLs().getDataset() || 'default';
        var embedUri = '/embed/graph/' + dataset + '/' + sharingCode;
        return sharingLink.replace('/su/' + sharingCode, embedUri);
    },
    showGeneratedEmbedCode: function($sub, $generatedEmbedCode, sharingLink) {
        'use strict';
        var embedCode = '<iframe src="' + this.buildGeneratedEmbedLink(sharingLink) + '" width="600px" height="800px" frameborder="0" scrolling="auto"></iframe>';
        $generatedEmbedCode.val(embedCode);
        if ($generatedEmbedCode.val() !== '') {
            $sub.addClass('open');
            $generatedEmbedCode.select();
            this.di.utilities().trackAnalyticEvent('Export', 'Embed code', '');
        }
        return this;
    },
    toggleGeneratedEmbedCode: function(e, forceClose) {
        'use strict';
        var $elem = $(e.currentTarget);
        var $sub = $elem.next('.tool-option__sub');
        var $generatedEmbedCode = $sub.find('.generated-embed-code');
        e.preventDefault();
        if (!$elem.hasClass('disabled')) {
            if ($sub.hasClass('open') || forceClose) {
                $sub.removeClass('open');
                $generatedEmbedCode.val('');
            } else {
                this.getSharingLink($.proxy(this.showGeneratedEmbedCode, this), false, $sub, $generatedEmbedCode);
            }
        }
        return this;
    },
    setExportLinks: function(e, exportWindow, type) {
        'use strict';
        var pngDataUri;
        if (!e.key) {
            e = e.originalEvent;
        }
        pngDataUri = this.di.utilities().getLocalStorage('PNG');
        if (pngDataUri && (e.key === 'PNG')) {
            $(window).off('storage');
            if (this.debug === false) {
                exportWindow.close();
            }
            if (type === 'png') {
                this.downloadURI(pngDataUri);
            }
        } else if (type === 'png') {
            console.log('PNG Export failed.');
        }
        return this;
    },
    exportWindow: function(type, sharingLink) {
        'use strict';
        var exportLink;
        var exportWindow;
        exportLink = this.buildGeneratedEmbedLink(sharingLink);
        exportWindow = window.open(exportLink);
        $(window).off('storage').on('storage', {
            exportWindow: exportWindow,
            type: type
        }, $.proxy(function(e) {
            this.setExportLinks(e, e.data.exportWindow, e.data.type);
        }, this));
        return this;
    },
    clickExportPNG: function(e) {
        'use strict';
        var localPNG = this.di.utilities().getLocalStorage('PNG');
        e.preventDefault();
        this.di.utilities().trackAnalyticEvent('Export', 'PNG', '');
        this.di.utilities().setLocalStorage('exportType', 'png');
        if (localPNG) {
            this.downloadURI(localPNG);
        } else {
            this.getSharingLink($.proxy(this.exportWindow, this), true, 'png');
        }
        return this;
    },
    clickExportPDF: function(e) {
        'use strict';
        e.preventDefault();
        this.di.utilities().trackAnalyticEvent('Export', 'PDF', '');
        this.di.utilities().setLocalStorage('exportType', 'pdf');
        this.getSharingLink($.proxy(this.exportWindow, this), true, 'pdf');
        return this;
    },
    getGraphFilename: function(type) {
        'use strict';
        var name = $('.graph-title').text().replace(/[^a-z0-9]/gi, '_').replace(/^(_{0,})/gi, '').replace(/(_{0,})$/gi, '').toLowerCase();
        name = name.substring(0, 240);
        if (!name.length || type === null) {
            name = 'data-tool-export';
        }
        return name;
    },
    downloadURI: function(uri) {
        'use strict';
        var $clickableLink;
        var fileType = uri.substring(0, 30).match(/data:.+\/(.+);/);
        var name;
        var type = 'file';
        var $toolOption = $('.tool-option.export');
        var $sub = $toolOption.next('.tool-option__sub');
        if (fileType[1]) {
            type = fileType[1];
        }
        name = this.getGraphFilename();
        $clickableLink = $(('.export-download-link-' + type));
        if ($clickableLink.length) {
            $clickableLink.attr('href', uri);
        } else {
            if (this.di.utilities().supportsDownloadAttr()) {
                $toolOption.removeClass('open');
                $sub.removeClass('open');
                $clickableLink = $('<a class="tool-option__title export-download-link hidden-link export-download-link-' + fileType[1] + '" href="' + uri + '" download="' + name + '">Download Link</a>').appendTo('body');
            } else {
                if ($toolOption.hasClass('open')) {
                    $toolOption.removeClass('open');
                    $sub.removeClass('open');
                    $clickableLink = $();
                } else {
                    $toolOption.addClass('open');
                    $sub.addClass('open');
                    $clickableLink = $('<a class="tool-option__title export-download-link export-download-link-' + fileType[1] + '" target="_blank" href="' + uri + '" >Download ' + type.toUpperCase() + '</a>').appendTo($sub);
                }
            }
        }
        if ($clickableLink.length) {
            $clickableLink[0].click();
        }
        return this;
    },
    getToolOptionClass: function(classNames) {
        'use strict';
        return $.trim(classNames.replace(/(\s)?(tool-option|open)([\w\-]+)?(\s)?/g, ''));
    },
    clickSocial: function($elem, link) {
        'use strict';
        var href = '';
        var width = 575;
        var height = 400;
        var left = ($(window).width() - width) / 2;
        var top = ($(window).height() - height) / 2;
        var opts = 'status=1' + ',width=' + width + ',height=' + height + ',top=' + top + ',left=' + left;
        var title = '';
        var pageTitle = $('.js-page-title').text().trim();
        var className = this.getToolOptionClass($elem[0].className);
        switch (className) {
            case 'twitter':
                href = 'https://twitter.com/share?url=' + encodeURIComponent(link) + '&text=' + encodeURIComponent('Centre For Cities: ' + pageTitle) + '&via=CentreforCities';
                title = 'Twitter';
                this.di.utilities().trackAnalyticEvent('Social Media Share', 'Twitter', '');
                break;
            case 'facebook':
                href = 'http://www.facebook.com/sharer.php?u=' + encodeURIComponent(link) + '&t=' + encodeURIComponent('Centre For Cities: ' + pageTitle);
                title = 'Facebook';
                this.di.utilities().trackAnalyticEvent('Social Media Share', 'Facebook', '');
                break;
        }
        if (href !== '') {
            $elem.attr('href', href);
            window.open(href, title, opts);
        }
        return this;
    },
    clickToolOption: function(e, defaultFunctionality) {
        'use strict';
        var $elem;
        var currentHref = window.location.href;
        var className;
        if (!defaultFunctionality) {
            e.preventDefault();
            $elem = $(e.currentTarget);
            className = this.getToolOptionClass($elem[0].className);
            switch (className) {
                case 'twitter':
                    this.getSharingLink($.proxy(this.clickSocial, this), false, $elem);
                    break;
                case 'facebook':
                    this.getSharingLink($.proxy(this.clickSocial, this), false, $elem);
                    break;
                case 'print':
                    currentHref = currentHref.split('#');
                    currentHref = currentHref[0] + '?embed=1&print=1#' + currentHref[1];
                    window.open(currentHref, 'Print', 'status=1');
                    break;
                case 'download':
                    if ($elem.hasClass('open')) {
                        $elem.next('.tool-option__sub').find('tool-option__close').trigger('click');
                    } else {
                        $elem.addClass('open');
                        $elem.next('.tool-option__sub').addClass('open');
                    }
                    this.getDownloadData($elem.data('download-type'), this.di.indicators().getGraphDataOpts());
                    break;
                case 'link':
                    $elem.toggleClass('open');
                    this.toggleGeneratedLink(e, false);
                    break;
                case 'embed':
                    $elem.toggleClass('open');
                    this.toggleGeneratedEmbedCode(e, false);
                    break;
                case 'export':
                    this.clickExportPNG(e);
                    break;
                default:
                    if ($elem.attr('href') !== '' && $elem.attr('href')) {
                        window.open($elem.attr('href'));
                    }
            }
        }
        return this;
    },
    clickCloseToolOption: function(e) {
        'use strict';
        var $elem = $(e.currentTarget).parents('.tool-option');
        var $toolOption = $elem.prev('.tool-option');
        var className = this.getToolOptionClass($toolOption[0].className);
        $elem.removeClass('open');
        $toolOption.removeClass('open');
        switch (className) {
            case 'download':
                if (this.ajax !== null) {
                    this.ajax.abort();
                    this.ajax = null;
                }
                if (this.notesCSVAjax !== null) {
                    this.notesCSVAjax.abort();
                    this.notesCSVAjax = null;
                }
                break;
        }
        return this;
    },
    runEvents: function() {
        'use strict';
        var self = this;
        this.settings.toolOptions.off('click', this).on('click', this, $.proxy(this.clickToolOption, this));
        this.settings.toolOptions.off('click', '.tool-option__close').on('click', '.tool-option__close', $.proxy(this.clickCloseToolOption, this));
        $(document).on('keyup keydown', function(e) {
            if ((e.metaKey || e.ctrlKey) && e.keyCode === 80) {
                e.preventDefault();
                self.di.sharing().settings.toolOptions.filter(function() {
                    return $(this).hasClass('print');
                }).trigger('click');
                return false;
            }
        });
        if (this.di.sharing().settings.printView) {
            this.di.utilities().trackAnalyticEvent('Export', 'Print', '');
            setTimeout(function() {
                window.print();
            }, 2500);
        }
        if (this.di.sharing().settings.exportView) {
            this.di.utilities().createCustomEvent('chartLoaded', $.proxy(this.exportEvent, this));
        }
        return this;
    }
};;
var Di = function() {
    'use strict';
};
Di.prototype = {
    _chart: {},
    _cities: {},
    _graphs: {},
    _hashURLs: {},
    _indicators: {},
    _prompts: {},
    _sharing: {},
    _utilities: {},
    chart: function($options, reset, chartName, callback) {
        'use strict';
        var returnNew = reset || false;
        var self = this;
        var theme = $('body').data('theme') || 'Index';
        if (($.isEmptyObject(this._chart) || returnNew) && chartName) {
            if (!$('#' + chartName + 'js').length) {
                this.utilities().lazyLoad('/data-tool/assets/js/Front/' + theme + '/' + chartName + '.js', function(script) {
                    var $script = $('<script id="' + chartName + 'js" type="text/javascript">' + script + '</script>');
                    $('body').append($script);
                    self._chart = new window[chartName]($options);
                    self._chart.runEvents();
                    callback(self._chart);
                }, function() {
                    throw new Error('The script ' + chartName + '.js couldn\'t load!');
                });
            } else {
                self._chart = new window[chartName]($options);
                self._chart.runEvents();
                callback(self._chart);
            }
        }
        return this._chart;
    },
    cities: function($options, reset) {
        'use strict';
        var returnNew = reset || false;
        if ($.isEmptyObject(this._cities) || returnNew) {
            this._cities = new Cities($options);
        }
        return this._cities;
    },
    graphs: function($options, reset) {
        'use strict';
        var returnNew = reset || false;
        if ($.isEmptyObject(this._graphs) || returnNew) {
            this._graphs = new Graphs($options);
        }
        return this._graphs;
    },
    hashURLs: function($options, reset) {
        'use strict';
        var returnNew = reset || false;
        if ($.isEmptyObject(this._hashURLs) || returnNew) {
            this._hashURLs = new HashURLs($options);
        }
        return this._hashURLs;
    },
    indicators: function($options, reset) {
        'use strict';
        var returnNew = reset || false;
        if ($.isEmptyObject(this._indicators) || returnNew) {
            this._indicators = new Indicators($options);
        }
        return this._indicators;
    },
    prompts: function($options, reset) {
        'use strict';
        var returnNew = reset || false;
        if ($.isEmptyObject(this._prompts) || returnNew) {
            this._prompts = new Prompts($options);
        }
        return this._prompts;
    },
    sharing: function($options, reset) {
        'use strict';
        var returnNew = reset || false;
        if ($.isEmptyObject(this._sharing) || returnNew) {
            this._sharing = new Sharing($options);
        }
        return this._sharing;
    },
    utilities: function($options, reset) {
        'use strict';
        var returnNew = reset || false;
        if ($.isEmptyObject(this._utilities) || returnNew) {
            this._utilities = new Utilities($options);
        }
        return this._utilities;
    },
    runEvents: function() {
        'use strict';
        this.utilities().injectDI(this);
        this.hashURLs().injectDI(this);
        this.indicators().injectDI(this);
        this.cities().injectDI(this);
        this.graphs().injectDI(this);
        this.prompts().injectDI(this);
        this.sharing().injectDI(this);
        this.hashURLs().runEvents();
        this.indicators().runEvents();
        this.cities().runEvents();
        this.graphs().startCharts();
        this.prompts().runEvents();
        this.hashURLs().init();
        this.sharing().runEvents();
    }
};

function windowPopup(url, width, height) {
    var left = (screen.width / 2) - (width / 2),
        top = (screen.height / 2) - (height / 2);
    window.open(url, "", "menubar=no,toolbar=no,resizable=yes,scrollbars=yes,width=" + width + ",height=" + height + ",top=" + top + ",left=" + left);
}
(function($) {
    'use strict';
    var defaultSpeed = 375;
    var $di = new Di();
    var $graph = $('#graph');
    var $graphWrapper = $('body').find('#graph-wrapper');
    var embedded = $('body').hasClass('embedded');
    var printView = $('body').hasClass('print-view');
    var exportView = $('body').hasClass('export-view');
    var embedHeight;
//    if (embedded && !printView && !exportView) {
        embedHeight = $(window).height() -  280;
        $graphWrapper.height(embedHeight);
        //$('<style type="text/css"> .scroll-wrapper.tbl-dt { max-height: ' + embedHeight + 'px;' + ' } </style>').appendTo('head');
        //
        $('.scroll-wrapper .tbl-dt').css('max-height', embedHeight+ 'px;');
//    } else {
//        $('.header-iframe').attr('src', '//www.centreforcities.org/datatool-iframe-header/');
//    }
    $di.utilities({
        speed: defaultSpeed
    });
    $di.hashURLs({
        dateSeparator: '--',
        optionsSeparator: '\\\\',
        pairSeparator: '&',
        valueSeparator: '='
    });
    $di.indicators({
        dropdown: $('.dropdown'),
        indicatorsHeading: $('#indicators-text'),
        indicatorsList: $('.indicator-list'),
        indicators: $('.indicator'),
        themes: $('.theme'),
        speed: defaultSpeed
    });
    $di.cities({
        averagesList: $('.filter.averages'),
        citiesList: $('.cities-list .cities, .filter.averages'),
        container: $('.cities-control'),
        filters: $('.filter, .buttons', '.cities-list'),
        speed: defaultSpeed
    });
    $di.graphs({
        container: $graph,
        embedded: embedded,
        graphWrapper: $graphWrapper,
        initialGraph: 'map',
        markerColour: '#868686',
        markerDisabledColor: '#868686',
        maximumToShow: 20,
        speed: defaultSpeed,
        tooltipMaximum: 7
    });
    $di.prompts({
        container: $graph,
        speed: defaultSpeed
    });
    $di.sharing({
        exportView: exportView,
        printView: printView,
        toolOptions: $('.tool-option'),
        speed: defaultSpeed
    });
    $di.runEvents();
    $di.cities().getCitiesList().find('.checkbox').addClass('ticked').end().find('.region:not(.extend)').addClass('current');
    if (embedded) {
        $('.tool-option.link').trigger('click');
    }
    $('a.factsheet.popup').on('click', function(e) {
        e.preventDefault();
        windowPopup($(this).attr('href'), 600, 800);
    });
    setTimeout(function() {
        $di.utilities().evenColumnHeight($('.list-columns.cities').find('.list-column').add('.list-columns.filters'));
    }, 100);
}(jQuery));;